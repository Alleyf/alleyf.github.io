/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LocalGPT
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/LocalGPTSettingTab.ts
var import_obsidian = require("obsidian");

// src/defaultSettings.ts
var DEFAULT_SETTINGS = {
  providers: {
    ollama: {
      ollamaUrl: "http://localhost:11434",
      defaultModel: "orca-mini",
      type: "ollama"
    },
    ollama_fallback: {
      ollamaUrl: "http://localhost:11434",
      defaultModel: "orca-mini",
      type: "ollama"
    },
    openaiCompatible: {
      url: "http://localhost:8080",
      apiKey: "",
      type: "openaiCompatible"
    },
    openaiCompatible_fallback: {
      url: "http://localhost:8080",
      apiKey: "",
      type: "openaiCompatible"
    }
  },
  defaultProvider: "ollama",
  fallbackProvider: "",
  actions: [
    {
      name: "\u{1FA84} General help",
      prompt: "",
      system: "You are an assistant helping a user write more content in a document based on a prompt. Output in markdown format. Do not use links. Do not include literal content from the original document."
    },
    {
      name: "\u270D\uFE0F Continue writing",
      prompt: "Act as a professional editor with many years of experience as a writer. Carefully finalize the following text, add details, use facts and make sure that the meaning and original style are preserved. Purposely write in detail, with examples, so that your reader is comfortable, even if they don't understand the specifics. Don't use clericalisms, evaluations without proof with facts, passive voice. Use Markdown markup language for formatting. Answer only content and nothing else, no introductory words, only substance.",
      system: "You are an AI assistant that follows instruction extremely well. Help as much as you can."
    },
    {
      name: "\u{1F36D} Summarize",
      prompt: "Make a concise summary of the key points of the following text.",
      system: "You are an AI assistant that follows instruction extremely well. Help as much as you can."
    },
    {
      name: "\u{1F4D6} Fix spelling and grammar",
      prompt: "Proofread the below for spelling and grammar.",
      system: "You are an AI assistant that follows instruction extremely well. Help as much as you can.",
      replace: true
    },
    {
      name: "\u2705 Find action items",
      prompt: 'Act as an assistant helping find action items inside a document. An action item is an extracted task or to-do found inside of an unstructured document. Use Markdown checkbox format: each line starts with "- [ ] "',
      system: "You are an AI assistant that follows instruction extremely well. Help as much as you can."
    }
  ],
  _version: 3
};

// src/LocalGPTSettingTab.ts
var SEPARATOR = "\u2702\uFE0F";
var LocalGPTSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.editEnabled = false;
    this.modelsOptions = {};
    this.changingOrder = false;
    this.useFallback = false;
    this.selectedProvider = "";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.selectedProvider = this.selectedProvider || this.plugin.settings.defaultProvider;
    this.useFallback = this.useFallback || Boolean(this.plugin.settings.fallbackProvider);
    const mainProviders = {
      ["ollama" /* OLLAMA */]: "Ollama",
      ["openaiCompatible" /* OPENAI_COMPATIBLE */]: "OpenAI compatible server"
    };
    const fallbackProviders = {
      ...mainProviders
    };
    if (this.plugin.settings.defaultProvider === "ollama" /* OLLAMA */) {
      delete fallbackProviders["ollama" /* OLLAMA */];
      fallbackProviders["ollama_fallback" /* OLLAMA_FALLBACK */] = "2\uFE0F\u20E3 Ollama";
    }
    if (this.plugin.settings.defaultProvider === "openaiCompatible" /* OPENAI_COMPATIBLE */) {
      delete fallbackProviders["openaiCompatible" /* OPENAI_COMPATIBLE */];
      fallbackProviders["openaiCompatible_fallback" /* OPENAI_COMPATIBLE_FALLBACK */] = "2\uFE0F\u20E3 OpenAI compatible servers";
    }
    new import_obsidian.Setting(containerEl).setHeading().setName("Selected AI provider").addDropdown(
      (dropdown) => dropdown.addOptions(mainProviders).setValue(String(this.plugin.settings.defaultProvider)).onChange(async (value) => {
        this.plugin.settings.defaultProvider = value;
        this.selectedProvider = value;
        if (this.useFallback) {
          this.plugin.settings.fallbackProvider = Object.keys(
            mainProviders
          ).find((key) => key !== value);
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Use fallback").addToggle((component) => {
      component.setValue(this.useFallback).onChange(async (value) => {
        this.useFallback = value;
        if (value) {
          const firstAvailableProvider = Object.keys(fallbackProviders)[0];
          this.plugin.settings.fallbackProvider = firstAvailableProvider;
          this.selectedProvider = firstAvailableProvider;
        } else {
          this.plugin.settings.fallbackProvider = "";
          this.selectedProvider = this.plugin.settings.defaultProvider;
        }
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.useFallback) {
      new import_obsidian.Setting(containerEl).setName("Fallback AI provider").setDesc(
        "If the Default provider is not accessible the plugin will try to reach the fallback one."
      ).addDropdown(
        (dropdown) => dropdown.addOptions(fallbackProviders).setValue(String(this.plugin.settings.fallbackProvider)).onChange(async (value) => {
          this.plugin.settings.fallbackProvider = value;
          this.selectedProvider = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    containerEl.createEl("div", { cls: "local-gpt-settings-separator" });
    containerEl.createEl("h3", { text: "Providers configuration" });
    const selectedProviderConfig = this.plugin.settings.providers[this.selectedProvider];
    const aiProvider = new import_obsidian.Setting(containerEl).setHeading().setName("Configure AI provider").setDesc("").addDropdown(
      (dropdown) => dropdown.addOptions({
        ...mainProviders,
        ...this.useFallback && {
          ["ollama_fallback" /* OLLAMA_FALLBACK */]: "2\uFE0F\u20E3 Ollama",
          ["openaiCompatible_fallback" /* OPENAI_COMPATIBLE_FALLBACK */]: "2\uFE0F\u20E3 OpenAI compatible servers"
        }
      }).setValue(String(this.selectedProvider)).onChange(async (value) => {
        this.selectedProvider = value;
        this.display();
      })
    );
    aiProvider.descEl.innerHTML = `
			If you would like to use other providers, please let me know <a href="https://github.com/pfrankov/obsidian-local-gpt/discussions/1">in the discussions</a>
		`;
    if (selectedProviderConfig.type === "ollama" /* OLLAMA */) {
      new import_obsidian.Setting(containerEl).setName("Ollama URL").setDesc("Default is http://localhost:11434").addText(
        (text) => text.setPlaceholder("http://localhost:11434").setValue(selectedProviderConfig.ollamaUrl).onChange(async (value) => {
          selectedProviderConfig.ollamaUrl = value;
          await this.plugin.saveSettings();
        })
      );
      const ollamaDefaultModel = new import_obsidian.Setting(containerEl).setName("Default model").setDesc("Name of the default Ollama model to use in prompts");
      if (selectedProviderConfig.ollamaUrl) {
        (0, import_obsidian.requestUrl)(`${selectedProviderConfig.ollamaUrl}/api/tags`).then(({ json }) => {
          if (!json.models || json.models.length === 0) {
            return Promise.reject();
          }
          this.modelsOptions = json.models.reduce(
            (acc, el) => {
              const name = el.name.replace(":latest", "");
              acc[name] = name;
              return acc;
            },
            {}
          );
          ollamaDefaultModel.addDropdown(
            (dropdown) => dropdown.addOptions(this.modelsOptions).setValue(
              String(
                selectedProviderConfig.defaultModel
              )
            ).onChange(async (value) => {
              selectedProviderConfig.defaultModel = value;
              await this.plugin.saveSettings();
            })
          ).addButton(
            (button) => button.setIcon("refresh-cw").onClick(async () => {
              this.display();
            })
          );
        }).catch(() => {
          ollamaDefaultModel.descEl.innerHTML = `Get the models from <a href="https://ollama.ai/library">Ollama library</a> or check that Ollama URL is correct.`;
          ollamaDefaultModel.addButton(
            (button) => button.setIcon("refresh-cw").onClick(async () => {
              this.display();
            })
          );
        });
      }
    }
    if (selectedProviderConfig.type === "openaiCompatible" /* OPENAI_COMPATIBLE */) {
      const openAICompatible = new import_obsidian.Setting(containerEl).setName("OpenAI compatible server URL").setDesc("").addText(
        (text) => text.setPlaceholder("http://localhost:8080").setValue(selectedProviderConfig.url).onChange(async (value) => {
          selectedProviderConfig.url = value;
          await this.plugin.saveSettings();
        })
      );
      openAICompatible.descEl.innerHTML = `
				There are several options to run local OpenAI-like server:
				<ul>
					<li><a href="https://github.com/ggerganov/llama.cpp/blob/master/examples/server/README.md">llama.cpp</a></li>
					<li><a href="https://github.com/abetlen/llama-cpp-python#openai-compatible-web-server">llama-cpp-python</a></li>
					<li><a href="https://localai.io/model-compatibility/llama-cpp/#setup">LocalAI</a></li>
					<li>Obabooga <a href="https://github.com/pfrankov/obsidian-local-gpt/discussions/8">Text generation web UI</a></li>
					<li><a href="https://lmstudio.ai/">LM Studio</a></li>
				</ul>
				After all installation and configuration make sure that you're using compatible model.<br/>
				For llama.cpp it is necessary to use models in ChatML format (e.g. <a href="https://huggingface.co/TheBloke/Orca-2-7B-GGUF/blob/main/orca-2-7b.Q4_K_M.gguf">Orca 2</a>)
			`;
      const apiKey = new import_obsidian.Setting(containerEl).setName("API key").setDesc("").addText(
        (text) => text.setPlaceholder("").setValue(selectedProviderConfig.apiKey).onChange(async (value) => {
          selectedProviderConfig.apiKey = value;
          await this.plugin.saveSettings();
        })
      );
      apiKey.descEl.innerHTML = `
				Optional. Check <a href="https://github.com/pfrankov/obsidian-local-gpt#using-with-openai">the docs</a> if you'd like to use OpenAI servers.
			`;
      const openaiDefaultModel = new import_obsidian.Setting(containerEl).setName("Default model").setDesc(
        "Optional. Name of the default model to use in prompts"
      );
      if (selectedProviderConfig.url) {
        (0, import_obsidian.requestUrl)({
          url: `${selectedProviderConfig.url.replace(
            /\/+$/i,
            ""
          )}/v1/models`,
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${selectedProviderConfig.apiKey}`
          }
        }).then(({ json }) => {
          if (!json.data || json.data.length === 0) {
            return Promise.reject();
          }
          const modelsOptions = json.data.reduce(
            (acc, el) => {
              const name = el.id;
              acc[name] = name;
              return acc;
            },
            {}
          );
          openaiDefaultModel.addDropdown(
            (dropdown) => dropdown.addOption("", "Not specified").addOptions(modelsOptions).setValue(
              String(
                selectedProviderConfig.defaultModel
              )
            ).onChange(async (value) => {
              selectedProviderConfig.defaultModel = value;
              await this.plugin.saveSettings();
            })
          ).addButton(
            (button) => button.setIcon("refresh-cw").onClick(async () => {
              this.display();
            })
          );
        }).catch(() => {
          openaiDefaultModel.addButton(
            (button) => button.setIcon("refresh-cw").onClick(async () => {
              this.display();
            })
          );
        });
      }
    }
    const editingAction = this.editExistingAction || {
      name: "",
      prompt: "",
      model: "",
      temperature: void 0,
      system: "",
      replace: false
    };
    const sharingActionsMapping = {
      name: "Name: ",
      system: "System: ",
      prompt: "Prompt: ",
      replace: "Replace: ",
      model: "Model: "
    };
    containerEl.createEl("div", { cls: "local-gpt-settings-separator" });
    containerEl.createEl("h3", { text: "Actions" });
    if (!this.editEnabled) {
      const quickAdd = new import_obsidian.Setting(containerEl).setName("Quick add").setDesc("").addText((text) => {
        text.inputEl.style.minWidth = "100%";
        text.setPlaceholder("Paste action");
        text.onChange(async (value) => {
          const quickAddAction = value.split(SEPARATOR).map((part) => part.trim()).reduce((acc, part) => {
            const foundMatchKey = Object.keys(
              sharingActionsMapping
            ).find((key) => {
              return part.startsWith(
                sharingActionsMapping[key]
              );
            });
            if (foundMatchKey) {
              acc[foundMatchKey] = part.substring(
                sharingActionsMapping[foundMatchKey].length,
                part.length
              );
            }
            return acc;
          }, {});
          if (quickAddAction.name) {
            await this.addNewAction(quickAddAction);
            text.setValue("");
            this.display();
          }
        });
      });
      quickAdd.descEl.innerHTML = `You can share the best sets prompts or get one <a href="https://github.com/pfrankov/obsidian-local-gpt/discussions/2">from the community</a>.<br/><strong>Important:</strong> if you already have an action with the same name it will be overwritten.`;
      new import_obsidian.Setting(containerEl).setName("Add new manually").addButton(
        (button) => button.setIcon("plus").onClick(async () => {
          this.editEnabled = true;
          this.editExistingAction = void 0;
          this.display();
        })
      );
    } else {
      if (this.plugin.settings.providers[this.plugin.settings.defaultProvider].type === "ollama" /* OLLAMA */) {
        new import_obsidian.Setting(containerEl).setName("Model").setDesc("Optional").addDropdown((dropdown) => {
          dropdown.addOption("", "Default model").addOptions(this.modelsOptions).onChange(async (value) => {
            editingAction.model = value;
          });
          (editingAction == null ? void 0 : editingAction.model) && dropdown.setValue(editingAction.model);
        });
      }
      new import_obsidian.Setting(containerEl).setName("Action name").addText((text) => {
        (editingAction == null ? void 0 : editingAction.name) && text.setValue(editingAction.name);
        text.inputEl.style.minWidth = "100%";
        text.setPlaceholder("Summarize selection");
        text.onChange(async (value) => {
          editingAction.name = value;
        });
      });
      new import_obsidian.Setting(containerEl).setName("System prompt").setDesc("Optional").addTextArea((text) => {
        (editingAction == null ? void 0 : editingAction.system) && text.setValue(editingAction.system);
        text.inputEl.style.minWidth = "100%";
        text.inputEl.style.minHeight = "6em";
        text.inputEl.style.resize = "vertical";
        text.setPlaceholder("You are a helpful assistant.");
        text.onChange(async (value) => {
          editingAction.system = value;
        });
      });
      new import_obsidian.Setting(containerEl).setName("Prompt").addTextArea((text) => {
        (editingAction == null ? void 0 : editingAction.prompt) && text.setValue(editingAction.prompt);
        text.inputEl.style.minWidth = "100%";
        text.inputEl.style.minHeight = "6em";
        text.inputEl.style.resize = "vertical";
        text.setPlaceholder("");
        text.onChange(async (value) => {
          editingAction.prompt = value;
        });
      });
      new import_obsidian.Setting(containerEl).setName("Replace selected text").setDesc(
        "If checked, the highlighted text will be replaced with a response from the model."
      ).addToggle((component) => {
        (editingAction == null ? void 0 : editingAction.replace) && component.setValue(editingAction.replace);
        component.onChange(async (value) => {
          editingAction.replace = value;
        });
      });
      const actionButtonsRow = new import_obsidian.Setting(containerEl).setName("");
      if (this.editExistingAction) {
        actionButtonsRow.addButton((button) => {
          button.buttonEl.style.marginRight = "2em";
          button.setButtonText("Remove").onClick(async () => {
            if (!button.buttonEl.hasClass("mod-warning")) {
              button.setClass("mod-warning");
              return;
            }
            this.plugin.settings.actions = this.plugin.settings.actions.filter(
              (innerAction) => innerAction !== editingAction
            );
            await this.plugin.saveSettings();
            this.editExistingAction = void 0;
            this.editEnabled = false;
            this.display();
          });
        });
      }
      actionButtonsRow.addButton((button) => {
        button.setButtonText("Close").onClick(async () => {
          this.editEnabled = false;
          this.editExistingAction = void 0;
          this.display();
        });
      }).addButton(
        (button) => button.setCta().setButtonText("Save").onClick(async () => {
          if (!editingAction.name) {
            new import_obsidian.Notice(
              "Please enter a name for the action."
            );
            return;
          }
          if (!this.editExistingAction) {
            if (this.plugin.settings.actions.find(
              (action) => action.name === editingAction.name
            )) {
              new import_obsidian.Notice(
                `An action with the name "${editingAction.name}" already exists.`
              );
              return;
            }
            await this.addNewAction(editingAction);
          } else {
            if (this.plugin.settings.actions.filter(
              (action) => action.name === editingAction.name
            ).length > 1) {
              new import_obsidian.Notice(
                `An action with the name "${editingAction.name}" already exists.`
              );
              return;
            }
            const index = this.plugin.settings.actions.findIndex(
              (innerAction) => innerAction === editingAction
            );
            this.plugin.settings.actions[index] = editingAction;
          }
          await this.plugin.saveSettings();
          this.editEnabled = false;
          this.editExistingAction = void 0;
          this.display();
        })
      );
    }
    containerEl.createEl("h4", { text: "Actions list" });
    let defaultModel = "";
    if (selectedProviderConfig.type === "ollama" /* OLLAMA */) {
      defaultModel = selectedProviderConfig.defaultModel;
    }
    this.plugin.settings.actions.forEach((action, actionIndex) => {
      const sharingString = [
        action.name && `${sharingActionsMapping.name}${action.name}`,
        action.system && `${sharingActionsMapping.system}${action.system}`,
        action.prompt && `${sharingActionsMapping.prompt}${action.prompt}`,
        action.replace && `${sharingActionsMapping.replace}${action.replace}`,
        this.plugin.settings.defaultProvider === "ollama" /* OLLAMA */ && (action.model || defaultModel) && `${sharingActionsMapping.model}${action.model || defaultModel}`
      ].filter(Boolean).join(` ${SEPARATOR}
`);
      if (!this.changingOrder) {
        const actionRow = new import_obsidian.Setting(containerEl).setName(action.name).setDesc("").addButton(
          (button) => button.setIcon("copy").onClick(async () => {
            navigator.clipboard.writeText(sharingString);
            new import_obsidian.Notice("Copied");
          })
        ).addButton(
          (button) => button.setButtonText("Edit").onClick(async () => {
            this.editEnabled = true;
            this.editExistingAction = this.plugin.settings.actions.find(
              (innerAction) => innerAction.name == action.name
            );
            this.display();
          })
        );
        actionRow.descEl.innerHTML = [
          action.system && `<b>${sharingActionsMapping.system}</b>${action.system}`,
          action.prompt && `<b>${sharingActionsMapping.prompt}</b>${action.prompt}`,
          this.plugin.settings.defaultProvider === "ollama" /* OLLAMA */ && action.model && `<b>${sharingActionsMapping.model}</b>${action.model}`
        ].filter(Boolean).join("<br/>\n");
      } else {
        const actionRow = new import_obsidian.Setting(containerEl).setName(action.name).setDesc("");
        if (actionIndex > 0) {
          actionRow.addButton(
            (button) => button.setIcon("arrow-up").onClick(async () => {
              const prev = this.plugin.settings.actions[actionIndex - 1];
              this.plugin.settings.actions[actionIndex - 1] = action;
              this.plugin.settings.actions[actionIndex] = prev;
              await this.plugin.saveSettings();
              this.display();
            })
          );
        }
        if (actionIndex < this.plugin.settings.actions.length - 1) {
          actionRow.addButton(
            (button) => button.setIcon("arrow-down").onClick(async () => {
              const next = this.plugin.settings.actions[actionIndex + 1];
              this.plugin.settings.actions[actionIndex + 1] = action;
              this.plugin.settings.actions[actionIndex] = next;
              await this.plugin.saveSettings();
              this.display();
            })
          );
        }
      }
    });
    if (this.plugin.settings.actions.length) {
      new import_obsidian.Setting(containerEl).setName("").addButton((button) => {
        this.changingOrder && button.setCta();
        button.setButtonText(this.changingOrder ? "Done" : "Change order").onClick(async () => {
          this.changingOrder = !this.changingOrder;
          this.display();
        });
      });
    }
    containerEl.createEl("h4", { text: "Danger zone" });
    new import_obsidian.Setting(containerEl).setName("Reset actions").setDesc(
      "\u{1F6A8} Reset all actions to the default. This cannot be undone and will delete all your custom actions."
    ).addButton(
      (button) => button.setClass("mod-warning").setButtonText("Reset").onClick(async () => {
        button.setDisabled(true);
        button.buttonEl.setAttribute("disabled", "true");
        button.buttonEl.classList.remove("mod-warning");
        this.plugin.settings.actions = DEFAULT_SETTINGS.actions;
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  async addNewAction(editingAction) {
    const alreadyExistingActionIndex = this.plugin.settings.actions.findIndex(
      (action) => action.name === editingAction.name
    );
    if (alreadyExistingActionIndex >= 0) {
      this.plugin.settings.actions[alreadyExistingActionIndex] = editingAction;
      new import_obsidian.Notice(`Rewritten "${editingAction.name}" action`);
    } else {
      this.plugin.settings.actions = [
        editingAction,
        ...this.plugin.settings.actions
      ];
      new import_obsidian.Notice(`Added "${editingAction.name}" action`);
    }
    await this.plugin.saveSettings();
  }
};

// src/spinnerPlugin.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var Spinner = class extends import_view.WidgetType {
  constructor(text) {
    super();
    this.text = text;
  }
  eq(other) {
    return other.text == this.text;
  }
  toDOM() {
    let wrap = document.createElement("div");
    wrap.innerText = this.text;
    wrap.addClass("local-gpt-streaming-text");
    const span = document.createElement("span");
    span.addClasses(["local-gpt-loading", "local-gpt-dots"]);
    if (!this.text.trim()) {
      return span;
    }
    return wrap;
  }
  ignoreEvent() {
    return false;
  }
};
var SpinnerPlugin = class {
  constructor(view) {
    this.editorView = view;
    this.listOfPositions = [];
    this.decorations = this.buildDecorations();
  }
  show(position) {
    this.listOfPositions.push(position);
    this.decorations = this.buildDecorations();
    return () => {
      this.hide(position);
    };
  }
  hide(position) {
    this.listOfPositions = this.listOfPositions.filter(
      (pos) => pos !== position
    );
    this.decorations = this.buildDecorations();
  }
  updateContent(text) {
    this.decorations = this.buildDecorations(text);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = this.buildDecorations();
    }
  }
  destroy() {
  }
  buildDecorations(text = "") {
    const builder = new import_state.RangeSetBuilder();
    this.listOfPositions.forEach((pos) => {
      const indentationWidget = import_view.Decoration.widget({
        widget: new Spinner(text),
        side: 1
      });
      builder.add(pos, pos, indentationWidget);
    });
    return builder.finish();
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var spinnerPlugin = import_view.ViewPlugin.fromClass(SpinnerPlugin, pluginSpec);

// src/providers/ollama.ts
var import_obsidian2 = require("obsidian");

// src/streamer.ts
async function streamer({
  response,
  abortController,
  onDone,
  onNext
}) {
  var _a;
  const reader = (_a = response.body) == null ? void 0 : _a.getReader();
  const decoder = new TextDecoder();
  if (!reader) {
    return "";
  }
  while (true) {
    if (abortController.signal.aborted) {
      break;
    }
    const { done, value } = await reader.read();
    const decodedValue = decoder.decode(value);
    if (done) {
      break;
    }
    onNext && onNext(decodedValue);
  }
  return onDone && onDone();
}

// src/providers/ollama.ts
var OllamaAIProvider = class {
  constructor({ defaultModel, ollamaUrl, onUpdate, abortController }) {
    this.defaultModel = defaultModel;
    this.ollamaUrl = ollamaUrl;
    this.onUpdate = onUpdate;
    this.abortController = abortController;
  }
  process(text = "", action, images = []) {
    const requestBody = {
      prompt: [action.prompt, text].filter(Boolean).join("\n\n"),
      model: action.model || this.defaultModel,
      options: {
        temperature: action.temperature || 0.2
      },
      stream: true
    };
    if (action.system) {
      requestBody.system = action.system;
    }
    if (images.length) {
      requestBody.images = images;
    }
    const { abortController } = this;
    const url = `${this.ollamaUrl.replace(/\/+$/i, "")}/api/generate`;
    return fetch(url, {
      method: "POST",
      body: JSON.stringify(requestBody),
      signal: abortController.signal
    }).then((response) => {
      let combined = "";
      return streamer({
        response,
        abortController,
        onNext: (data) => {
          const lines = data.split("\n").filter((line) => line.trim() !== "");
          for (const line of lines) {
            const message = line;
            try {
              const parsed = JSON.parse(message);
              combined += parsed.response || "";
            } catch (error) {
              console.error(
                "Could not JSON parse stream message",
                message,
                error
              );
            }
          }
          this.onUpdate(combined);
        },
        onDone: () => {
          return combined;
        }
      });
    }).catch((error) => {
      if (abortController.signal.aborted) {
        return Promise.reject(error);
      }
      return (0, import_obsidian2.requestUrl)({
        url,
        method: "POST",
        body: JSON.stringify({
          ...requestBody,
          stream: false
        })
      }).then(({ json }) => {
        return json.response;
      });
    });
  }
};

// src/providers/openai-compatible.ts
var OpenAICompatibleAIProvider = class {
  constructor({ url, apiKey, defaultModel, abortController, onUpdate }) {
    this.url = url;
    this.apiKey = apiKey;
    this.defaultModel = defaultModel;
    this.abortController = abortController;
    this.onUpdate = onUpdate;
  }
  process(text = "", action, images = []) {
    const messages = [
      action.system && {
        role: "system",
        content: action.system
      },
      !images.length && {
        role: "user",
        content: [action.prompt, text].filter(Boolean).join("\n\n")
      },
      images.length && {
        role: "user",
        content: [
          {
            type: "text",
            text: [action.prompt, text].filter(Boolean).join("\n\n")
          },
          ...images.map((image) => ({
            type: "image_url",
            image_url: {
              url: `data:image/jpeg;base64,${image}`
            }
          }))
        ]
      }
    ].filter(Boolean);
    const requestBody = {
      stream: true,
      model: action.model || this.defaultModel,
      messages
    };
    const { abortController } = this;
    return fetch(`${this.url.replace(/\/+$/i, "")}/v1/chat/completions`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...this.apiKey && {
          Authorization: `Bearer ${this.apiKey}`
        }
      },
      body: JSON.stringify(requestBody),
      signal: abortController.signal
    }).then((response) => {
      let combined = "";
      return new Promise((resolve, reject) => {
        streamer({
          response,
          abortController,
          onNext: (data) => {
            var _a, _b;
            const lines = data.split("\n").filter((line) => line.trim() !== "");
            for (const line of lines) {
              const message = line.replace(/^data: /, "");
              if (message === "[DONE]") {
                break;
              }
              try {
                const parsed = JSON.parse(message);
                combined += ((_b = (_a = parsed.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.content) || "";
              } catch (error) {
                try {
                  reject(JSON.parse(data).error);
                } catch (e) {
                  reject(
                    "Could not JSON parse stream message"
                  );
                  console.error(
                    "Could not JSON parse stream message",
                    message,
                    error
                  );
                }
              }
            }
            this.onUpdate(combined);
          },
          onDone: () => {
            resolve(combined);
            return combined;
          }
        });
      });
    });
  }
};

// src/main.ts
var LocalGPT = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.abortControllers = [];
    this.escapeHandler = (event) => {
      if (event.key === "Escape") {
        this.abortControllers.forEach(
          (abortControllers) => {
            abortControllers.abort();
          }
        );
        this.abortControllers = [];
      }
    };
  }
  async onload() {
    await this.loadSettings();
    this.reload();
    this.registerEditorExtension(spinnerPlugin);
    this.addSettingTab(new LocalGPTSettingTab(this.app, this));
  }
  processText(text, selectedText) {
    if (!text.trim()) {
      return "";
    }
    return ["\n", text.trim().replace(selectedText, "").trim(), "\n"].join(
      ""
    );
  }
  addCommands() {
    this.addCommand({
      id: "context-menu",
      name: "Show context menu",
      editorCallback: (editor) => {
        const editorView = editor.cm;
        const selection = editor.getSelection();
        let selectedText = selection || editor.getValue();
        const cursorPositionFrom = editor.getCursor("from");
        const cursorPositionTo = editor.getCursor("to");
        const contextMenu = new import_obsidian3.Menu();
        this.settings.actions.forEach((action) => {
          contextMenu.addItem((item) => {
            item.setTitle(action.name).onClick(async () => {
              const abortController = new AbortController();
              this.abortControllers.push(abortController);
              const spinner = editorView.plugin(spinnerPlugin) || void 0;
              const hideSpinner = spinner == null ? void 0 : spinner.show(
                editor.posToOffset(cursorPositionTo)
              );
              this.app.workspace.updateOptions();
              const onUpdate = (updatedString) => {
                spinner.updateContent(
                  this.processText(
                    updatedString,
                    selectedText
                  )
                );
                this.app.workspace.updateOptions();
              };
              const getAIProvider = (providerName) => {
                switch (this.settings.providers[providerName].type) {
                  case "openaiCompatible" /* OPENAI_COMPATIBLE */: {
                    const { url, apiKey, defaultModel } = this.settings.providers[providerName];
                    return new OpenAICompatibleAIProvider({
                      url,
                      apiKey,
                      defaultModel,
                      abortController,
                      onUpdate
                    });
                  }
                  case "ollama" /* OLLAMA */:
                  default: {
                    const { ollamaUrl, defaultModel } = this.settings.providers[providerName];
                    return new OllamaAIProvider({
                      defaultModel,
                      ollamaUrl,
                      abortController,
                      onUpdate
                    });
                  }
                }
              };
              const aiProvider = getAIProvider(
                this.settings.defaultProvider
              );
              const regexp = /!\[\[(.+?\.(?:png|jpe?g))]]/gi;
              const fileNames = Array.from(
                selectedText.matchAll(regexp),
                (match) => match[1]
              );
              selectedText = selectedText.replace(regexp, "");
              const imagesInBase64 = (await Promise.all(
                fileNames.map((fileName) => {
                  const filePath = this.app.metadataCache.getFirstLinkpathDest(
                    fileName,
                    // @ts-ignore
                    this.app.workspace.getActiveFile().path
                  );
                  if (!filePath) {
                    return Promise.resolve("");
                  }
                  return this.app.vault.adapter.readBinary(filePath.path).then((buffer) => {
                    const bytes = new Uint8Array(buffer);
                    const output = [];
                    for (const byte of bytes) {
                      output.push(
                        String.fromCharCode(
                          byte
                        )
                      );
                    }
                    const binString = output.join("");
                    return btoa(binString);
                  });
                })
              )).filter(Boolean) || [];
              aiProvider.process(selectedText, action, imagesInBase64).catch((error) => {
                if (this.settings.fallbackProvider) {
                  new import_obsidian3.Notice(
                    `Action processed with a fallback`
                  );
                  return getAIProvider(
                    this.settings.fallbackProvider
                  ).process(
                    selectedText,
                    action,
                    imagesInBase64
                  );
                }
                return Promise.reject(error);
              }).then((data) => {
                hideSpinner && hideSpinner();
                this.app.workspace.updateOptions();
                if (action.replace) {
                  editor.replaceRange(
                    data.trim(),
                    cursorPositionFrom,
                    cursorPositionTo
                  );
                } else {
                  editor.replaceRange(
                    this.processText(
                      data,
                      selectedText
                    ),
                    {
                      ch: 0,
                      line: cursorPositionTo.line + 1
                    }
                  );
                }
              }).catch((error) => {
                if (!abortController.signal.aborted) {
                  new import_obsidian3.Notice(
                    `Error while generating text: ${error.message}`
                  );
                }
                hideSpinner && hideSpinner();
                this.app.workspace.updateOptions();
              });
            });
          });
        });
        const fromRect = editorView.coordsAtPos(
          editor.posToOffset(cursorPositionFrom)
        );
        const toRect = editorView.coordsAtPos(
          editor.posToOffset(cursorPositionTo)
        );
        contextMenu.showAtPosition({
          x: fromRect.left,
          y: toRect.top + (editorView.defaultLineHeight || 0)
        });
      }
    });
  }
  onunload() {
    document.removeEventListener("keydown", this.escapeHandler);
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    let needToSave = false;
    if (loadedData) {
      if (!loadedData._version || loadedData._version < 1) {
        needToSave = true;
        loadedData.providers = DEFAULT_SETTINGS.providers;
        loadedData.providers.ollama.ollamaUrl = loadedData.ollamaUrl;
        delete loadedData.ollamaUrl;
        loadedData.providers.ollama.defaultModel = // @ts-ignore
        loadedData.defaultModel;
        delete loadedData.defaultModel;
        loadedData.selectedProvider = DEFAULT_SETTINGS.selectedProvider;
        loadedData._version = 2;
      }
      if (loadedData._version < 3) {
        needToSave = true;
        loadedData.defaultProvider = // @ts-ignore
        loadedData.selectedProvider || DEFAULT_SETTINGS.defaultProvider;
        delete loadedData.selectedProvider;
        Object.keys(loadedData.providers).forEach((key) => {
          loadedData.providers[key].type = key;
        });
        loadedData.providers.openaiCompatible && // @ts-ignore
        (loadedData.providers.openaiCompatible.apiKey = "");
        loadedData._version = 3;
      }
      Object.keys(DEFAULT_SETTINGS.providers).forEach((key) => {
        if (loadedData.providers[key]) {
          return;
        }
        loadedData.providers[key] = DEFAULT_SETTINGS.providers[key];
        needToSave = true;
      });
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    if (needToSave) {
      await this.saveData(this.settings);
    }
  }
  reload() {
    this.onunload();
    this.addCommands();
    this.abortControllers = [];
    document.addEventListener("keydown", this.escapeHandler);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.reload();
  }
};
