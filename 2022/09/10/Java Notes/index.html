

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="alleyf">
  <meta name="keywords" content="">
  
    <meta name="description" content="some notation about java。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_Notes">
<meta property="og:url" content="https://alleyf.github.io/2022/09/10/Java%20Notes/index.html">
<meta property="og:site_name" content="alleyf">
<meta property="og:description" content="some notation about java。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907091018.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135804.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135908.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135953.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135958.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140005.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140009.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140707.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140707.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907143232.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907142721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907150838.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220909084420.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220909093029.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220909092844.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220914154845348.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220916083605738.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220916085315869.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220921141638509.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220921145517282.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220921155545894.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923082921856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923083806822.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923092011478.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923093134846.png">
<meta property="og:image" content="c:/Users/alleyf/AppData/Roaming/Typora/typora-user-images/image-20220928141405830.png">
<meta property="og:image" content="c:/Users/alleyf/AppData/Roaming/Typora/typora-user-images/image-20220928142730920.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220928143014612.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220928160253693.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220928160326479.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930081159260.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930090145928.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930090437034.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930090537860.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080603796.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210512173109590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080648065.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210512175007490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080759956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/qiV0by.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080944453.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210512224504688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70,t_70, #pic_center">
<meta property="og:image" content="http://c.biancheng.net/uploads/allimg/200115/5-200115142HWK.png">
<meta property="og:image" content="http://c.biancheng.net/uploads/allimg/200115/5-200115142K1644.png">
<meta property="og:image" content="http://c.biancheng.net/uploads/allimg/200115/5-200115145253550.png">
<meta property="og:image" content="http://c.biancheng.net/uploads/allimg/200115/5-200115151G3J0.png">
<meta property="article:published_time" content="2022-09-10T02:00:00.000Z">
<meta property="article:modified_time" content="2022-10-12T08:24:57.882Z">
<meta property="article:author" content="alleyf">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907091018.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java_Notes - alleyf</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"alleyf.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"d57048846da607439cf11718741f2eb0","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?d57048846da607439cf11718741f2eb0";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mr.Alleyf</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java_Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        alleyf
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-10 10:00" pubdate>
          September 10, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          353 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java_Notes</h1>
            
              <p class="note note-info">
                
                  
                    Last updated on 3 days ago
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="第一章、计算机语言及系统概述"><a href="#第一章、计算机语言及系统概述" class="headerlink" title="第一章、计算机语言及系统概述"></a>第一章、计算机语言及系统概述</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907091018.png" srcset="/img/loading.gif" lazyload style="zoom: 33%"  align="middle" /></li>
<li>特点：<strong>Write once，run anywhere！</strong></li>
</ol>
<ul>
<li><strong>java：java program-&gt;执行编译后的程序</strong></li>
<li> <strong>javac：java program.java-&gt;编译该程序生成.class文件</strong></li>
<li> <strong>javadoc：javadoc program-&gt;生成该程序的html文档</strong></li>
</ul>
<ol start="3">
<li><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135804.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" /></li>
<li><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135836.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" />
## 代码示例
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
# 第二章、数据类型及变量</li>
</ol>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135908.png" srcset="/img/loading.gif" lazyload style="zoom:33%;"  align="middle"/>

<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135913.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" align="middle"/>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">DefineKey</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> _j=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> $k=<span class="hljs-number">2</span>;<br><span class="hljs-comment">//        int 1i=0;(NO)</span><br><span class="hljs-comment">//        int 中国=1;(不建议)</span><br>        <span class="hljs-type">byte</span> a=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">double</span> b=<span class="hljs-number">0.1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><div>
    <center>
    <p>
        <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135920.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
       </p>
    </br>
    <p>
        <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135925.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
    </p>
    </br>
    <p>
        <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135953.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />
    </p>
</center>
</div>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BaseData</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">123</span>;<span class="hljs-comment">//默认十进制</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0123</span>;<span class="hljs-comment">//八进制</span><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0x123</span>;<span class="hljs-comment">//16进制</span><br>    <span class="hljs-type">long</span> c=<span class="hljs-number">55555</span>;<br>    <span class="hljs-type">long</span> d=<span class="hljs-number">555555555555555L</span>;<br>    <span class="hljs-type">double</span> e=<span class="hljs-number">521e2</span>;<br>    <span class="hljs-type">char</span> f=<span class="hljs-string">&#x27;\u0064&#x27;</span>;<br>    System.out.println(f);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907135958.png" srcset="/img/loading.gif" lazyload style="zoom:33%" />
</div>





<div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140005.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" />
</div>



<div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140009.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" />
</div>



<div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140012.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" />
</div>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140707.png" srcset="/img/loading.gif" lazyload style="zoom: 53%" align="middle" />
</div>





<div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907140707.png" srcset="/img/loading.gif" lazyload style="zoom: 53%" align="middle" />
</div>

<p><strong>提升转换不丢失精度;(type)var强制类型转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TypeChange</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">double</span> s=<span class="hljs-number">3.1415</span>;<br>    <span class="hljs-type">int</span> n=(<span class="hljs-type">int</span>)s;<br>    <span class="hljs-type">char</span> b=(<span class="hljs-type">char</span>)n;<br>    <span class="hljs-type">char</span> a=<span class="hljs-string">&#x27;a&#x27;</span>;<br>    String c;<br>    System.out.println(n+b);<br>    <span class="hljs-type">int</span> money=<span class="hljs-number">1000000000</span>;<span class="hljs-comment">//int型为4个字节最大为21亿，超出则异常</span><br>    <span class="hljs-type">int</span> years=<span class="hljs-number">20</span>;<br>    <span class="hljs-type">double</span> total=(<span class="hljs-type">double</span>)(money)*years;<span class="hljs-comment">//提前将其中一个整形转换为浮点型以避免精度缺失</span><br>    System.out.println(total);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><strong>实例</strong>变量：在<strong>堆</strong>中。</li>
<li><strong>静态</strong>变量：在<strong>方法区</strong>。</li>
<li><strong>局部</strong>变量：在<strong>栈</strong>中。</li>
</ul>
<img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907143232.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" />




<p>以上三大变量中：</p>
<p><strong>局部变量永远都不会存在线程安全问题。</strong></p>
<ul>
<li>因为局部变量不共享。（一个线程一个栈。）</li>
<li>局部变量在<strong>栈</strong>中。所以局部变量永远都不会共享。</li>
</ul>
<ol>
<li>实例变量在堆中，堆只有1个。</li>
<li>静态变量在方法区中，方法区只有1个。</li>
</ol>
<p><strong>堆和方法区都是多线程共享的，所以可能存在线程安全问题。</strong></p>
<p><strong>总结：</strong></p>
<ul>
<li><strong>局部变量+常量</strong>：不会有线程安全问题。</li>
<li><strong>成员变量（实例+静态）</strong>：可能会有线程安全问题。</li>
</ul>
<blockquote>
<p>最终变量（必须初始化）：<code>**final** type variable=value；</code>（<strong>定义时初始化或构造函数初始化</strong>）</p>
</blockquote>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li><strong>只能被初始化一次</strong></li>
<li><strong>常量名全部大写，单词过多使用下划线</strong></li>
</ul>
<img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907142721.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" />



<h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220907150838.png" srcset="/img/loading.gif" lazyload style="zoom:33%" align="middle" />



<h2 id="输出进制格式化"><a href="#输出进制格式化" class="headerlink" title="输出进制格式化"></a>输出进制格式化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;二进制输出&quot;</span>+Integer.toBinaryString(a));<br>System.out.println(<span class="hljs-string">&quot;八进制输出&quot;</span>+Integer.toOctalString(a));<br>System.out.println(<span class="hljs-string">&quot;十六进制输出&quot;</span>+Integer.toHexString(a));<br></code></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ul>
<li><p>定义：<strong>type[] arrayname = new type[num] 或  type arrayname[] = new type[num]</strong></p>
</li>
<li><p><strong>初始化默认值为零</strong></p>
</li>
<li><p><strong>数组直接赋值属于传引用，指向同一个地址空间</strong></p>
</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul>
<li>定义：<strong>type[][] arrayname = new type[m] [n]</strong></li>
<li>可以不规则，给不同行分配不同大小的列</li>
<li><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220909084420.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" align="middle"  /></li>
</ul>
<h2 id="容器遍历元素"><a href="#容器遍历元素" class="headerlink" title="容器遍历元素"></a>容器遍历元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : fib)<br>/ /vaue获得fib数组每个元素,<br>/ /相当于fib[i]<br>	System.out,print(<span class="hljs-string">&quot; &quot;</span> +value);<br></code></pre></td></tr></table></figure>

<h2 id="方法（递归）"><a href="#方法（递归）" class="headerlink" title="方法（递归）"></a>方法（递归）</h2><ul>
<li><strong>递归方法适合用于分段函数类型的问题求解，必须有递归头和递归体</strong></li>
<li><strong>递归和堆栈原理类似，递归也可以通过堆栈实现</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//斐波那契数列第n项</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fib</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        System.out.println(sequence(<span class="hljs-number">10</span>));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sequence</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>|n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> sequence(n-<span class="hljs-number">2</span>)+sequence(n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;Index error&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><p>字符串常量“abc”</p>
</li>
<li><p>String是字符串类</p>
</li>
<li><p><code>s.charAt(index)//索引下标的值</code></p>
</li>
<li><p>字符串变量及运算</p>
<ul>
<li><p>赋值运算</p>
<p>​    String str = “abc”;</p>
<p>​    String str2 = str;</p>
</li>
<li><p>连接运算+ +=</p>
<p>​    str = “abc” + “xyz”; //str的值为”abcxyz”</p>
</li>
</ul>
</li>
<li><p><strong>字符串不是字符数组</strong></p>
</li>
<li><div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220909093029.png" srcset="/img/loading.gif" lazyload style="zoom:25%" align="middle"/>
</div></li>
</ol>
<h2 id="API文档"><a href="#API文档" class="headerlink" title="API文档"></a>API文档</h2><div align="center">
    <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/blog/20220909092844.png" srcset="/img/loading.gif" lazyload style="zoom:25%" align="middle" />
</div>



<h1 id="第三章、类的封装、继承和多态"><a href="#第三章、类的封装、继承和多态" class="headerlink" title="第三章、类的封装、继承和多态"></a>第三章、类的封装、继承和多态</h1><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类的特点：<code>具有封装性，继承性，多态性和抽象性。</code></p>
<p>对象：<code>对象的实例。</code></p>
<p>注：</p>
<ul>
<li>Java中进行方法调用中传递参数时，<strong>遵循值传递的原则</strong>：基本类型传递的是该 数据值本身。引用类型传递的是对对象的引用，而不是对象本身。</li>
<li>与c++类似，类的定义和调用要分开在两个文件中，类的声明与定义在一个文件，类的调用要在另外一个文件的类中定义一个类对象: <code>classname objname=new classname()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类的声明</span><br><span class="hljs-keyword">package</span> ch4;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">people</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getname</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setname</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setage</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类的调用</span><br><span class="hljs-keyword">package</span> ch4;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">callpeople</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">people</span> <span class="hljs-variable">zyk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">people</span>();<br>        <span class="hljs-type">people</span> <span class="hljs-variable">fcs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">people</span>();<br>        fcs = zyk;<br>        zyk.setname(<span class="hljs-string">&quot;赵逸坤&quot;</span>);<br>        zyk.setage(<span class="hljs-number">21</span>);<br>        System.out.println(zyk.getname()+<span class="hljs-string">&quot;今年&quot;</span>+zyk.getage()+<span class="hljs-string">&quot;岁了&quot;</span>);<br>        System.out.println(zyk);<br>        System.out.println(fcs);<br><span class="hljs-comment">//        Scanner in = new Scanner(System.in);</span><br><span class="hljs-comment">//        String name = in.next();</span><br><span class="hljs-comment">//        System.out.println(in);</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h2><h3 id="1构造方法和析构方法"><a href="#1构造方法和析构方法" class="headerlink" title="1构造方法和析构方法"></a>1构造方法和析构方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在类里进行定义构造方法，用this对对象引用，从而避免与形参名的冲突</span><br><span class="hljs-comment">//super为隐式参数，为对父类的引用</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">people</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-comment">//析构方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 对象的清理工作</span><br>&#125;<br><span class="hljs-comment">//给对象赋值为null，则对象的内存将会释放，但静态方法和变量不会释放</span><br></code></pre></td></tr></table></figure>

<p><strong>方法和运算符重载：</strong></p>
<p><code>通过参数列表中参数的类型、个数和顺序的不同进行区别</code></p>
<h3 id="2对象的引用和运算"><a href="#2对象的引用和运算" class="headerlink" title="2对象的引用和运算"></a>2对象的引用和运算</h3><ul>
<li>instanceof对象运算符       eg：<code>d instanceof MyDate</code></li>
<li>super为隐式参数，为对父类的引用</li>
<li>this为隐式参数，为对对象本身的引用</li>
<li>普通方法中，this总是指向调用该方法的对象; 构造方法中，this总是指向正要初始化的对象；this不能用于static方法；可以在一个构造方法中通过this调用其它构造方法，且必须是构造方法中 的第一条语句</li>
</ul>
<h3 id="3访问控制-隐藏-封装"><a href="#3访问控制-隐藏-封装" class="headerlink" title="3访问控制-隐藏/封装"></a>3访问控制-隐藏/封装</h3><ul>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用， 从而提高系统的可扩展性、可维护性。</li>
<li>boolean变量的get方法是is开头；常量或 static 变量公开</li>
<li>default：默认访问控制属性，什么都没加就是该控制符。有的书上说 friendly、package，这都是一个意思，都不能真的写出来，如果什么访 问修饰符都不加，就是default/friendly/package</li>
<li>Java的访问控制是停留在编译层，也就是它不会在.class文件中留下任何 痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，可 以访问任何包下任何类中的成员，例如，访问类中的私有成员也是可以的。说明访问控制是<code>伪封装（类似于python）</code>。</li>
</ul>
<h4 id="类的访问权限："><a href="#类的访问权限：" class="headerlink" title="类的访问权限："></a>类的访问权限：</h4><p>  <strong>只有public和缺省两种</strong></p>
<p>  eg：public class MyDate 或class MyDate_ex</p>
<h4 id="类成员和函数的访问权限："><a href="#类成员和函数的访问权限：" class="headerlink" title="类成员和函数的访问权限："></a>类成员和函数的访问权限：</h4>  <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220914154845348.png" srcset="/img/loading.gif" lazyload alt="image-20220914154845348" style="zoom:60%" align="middle" />



<h4 id="声明set-和get-方法存取对象的属性"><a href="#声明set-和get-方法存取对象的属性" class="headerlink" title="声明set()和get()方法存取对象的属性"></a>声明set()和get()方法存取对象的属性</h4><h3 id="4静态成员"><a href="#4静态成员" class="headerlink" title="4静态成员"></a>4静态成员</h3><ul>
<li><p>静态成员是属于类本身的公共属性或方法。</p>
</li>
<li><p>静态成员变量也叫类属性或类变量，静态成员变量调用时可以对象.类属性或类名.类属性来访问。</p>
</li>
<li><p>静态方法调用时只能通过类名.类方法调用，在调用该方法时，不会将对象的引用（this）传递给它，所以在 static 方法中不可访问非static的成员，静态方法只能访问静态成员变量或静态方法。</p>
</li>
<li><p> 父类中是静态方法，子类中不能覆盖为非静态方法；在符合覆盖规则的前提下， 在父子类中，父类中的静态方法可以被子类中的静态方法覆盖，但无多态。 （在使用对象调用静态方法时，实则是调用编译时类型的静态方法）。</p>
</li>
<li><p>父子类中，静态方法只能被静态方法覆盖，父子类中，非静态方法只能被非静 态方法覆盖。</p>
</li>
</ul>
<h4 id="静态初始化块-static"><a href="#静态初始化块-static" class="headerlink" title="静态初始化块 static {}"></a>静态初始化块 static {}</h4><p>注：如果希望加载后，对整个类进行某些初始化操作，可以使用static初始化块</p>
<ol>
<li>是在类初始化时执行，不是在创建对象时执行。 </li>
<li>静态初始化块中不能访问非static成员变量。</li>
<li>执行顺序：上溯到Object类，先执行Object的静态初始化块，再向下执行子 类的静态初始化块，直到我们的类的静态初始化块为止。</li>
</ol>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ul>
<li><u>通过extends父类(单继承)关键词或implements接口(多继承)</u></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>&#123;<br>String speciality;<br><span class="hljs-comment">//专业</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>不支持多继承</strong></p>
</li>
<li><p>在java（C++-）中类只有单继承，没有像C++那样的多继承。多 继承，就是为了实现代码的复用性，却引入了复杂性，使得系统类之间 的关系混乱；Java中的多继承，可以通过接口实现</p>
</li>
<li><p>如果定义一个类时，没有调用extends，则它的父类是java.lang.Object。Object类是所有java类的根基类。</p>
</li>
</ul>
<h3 id="1-方法的重写"><a href="#1-方法的重写" class="headerlink" title="1.方法的重写"></a>1.方法的重写</h3><ul>
<li><p>在子类中可以根据需要对父类中继承来的方法进行重写。</p>
</li>
<li><p>重写方法必须和被重写方法具有相同方法名称、参数列表。通过子类去调用该<br>方法，会调用重写方法而不是被重写方法(叫做重写方法覆盖被重写方法)。</p>
</li>
<li><p>可以在子类重写方法中调用被重写方法: super关键字。</p>
</li>
<li><p>重写方法的访问权限，子类大于等于父类(由于多态)。</p>
</li>
<li><p>重写方法的返回值类型和声明异常类型，子类小于等于父类。</p>
</li>
<li><p>对象.方法() :先在本类内部找是否有该方法，如果没有，到直接父类去找,<br>如果还没有，则一直往上层找，一直找到Object， 如果还没有，则报错。</p>
</li>
<li><p>子类继承父类的成员变量,子类继承父类除构造方法以外的成员方法,子类不能继承父类的构造方法,子类可以增加成员，可以重定义从父类继承来的成员，但不能删除它们。</p>
</li>
</ul>
<h3 id="2-子类对父类的访问权限"><a href="#2-子类对父类的访问权限" class="headerlink" title="2.子类对父类的访问权限"></a>2.子类对父类的访问权限</h3><ul>
<li><p>子类不能访问父类的私有成员( private )</p>
</li>
<li><p>子类能够访问父类的公有成员( public)和保护成员(protected)</p>
</li>
<li><p>子类对父类的缺省权限成员的访问控制，以包为界分两种情况，可以访问当前包中成员。</p>
</li>
</ul>
<h3 id="3-super引用"><a href="#3-super引用" class="headerlink" title="3.super引用"></a>3.super引用</h3><ol>
<li><p>调用父类的构造方法：super([参数列表])</p>
</li>
<li><p>super是直接父类对象的引用，和this类似。</p>
</li>
<li><p>引用父类同名成员</p>
<ul>
<li><p>子类隐藏父类成员变量：super.成员变量</p>
</li>
<li><p>子类覆盖父类成员方法：super.成员方法([参数列表])</p>
</li>
</ul>
</li>
<li><p>构造方法:任何类的构造方法中，若是构造函数的第一行代码没有显式调用<br>super(..);那么Java默认都会调用super();作为父类的初始化函数。所以这里的super()加不加都会无所谓。( 内存分析，wrap:new对象的时候采用子类包裹父类的结构)</p>
</li>
<li><p>同一个构造方法里面不能同时调用super()和this()。</p>
</li>
<li><p>在本类构造方法中通过super()调用，会一直 上溯到Object()这个构造函数,<br>然后按类层级，依次向下执行各层级构造函数中剩下的代码，直至最低层级的<br>构造函数。同this()一样，super()方法也应该放到构造方法的第一行。</p>
</li>
<li><p>new一个类的对象的时候，通过构造方法的从上至下的依次调用，就依次建<br>立了新的根对象、父类对象和自身对象，其中，this指向新建的对象本身，<br>super指向新建的直接父类对象本身。</p>
</li>
</ol>
<h3 id="4-组合VS继承"><a href="#4-组合VS继承" class="headerlink" title="4.组合VS继承"></a>4.组合VS继承</h3><ol>
<li><p>“is-a”关系使用继承，“has-a”关系使用组合:计算机类、主板类。可以通过在计算机类中增加主板属性来复用主板类的代码。</p>
</li>
<li><p>如果仅仅从代码复用的角度考虑，组合完全可以替代继承。</p>
</li>
<li><p>所谓组合，就是把要组合的另一个类作为属性放到类里面。</p>
</li>
<li><p>是就用继承、有就用组合。</p>
</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220916083605738.png" srcset="/img/loading.gif" lazyload alt="image-20220916083605738"></p>
<h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><h3 id="1-子类重定义父类成员"><a href="#1-子类重定义父类成员" class="headerlink" title="1.子类重定义父类成员"></a>1.子类重定义父类成员</h3><ul>
<li>子类隐藏父类成员变量</li>
<li>子类覆盖父类成员方法<ul>
<li>覆盖(override)是指子类声明并实现父类中的同名方法并且参数列表也完全相同。子类继承并重载父类成员方法</li>
<li>重载.(overload)是指同一个类中的多个方法可以同名但参数列表必须不同。</li>
</ul>
</li>
</ul>
<h3 id="2-类型的多态"><a href="#2-类型的多态" class="headerlink" title="2.类型的多态"></a>2.类型的多态</h3><ul>
<li><p>子类对象即是父类对象</p>
<p><code>new Student() instanceof Person //true</code></p>
<p><code>new Person() instanceof Student //false</code></p>
</li>
<li><p>父类对象引用子类对象</p>
<p><code>Person p = new Student(); / /赋值相容</code><br><code>Student s = new Person();//语法错误</code><br><code>Object obj = new Person();/ /赋值相容</code></p>
</li>
</ul>
<h3 id="3-编译时的多态和运行时的多态"><a href="#3-编译时的多态和运行时的多态" class="headerlink" title="3.编译时的多态和运行时的多态"></a>3.编译时的多态和运行时的多态</h3><ul>
<li><p>编译时多态性</p>
<p><u>方法重载都是编译时多态。</u></p>
<p><u>方法覆盖表现出两种多态性，当对象引用本类实例时，为编译时多态，否则为运行时多态。</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(.....);<br>p.toString()<br><span class="hljs-comment">//执行Person类的toString()</span><br>Student s= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Studen</span>(.....);<br>s.toString()<br><span class="hljs-comment">//执行Student类的toString()</span><br></code></pre></td></tr></table></figure></li>
<li><p>运行时多态性</p>
<p><u>自下而上搜索，有则调用无责溯源</u></p>
<p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220916085315869.png" srcset="/img/loading.gif" lazyload alt="image-20220916085315869"></p>
</li>
</ul>
<h3 id="4-多态的方法实现"><a href="#4-多态的方法实现" class="headerlink" title="4.多态的方法实现"></a>4.多态的方法实现</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220921141638509.png" srcset="/img/loading.gif" lazyload alt="image-20220921141638509"></p>
<ul>
<li><p>子类类型的对象地址可以直接赋给父类类型的引用对象，这个称为向上转型，是实现多态的基础。</p>
</li>
<li><p>A instanceof B: A对象的类型是否是B类型，只有在A对象的类型和B类型相同，或为父子类型时，编译不报错。而在运行时，只有A对象类型为B类型的子类型或者就是B类型时，结果才返回true。</p>
</li>
<li><p>内存分析(例子: myServlet) :调用父类的service(),然后调用子类的doGet() (注意: this关键字指向整个最终包裹对象，即最外层的子对象;而在包裹对象中，每-一层对象通过super关键字指向内一层的父对象)。</p>
</li>
<li><p>多态指的是方法的多态(到底调用那个方法，运行时决定)，属性没有多态。</p>
</li>
<li><p>针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p>
</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220921145517282.png" srcset="/img/loading.gif" lazyload alt="image-20220921145517282"></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClosedFigure</span><br><span class="hljs-comment">//闭合图形抽象类</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">( )</span>;<br><span class="hljs-comment">//计算面积，抽象方法，以分号&quot;;&quot;结束</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><u>构造方法、静态成员方法</u>不能被声明为抽象<br>方法。</li>
<li>一个非抽象类必须实现从父类继承来的所有<br>抽象方法。</li>
<li>不能创建抽象类的实例。例如:<code>ClosedFigure g = new ClosedFigure();</code> </li>
<li><u>abstract修饰方式的初衷就是要求其子类覆盖(实现)这个方法，并且调用时可以以多态方式调用子类覆盖后的方法(抽象类主要和多态技术相结合)</u>，即抽象方法必须在其子类中实现，除非子类本身也是抽象类。<u>abstract不允许修饰成员变量</u>，因为成员变量也没有重写这个概念!</li>
<li>抽象类可以只有具体方法，也可以全是抽象方法，子类继承抽象类也可以是抽象类，但要实例化的类不能是抽象类。</li>
<li>不能放在一起的修饰符: <u>final和abstract, private和abstract, static和abstract</u>，因为abstract修饰的方法是必须在其子类中实现(覆盖)，才能以多态方式调用，以上修饰符在修饰方法时期子类都覆盖不了这个方法，<u>final是不可以覆盖</u>，<u>private是不能</u><br><u>够继承到子类</u>，所以也就不能覆盖，<u>static是可以覆盖的，但是在调用时会调用编译时类型的方法，因为调用的是父类的方法，而父类的方法又是抽象的方法，又不能够调用</u>，所以上面的修饰符不能放在一起。</li>
</ol>
<h2 id="最终类"><a href="#最终类" class="headerlink" title="最终类"></a>最终类</h2><ol>
<li><p>声明最终类， 不能被继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span><br><span class="hljs-comment">//数学类，最终类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMath</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Math</span><br><span class="hljs-comment">//语法错</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Ellipse</span> / /最终类<br></code></pre></td></tr></table></figure></li>
<li><p>声明最终方法,不能被子类覆盖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Ellipse</span><br><br>/ /非最终类<br><br>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-title function_">area</span><span class="hljs-params">( )</span><br><br><span class="hljs-comment">//最终方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="final关键词"><a href="#final关键词" class="headerlink" title="final关键词"></a>final关键词</h3><ol>
<li>final修饰变量时表示常量。<u>变量被final修饰，就会变成常量</u>(常量应大写)，一旦赋值不能改变(可以在<u>初始化时直接赋值</u>，也可以在<u>构造方法里赋值</u>，只能在这两种方法里二选一，<u>必须为常量赋值</u>) ;final的常量不会有默认初始值，对于直接在初始化时赋值方式，final修饰符常和static修饰符一起使用。</li>
<li>final修饰方法( 最终方法)时表示<u>该方法不可被子类重写</u>。但是<u>可以被重载</u>。</li>
<li><u>final修饰类</u>(最终类)时表示修饰的<u>类不能有子类</u>，不能被继承。比如Math、String。 final类中的方法也都是final的。</li>
</ol>
<h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><p><u>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以将该抽象类改为接口。</u></p>
<p>类不能多继承类，但可以实现多个接口，一个接口可以继承多个接口。</p>
<p>接口可以看成<u><strong>狭义抽象</strong></u>，将设计与实现彻底分离。</p>
<p>通过给类新增接口来改变类，而不影响子类。</p>
<p>接口不能有构造方法，抽象类可以有。</p>
<p>接口可以定义<code>default</code>方法（有方法实体，子类可以不用重写）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> ;<br>String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类实现接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//规定下面的编译为重写</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="抽象类和接口的对比"><a href="#抽象类和接口的对比" class="headerlink" title="抽象类和接口的对比"></a>抽象类和接口的对比</h3><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220921155545894.png" srcset="/img/loading.gif" lazyload alt="image-20220921155545894" style="zoom: 80%" align="middle" />



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Xiao Ming&quot;</span>);<br>        p.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(getName() + <span class="hljs-string">&quot; run&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="接口与抽象的区别"><a href="#接口与抽象的区别" class="headerlink" title="接口与抽象的区别"></a>接口与抽象的区别</h3><ul>
<li><p>接口不能有方法体，抽象类可以有。</p>
</li>
<li><p>接口不能有静态方法，抽象类可以有。</p>
</li>
<li><p>在接口中凡是变量必须是public static final,而在抽象类中没有要求。</p>
</li>
<li><p>抽象类本质上还是-一个类，子类是用关键字extends来继承它，并扩展的，有非常强的is-a的关系。而接口，是被其他类用关键字implements来实现接口定义的方法的。接口只是定义功能和行为规范，如果一个类实现了一个接口，那么这个类必须遵守这个接口的方法约定，但没有is-a的关系。</p>
</li>
</ul>
<h3 id="内部类和内部接口"><a href="#内部类和内部接口" class="headerlink" title="内部类和内部接口"></a>内部类和内部接口</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923082921856.png" srcset="/img/loading.gif" lazyload alt="image-20220923082921856"></p>
<ul>
<li><p>内嵌类型不能与外层类型同名。</p>
</li>
<li><p>内部类中可以声明成员变量和成员方法。</p>
</li>
<li><p>内部类可以继承父类或实现接口。.</p>
</li>
<li><p>可以声明内部类为抽象类，该抽象类必须被其他内部类继承;内部接口必须被其他内部类实现。</p>
</li>
<li><p>使用点运算符“”引用内嵌类型:外层类型.内嵌类型Pixel.Color</p>
</li>
<li><p>内嵌类型具有类中成员的4种访问控制权限。当内部类可被访问时，才能考虑内部类中成员的访问控制权限。</p>
</li>
<li><p>内嵌类型与其外层类型彼此信任，能访问对方的所有成员</p>
</li>
<li><p>内部接口总是静态的。内部类可声明是静态的或实例的，静态内部类能够声明静态成员，但不能引用外部类的实例成员;实例内部类不能声明静态成员。</p>
</li>
<li><p>在实例内部类中，使用以下格式引用或调用外部类当前实例的成员变量或实例成员方法:</p>
<p><code>外部类.this.成员变量//引用外部类当前实例的成员变量</code></p>
<p><code>外部类.this.实例成员方法(参数列表)//调用外部类当前实例的成员方法</code></p>
</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923083806822.png" srcset="/img/loading.gif" lazyload alt="image-20220923083806822"></p>
<p>**自动裝箱:**基本数据类型就自动的封装到与它相同类型的包装中。如:Integeri = 100;本质上就是编译器编译时自动为我们添加了Integeri = new Integer( 100);<br><strong>自动拆箱</strong>:包装类对象自动转化为基本数据类型。如:inta=new Integer(100);本质上就是编译器编译时自动为我们添加了inta = new Integer( 100).intValue();<br><strong>缓存问题:</strong> [-128,127]之 间的数对应的包装类对象，仍然当做基本数据类型来处理;一旦遇到一个这个之间的数(默认为这些小的数使用频率会很高)，把他包装成-一个对象后，就缓存起来，下次如果又要包装-一个这个数的对象，则去看是否已经有这个对象，有就直接拿来使用，这样可以节省内存空间、提高效率(享元模式)。<br>**享元模式:**有很多小对象，它们的大部分属性相同，这时可以把它们变成-一个对象，那些相同的属性为对象的内部状态，那些不同的属性可以变为方法的参数，由外部传入。例: -128~127 内的相同整数自动装箱为同一个对象。</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型声明"><a href="#泛型声明" class="headerlink" title="泛型声明"></a>泛型声明</h3><p><code>[修饰符] class 类&lt;类型参数列表&gt; [extends父类] [implements 接口列表]</code><br><code>[public] interface 接口 &lt; 类型参数列表&gt; [extends父接口列表]</code><br><code>[public] [static]&lt; &lt; 类型参数列表&gt;返回值类型方法([参数列表]) [throws 异常类列表]</code></p>
<p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923092011478.png" srcset="/img/loading.gif" lazyload alt="image-20220923092011478"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericIntercace</span>&lt;T&gt; &#123;<br>T <span class="hljs-title function_">getData</span><span class="hljs-params">()</span>;<span class="hljs-comment">//类似于c++的模板</span><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>接口中泛型字母只能使用在方法中，不能使用在全局常量中</p>
</li>
<li><p>泛型方法可以在非泛型类中</p>
</li>
</ul>
<h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>泛型父类:子类为”富二代”:子类的泛型要比父类多</p>
<ol>
<li><p>保留父类的泛型–&gt;子类为泛型类</p>
</li>
<li><p>不保留父类泛型–&gt;子类按需实现</p>
</li>
</ol>
<ul>
<li>子类. [重写方法]的参数类型–&gt;随父类而定</li>
<li>子类新增的方法，参数类型随子类而定</li>
<li>子类中使用父类的[属性] –&gt; 随父类而定</li>
<li>子类使用自己的属性–&gt;随子类而定</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220923093134846.png" srcset="/img/loading.gif" lazyload alt="image-20220923093134846"></p>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><ul>
<li>定义:泛型擦除是指在继承(实现)或使用时没有指定具体的类型</li>
<li>特点:一旦擦除之后按Object处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//2)没有类型擦除--》Object</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C4</span> &lt;A,B&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Object name)</span> &#123;子类重写方法的参数类型--&gt;随父类而定:<br>Object <br><span class="hljs-type">this</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>:);<span class="hljs-comment">//Object类型，子类使用父类的[属性]，类型</span><br>随父类而定<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ul>
<li>T、K、V、E等泛型字母为有类型，类型参数赋予具体的值</li>
<li>?未知类型类型参数赋予不确定值，任意类型</li>
<li>只能用在声明类型、方法参数上，不能用在定义泛型类上</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[ args)</span> &#123;<br>List&lt;String&gt; name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayL</span> ist&lt;String&gt;();<br>List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayL</span> ist&lt;Integer&gt;();<br>List&lt;Number&gt; number = <span class="hljs-keyword">new</span><br><span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>name.add(<span class="hljs-string">&quot;icon&quot;</span>);<br>age.add(<span class="hljs-number">18</span>);<br>number.add(<span class="hljs-number">314</span>);<br>getData(name);<br>getData(age); <br>getData(number);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">(List&lt;?&gt; data)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;data :&quot;</span> + data.get(<span class="hljs-number">0</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="第四章、异常处理"><a href="#第四章、异常处理" class="headerlink" title="第四章、异常处理"></a>第四章、异常处理</h1><h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><ul>
<li>用户输入了非法数据。 </li>
<li>要打开的文件不存在。 </li>
<li>网络通信时连接中断，或者JVM内存溢出。</li>
</ul>
<p><img src="C:\Users\alleyf\AppData\Roaming\Typora\typora-user-images\image-20220928141405830.png" srcset="/img/loading.gif" lazyload alt="image-20220928141405830"></p>
<h2 id="异常处理基础"><a href="#异常处理基础" class="headerlink" title="异常处理基础"></a>异常处理基础</h2><ul>
<li><p>将程序正常代码与错误处理代码分开。</p>
</li>
<li><p>使程序具有处理运行错误的能力。</p>
</li>
</ul>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>( Error)指程序运行时遇到的硬件、操作系统、<br>虚拟机的错误。 Error错误类。Java程序<strong>不能处理错误</strong>，只能依靠外界干预。</p>
<ol>
<li>NoClassDefFoundError类定，义未找到错误。没有<br>.class文件， 或没有main()方法时。</li>
<li>OutOfMemoryError内存溢出错误。没有可用内存时。</li>
<li>StackOverflowError栈溢出错误。当递归函数不能正常结束时。</li>
</ol>
<p><img src="C:\Users\alleyf\AppData\Roaming\Typora\typora-user-images\image-20220928142730920.png" srcset="/img/loading.gif" lazyload alt="image-20220928142730920"></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>（Exception）指在硬件、操作系统、虚拟 机正常时，程序遇到的运行错（语义错）</p>
<h4 id="异常类（默认java-lang包）"><a href="#异常类（默认java-lang包）" class="headerlink" title="异常类（默认java.lang包）"></a>异常类（默认java.lang包）</h4><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220928143014612.png" srcset="/img/loading.gif" lazyload alt="image-20220928143014612"></p>
<h4 id="内置异常类"><a href="#内置异常类" class="headerlink" title="内置异常类"></a>内置异常类</h4><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220928160253693.png" srcset="/img/loading.gif" lazyload alt="image-20220928160253693"></p>
<h4 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h4><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220928160326479.png" srcset="/img/loading.gif" lazyload alt="image-20220928160326479"></p>
<p>异常类声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Throwable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> <br>&#123;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> <span class="hljs-comment">//获得异常信息</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> <span class="hljs-comment">//获得异常对象的描述信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStackTrace</span><span class="hljs-params">()</span><span class="hljs-comment">//显示异常栈跟踪信息</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Exception</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Exception</span><span class="hljs-params">(String message)</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol>
<li><p><strong>ArithmeticException</strong></p>
<p> 3/0 //整除，除数为0，算术异常</p>
<p>3.0/0 //实数除，除数为0，无穷大 </p>
</li>
<li><p><strong>NullPointerException</strong> 空对象异常</p>
<p> int x[] = null;</p>
<p> x[0] = 1; //对空数组中的元素进行操作</p>
<p> String str = null;</p>
<p> str.length() //空对象调用方法</p>
</li>
<li><p><strong>ClassCastException</strong> </p>
<p>Object obj = new Object(); </p>
<p>String str = (String) obj; //类型强制转换异常</p>
</li>
</ol>
<h2 id="异常处理措施"><a href="#异常处理措施" class="headerlink" title="异常处理措施"></a>异常处理措施</h2><h3 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span><br>&#123;<br>语句<span class="hljs-number">1</span>； <span class="hljs-comment">//存在潜在异常的代码</span><br>&#125;<br><span class="hljs-keyword">catch</span> (异常类 异常对象)<br>&#123;<br>语句<span class="hljs-number">2</span>； <span class="hljs-comment">//捕获到异常并进行处理的代码</span><br>&#125;<br><span class="hljs-keyword">finally</span><br>&#123;<br>语句<span class="hljs-number">3</span>；<span class="hljs-comment">//最后必须执行的代码，无论是否捕获到异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p><u>抛出异常对象的throw语句</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">[修饰符] 返回值类型 方法([参数列表])[<span class="hljs-keyword">throws</span>异常类列表]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s)</span><br><span class="hljs-keyword">throws</span> NumberFormatException<br>日期类声明抛出异常的方法与方法调用者处理异常。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span><br><span class="hljs-keyword">throws</span> Exception<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyDate</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span><br><span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-built_in">this</span>.set(year, month, day);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception<br></code></pre></td></tr></table></figure>

<h3 id="throws和throw以及try-catch-finally的区别"><a href="#throws和throw以及try-catch-finally的区别" class="headerlink" title="throws和throw以及try-catch-finally的区别"></a>throws和throw以及try-catch-finally的区别</h3><ul>
<li>throws为方法声明可能出现的异常，函数调用者处理不处理异常则继续向下抛出异常直至被处理，否则程序结束。</li>
<li>throw主要是发现异常并抛出指定的异常给调用者。</li>
<li>throw要么和try-catch-finally语句配套使用，要么与throws配套 使用。但throws可以单独使用，然后再由处理异常的方法捕获。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowsDemo</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwOne</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>System.out.println(<span class="hljs-string">&quot;Inside throwOne.&quot;</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalAccessException</span>(<span class="hljs-string">&quot;demo&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br>throwOne();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;Caught &quot;</span> + e);<br>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第五章、图形用户界面（GUI）"><a href="#第五章、图形用户界面（GUI）" class="headerlink" title="第五章、图形用户界面（GUI）"></a>第五章、图形用户界面（GUI）</h1><h2 id="AWT组件及其属性"><a href="#AWT组件及其属性" class="headerlink" title="AWT组件及其属性"></a>AWT组件及其属性</h2><ul>
<li>java.awt包提供抽象窗口工具集（Abstract  Window Tookit，AWT）</li>
<li>javax.swing包提供JDK 1.2的Swing组件， 它扩展了AWT组件的功能</li>
</ul>
<h3 id="AWT组件"><a href="#AWT组件" class="headerlink" title="AWT组件"></a>AWT组件</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930081159260.png" srcset="/img/loading.gif" lazyload alt="image-20220930081159260"></p>
<h3 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h3><h3 id="颜色和字体"><a href="#颜色和字体" class="headerlink" title="颜色和字体"></a>颜色和字体</h3><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930090145928.png" srcset="/img/loading.gif" lazyload alt="image-20220930090145928"></p>
<h2 id="Swing组件及事件"><a href="#Swing组件及事件" class="headerlink" title="Swing组件及事件"></a>Swing组件及事件</h2><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930090437034.png" srcset="/img/loading.gif" lazyload alt="image-20220930090437034"></p>
<p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20220930090537860.png" srcset="/img/loading.gif" lazyload alt="image-20220930090537860"></p>
<h2 id="图形图像"><a href="#图形图像" class="headerlink" title="图形图像"></a>图形图像</h2><h1 id="第六章、多线程编程"><a href="#第六章、多线程编程" class="headerlink" title="第六章、多线程编程"></a>第六章、多线程编程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>是系统进行<strong>资源分配的基本单位</strong>，指一个内存中运行的应用程序 ，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>是系统<strong>资源调度的基本单位</strong>，进程内部的一个独立执行单元；一个进程可以同时并发的运行多个线程，可以理解为一个进程便相当于一个单 CPU 操作系统，而线程便是这个系统中运行的多个任务。 </p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>进程：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。</p>
<p>线程：<strong>堆内存</strong>和<strong>方法区</strong>是<strong>共享</strong>的，<strong>栈内存</strong>是<strong>独立</strong>的，线程消耗的资源比进程小的多。 </p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><strong><code>提高系统的资源利用率和程序的处理效率</code></strong></p>
<h3 id="状态及转换"><a href="#状态及转换" class="headerlink" title="状态及转换"></a>状态及转换</h3><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080603796.png" srcset="/img/loading.gif" lazyload>



<img src="https://img-blog.csdnimg.cn/20210512173109590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload>




<h3 id="多线程结构"><a href="#多线程结构" class="headerlink" title="多线程结构"></a>多线程结构</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080648065.png" srcset="/img/loading.gif" lazyload alt="image-20221007080648065"></p>
<p><img src="https://img-blog.csdnimg.cn/20210512175007490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080759956.png" srcset="/img/loading.gif" lazyload alt="image-20221007080759956"></p>
<h2 id="Java的线程对象"><a href="#Java的线程对象" class="headerlink" title="Java的线程对象"></a>Java的线程对象</h2><ol>
<li>通过实现<strong>接口Runnable，实现void run()方法</strong>创建线程对象，是线程对象。<ul>
<li>创建一个实现Runnable接口的类。</li>
<li>实现类去实现Runnable接口中的抽象方法：run()。</li>
<li>创建实现类的对象。</li>
<li>将此对象作为参数传到Thread类的构造器中，创建Thread类的对象。</li>
<li>通过Thread类的对象调用start()方法。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.broky.multiThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建实现类的对象</span><br>        <span class="hljs-type">RunnableThread01</span> <span class="hljs-variable">runnableThread01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableThread01</span>();<br>        <span class="hljs-comment">//创建Thread类的对象,并将实现类的对象当做参数传入构造器</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnableThread01);<br>        <span class="hljs-comment">//使用Thread类的对象去调用Thread类的start()方法:①启动了线程 ②Thread中的run()调用了Runnable中的run()</span><br>        t1.start();<br><br>        <span class="hljs-comment">//在创建一个线程时，只需要new一个Thread类就可,不需要new实现类</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnableThread01);<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//RunnableThread01实现Runnable接口的run()抽象方法</span><br><span class="hljs-comment">// 这并不是一个线程类，是一个可运行的类。它还不是一个线程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableThread01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>通过**继承Thread类并重写void run()**方法创建线程对象，是线程的目标对象。<ul>
<li>创建一个继承于Thread类的子类。</li>
<li>重写Thread类的run()方法。</li>
<li>创建Thread类的子类的对象。</li>
<li>通过此对象调用start()来启动一个线程。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.broky.multiThread.exer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExerDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread01</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread02</span>().start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>两种实现方式的比较</strong></p>
<ul>
<li><p><strong>第二种方式</strong>实现接口比较常用，因为一个类实现了接口，它还可以去继承其它的类，更灵活。</p>
</li>
<li><p>Java中只允许单进程，以卖票程序TiketSales类来说，很有可能这个类本来就有父类，这样一来就不可以继承Thread类来完成多线程了，但是一个类可以实现多个接口，因此实现的方式没有类的单继承性的局限性，用实现Runnable接口的方式来完成多线程更加实用。</p>
</li>
<li><p>实现Runnable接口的方式天然具有共享数据的特性（不用static变量）。因为继承Thread的实现方式，需要创建多个子类的对象来进行多线程，如果子类中有变量A，而不使用static约束变量的话，每个子类的对象都会有自己独立的变量A，只有static约束A后，子类的对象才共享变量A。而实现Runnable接口的方式，只需要创建一个实现类的对象，要将这个对象传入Thread类并创建多个Thread类的对象来完成多线程，而这多个Thread类对象实际上就是调用一个实现类对象而已。实现的方式更适合来处理多个线程有共享数据的情况。</p>
</li>
<li><p>联系：Thread类中也实现了Runnable接口</p>
</li>
<li><p>相同点两种方式都需要重写run()方法，线程的执行逻辑都在run()方法中</p>
</li>
</ul>
<ol start="3">
<li>实现Callable接口<ul>
<li>相比run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.broky.multiThread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建线程的方式三：实现Callable接口。 ---JDK5新特性</span><br><span class="hljs-comment"> * 如何理解Callable比Runnable强大？</span><br><span class="hljs-comment"> * 1.call()可以有返回值</span><br><span class="hljs-comment"> * 2.call()可以抛出异常被外面的操作捕获</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//1.创建一个实现Callable的实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;<br>    <span class="hljs-comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                System.out.println(i);<br>                sum += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadNew</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//3.创建Callable接口实现类的对象</span><br>        <span class="hljs-type">NumThread</span> <span class="hljs-variable">numThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumThread</span>();<br>        <span class="hljs-comment">//4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(numThread);<br>        <span class="hljs-comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//6.获取Callable中Call方法的返回值</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;总和为&quot;</span>+sum);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>线程池</p>
<ul>
<li><strong>背景：</strong></li>
</ul>
<p> 经常创建和销毁、使用量特别大的资源、比如并发情况下的线程、对性能影响很大。</p>
<ul>
<li><strong>思路：</strong></li>
</ul>
<p> 提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<ul>
<li><strong>优点：</strong></li>
</ul>
<p> 提高响应速度（减少了创建新线程的时间）</p>
<p> 降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
<p> 便于线程管理</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.broky.multiThread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建线程的方式四：使用线程池</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 面试题：创建多线程有几种方式</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 13roky</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021-04-22 21:49</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:\t&quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//1.提供指定线程数量的线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">service1</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) service;<br>        <span class="hljs-comment">//设置线程池的属性</span><br>        <span class="hljs-comment">//        System.out.println(service.getClass());</span><br>        <span class="hljs-comment">//        service1.setCorePoolSize(15);</span><br>        <span class="hljs-comment">//        service1.setKeepAliveTime();</span><br><br>        <span class="hljs-comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象。</span><br>        service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumberThread</span>()); <span class="hljs-comment">//适合用于Runnable</span><br>        <span class="hljs-comment">//        service.submit(); 适合适用于Callable</span><br>        <span class="hljs-comment">//关闭线程池</span><br>        service.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h3><ul>
<li><p>start() : 启动当前线程, 调用当前线程的run()方法</p>
</li>
<li><p>run() : 通常需要重写Thread类中的此方法, 将创建的线程要执行的操作声明在此方法中</p>
</li>
<li><p>currentThread() : 静态方法, 返回当前代码执行的线程</p>
</li>
<li><p>getName() : 获取当前线程的名字</p>
</li>
<li><p>setName() : 设置当前线程的名字</p>
</li>
<li><p>yield() : 释放当前CPU的执行权，回到就绪状态，在回到就绪之后，<strong>有可能还会再次抢到</strong>,抢到后接着运行（让位）。</p>
</li>
<li><p>join(long millis, int nanos) : 在线程a中调用线程b的join(), 此时线程a进入阻塞状态, 直到线程b完全执行完以后（等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒）, 线程a才结束阻塞状态</p>
</li>
<li><p>stop() : 已过时. 当执行此方法时,强制结束当前线程.</p>
</li>
<li><p>sleep(long militime) : 让线程睡眠指定的毫秒数后回到就绪态抢夺CPU时间片，在指定时间内，线程是定时等待状态,可以实现线程定时执行。</p>
</li>
<li><p>isAlive() ：判断当前线程是否存活</p>
</li>
</ul>
<p><strong>join用法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest13</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main begin&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable7</span>());<br>        t.setName(<span class="hljs-string">&quot;t&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">//合并线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join(); <span class="hljs-comment">// t合并到当前线程中，当前线程受阻塞，t线程执行直到结束。</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;main over&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable7</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;---&gt;&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>线程正常结束模板</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">thread10</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyRunable4</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunable4</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>        t.setName(<span class="hljs-string">&quot;t&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">// 模拟5秒</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// 终止线程</span><br>        <span class="hljs-comment">// 你想要什么时候终止t的执行，那么你把标记修改为false，就结束了。</span><br>        r.run = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunable4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-comment">// 打一个布尔标记</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(run)&#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;---&gt;&quot;</span> + i);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// return就结束了，你在结束之前还有什么没保存的。</span><br>                <span class="hljs-comment">// 在这里可以保存呀。</span><br>                <span class="hljs-comment">//save....</span><br><br>                <span class="hljs-comment">//终止当前线程</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>JDk中用Thread.State类定义了线程的几种状态</li>
</ul>
<p>想要实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在他的一个完整的生命周期中通常要经历如下的<strong>五种状态</strong>：</p>
<ol>
<li>新建：当一个Thread类或其子类的对象被声明并创建时，新的线程对象处于新建状态。</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源。</li>
<li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能。</li>
<li>阻塞：在某种特殊情况下，被认为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态。</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性的中止或出现异常倒置导致结束。<div align="center">
 <img src='https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/qiV0by.png'>
</div></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/image-20221007080944453.png" srcset="/img/loading.gif" lazyload alt="image-20221007080944453"></h3><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><h3 id="调度种类"><a href="#调度种类" class="headerlink" title="调度种类"></a>调度种类</h3><ul>
<li><strong>抢占式</strong>调度模型：<br>那个线程的优先级比较高，抢到的CPU时间片的概率就高一些/多一些。<br><strong>java采用的就是抢占式调度模型</strong>。</li>
<li><strong>均分式</strong>调度模型：<br>平均分配CPU时间片。每个线程占有的CPU时间片时间长度一样。<br>平均分配，一切平等。<br>有一些编程语言，线程调度模型采用的是这种方式。</li>
</ul>
<h3 id="cpu的调度策略"><a href="#cpu的调度策略" class="headerlink" title="cpu的调度策略"></a>cpu的调度策略</h3><ul>
<li><strong>时间片：</strong>cpu正常情况下的调度策略。即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</li>
<li><strong>抢占式：</strong>高优先级的线程抢占cpu。</li>
</ul>
<h3 id="Java的调度算法："><a href="#Java的调度算法：" class="headerlink" title="Java的调度算法："></a>Java的调度算法：</h3><ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略。</li>
<li>堆高优先级，使用优先调度的抢占式策略。</li>
</ul>
<p><strong>线程的优先级等级</strong>（一共有10挡）</p>
<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN_PRIORITY：1</li>
<li>NORM_PRIORITY：5 (默认优先级)</li>
</ul>
<p><strong>获取和设置当前线程的优先级</strong></p>
<ul>
<li><code>getPriority();</code> 获取</li>
<li><code>setPriority(int p);</code> 设置</li>
</ul>
<p><strong>说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有高优先级的线程执行完成以后，低优先级的线程才执行。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.coding.demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Threadtest11</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;最高优先级：&quot;</span> + Thread.MAX_PRIORITY);<span class="hljs-comment">//最高优先级：10</span><br>        System.out.println(<span class="hljs-string">&quot;最低优先级:&quot;</span> + Thread.MIN_PRIORITY);<span class="hljs-comment">//最低优先级:1</span><br>        System.out.println(<span class="hljs-string">&quot;默认优先级:&quot;</span> + Thread.NORM_PRIORITY);<span class="hljs-comment">//默认优先级:5</span><br>        <br>        <span class="hljs-comment">// main线程的默认优先级是：5</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程的默认优先级是：&quot;</span> + Thread.currentThread().getPriority());<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable5</span>());<br>        t.setPriority(<span class="hljs-number">10</span>);<br>        t.setName(<span class="hljs-string">&quot;t&quot;</span>);<br>        t.start();<br><br>        <span class="hljs-comment">// 优先级较高的，只是抢到的CPU时间片相对多一些。</span><br>        <span class="hljs-comment">// 大概率方向更偏向于优先级比较高的。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable5</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="安全问题出现的条件"><a href="#安全问题出现的条件" class="headerlink" title="安全问题出现的条件"></a>安全问题出现的条件</h3><p><strong>满足三个条件：</strong></p>
<ol>
<li>条件1：<strong>多线程并发</strong>。</li>
<li>条件2：<strong>有共享数据</strong>。</li>
<li>条件3：<strong>共享数据有修改的行为</strong>。</li>
</ol>
<p>满足以上3个条件之后，就会存在线程安全问题。</p>
<h3 id="两个专业术语"><a href="#两个专业术语" class="headerlink" title="两个专业术语"></a>两个专业术语</h3><p><strong>异步编程模型：</strong><br>线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，谁也不需要等谁，这种编程模型叫做：异步编程模型。</p>
<p>实质：多线程并发（效率较高）</p>
<p><strong>异步就是并发。</strong></p>
<p><strong>同步编程模型：</strong><br>线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，两个线程之间发生了等待关系，这就是同步编程模型。</p>
<p>实质：线程排队执行，效率较低。</p>
<p><strong>同步就是排队。</strong></p>
<h3 id="线程安全和非线程安全的类的选择"><a href="#线程安全和非线程安全的类的选择" class="headerlink" title="线程安全和非线程安全的类的选择"></a>线程安全和非线程安全的类的选择</h3><ul>
<li><p>StringBuffer是线程安全的类，但效率低。</p>
</li>
<li><p>StringBuilder是非线程安全的类，用于代替StringBuffer。</p>
</li>
<li><p>ArrayList是非线程安全的，用于代替Vector。</p>
</li>
<li><p>Vector是线程安全的。</p>
</li>
<li><p>HashMap HashSet是非线程安全的，用于代替Hashtable。</p>
</li>
<li><p>Hashtable是线程安全的。</p>
</li>
</ul>
<p>线程安全的类的方法都是<strong>同步方法</strong>，因此这些类是安全的，线程非安全的类可以用作<strong>局部变量</strong>以避免线程安全问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>是一上来就选择线程同步吗？synchronized</p>
<p>不是，synchronized会让程序的执行效率降低，用户体验不好。<br>系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择线程同步机制。</p>
<ul>
<li>第一种方案：尽量使用<strong>局部变量</strong> <em>代替</em> “<strong>实例变量</strong>和<strong>静态变量</strong>”。</li>
<li>第二种方案：<strong>如果必须是实例变量</strong>，那么可以考虑<strong>创建多个对象</strong>，这样实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，对象不共享，就没有数据安全问题了。）</li>
<li>第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择<strong>synchronized</strong>了。<strong>线程同步机制</strong>。</li>
</ul>
<h2 id="synchronized-线程同步"><a href="#synchronized-线程同步" class="headerlink" title="synchronized-线程同步"></a>synchronized-线程同步</h2><p>线程同步机制的<strong>语法</strong>是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>()&#123;<br>	<span class="hljs-comment">// 线程同步代码块。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>重点：</strong><br>synchronized后面<strong>小括号()</strong> 中传的这个“数据”是相当关键的。这个数据必须是 <strong><code>多线程共享</code></strong> 的数据。才能达到多线程排队。</p>
<p><strong>注意：</strong><br>在java语言中，任何一个对象都有“一把锁”，其实这把锁就是标记。（只是把它叫做锁。）<br><strong>100个对象，100把锁。1个对象1把锁。</strong></p>
<h3 id="同步的执行原理"><a href="#同步的执行原理" class="headerlink" title="同步的执行原理"></a>同步的执行原理</h3><p>1、假设t1和t2线程并发，开始执行以下代码的时候，肯定有一个先一个后。</p>
<p>2、假设t1先执行了，遇到了<strong>synchronized</strong>，这个时候自动找“后面<strong>共享对象</strong>”的<strong>对象锁</strong>，<br>找到之后，并<strong>占有这把锁</strong>，然后<strong>执行同步代码块</strong>中的程序，在程序执行过程中一直都是<br><strong>占有这把锁</strong>的。<strong>直到同步代码块代码结束，这把锁才会释放。</strong></p>
<p>3、假设t1已经占有这把锁，此时t2也遇到synchronized关键字，也会去占有后面<br>共享对象的这把锁，结果这把锁被t1占有，t2只能在同步代码块外面<strong>等待t1的结束</strong>，<br>直到t1把同步代码块执行结束了，t1会归还这把锁，此时t2终于等到这把锁，然后<br>t2占有这把锁之后，进入同步代码块执行程序。</p>
<p>4、这样就达到了<strong>线程排队</strong>执行。</p>
<p><strong>重中之重：</strong><br><code>“锁”</code>即该对象的<strong>控制权</strong>，有锁才能修改该对象；这个共享对象一定要选好了。这个共享对象一定是你需要排队执行的这些线程对象所共享的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> String actno;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> balance; <span class="hljs-comment">//实例变量。</span><br><br>    <span class="hljs-comment">//对象</span><br>    Object o= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 实例变量。（Account对象是多线程共享的，Account对象中的实例变量obj也是共享的。）</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account</span><span class="hljs-params">(String actno, <span class="hljs-type">double</span> balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.actno = actno;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getActno</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> actno;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setActno</span><span class="hljs-params">(String actno)</span> &#123;<br>        <span class="hljs-built_in">this</span>.actno = actno;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBalance</span><span class="hljs-params">(<span class="hljs-type">double</span> balance)</span> &#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-comment">//取款的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 以下可以共享,金额不会出错</span><br><span class="hljs-comment">         * 以下这几行代码必须是线程排队的，不能并发。</span><br><span class="hljs-comment">         * 一个线程把这里的代码全部执行结束之后，另一个线程才能进来。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">//synchronized(actno) &#123;</span><br>        <span class="hljs-comment">//synchronized(o) &#123;</span><br>        <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 以下不共享，金额会出错</span><br><span class="hljs-comment">         */</span><br>		  <span class="hljs-comment">/*Object obj = new Object();</span><br><span class="hljs-comment">	        synchronized(obj) &#123; // 这样编写就不安全了。因为obj2不是共享对象。</span><br><span class="hljs-comment">	        synchronized(null) &#123;//编译不通过</span><br><span class="hljs-comment">	        String s = null;</span><br><span class="hljs-comment">	        synchronized(s) &#123;//java.lang.NullPointerException*/</span><br>            <span class="hljs-type">double</span> <span class="hljs-variable">before</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBalance();<br>            <span class="hljs-type">double</span> <span class="hljs-variable">after</span> <span class="hljs-operator">=</span> before - money;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-built_in">this</span>.setBalance(after);<br>        <span class="hljs-comment">//&#125;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 两个线程必须共享同一个账户对象。</span><br>    <span class="hljs-keyword">private</span> Account act;<br><br>    <span class="hljs-comment">// 通过构造方法传递过来账户对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountThread</span><span class="hljs-params">(Account act)</span> &#123;<br>        <span class="hljs-built_in">this</span>.act = act;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;<br>        act.withdraw(money);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;对&quot;</span>+act.getActno()+<span class="hljs-string">&quot;取款&quot;</span>+money+<span class="hljs-string">&quot;成功，余额&quot;</span> + act.getBalance());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建账户对象（只创建1个）</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">act</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;act-001&quot;</span>, <span class="hljs-number">10000</span>);<br>        <span class="hljs-comment">// 创建两个线程，共享同一个对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountThread</span>(act);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountThread</span>(act);<br><br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    	&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码锁<strong>this、实例变量actno、实例变量o</strong>都可以！因为这三个是线程共享！</p>
<h3 id="同步方法-synchronized"><a href="#同步方法-synchronized" class="headerlink" title="同步方法-synchronized"></a>同步方法-synchronized</h3><p><strong>同步方法</strong>:就是把synchronized关键字加到方法上</p>
<p>格式:</p>
<p>修饰符synchronized返回值类型方法名(方法参数){ }</p>
<p><strong>同步方法</strong>的锁对象是什么呢?</p>
<p><code>this</code></p>
<p><strong>同步静态方法</strong>:就是把synchronized关键字加到静态方法上</p>
<p>格式:</p>
<p>修饰符static synchronized返回值类型方法名(方法参数){ }</p>
<p><strong>同步静态方法</strong>的锁对象是什么呢?</p>
<p><code>类名.class</code></p>
<p>注意：</p>
<blockquote>
<p>synchronized出现在实例方法上，一定锁的是 <strong><code>this</code></strong>; 没得挑。只能是this。不能是其他的对象了。所以这种方式<strong>不灵活</strong>。</p>
</blockquote>
<ol>
<li>缺点</li>
</ol>
<p>synchronized出现在实例方法上，表示<strong>整个方法体都需要同步</strong>，可能会无故<strong>扩大同步的范围</strong>，导致程序的<strong>执行效率降低</strong>。所以这种方式<strong>不常用</strong>。</p>
<ol start="2">
<li>优点</li>
</ol>
<p>代码写的少了，节俭了。</p>
<ol start="3">
<li> 总结</li>
</ol>
<p>如果共享的对象就是<strong>this</strong>，并且需要<strong>同步的代码块是整个方法体</strong>，建议使用这种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">double</span> money)</span>&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">before</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBalance();<br>    <span class="hljs-type">double</span> <span class="hljs-variable">after</span> <span class="hljs-operator">=</span> before - money;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.setBalance(after);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="在方法调用处synchronized"><a href="#在方法调用处synchronized" class="headerlink" title="在方法调用处synchronized"></a>在方法调用处synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;<br>    <span class="hljs-comment">// 取款</span><br>    <span class="hljs-comment">// 多线程并发执行这个方法。</span><br>    <span class="hljs-comment">//synchronized (this) &#123; //这里的this是AccountThread对象，这个对象不共享！</span><br>    <span class="hljs-keyword">synchronized</span> (act) &#123; <span class="hljs-comment">// 这种方式也可以，只不过扩大了同步的范围，效率更低了。</span><br>        act.withdraw(money);<br>    &#125;<br><br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;对&quot;</span>+act.getActno()+<span class="hljs-string">&quot;取款&quot;</span>+money+<span class="hljs-string">&quot;成功，余额&quot;</span> + act.getBalance());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种方式也可以，只不过<strong>扩大了同步的范围</strong>，效率更低了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>synchronized有三种写法：</strong></p>
<ol>
<li>同步代码块</li>
</ol>
<p>特点：<strong>灵活</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(线程共享对象)&#123;<br>	同步代码块;<br>&#125;<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>在实例方法上使用synchronized</li>
</ol>
<p>表示<strong>共享对象</strong>一定是 <strong><code>this</code></strong> 并且同步代码块是<strong>整个方法体</strong>。</p>
<ol start="3">
<li>在静态方法上使用synchronized</li>
</ol>
<p>表示找 <strong><code>类锁</code><strong>。</strong>类锁永远只有1把</strong>。</p>
<p><strong>就算创建了100个对象，那类锁也只有1把。</strong></p>
<p><strong>注意区分：</strong></p>
<ul>
<li>对象锁：1个对象1把锁，100个对象100把锁。</li>
<li>类锁：100个对象，也可能只是1把类锁。</li>
</ul>
<h2 id="LOCK锁"><a href="#LOCK锁" class="headerlink" title="LOCK锁"></a>LOCK锁</h2><p>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作</p>
<p>Lock中提供了<strong>获得锁和释放锁</strong>的方法</p>
<ul>
<li><p>void lock():获得锁</p>
</li>
<li><p>void unlock():释放锁</p>
</li>
</ul>
<p>Lock是接口不能直接实例化，这里采用它的实现类<strong>ReentrantLock</strong>来实例化</p>
<ul>
<li><p>Reentrantlock的构造方法</p>
</li>
<li><p>ReentrantLock(): 创建一个ReentrantLock的实例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ch6;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Locktest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">sellticket</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">sellticket</span>(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t, <span class="hljs-string">&quot;t2&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(t, <span class="hljs-string">&quot;t3&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><span class="hljs-comment">//        System.out.println(Thread.currentThread().getName());</span><br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">selltickets</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tickets;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    selltickets(<span class="hljs-type">int</span> tickets) &#123;<br>        <span class="hljs-built_in">this</span>.tickets = tickets;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                sell();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (tickets &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//                            Thread.yield();</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;正在出售第&quot;</span> + <span class="hljs-built_in">this</span>.tickets + <span class="hljs-string">&quot;张票&quot;</span>);<br>                tickets--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">finally</span>&#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h3><table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">void wait()</td>
<td align="left">导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</td>
</tr>
<tr>
<td align="center">void notify()</td>
<td align="left">唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td align="center">void notifyAll()</td>
<td align="left">唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
<h2 id="死锁（DeadLock）"><a href="#死锁（DeadLock）" class="headerlink" title="死锁（DeadLock）"></a>死锁（DeadLock）</h2><img src="https://img-blog.csdnimg.cn/20210512224504688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzE1OTQz,size_16,color_FFFFFF,t_70,t_70, #pic_center" srcset="/img/loading.gif" lazyload>

<p><u>代码示例</u>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 比如：t1想先穿衣服在穿裤子</span><br><span class="hljs-comment"> *       t2想先穿裤子在传衣服</span><br><span class="hljs-comment"> * 此时：t1拿到衣服，t2拿到裤子；</span><br><span class="hljs-comment"> * 由于t1拿了衣服，t2找不到衣服；t2拿了裤子，t1找不到裤子</span><br><span class="hljs-comment"> * 就会导致死锁的发生！</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread_DeadLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dress</span> <span class="hljs-variable">dress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dress</span>();<br>        <span class="hljs-type">Trousers</span> <span class="hljs-variable">trousers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trousers</span>();<br>        <span class="hljs-comment">//t1、t2共享dress和trousers。</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable1</span>(dress, trousers), <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable2</span>(dress, trousers), <span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    Dress dress;<br>    Trousers trousers;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable1</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable1</span><span class="hljs-params">(Dress dress, Trousers trousers)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dress = dress;<br>        <span class="hljs-built_in">this</span>.trousers = trousers;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(dress)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (trousers)&#123;<br>                System.out.println(<span class="hljs-string">&quot;--------------&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    Dress dress;<br>    Trousers trousers;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable2</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyRunnable2</span><span class="hljs-params">(Dress dress, Trousers trousers)</span> &#123;<br>        <span class="hljs-built_in">this</span>.dress = dress;<br>        <span class="hljs-built_in">this</span>.trousers = trousers;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(trousers)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (dress)&#123;<br>                System.out.println(<span class="hljs-string">&quot;。。。。。。。。。。。。。。&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dress</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trousers</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>











<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><h3 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h3><ul>
<li>一类是：<strong>用户线程</strong></li>
<li>一类是：<strong>守护线程</strong>（<strong>后台线程</strong>）</li>
</ul>
<p>其中具有代表性的就是：<strong>垃圾回收线程（守护线程）</strong>。</p>
<h4 id="守护线程的特点"><a href="#守护线程的特点" class="headerlink" title="守护线程的特点"></a>守护线程的特点</h4><p>一般守护线程是一个<strong>死循环</strong>，<strong>所有的用户线程只要结束，守护线程自动结束</strong>。</p>
<p>注意：<strong>主线程main</strong>方法是一个<strong>用户线程</strong>。</p>
<h4 id="守护线程用法"><a href="#守护线程用法" class="headerlink" title="守护线程用法"></a>守护线程用法</h4><p>每天00:00的时候系统数据自动备份。<br>这个需要使用到定时器，并且我们可以将定时器设置为守护线程。<br>一直在那里看着，没到00:00的时候就备份一次。所有的用户线程如果结束了，守护线程自动退出，没有必要进行数据备份了。</p>
<table>
<thead>
<tr>
<th>void setDaemon(boolean on)</th>
<th>on为true表示把线程设置为守护线程</th>
</tr>
</thead>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest14</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BakDataThread</span>();<br>        t.setName(<span class="hljs-string">&quot;备份数据的线程&quot;</span>);<br><br>        <span class="hljs-comment">// 启动线程之前，将线程设置为守护线程</span><br>        t.setDaemon(<span class="hljs-literal">true</span>);<br><br>        t.start();<br><br>        <span class="hljs-comment">// 主线程：主线程是用户线程</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;---&gt;&quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BakDataThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 即使是死循环，但由于该线程是守护者，当用户线程结束，守护线程自动终止。</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;---&gt;&quot;</span> + (++i));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="第七章、数据IO流操作"><a href="#第七章、数据IO流操作" class="headerlink" title="第七章、数据IO流操作"></a>第七章、数据IO流操作</h1><h2 id="输入输出流概念"><a href="#输入输出流概念" class="headerlink" title="输入输出流概念"></a>输入输出流概念</h2><p>数据流是 Java 进行 I/O 操作的对象，它按照不同的标准可以分为不同的类别。</p>
<ul>
<li>按照流的方向主要分为输入流和输出流两大类。</li>
<li>数据流按照数据单位的不同分为字节流和字符流。</li>
<li>按照功能可以划分为节点流和处理流。</li>
</ul>
<p>数据流的处理只能按照数据序列的顺序来进行，即前一个数据处理完之后才能处理后一个数据。数据流以输入流的形式被程序获取，再以输出流的形式将数据输出到其它设备。图 1 为输入流模式，图 2 为输出流模式。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200115/5-200115142HWK.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="http://c.biancheng.net/uploads/allimg/200115/5-200115142K1644.png" srcset="/img/loading.gif" lazyload alt="输入流模式"></p>
<h3 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h3><p>Java 流相关的类都封装在 java.io 包中，而且每个数据流都是一个对象。所有输入流类都是 InputStream 抽象类（字节输入流）和 Reader 抽象类（字符输入流）的子类。其中 InputStream 类是字节输入流的抽象类，是所有字节输入流的父类，其层次结构如图 3 所示。</p>
<div align="center">
    <img src="http://c.biancheng.net/uploads/allimg/200115/5-200115145253550.png" srcset="/img/loading.gif" lazyload>
</div>


<p>InputStream 类中所有方法遇到错误时都会引发 IOException 异常。如下是该类中包含的常用方法。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">int read()</td>
<td>从输入流读入一个 8 字节的数据，将它转换成一个 0~ 255 的整数，返回一个整数，如果遇到输入流的结尾返回 -1</td>
</tr>
<tr>
<td align="left">int read(byte[] b)</td>
<td>从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，返回的字节数表示读取的字节数，如果遇到输入流的结尾返回 -1</td>
</tr>
<tr>
<td align="left">int read(byte[] b,int off,int len)</td>
<td>从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，其中 off 是指在数组中开始保存数据位置的起始下标，len 是指读取字节的位数。返回的是实际读取的字节数，如果遇到输入流的结尾则返回 -1</td>
</tr>
<tr>
<td align="left">void close()</td>
<td>关闭数据流，当完成对数据流的操作之后需要关闭数据流</td>
</tr>
<tr>
<td align="left">int available()</td>
<td>返回可以从数据源读取的数据流的位数。</td>
</tr>
<tr>
<td align="left">skip(long n)</td>
<td>从输入流跳过参数 n 指定的字节数目</td>
</tr>
<tr>
<td align="left">boolean markSupported()</td>
<td>判断输入流是否可以重复读取，如果可以就返回 true</td>
</tr>
<tr>
<td align="left">void mark(int readLimit)</td>
<td>如果输入流可以被重复读取，从流的当前位置开始设置标记，readLimit 指定可以设置标记的字节数</td>
</tr>
<tr>
<td align="left">void reset()</td>
<td>使输入流重新定位到刚才被标记的位置，这样可以重新读取标记过的数据</td>
</tr>
</tbody></table>
<p>上述最后 3 个方法一般会结合在一起使用，首先使用 markSupported() 判断，如果可以重复读取，则使用 mark(int readLimit) 方法进行标记，标记完成之后可以使用 read() 方法读取标记范围内的字节数，最后使用 reset() 方法使输入流重新定位到标记的位置，继而完成重复读取操作。</p>
<p>Java 中的字符是 Unicode 编码，即双字节的，而 InputerStream 是用来处理单字节的，在处理字符文本时不是很方便。这时可以使用 Java 的文本输入流 Reader 类，该类是字符输入流的抽象类，即所有字符输入流的实现都是它的子类，该类的方法与 InputerSteam 类的方法类似，这里不再介绍。</p>
<h3 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h3><p>在 Java 中所有输出流类都是 OutputStream 抽象类（字节输出流）和 Writer 抽象类（字符输出流）的子类。其中 OutputStream 类是字节输出流的抽象类，是所有字节输出流的父类，其层次结构如图 4 所示。</p>
<div align="center">
    <img src="http://c.biancheng.net/uploads/allimg/200115/5-200115151G3J0.png" srcset="/img/loading.gif" lazyload>
</div>


<p>OutputStream 类是所有字节输出流的超类，用于以二进制的形式将数据写入目标设备，该类是抽象类，不能被实例化。OutputStream 类提供了一系列跟数据输出有关的方法，如下所示。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>int write(b)</td>
<td>将指定字节的数据写入到输出流</td>
</tr>
<tr>
<td>int write (byte[] b)</td>
<td>将指定字节数组的内容写入输出流</td>
</tr>
<tr>
<td>int write (byte[] b,int off,int len)</td>
<td>将指定字节数组从 off 位置开始的 len 字节的内容写入输出流</td>
</tr>
<tr>
<td>close()</td>
<td>关闭数据流，当完成对数据流的操作之后需要关闭数据流</td>
</tr>
<tr>
<td>flush()</td>
<td>刷新输出流，强行将缓冲区的内容写入输出流</td>
</tr>
</tbody></table>
<p>每个Java程序运行时都带有一个系统流，系统流对应的类为 java.lang.System。Sytem 类封装了 Java 程序运行时的 3 个系统流，分别通过 in、out 和 err 变量来引用。这 3 个系统流如下所示：</p>
<ul>
<li>System.in：标准输入流，默认设备是键盘。</li>
<li>System.out：标准输出流，默认设备是控制台。</li>
<li>System.err：标准错误流，默认设备是控制台。</li>
</ul>
<p>Java 中常见编码说明如下：</p>
<ul>
<li>ISO8859-1：属于单字节编码，最多只能表示 0~255 的字符范围。</li>
<li>GBK/GB2312：中文的国标编码，用来表示汉字，属于双字节编码。GBK 可以表示简体中文和繁体中文，而 GB2312 只能表示简体中文。GBK 兼容 GB2312。</li>
<li>Unicode：是一种编码规范，是为解决全球字符通用编码而设计的。UTF-8 和 UTF-16 是这种规范的一种实现，此编码不兼容 ISO8859-1 编码。Java 内部采用此编码。</li>
<li>UTF：UTF 编码兼容了 ISO8859-1 编码，同时也可以用来表示所有的语言字符，不过 UTF 编码是不定长编码，每一个字符的长度为 1~6 个字节不等。一般在中文网页中使用此编码，可以节省空间。</li>
</ul>
<p>在程序中如果处理不好字符编码，就有可能出现乱码问题。例如现在本机的默认编码是 GBK，但在程序中使用了 ISO8859-1 编码，则就会出现字符的乱码问题。就像两个人交谈，一个人说中文，另外一个人说英语，语言不同就无法沟通。为了避免产生乱码，程序编码应与本地的默认编码保持一致。</p>
<p>本地的默认编码可以使用 System 类查看。Java 中 System 类可以取得与系统有关的信息，所以直接使用此类可以找到系统的默认编码。方法如下所示：</p>
<p><code>public static Properties getProperty()</code></p>
<p>使用上述方法可以查看 JVM 的默认编码，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-comment">// 获取当前系统编码    </span><br>    System.out.println(<span class="hljs-string">&quot;系统默认编码：&quot;</span> + System.getProperty(<span class="hljs-string">&quot;file.encoding&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h2><p>InputStream 类及其子类的对象表示字节输入流，InputStream 类的常用子类如下。</p>
<ul>
<li>ByteArrayInputStream 类：将字节数组转换为字节输入流，从中读取字节。</li>
<li>FileInputStream 类：从文件中读取数据。</li>
<li>PipedInputStream 类：连接到一个 PipedOutputStream（管道输出流）。</li>
<li>SequenceInputStream 类：将多个字节输入流串联成一个字节输入流。</li>
<li>ObjectInputStream 类：将对象反序列化。</li>
</ul>
<p>使用 InputStream 类的方法可以从流中读取一个或一批字节。表 1 列出了 InputStream 类的常用方法。</p>
<table>
<thead>
<tr>
<th>方法名及返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>从输入流中读取一个 8 位的字节，并把它转换为 0~255 的整数，最后返回整数。 如果返回 -1，则表示已经到了输入流的末尾。为了提高 I/O 操作的效率，建议尽量 使用 read() 方法的另外两种形式</td>
</tr>
<tr>
<td>int read(byte[] b)</td>
<td>从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。 该方法返回 读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td>int read(byte[] b, int off, int len)</td>
<td>从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。其中，off 指 定在字节数组中开始保存数据的起始下标；len 指定读取的字节数。该方法返回实际 读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭输入流。在读操作完成后，应该关闭输入流，系统将会释放与这个输入流相关 的资源。注意，InputStream 类本身的 close() 方法不执行任何操作，但是它的许多 子类重写了 close() 方法</td>
</tr>
<tr>
<td>int available()</td>
<td>返回可以从输入流中读取的字节数</td>
</tr>
<tr>
<td>long skip(long n)</td>
<td>从输入流中跳过参数 n 指定数目的字节。该方法返回跳过的字节数</td>
</tr>
<tr>
<td>void mark(int readLimit)</td>
<td>在输入流的当前位置开始设置标记，参数 readLimit 则指定了最多被设置标记的字 节数</td>
</tr>
<tr>
<td>boolean markSupported()</td>
<td>判断当前输入流是否允许设置标记，是则返回 true，否则返回 false</td>
</tr>
<tr>
<td>void reset()</td>
<td>将输入流的指针返回到设置标记的起始处</td>
</tr>
</tbody></table>
<p>注意：在使用 mark() 方法和 reset() 方法之前，需要判断该文件系统是否支持这两个方法，以避免对程序造成影响。</p>
<h2 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h2><p>OutputStream 类及其子类的对象表示一个字节输出流。OutputStream 类的常用子类如下。</p>
<ul>
<li>ByteArrayOutputStream 类：向内存缓冲区的字节数组中写数据。</li>
<li>FileOutputStream 类：向文件中写数据。</li>
<li>PipedOutputStream 类：连接到一个 PipedlntputStream（管道输入流）。</li>
<li>ObjectOutputStream 类：将对象序列化。</li>
</ul>
<p>利用 OutputStream 类的方法可以从流中写入一个或一批字节。表 2 列出了 OutputStream 类的常用方法。</p>
<table>
<thead>
<tr>
<th>方法名及返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>向输出流写入一个字节。这里的参数是 int 类型，但是它允许使用表达式， 而不用强制转换成 byte 类型。为了提高 I/O 操作的效率，建议尽量使用 write() 方法的另外两种形式</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>把参数 b 指定的字节数组中的所有字节写到输出流中</td>
</tr>
<tr>
<td>void write(byte[] b,int off,int len)</td>
<td>把参数 b 指定的字节数组中的若干字节写到输出流中。其中，off 指定字节 数组中的起始下标，len 表示元素个数</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭输出流。写操作完成后，应该关闭输出流。系统将会释放与这个输出 流相关的资源。注意，OutputStream 类本身的 close() 方法不执行任何操 作，但是它的许多子类重写了 close() 方法</td>
</tr>
<tr>
<td>void flush()</td>
<td>为了提高效率，在向输出流中写入数据时，数据一般会先保存到内存缓冲 区中，只有当缓冲区中的数据达到一定程度时，缓冲区中的数据才会被写 入输出流中。使用 flush() 方法则可以强制将缓冲区中的数据写入输出流， 并清空缓冲区</td>
</tr>
</tbody></table>
<p>在 <a href="http://alleyf.github.io/">Java</a> 中，File 类是 java.io 包中唯一代表磁盘文件本身的对象，也就是说，如果希望在程序中操作文件和目录，则都可以通过 File 类来完成。File 类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等。</p>
<p>File 类不能访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。</p>
<p>File 类提供了如下三种形式构造方法。</p>
<ol>
<li>File(String path)：如果 path 是实际存在的路径，则该 File 对象表示的是目录；如果 path 是文件名，则该 File 对象表示的是文件。</li>
<li>File(String path, String name)：path 是路径名，name 是文件名。</li>
<li>File(File dir, String name)：dir 是路径对象，name 是文件名。</li>
</ol>
<p>使用任意一个构造方法都可以创建一个 File 对象，然后调用其提供的方法对文件进行操作。在表 1 中列出了 File 类的常用方法及说明。</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean canRead()</td>
<td>测试应用程序是否能从指定的文件中进行读取</td>
</tr>
<tr>
<td>boolean canWrite()</td>
<td>测试应用程序是否能写当前文件</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除当前对象指定的文件</td>
</tr>
<tr>
<td>boolean exists()</td>
<td>测试当前 File 是否存在</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>返回由该对象表示的文件的绝对路径名</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</td>
</tr>
<tr>
<td>String getParent()</td>
<td>返回当前 File 对象所对应目录（最后一级子目录）的父目录名</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>测试当前 File 对象表示的文件是否为一个绝对路径名。该方法消除了不同平台的差异，可以直接判断 file 对象是否为绝对路径。在 UNIX/Linux/BSD 等系统上，如果路径名开头是一条斜线<code>/</code>，则表明该 File 对象对应一个绝对路径；在 Windows 等系统上，如果路径开头是盘符，则说明它是一个绝对路径。</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>测试当前 File 对象表示的文件是否为一个路径</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>测试当前 File 对象表示的文件是否为一个“普通”文件</td>
</tr>
<tr>
<td>long lastModified()</td>
<td>返回当前 File 对象表示的文件最后修改的时间</td>
</tr>
<tr>
<td>long length()</td>
<td>返回当前 File 对象表示的文件长度</td>
</tr>
<tr>
<td>String[] list()</td>
<td>返回当前 File 对象指定的路径文件列表</td>
</tr>
<tr>
<td>String[] list(FilenameFilter)</td>
<td>返回当前 File 对象指定的目录中满足指定过滤器的文件列表</td>
</tr>
<tr>
<td>boolean mkdir()</td>
<td>创建一个目录，它的路径名由当前 File 对象指定</td>
</tr>
<tr>
<td>boolean mkdirs()</td>
<td>创建一个目录，它的路径名由当前 File 对象指定</td>
</tr>
<tr>
<td>boolean renameTo(File)</td>
<td>将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</td>
</tr>
</tbody></table>
<p>File 类中有以下两个常用常量：</p>
<ul>
<li>public static final String pathSeparator：指的是分隔连续多个路径字符串的分隔符，Windows 下指<code>;</code>。例如 <code>java -cp test.jar;abc.jar HelloWorld</code>。</li>
<li>public static final String separator：用来分隔同一个路径字符串中的目录的，Windows 下指<code>/</code>。例如 <code>C:/Program Files/Common Files</code>。</li>
</ul>
<p>注意：可以看到 File 类的常量定义的命名规则不符合标准命名规则，常量名没有全部大写，这是因为 Java 的发展经过了一段相当长的时间，而命名规范也是逐步形成的，File 类出现较早，所以当时并没有对命名规范有严格的要求，这些都属于 Java 的历史遗留问题。</p>
<blockquote>
<p>Windows 的路径分隔符使用反斜线“\”，而 Java 程序中的反斜线表示转义字符，所以如果需要在 Windows 的路径下包括反斜线，则应该使用两条反斜线或直接使用斜线“/”也可以。Java 程序支持将斜线当成平台无关的路径分隔符。</p>
</blockquote>
<p>假设在 Windows 操作系统中有一文件 <code>D:\javaspace\hello.java</code>，在 Java 中使用的时候，其路径的写法应该为 <code>D:/javaspace/hello.java</code> 或者 <code>D:\\javaspace\\hello.java</code>。</p>
<h2 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h2><p>Reader 类是所有字符流输入类的父类，该类定义了许多方法，这些方法对所有子类都是有效的。</p>
<p>Reader 类的常用子类如下。</p>
<ul>
<li>CharArrayReader 类：将字符数组转换为字符输入流，从中读取字符。</li>
<li>StringReader 类：将字符串转换为字符输入流，从中读取字符。</li>
<li>BufferedReader 类：为其他字符输入流提供读缓冲区。</li>
<li>PipedReader 类：连接到一个 PipedWriter。</li>
<li>InputStreamReader 类：将字节输入流转换为字符输入流，可以指定字符编码。</li>
</ul>
<p>与 InputStream 类相同，在 Reader 类中也包含 close()、mark()、skip() 和 reset() 等方法，这些方法可以参考 InputStream 类的方法。下面主要介绍 Reader 类中的 read() 方法，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>方法名及返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>从输入流中读取一个字符，并把它转换为 0~65535 的整数。如果返回 -1， 则表示 已经到了输入流的末尾。为了提高 I/O 操作的效率，建议尽量使用下面两种 read() 方法</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。 该方 法返回读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
<tr>
<td>int read(char[] cbuf,int off,int len)</td>
<td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。其中， off 指定在字符数组中开始保存数据的起始下标，len 指定读取的字符数。该方法返 回实际读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td>
</tr>
</tbody></table>
<h2 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h2><p>与 Reader 类相反，Writer 类是所有字符输出流的父类，该类中有许多方法，这些方法对继承该类的所有子类都是有效的。</p>
<p>Writer 类的常用子类如下。</p>
<ul>
<li>CharArrayWriter 类：向内存缓冲区的字符数组写数据。</li>
<li>StringWriter 类：向内存缓冲区的字符串（StringBuffer）写数据。</li>
<li>BufferedWriter 类：为其他字符输出流提供写缓冲区。</li>
<li>PipedWriter 类：连接到一个 PipedReader。</li>
<li>OutputStreamReader 类：将字节输出流转换为字符输出流，可以指定字符编码。</li>
</ul>
<p>与 OutputStream 类相同，Writer 类也包含 close()、flush() 等方法，这些方法可以参考 OutputStream 类的方法。下面主要介绍 Writer 类中的 write() 方法和 append() 方法，如表 2 所示。</p>
<table>
<thead>
<tr>
<th>方法名及返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>向输出流中写入一个字符</td>
</tr>
<tr>
<td>void write(char[] cbuf)</td>
<td>把参数 cbuf 指定的字符数组中的所有字符写到输出流中</td>
</tr>
<tr>
<td>void write(char[] cbuf,int off,int len)</td>
<td>把参数 cbuf 指定的字符数组中的若干字符写到输出流中。其中，off 指定 字符数组中的起始下标，len 表示元素个数</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>向输出流中写入一个字符串</td>
</tr>
<tr>
<td>void write(String str, int off,int len)</td>
<td>向输出流中写入一个字符串中的部分字符。其中，off 指定字符串中的起 始偏移量，len 表示字符个数</td>
</tr>
<tr>
<td>append(char c)</td>
<td>将参数 c 指定的字符添加到输出流中</td>
</tr>
<tr>
<td>append(charSequence esq)</td>
<td>将参数 esq 指定的字符序列添加到输出流中</td>
</tr>
<tr>
<td>append(charSequence esq,int start,int end)</td>
<td>将参数 esq 指定的字符序列的子序列添加到输出流中。其中，start 指定 子序列的第一个字符的索引，end 指定子序列中最后一个字符后面的字符 的索引，也就是说子序列的内容包含 start 索引处的字符，但不包括 end 索引处的字符</td>
</tr>
</tbody></table>
<p>注意：Writer 类所有的方法在出错的情况下都会引发 <strong>IOException</strong> 异常。关闭一个流后，再对其进行任何操作都会产生错误。</p>
<h2 id="字符文件输入流"><a href="#字符文件输入流" class="headerlink" title="字符文件输入流"></a>字符文件输入流</h2><p>为了读取方便，Java 提供了用来读取字符文件的便捷类——FileReader。该类的构造方法有如下两种重载形式。</p>
<ol>
<li>FileReader(File file)：在给定要读取数据的文件的情况下创建一个新的 FileReader 对象。其中，file 表示要从中读取数据的文件。</li>
<li>FileReader(String fileName)：在给定从中读取数据的文件名的情况下创建一个新 FileReader 对象。其中，fileName 表示要从中读取数据的文件的名称，表示的是一个文件的完整路径。</li>
</ol>
<p>在用该类的构造方法创建 FileReader 读取对象时，默认的字符编码及字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在 FilelnputStream 上构造一个 InputStreamReader。</p>
<p>注意：在创建 FileReader 对象时可能会引发一个 FileNotFoundException 异常，因此需要使用 try catch 语句捕获该异常。</p>
<p>字符流和字节流的操作步骤相同，都是首先创建输入流或输出流对象，即建立连接管道，建立完成后进行读或写操作，最后关闭输入/输出流通道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test12</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:/myJava/HelloJava.java&quot;</span>); <span class="hljs-comment">// 创建FileReader对象</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;D:\\myJava\\HelloJava.java文件内容如下：&quot;</span>);<br>            <span class="hljs-keyword">while</span> ((i = fr.read()) != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 循环读取</span><br>                System.out.print((<span class="hljs-type">char</span>) i); <span class="hljs-comment">// 将读取的内容强制转换为char类型</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.print(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fr.close(); <span class="hljs-comment">// 关闭对象</span><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上述代码，首先创建了 FileReader 字符输入流对象 fr，该对象指向 D:\myJava\HelloJava.java 文件，然后定义变量 i 来接收调用 read() 方法的返回值，即读取的字符。在 while 循环中，每次读取一个字符赋给整型变量 i，直到读取到文件末尾时退出循环（当输入流读取到文件末尾时，会返回值 -1）。</p>
<h2 id="字符文件输出流"><a href="#字符文件输出流" class="headerlink" title="字符文件输出流"></a>字符文件输出流</h2><p>Java 提供了写入字符文件的便捷类——FileWriter，该类的构造方法有如下 4 种重载形式。</p>
<ol>
<li>FileWriter(File file)：在指定 File 对象的情况下构造一个 FileWriter 对象。其中，file 表示要写入数据的 File 对象。</li>
<li>FileWriter(File file,boolean append)：在指定 File 对象的情况下构造一个 FileWriter 对象，如果 append 的值为 true，则将字节写入文件末尾，而不是写入文件开始处。</li>
<li>FileWriter(String fileName)：在指定文件名的情况下构造一个 FileWriter 对象。其中，fileName 表示要写入字符的文件名，表示的是完整路径。</li>
<li>FileWriter(String fileName,boolean append)：在指定文件名以及要写入文件的位置的情况下构造 FileWriter 对象。其中，append 是一个 boolean 值，如果为 true，则将数据写入文件末尾，而不是文件开始处。</li>
</ol>
<p>在创建 FileWriter 对象时，默认字符编码和默认字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在 FileOutputStream 上构造一个 OutputStreamWriter 对象。</p>
<p>FileWriter 类的创建不依赖于文件存在与否，如果关联文件不存在，则会自动生成一个新的文件。在创建文件之前，FileWriter 将在创建对象时打开它作为输出。如果试图打开一个只读文件，将引发一个 IOException 异常。</p>
<p>注意：在创建 FileWriter 对象时可能会引发 IOException 或 SecurityException 异常，因此需要使用 try catch 语句捕获该异常。</p>
<p>编写一个程序，将用户输入的 4 个字符串保存到 D:\myJava\book.txt 文件中。在这里使用 FileWriter 类中的 write() 方法循环向指定文件中写入数据，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test13</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;D:\\myJava\\book.txt&quot;</span>); <span class="hljs-comment">// 创建FileWriter对象</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;请输入第&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个字符串：&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> input.next(); <span class="hljs-comment">// 读取输入的名称</span><br>                fw.write(name + <span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 循环写入文件</span><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;录入完成！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fw.close(); <span class="hljs-comment">// 关闭对象</span><br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上述代码，首先创建了一个指向 D:\myJava\book.txt 文件的字符文件输出流对象 fw，然后使用 for 循环录入 4 个字符串，并调用 write() 方法将字符串写入到指定的文件中。最后在 finally 语句中关闭字符文件输出流。</p>
<h2 id="字符缓冲区输入流"><a href="#字符缓冲区输入流" class="headerlink" title="字符缓冲区输入流"></a>字符缓冲区输入流</h2><p>BufferedReader 类主要用于辅助其他字符输入流，它带有缓冲区，可以先将一批数据读到内存缓冲区。接下来的读操作就可以直接从缓冲区中获取数据，而不需要每次都从数据源读取数据并进行字符编码转换，这样就可以提高数据的读取效率。</p>
<p>BufferedReader 类的构造方法有如下两种重载形式。</p>
<ol>
<li>BufferedReader(Reader in)：创建一个 BufferedReader 来修饰参数 in 指定的字符输入流。</li>
<li>BufferedReader(Reader in,int size)：创建一个 BufferedReader 来修饰参数 in 指定的字符输入流，参数 size 则用于指定缓冲区的大小，单位为字符。</li>
</ol>
<p>除了可以为字符输入流提供缓冲区以外，BufferedReader 还提供了 <code>readLine()</code> 方法，该方法返回包含该行内容的字符串，但该字符串中不包含任何终止符，如果已到达流末尾，则返回 null。readLine() 方法表示每次读取一行文本内容，当遇到换行（\n）、回车（\r）或回车后直接跟着换行标记符即可认为某行已终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test13</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;D:\\myJava\\book.txt&quot;</span>); <span class="hljs-comment">// 创建 FileReader 对象</span><br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr); <span class="hljs-comment">// 创建 BufferedReader 对象</span><br>            System.out.println(<span class="hljs-string">&quot;D:\\myJava\\book.txt 文件中的内容如下：&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">strLine</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">while</span> ((strLine = br.readLine()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 循环读取每行数据</span><br>                System.out.println(strLine);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e1) &#123;<br>            e1.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fr.close(); <span class="hljs-comment">// 关闭 FileReader 对象</span><br>                br.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上述代码，首先分别创建了名称为 fr 的 FileReader 对象和名称为 br 的 BufferedReader 对象，然后调用 BufferedReader 对象的 readLine() 方法逐行读取文件中的内容。如果读取的文件内容为 Null，即表明已经读取到文件尾部，此时退出循环不再进行读取操作。最后将字符文件输入流和带缓冲的字符输入流关闭.</p>
<h2 id="字符缓冲区输出流"><a href="#字符缓冲区输出流" class="headerlink" title="字符缓冲区输出流"></a>字符缓冲区输出流</h2><p>BufferedWriter 类主要用于辅助其他字符输出流，它同样带有缓冲区，可以先将一批数据写入缓冲区，当缓冲区满了以后，再将缓冲区的数据一次性写到字符输出流，其目的是为了提高数据的写效率。</p>
<p>BufferedWriter 类的构造方法有如下两种重载形式。</p>
<ol>
<li>BufferedWriter(Writer out)：创建一个 BufferedWriter 来修饰参数 out 指定的字符输出流。</li>
<li>BufferedWriter(Writer out,int size)：创建一个 BufferedWriter 来修饰参数 out 指定的字符输出流，参数 size 则用于指定缓冲区的大小，单位为字符。</li>
</ol>
<p>该类除了可以给字符输出流提供缓冲区之外，还提供了一个新的方法 newLine()，该方法用于写入一个行分隔符。行分隔符字符串由系统属性 line.separator 定义，并且不一定是单个新行（\n）符。</p>
<p>提示：BufferedWriter 类的使用与 FileWriter 类相同，这里不再重述。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java_Notes</div>
      <div>https://alleyf.github.io/2022/09/10/Java Notes/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>alleyf</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>September 10, 2022</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>October 12, 2022</div>
        </div>
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/10/NoteBook/" title="NoteBook_notes">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">NoteBook_notes</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/09/10/Python_Notes/" title="Python_Notes">
                        <span class="hidden-mobile">Python_Notes</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.7.2/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"636f2864e051a199b91c","clientSecret":"5185fd11115bbcd8d2f636bc80de6bed98ed14c1","repo":"Gitalk","owner":"Alleyf","admin":["Alleyf"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":false,"proxy":"https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token"},
          {
            id: 'e9f2531d94c1daf7befdd282376b854e'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/Alleyf" target="_blank" rel="nofollow noopener"><span>Alleyf</span></a> <i class="iconfont icon-love"></i> <a href="https://fcsy.fit" target="_blank" rel="nofollow noopener"><span>Homepage</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      陕ICP备2022010038号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2022010038"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>陕公网安备2022010038号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
