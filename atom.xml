<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alleyf</title>
  
  
  <link href="https://alleyf.github.io/atom.xml" rel="self"/>
  
  <link href="https://alleyf.github.io/"/>
  <updated>2023-11-18T07:29:20.969Z</updated>
  <id>https://alleyf.github.io/</id>
  
  <author>
    <name>alleyf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://alleyf.github.io/2023/11/2031f5e35441.html"/>
    <id>https://alleyf.github.io/2023/11/2031f5e35441.html</id>
    <published>2023-11-18T07:27:12.570Z</published>
    <updated>2023-11-18T07:29:20.969Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>服务器环境：<br>java（jdk 1.8）环境，nacos（1.3.2），neo 4 j（3.5.5），mysql（8.0）</p></li><li><p>打开路由 iptables，打开 tcp 端口，打开对应端口的防火墙</p></li><li><p>所有模块的 api 下的 resources 下的 bootstrap.yml 修改端口号，端口号不能冲突</p></li><li><p>bootstrap-dev.yml 数据库名和密码以及 url 改成相应的服务器的地址</p></li><li><p>common 和 crontab 两个模块不用启动 api 的 jar，其他都需要启动对应 api 的 jar 包</p></li><li><p>vue 打包为生产环境的包</p></li><li><p>注意 linux 上 api 端口是否开启并且是否被其他进程占用</p></li><li><p>前端的 nginx 的配置文件对接口设置反向代理，解决跨域请求问题</p></li><li><p>neo 4 j 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">dbms.security.auth_enabled=false#neo4j.conf配置文件要解除这个鉴权注释，不然无法连接上neo4j<br></code></pre></td></tr></table></figure></li><li><p>修改前端 css 中的 app.css 中的字体路径为：<code>src:url(../fonts/element-icons.535877f.woff) format(&quot;woff&quot;),url(../fonts/element-icons.732389d.ttf)</code></p></li><li><p>每次前端重新打包需要修改 vr.vue 中的 iframe 路径为对应的包名：<code>src=&quot;202305142049/static/vrassets/index2.html&quot;</code>，以及 dist 的 index 中也修改为对应包名：<code>&lt;script&gt;document.write(&#39;&lt;script src=&quot;./config/index.js?t=&#39; + 202305142049 + &#39;&quot;&gt;&lt;\/script&gt;&#39;)&lt;/script&gt;</code></p></li><li><p>查看 java 进程指令：<code>ps -ef | grep java</code></p></li><li><p>后端部署指令：<code>nohup java -Xms200m -Xmx300m -jar score-api-0.0.1-SNAPSHOT.jar&amp;</code></p></li><li><p>查看接口文档的方法： <a href="http://localhost:8083/capacity-api/swagger-ui.html">http://localhost:8083/capacity-api/swagger-ui.html</a></p></li><li><p><code>alt+enter</code> 是 idea 中的提示键，会给出代码提示，非常便捷</p></li></ol><p><a href="http://192.168.1.11:8898/">edop</a><br>用户名和密码：admin<br><strong>nacos：</strong></p><ul><li>用户名和密码：nacos</li><li>nacos 路径为：<code>/opt/nacos/bin/</code></li><li>启动指令为：<code>sh startup.sh -m standalone</code></li></ul><p><code>问题：</code></p><ol><li><code>所有的数据表是否最新完整的，ReqApi查询存在问题： SELECT COUNT(1) FROM inventory_strategy WHERE (time = ?) ，数据表没有time字段</code></li><li><code>前端目前的代码无法build，有没有最新的代码。</code></li><li><code>前端菜单找不到在哪</code></li></ol><p>数据库品牌字段修改：</p><ol><li>五菱-&gt;品牌 1</li><li>宝骏-&gt;品牌 2</li><li>新宝骏-&gt;品牌 3</li><li>新能源-&gt;品牌 4</li><li>年份 2021-&gt;2023(还未改)</li><li>细分品类：<ul><li>品牌 1-》耀芒、银标、天启</li><li>品牌 2-》紫骏、红月</li><li>品牌 3-》歆光、璀璨</li><li>品牌 4-》启航、破浪</li></ul></li></ol><p>后端修改数据库内容：</p><ul><li><img src="C:\Users\alleyf\AppData\Roaming\Typora\typora-user-images\image-20230430143128448.png" alt="image-20230430143128448"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;服务器环境：&lt;br&gt;java（jdk 1.8）环境，nacos（1.3.2），neo 4 j（3.5.5），mysql（8.0）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开路由 iptables，打开 tcp 端口，打开对应端口的防火墙&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="运维开发" scheme="https://alleyf.github.io/categories/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Git-简记</title>
    <link href="https://alleyf.github.io/2023/11/5528aeec932a.html"/>
    <id>https://alleyf.github.io/2023/11/5528aeec932a.html</id>
    <published>2023-11-16T09:29:36.000Z</published>
    <updated>2023-11-18T15:02:11.304Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><h1 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git 分为三个区，工作流程如下：</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311162202035.png" alt="image.png"></p><h2 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h2><p>git 文件有四种状态：</p><ol><li>未跟踪：创建但未被 git 管理的文件</li><li>未修改：被管理但未修改的文件</li><li>已修改：修改后未添加到暂存区的文件</li><li>已暂存：添加到暂存区的文件<br><img src="http://qnpicmap.fcsluck.top/pics/202311162206125.png" alt="image.png"></li></ol><h1 id="安装和初始化配置"><a href="#安装和初始化配置" class="headerlink" title="安装和初始化配置"></a>安装和初始化配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p><a href="https://git-scm.com/">git官方地址</a>：按需下载对应自己<strong>电脑操作系统</strong>的版本。</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>查看 git 版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git -v<br></code></pre></td></tr></table></figure><p><img src="http://qnpicmap.fcsluck.top/pics/202311162135814.png" alt="image.png|500"></p><p>首次安装 git 使用以下命令配置全局仓库用户名和邮箱信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;Jasper Yang&quot;  #设置用户名<br>git config --global user.email geekhall.cn@gmail.com #设置密码<br>git config --global credential.helper store #保存上述信息<br></code></pre></td></tr></table></figure><p>查看&#x2F;清除全局配置信息：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-built_in">--list</span> <span class="hljs-comment">#查看</span><br><span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-built_in">--global</span> <span class="hljs-built_in">--unset</span> &lt;<span class="hljs-string">entry-name</span>&gt; <span class="hljs-comment">#清除全局配置</span><br></code></pre></td></tr></table></figure><p><img src="http://qnpicmap.fcsluck.top/pics/202311162140448.png" alt="image.png"></p><p>查看隐藏的. git 文件：</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311162146376.png"></p><p>清除隐藏的. git 文件则 git 仓库将被清除：<br><img src="http://qnpicmap.fcsluck.top/pics/202311162149713.png" alt="image.png"></p><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="创建-git-仓库"><a href="#创建-git-仓库" class="headerlink" title="创建 git 仓库"></a>创建 git 仓库</h2><h3 id="本地初始化"><a href="#本地初始化" class="headerlink" title="本地初始化"></a>本地初始化</h3><p>在本地需要创建 git 仓库的文件夹下打开 <strong>git bash</strong> 执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git init （init_repo_dir_name）#后面可选在当前目录新建目录作为git仓库<br></code></pre></td></tr></table></figure><h3 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone https://github.com/Alleyf/linux-tutorial.git<br></code></pre></td></tr></table></figure><p><img src="http://qnpicmap.fcsluck.top/pics/202311162159698.png" alt="image.png"></p><h2 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git status<br>git ls-files #查看暂存区的文件<br></code></pre></td></tr></table></figure><p>查看状态：<br><img src="http://qnpicmap.fcsluck.top/pics/202311162220832.png" alt="image.png|575"><br>查看暂存区内容：<br><img src="http://qnpicmap.fcsluck.top/pics/202311180014236.png" alt="|575"></p><h2 id="连接云端仓库"><a href="#连接云端仓库" class="headerlink" title="连接云端仓库"></a>连接云端仓库</h2><p><img src="http://qnpicmap.fcsluck.top/pics/202311162229748.png" alt="image.png|575"></p><p>添加一个 git URL 作为别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add [alias] [url]<br></code></pre></td></tr></table></figure><p>显示您设置的远程存储库的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote<br></code></pre></td></tr></table></figure><p>显示远程存储库的名称和 URL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote -v<br></code></pre></td></tr></table></figure><p>删除远程存储库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote rm [remote repo name]<br></code></pre></td></tr></table></figure><p>更改 git repo 的 URL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote set-url origin [git_url]<br></code></pre></td></tr></table></figure><h2 id="同步仓库文件"><a href="#同步仓库文件" class="headerlink" title="同步仓库文件"></a>同步仓库文件</h2><h3 id="拉取仓库"><a href="#拉取仓库" class="headerlink" title="拉取仓库"></a>拉取仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull<br></code></pre></td></tr></table></figure><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add fileName/.  #&quot;.&quot;代表添加当前文件夹下的全部文件到存储区<br></code></pre></td></tr></table></figure><p><img src="http://qnpicmap.fcsluck.top/pics/202311162233770.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;提交时的备注信息&quot;<br></code></pre></td></tr></table></figure><p>git commit 只会提交<strong>存储区中的文件到仓库</strong>，<strong>未跟踪即未添加到存储区的文件不会被提交</strong>到仓库，如下 file 2.md 是新增未跟踪的文件不会被同 file1.md 提交到仓库:<br><img src="http://qnpicmap.fcsluck.top/pics/202311162235693.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &quot;远程库名&quot; <br></code></pre></td></tr></table></figure><h2 id="查看记录"><a href="#查看记录" class="headerlink" title="查看记录"></a>查看记录</h2><p>查看提交记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log<br></code></pre></td></tr></table></figure><p><img src="http://qnpicmap.fcsluck.top/pics/202311162257259.png" alt="|525"></p><p>查看历史记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reflog<br></code></pre></td></tr></table></figure><p><img src="http://qnpicmap.fcsluck.top/pics/202311180021976.png" alt="image.png|525"></p><h2 id="回退-溯版本"><a href="#回退-溯版本" class="headerlink" title="回退&#x2F;溯版本"></a>回退&#x2F;溯版本</h2><p>git reset有三种模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft 版本号 #回退版本后的内容保留工作区和暂存区<br>git reset --hard 版本号 #都不保留<br>git reset --mixed 版本号 #仅保留工作区内容<br></code></pre></td></tr></table></figure><p><img src="http://qnpicmap.fcsluck.top/pics/202311180007484.png" alt="image.png"></p><p>不同模式，工作区和暂存区的内容会不同。</p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="查询-切换-新建分支"><a href="#查询-切换-新建分支" class="headerlink" title="查询&#x2F;切换&#x2F;新建分支"></a>查询&#x2F;切换&#x2F;新建分支</h2><ol><li>查询分支，使用以下指令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch #查询本地分支<br>git branch -r #查询远程分支<br></code></pre></td></tr></table></figure><ol start="2"><li>切换或新建分支，使用以下指令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git chechout &quot;branchName&quot; #切换分支<br>git checkout -b &quot;branchName&quot; #新建分支并切换到该分支<br></code></pre></td></tr></table></figure><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><ol><li>删除<strong>本地分支</strong>，删除前会进行检查是否<em>本分支内容已经合并到主分支</em>，使用以下指令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d &quot;branchName&quot;<br></code></pre></td></tr></table></figure><blockquote><p>强制删除分支使用 <code>-D</code> 参数。</p></blockquote><ol start="2"><li>删除<strong>远程分支</strong>，使用以下指令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push &quot;远程库名&quot; -d &quot;branch name&quot; <br></code></pre></td></tr></table></figure><blockquote><p>强制删除分支使用 <code>-D</code> 参数。</p></blockquote><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.bilibili.com/video/BV1HM411377j/<br>title: &quot;【GeekHour】一小时Git教程_哔哩哔哩_bilibili&quot;<br>description: &quot;【GeekHour】一小时Git教程共计19条视频，包括：01.课程简介、02.安装和初始化配置、03.新建仓库等，UP主更多精彩视频，请关注UP账号。&quot;<br>host: www.bilibili.com<br>image: //i0.hdslb.com/bfs/archive/be265386c6db1da0e1233e9743e02b252ea07b53.jpg@100w_100h_1c.png<br></code></pre></td></tr></table></figure><ol><li><a href="https://www.bilibili.com/video/BV1HM411377j/">【GeekHour】一小时Git教程_哔哩哔哩_bilibili</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://wangchujiang.com/reference/docs/git.html<br>title: &quot;Git 备忘清单 &amp;  git cheatsheet &amp;  Quick Reference&quot;<br>host: wangchujiang.com<br>favicon: data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%221em%22%20width%3D%221em%22%3E%20%3Cpath%20d%3D%22m21.66%2010.44-.98%204.18c-.84%203.61-2.5%205.07-5.62%204.77-.5-.04-1.04-.13-1.62-.27l-1.68-.4c-4.17-.99-5.46-3.05-4.48-7.23l.98-4.19c.2-.85.44-1.59.74-2.2%201.17-2.42%203.16-3.07%206.5-2.28l1.67.39c4.19.98%205.47%203.05%204.49%207.23Z%22%20fill%3D%22%23c9d1d9%22%2F%3E%20%3Cpath%20d%3D%22M15.06%2019.39c-.62.42-1.4.77-2.35%201.08l-1.58.52c-3.97%201.28-6.06.21-7.35-3.76L2.5%2013.28c-1.28-3.97-.22-6.07%203.75-7.35l1.58-.52c.41-.13.8-.24%201.17-.31-.3.61-.54%201.35-.74%202.2l-.98%204.19c-.98%204.18.31%206.24%204.48%207.23l1.68.4c.58.14%201.12.23%201.62.27Zm2.43-8.88c-.06%200-.12-.01-.19-.02l-4.85-1.23a.75.75%200%200%201%20.37-1.45l4.85%201.23a.748.748%200%200%201-.18%201.47Z%22%20fill%3D%22%23228e6c%22%20%2F%3E%20%3Cpath%20d%3D%22M14.56%2013.89c-.06%200-.12-.01-.19-.02l-2.91-.74a.75.75%200%200%201%20.37-1.45l2.91.74c.4.1.64.51.54.91-.08.34-.38.56-.72.56Z%22%20fill%3D%22%23228e6c%22%20%2F%3E%20%3C%2Fsvg%3E<br></code></pre></td></tr></table></figure></li><li><a href="https://wangchujiang.com/reference/docs/git.html">Git 备忘清单 &amp; git cheatsheet &amp; Quick Reference</a></li></ol>]]></content>
    
    
    <summary type="html">一些关于 git 的常用操作。</summary>
    
    
    
    <category term="运维开发" scheme="https://alleyf.github.io/categories/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Git" scheme="https://alleyf.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud Alibaba-微服务进阶</title>
    <link href="https://alleyf.github.io/2023/11/c09639791c22.html"/>
    <id>https://alleyf.github.io/2023/11/c09639791c22.html</id>
    <published>2023-11-16T07:49:01.000Z</published>
    <updated>2023-11-18T15:23:30.370Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><h1 id="微服务进阶"><a href="#微服务进阶" class="headerlink" title="微服务进阶"></a>微服务进阶</h1><p><img src="https://s2.loli.net/2023/03/06/V1dFqQMR7T2GzSJ.png" alt="image-20230306230950443"><br>前面我们了解了微服务的一套解决方案，但是它是基于 Netflix 的解决方案，实际上我们发现，很多框架都已经停止维护了，来看看目前我们所认识到的 SpringCloud 各大组件的维护情况：</p><ul><li><strong>注册中心：</strong> Eureka（属于<em>Netflix</em>，2. x 版本不再开源，1. x 版本仍在更新）</li><li><strong>服务调用：</strong> Ribbon（属于<em>Netflix</em>，停止更新，已经彻底被移除）、SpringCloud Loadbalancer（属于<em>SpringCloud</em>官方，目前的默认方案）</li><li><strong>服务降级：</strong> Hystrix（属于<em>Netflix</em>，停止更新，已经彻底被移除）</li><li><strong>路由网关：</strong> Zuul（属于<em>Netflix</em>，停止更新，已经彻底被移除）、Gateway（属于<em>SpringCloud</em>官方，推荐方案）</li><li><strong>配置中心：</strong> Config（属于<em>SpringCloud</em>官方）</li></ul><p>可见，我们之前使用的整套解决方案中，超过半数的组件都已经处于不可用状态，并且部分组件都是 SpringCloud 官方出手提供框架进行解决，因此，寻找一套更好的解决方案势在必行，也就引出了我们本章的主角：<strong>SpringCloud Alibaba</strong><br>阿里巴巴作为业界的互联网大厂，给出了一套全新的解决方案，官方网站（中文）： <a href="https://spring-cloud-alibaba-group.github.io/github-pages/2021/zh-cn/index.html">https://spring-cloud-alibaba-group.github.io/github-pages/2021/zh-cn/index.html</a></p><blockquote><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p></blockquote><p>目前 Spring Cloud Alibaba 提供了如下功能:</p><ol><li><strong>服务限流降级</strong>：支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Dubbo 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>Rpc 服务</strong>：扩展 Spring Cloud 客户端 RestTemplate 和 OpenFeign，支持调用 Dubbo RPC 服务</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解，高效并且对业务零侵入地解决分布式事务问题。</li><li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li><li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ol><p>可以看到，SpringCloudAlibaba 实际上是对我们的 SpringCloud 组件增强功能，是 SpringCloud 的增强框架，可以兼容 SpringCloud 原生组件和 SpringCloudAlibaba 的组件。<br>开始学习之前，把我们之前打包好的拆分项目解压，我们将基于它进行讲解。</p><hr><p><img src="https://s2.loli.net/2023/03/06/pQkSrLx9NZRn8Ub.png" alt="image-20230306230942876"></p><h2 id="Nacos-更加全能的注册中心"><a href="#Nacos-更加全能的注册中心" class="headerlink" title="Nacos 更加全能的注册中心"></a>Nacos 更加全能的注册中心</h2><p>Nacos（<strong>Na</strong>ming <strong>Co</strong>nfiguration <strong>S</strong>ervice）是一款阿里巴巴开源的服务注册与发现、配置管理的组件，相当于是 Eureka+Config 的组合形态。</p><h3 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>Nacos 服务器是独立安装部署的，因此我们需要下载最新的 Nacos 服务端程序，下载地址： <a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a> ，连不上可以到视频下方云盘中下载。<br><img src="https://s2.loli.net/2023/03/06/VStPIABaXxMp2N9.png" alt="image-20230306231045825"><br>可以看到目前最新的版本是 <code>1.4.3</code> 版本（2022 年 2 月 27 日发布的），我们直接下载 <code>zip</code> 文件即可。<br>接着我们将文件进行解压，得到以下内容：<br><img src="https://s2.loli.net/2023/03/06/wWbuXRGizrQCT8J.png" alt="image-20230306231054919"><br>我们直接将其拖入到项目文件夹下，便于我们一会在 IDEA 内部启动，接着添加运行配置：<br><img src="https://s2.loli.net/2023/03/06/bM8doEZPth7DHfe.png" alt="image-20230306231104823"><br>其中 <code>-m standalone</code> 表示单节点模式，Mac 和 Linux 下记得将解释器设定为 <code>/bin/bash</code>，由于 Nacos 在 Mac&#x2F;Linux 默认是后台启动模式，我们修改一下它的 bash 文件，让它变成前台启动，这样 IDEA 关闭了 Nacos 就自动关闭了，否则开发环境下很容易忘记关：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注释掉 nohup $JAVA $&#123;JAVA_OPT&#125; nacos.nacos &gt;&gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;</span><br><span class="hljs-comment"># 替换成下面的</span><br><span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> nacos.nacos<br></code></pre></td></tr></table></figure><p>接着我们点击启动：<br><img src="https://s2.loli.net/2023/03/06/O3pMSvDbxPKYT5q.png" alt="image-20230306231113946"><br>OK，启动成功，可以看到它的管理页面地址也是给我们贴出来了： <a href="http://localhost:8848/nacos/index.html">http://localhost:8848/nacos/index.html</a> ，访问这个地址：<br><img src="https://s2.loli.net/2023/03/06/sbKTUqhLViIfrmR.png" alt="image-20230306231125828"><br>默认的用户名和管理员密码都是 <code>nacos</code>，直接登陆即可，可以看到进入管理页面之后功能也是相当丰富：<br><img src="https://s2.loli.net/2023/03/06/dom3WpJsiajgCE7.png" alt="image-20230306231150574"><br>至此，Nacos 的安装与部署完成。</p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>现在我们要实现基于 Nacos 的服务注册与发现，那么就需要导入 SpringCloudAlibaba 相关的依赖，我们在父工程将依赖进行管理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 这里引入最新的SpringCloud依赖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 这里引入最新的SpringCloudAlibaba依赖，2021.0.1.0版本支持SpringBoot2.6.X --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们就可以在子项目中添加<strong>服务发现依赖</strong>了，比如我们以图书服务为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和注册到 Eureka 一样，我们也需要在配置文件中配置 Nacos 注册中心的地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br><span class="hljs-comment"># 之后所有的图书服务节点就81XX端口</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8101</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://cloudstudy.mysql.cn-chengdu.rds.aliyuncs.com:3306/cloudstudy</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-comment"># 应用名称 bookservice</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">bookservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># 配置Nacos注册中心地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><p>接着启动我们的图书服务，可以在 Nacos 的服务列表中找到：<br><img src="https://s2.loli.net/2023/03/06/9PLBGOXoaERnUwM.png" alt="image-20230306231202683"><br>按照同样的方法，我们接着将另外两个服务也注册到 Nacos 中：<br><img src="https://s2.loli.net/2023/03/06/K6VBtqEWSLnMp21.png" alt="image-20230306231211930"><br>接着我们使用 OpenFeign，实现<strong>服务发现远程调用以及负载均衡</strong>，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里需要单独导入LoadBalancer依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;bookservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; bookClient.getBookById(b.getBid()))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run (BorrowApplication. class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们进行测试：<br><img src="https://s2.loli.net/2023/03/06/HIGvXAad1EOVPt6.png" alt="image-20230306231226300"><br>测试正常，可以自动发现服务，接着我们来多配置几个实例，去掉图书服务和用户服务的端口配置：<br><img src="https://s2.loli.net/2023/03/06/WZGdJ5BYpmbMuNT.png" alt="image-20230306231234119"><br>然后我们在图书服务和用户服务中添加一句打印方便之后查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/&#123;uid&#125;&quot;</span>)<br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>    System.out.println (<span class="hljs-string">&quot;调用用户服务&quot;</span>);<br>    <span class="hljs-keyword">return</span> service.getUserById (uid);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在将全部服务启动：<br><img src="https://s2.loli.net/2023/03/06/GCrm8wgWXLzYhtK.png" alt="image-20230306231244149"><br>可以看到 Nacos 中的实例数量已经显示为<code>2</code>：<br><img src="https://s2.loli.net/2023/03/06/p6iYrPa8e1btZkl.png" alt="image-20230306231251732"><br>接着我们调用借阅服务，看看能否负载均衡远程调用：<br><img src="https://s2.loli.net/2023/03/06/jCl8RGhaIiUDBgm.png" alt="image-20230306231259820"><br><img src="https://s2.loli.net/2023/03/06/2bWdfmnVOyGzlZr.png" alt="image-20230306231306653"><br>OK，负载均衡远程调用没有问题，这样我们就实现了基于 Nacos 的服务的注册与发现，实际上大致流程与 Eureka 一致。<br>值得注意的是，Nacos 区分了<strong>临时实例和非临时实例</strong>：<br><img src="https://s2.loli.net/2023/03/06/cF5MoVX6vNnzx9j.png" alt="image-20230306231317971"><br>那么临时和非临时有什么区别呢？</p><ul><li>临时实例：和 Eureka 一样，采用心跳机制向 Nacos 发送请求保持在线状态，一旦心跳停止，代表实例下线，不保留实例信息。</li><li>非临时实例：由 Nacos 主动进行联系，如果连接失败，那么不会移除实例信息，而是将健康状态设定为 false，相当于会对某个实例状态持续地进行监控。</li></ul><p>我们可以通过配置文件进行修改临时实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 将 ephemeral 修改为 false，表示非临时实例</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>接着我们在 Nacos 中查看，可以发现实例已经不是临时的了：<br><img src="https://s2.loli.net/2023/03/06/FdRTjlKszDoOPU3.png" alt="image-20230306231328378"><br>如果这时我们关闭此实例，那么会变成这样：<br><img src="https://s2.loli.net/2023/03/06/R5Jyhl29UcvuOCb.png" alt="image-20230306231337931"><br>只是将健康状态变为 false，而不会删除实例的信息。</p><h3 id="集群分区"><a href="#集群分区" class="headerlink" title="集群分区"></a>集群分区</h3><p>实际上集群分区概念在之前的 Eureka 中也有出现，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br><span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8888/eureka</span><br>      <span class="hljs-comment"># 这个 defaultZone 是个啥玩意，为什么要用这个名称？为什么要要用这样的形式来声明注册中心？</span><br></code></pre></td></tr></table></figure><p>在一个分布式应用中，相同服务的实例可能会在不同的机器、位置上启动，比如我们的用户管理服务，可能在成都有 1 台服务器部署、重庆有一台服务器部署，而这时，我们在成都的服务器上启动了借阅服务，那么如果我们的借阅服务现在要调用用户服务，就应该优先选择同一个区域的用户服务进行调用，这样会使得响应速度更快。<br><img src="https://s2.loli.net/2023/03/06/szyGRrEfZ1KWmpj.png" alt="image-20230306231411711"><br>因此，我们可以对部署在不同机房的服务进行分区，可以看到实例的分区是默认：<br><img src="https://s2.loli.net/2023/03/06/wlO9dQ1NtKCxFTi.png" alt="image-20230306231402008"><br>我们可以直接在配置文件中进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 修改为重庆地区的集群</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chongqing</span><br></code></pre></td></tr></table></figure><p>当然由于我们这里使用的是不同的启动配置，直接在启动配置中添加环境变量<code>spring. cloud. nacos. discovery. cluster-name</code>也行，这里我们将用户服务和图书服务两个区域都分配一个，借阅服务就配置为成都地区：<br><img src="https://s2.loli.net/2023/03/06/cwIhdCMmATELvlN.png" alt="image-20230306231435388"><br>修改完成之后，我们来尝试重新启动一下（Nacos 也要重启），观察 Nacos 中集群分布情况：<br><img src="https://s2.loli.net/2023/03/06/jrYo3epaLMyQnu4.png" alt="image-20230306231443247"><br>可以看到现在有两个集群，并且都有一个实例正在运行。我们接着去调用借阅服务，但是发现并没有按照区域进行优先调用，而依然使用的是轮询模式的负载均衡调用。<br>我们必须要提供 Nacos 的负载均衡实现才能开启区域优先调用机制，只需要在配制文件中进行修改即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chengdu</span><br>    <span class="hljs-comment"># 将 loadbalancer 的 nacos 支持开启，集成 Nacos 负载均衡</span><br>    <span class="hljs-attr">loadbalancer:</span><br>      <span class="hljs-attr">nacos:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>现在我们重启借阅服务，会发现优先调用的是同区域的用户和图书服务，现在我们可以将成都地区的服务下线：<br><img src="https://s2.loli.net/2023/03/06/s1ko9UcD4mMQ5fW.png" alt="image-20230306231453470"><br>可以看到，在下线之后，由于本区域内没有可用服务了，借阅服务将会调用重庆区域的用户服务。<br>除了根据区域优先调用之外，同一个区域内的实例也可以单独设置权重，Nacos 会优先选择权重更大的实例进行调用，我们可以直接在管理页面中进行配置：<br><img src="https://s2.loli.net/2023/03/06/1pAckEZN5ltXKWG.png" alt="image-20230306231500731"><br>或是在配置文件中进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chengdu</span><br>        <span class="hljs-comment"># 权重大小，越大越优先调用，默认为 1</span><br>        <span class="hljs-attr">weight:</span> <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><p>通过配置权重，某些性能不太好的机器就能够更少地被使用，而更多的使用那些网络良好性能更高的主机上的实例。</p><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>前面我们学习了 SpringCloud Config，我们可以通过配置服务来加载远程配置，这样我们就可以在远端集中管理配置文件。<br>实际上我们可以在<code>bootstrap. yml</code>中配置远程配置文件获取，然后再进入到配置文件加载环节，而 Nacos 也支持这样的操作，使用方式也比较类似，比如我们现在想要将借阅服务的配置文件放到 Nacos 进行管理，那么这个时候就需要在 Nacos 中创建配置文件：<br><img src="https://s2.loli.net/2023/03/06/6j2pAmdfyIGz9Cu.png" alt="image-20230306231534251"><br>将借阅服务的配置文件全部（当然正常情况下是不会全部 CV 的，只会复制那些需要经常修改的部分，这里为了省事就直接全部 CV 了）复制过来，注意<strong>Data ID</strong>的格式跟我们之前一样，<code>应用名称-环境. yml</code>，如果只编写应用名称，那么代表此配置文件无论在什么环境下都会使用，然后每个配置文件都可以进行分组，也算是一种分类方式：<br><img src="https://s2.loli.net/2023/03/06/7ACoW3txIsjLzu2.png" alt="image-20230306231514151"><br>完成之后点击发布即可：<br><img src="https://s2.loli.net/2023/03/06/alFpWGfNejImQEw.png" alt="image-20230306231522828"><br>然后在项目中导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. springframework. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. alibaba. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们在借阅服务中添加<code>bootstrap. yml</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>  <span class="hljs-comment"># 服务名称和配置文件保持一致</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">profiles:</span><br>  <span class="hljs-comment"># 环境也是和配置文件保持一致</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># 配置文件后缀名</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span><br>        <span class="hljs-comment"># 配置中心服务器地址，也就是 Nacos 地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure><p>现在我们启动服务试试看：<br><img src="https://s2.loli.net/2023/03/06/5J4FfMgtGwZhP3C.png" alt="image-20230306231605960"><br>可以看到成功读取配置文件并启动了，实际上使用上来说跟之前的 Config 是基本一致的。<br>Nacos 还支持<strong>配置文件的热更新</strong>，比如我们在配置文件中添加了一个属性，而这个时候可能需要实时修改，并在后端实时更新，那么这种该怎么实现呢？我们创建一个新的 Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;$&#123;test. txt&#125;&quot;</span>)  <span class="hljs-comment">//我们从配置文件中读取 test. txt 的字符串值，作为 test 接口的返回值</span><br>    String txt;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> txt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们修改一下配置文件，然后重启服务器：<br><img src="https://s2.loli.net/2023/03/06/9xthuBpgFs4PTSq.png" alt="image-20230306231616512"><br>可以看到已经可以正常读取了：<br><img src="https://s2.loli.net/2023/03/06/kacrSVGYMpwK2jx.png" alt="image-20230306231626447"><br>现在我们将配置文件的值进行修改：<br><img src="https://s2.loli.net/2023/03/06/YLC2H6yGoVi5z1f.png" alt="image-20230306231634007"><br>再次访问接口，会发现没有发生变化：<br><img src="https://s2.loli.net/2023/03/06/isTaOUQwMVWGCY9.png" alt="image-20230306231641913"><br>但是后台是成功检测到值更新了，但是值却没改变：<br><img src="https://s2.loli.net/2023/03/06/dR4thB5JTk1cGjm.png" alt="image-20230306231656905"><br>那么如何才能实现配置热更新呢？我们可以像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span>   <span class="hljs-comment">//添加此注解就能实现自动刷新了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;$&#123;test. txt&#125;&quot;</span>)<br>    String txt;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> txt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启服务器，再次重复上述实验，成功。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>我们还可以将配置文件或是服务实例划分到不同的命名空间中，其实就是区分开发、生产环境或是引用归属之类的：<br><img src="https://s2.loli.net/2023/03/06/7itUIhz3NupRdr6.png" alt="image-20230306231706215"><br>这里我们创建一个新的命名空间：<br><img src="https://s2.loli.net/2023/03/06/DC2I1MvVFjYmPEq.png" alt="image-20230306231713676"><br>可以看到在 dev 命名空间下，没有任何配置文件和服务：<br><img src="https://s2.loli.net/2023/03/06/Ek4APjgGcqbitNm.png" alt="image-20230306231723164"><br>我们在不同的命名空间下，实例和配置都是相互之间隔离的，我们也可以在配置文件中指定当前的命名空间。</p><h3 id="实现高可用"><a href="#实现高可用" class="headerlink" title="实现高可用"></a>实现高可用</h3><p>由于 Nacos 暂不支持 Arm 架构芯片的 Mac 集群搭建，本小节用 Linxu 云主机（Nacos 比较吃内存，2 个 Nacos 服务器集群，至少2G 内存）环境演示。<br>通过前面的学习，我们已经了解了如何使用 Nacos 以及 Nacos 的功能等，最后我们来看看，如果像之前 Eureka 一样，搭建 Nacos 集群，实现高可用。<br>官方方案： <a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a><br><img src="https://s2.loli.net/2023/03/06/H1AvxOK78yspP5k.jpg" alt="deployDnsVipMode.jpg"></p><blockquote><p><a href="http://ip1:port/openAPI">http://ip1:port/openAPI</a> 直连 ip 模式，机器挂则需要修改 ip 才可以使用。</p><p><a href="http://SLB:port/openAPI">http://SLB:port/openAPI</a> 挂载 SLB 模式 (内网 SLB，不可暴露到公网，以免带来安全风险)，直连 SLB 即可，下面挂 server 真实 ip，可读性不好。</p><p><a href="http://nacos.com:port/openAPI">http://nacos.com:port/openAPI</a> 域名 + SLB 模式 (内网 SLB，不可暴露到公网，以免带来安全风险)，可读性好，而且换 ip 方便，推荐模式</p></blockquote><p>我们来看看它的架构设计，它推荐我们在所有的 Nacos 服务端之前建立一个负载均衡，我们通过访问负载均衡服务器来间接访问到各个 Nacos 服务器。实际上就，是比如有三个 Nacos 服务器做集群，但是每个服务不可能把每个 Nacos 都去访问一次进行注册，实际上只需要在任意一台 Nacos 服务器上注册即可，Nacos 服务器之间会自动同步信息，但是如果我们随便指定一台 Nacos 服务器进行注册，如果这台 Nacos 服务器挂了，但是其他 Nacos 服务器没挂，这样就没办法完成注册了，但是实际上整个集群还是可用的状态。<br>所以这里就需要在所有 Nacos 服务器之前搭建一个 SLB（服务器负载均衡），这样就可以避免上面的问题了。但是我们知道，如果要实现外界对服务访问的负载均衡，我们就得用比如之前说到的 Gateway 来实现，而这里实际上我们可以用一个更加方便的工具：Nginx，来实现（之前我们没讲过，但是使用起来很简单，放心后面会带着大家使用）<br>关于 SLB 最上方还有一个 DNS（我们在<code>计算机网络</code>这门课程中学习过），这个是因为 SLB 是裸 IP，如果 SLB 服务器修改了地址，那么所有微服务注册的地址也得改，所以这里是通过加域名，通过域名来访问，让 DNS 去解析真实 IP，这样就算改变 IP，只需要修改域名解析记录即可，域名地址是不会变化的。<br>最后就是 Nacos 的数据存储模式，在单节点的情况下，Nacos 实际上是将数据存放在自带的一个嵌入式数据库中：<br><img src="https://s2.loli.net/2023/03/06/Fuxq9Dl3rGfnTZA.png" alt="image-20230306231744022"><br>而这种模式只适用于单节点，在多节点集群模式下，肯定是不能各存各的，所以，Nacos 提供了 MySQL 统一存储支持，我们只需要让所有的 Nacos 服务器连接 MySQL 进行数据存储即可，官方也提供好了 SQL 文件。<br>现在就可以开始了，第一步，我们直接导入数据库即可，文件在 conf 目录中：<br><img src="https://s2.loli.net/2023/03/06/97suBpfdeF54rc2.png" alt="image-20230306231753589"><br>我们来将其导入到数据库，可以看到生成了很多的表：<br><img src="https://s2.loli.net/2023/03/06/cf76RJ9VUiQBlje.png" alt="image-20230306231802722"><br>然后我们来创建两个 Nacos 服务器，做一个迷你的集群，这里使用<code>scp</code>命令将 nacos 服务端上传到 Linux 服务器（注意需要提前安装好 JRE 8 或更高版本的环境）：<br><img src="https://s2.loli.net/2023/03/06/RW4JIBKVXSbG3lZ.png" alt="image-20230306231811912"><br>解压之后，我们对其配置文件进行修改，首先是<code>application. properties</code>配置文件，修改以下内容，包括 MySQL 服务器的信息：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">### Default web server port:</span><br><span class="hljs-attr">server.</span> <span class="hljs-string">port=8801</span><br><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.</span> <span class="hljs-string">datasource. platform=mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">num=1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">url. 0=jdbc:mysql://cloudstudy. mysql. cn-chengdu. rds. aliyuncs. com: 3306/nacos? characterEncoding=utf 8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">user. 0=nacos</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">password. 0=nacos</span><br></code></pre></td></tr></table></figure><p>然后修改集群配置，这里需要重命名一下：<br><img src="https://s2.loli.net/2023/03/06/2pe51dHQsJkPVY7.png" alt="image-20230306231821488"><br>端口记得使用内网 IP 地址：<br><img src="https://s2.loli.net/2023/03/06/5CbEGQ7rX2StUkR.png" alt="image-20230306231828707"><br>最后我们修改一下 Nacos 的内存分配以及前台启动，直接修改<code>startup. sh</code>文件（内存有限，玩不起高的）：<br><img src="https://s2.loli.net/2023/03/06/kQF3lN24vcBqzDi.png" alt="image-20230306231836711"><br>保存之后，将 nacos 复制一份，并将端口修改为 8802，接着启动这两个 Nacos 服务器。<br><img src="https://s2.loli.net/2023/03/06/PQYi69aKZUXrNlJ.png" alt="image-20230306231845850"><br>然后我们打开管理面板，可以看到两个节点都已经启动了：<br><img src="https://s2.loli.net/2023/03/06/Lbf14V39SCdghvO.png" alt="image-20230306231854072"><br>这样，我们第二步就完成了，接着我们需要添加一个 SLB，这里我们用 Nginx 做反向代理：</p><blockquote><p><em>Nginx</em> (engine x) 是一个高性能的 <a href="https://baike.baidu.com/item/HTTP">HTTP</a> 和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a> web 服务器，同时也提供了 IMAP&#x2F;POP 3&#x2F;SMTP 服务。它相当于在内网与外网之间形成一个网关，所有的请求都可以由 Nginx 服务器转交给内网的其他服务器。</p></blockquote><p>这里我们直接安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install nginx<br></code></pre></td></tr></table></figure><p>可以看到直接请求 80 端口之后得到，表示安装成功：<br><img src="https://s2.loli.net/2023/03/06/gVuMlAXcY34Ka2C.png" alt="image-20230306231903833"><br>现在我们需要让其代理我们刚刚启动的两个 Nacos 服务器，我们需要对其进行一些配置。配置文件位于<code>/etc/nginx/nginx. conf</code>，添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">#添加我们在上游刚刚创建好的两个nacos服务器<br>upstream nacos-server &#123;<br>        server 10.0.0.12:8801;<br>        server 10.0.0.12:8802;<br>&#125;<br>server &#123;<br>        listen   80;<br>        server_name  1.14.121.107;<br>        location /nacos &#123;<br>                proxy_pass http://nacos-server ;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启 Nginx 服务器，成功连接：<br><img src="https://s2.loli.net/2023/03/06/2hrxcizHPvSq8be.png" alt="image-20230306231912734"><br>然后我们将所有的服务全部修改为云服务器上 Nacos 的地址，启动试试看。<br><img src="https://s2.loli.net/2023/03/06/gdh43ciamLnBRFV.png" alt="image-20230306231925001"><br>这样，我们就搭建好了 Nacos 集群。</p><blockquote><p>[!NOTE] Tips</p><ol><li>nacos集群模式时<em>cluster.conf</em>必须配置的<strong>ip是本地ip地址，不能是127.0.0.1</strong></li><li>nacos修改<em>application.properties</em>配置文件不生效，原因在于bin目录下的startup启动文件中设置的<strong>配置文件的位置不对</strong>(不能带<code>optional:</code>)，要改为：<br>windows（startup.cmd）：<code>set &quot;NACOS_CONFIG_OPTS=--spring.config.additional-location=%CUSTOM_SEARCH_LOCATIONS%&quot;</code><br>linux（startup.sh）:<code>JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; --spring.config.additional-location=$&#123;CUSTOM_SEARCH_LOCATIONS&#125;&quot;</code></li></ol></blockquote><hr><p><img src="https://s2.loli.net/2023/03/06/xnmustzRkFZJWIP.png" alt="image-20230306231932929"></p><h2 id="Sentinel-流量防卫兵"><a href="#Sentinel-流量防卫兵" class="headerlink" title="Sentinel 流量防卫兵"></a>Sentinel 流量防卫兵</h2><p><strong>注意：</strong> 这一章有点小绕，思路理清。<br>经过之前的学习，我们了解了微服务存在的雪崩问题，也就是说一个微服务出现问题，有可能导致整个链路直接不可用，这种时候我们就需要进行及时的熔断和降级，这些策略，我们之前通过使用 Hystrix 来实现。<br>SpringCloud Alibaba 也有自己的微服务容错组件，但是它相比 Hystrix 更加的强大。</p><blockquote><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p></blockquote><p>Sentinel 具有以下特征:</p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java&#x2F;Go&#x2F;C++ 等多语言的原生实现。</li><li><strong>完善的 SPI 扩展机制</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="安装与部署-1"><a href="#安装与部署-1" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>和 Nacos 一样，它是独立安装和部署的，下载地址： <a href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a><br><img src="https://s2.loli.net/2023/03/06/oZdLMAJaCD3Uw9F.png" alt="image-20230306231950297"><br>注意下载下来之后是一个<code>jar</code>文件（其实就是个 SpringBoot 项目），我们需要在 IDEA 中添加一些运行配置：<br><img src="https://s2.loli.net/2023/03/06/Hjm4Z38s95YiFvI.png" alt="image-20230306232001525"><br>接着就可以直接启动啦，当然默认端口占用 8080，如果需要修改，可以添加环境变量：<br><img src="https://s2.loli.net/2023/03/06/RfVAdtOqJjWlx6E.png" alt="image-20230306232012301"><br>启动之后，就可以访问到 Sentinel 的监控页面了，用户名和密码都是<code>sentinel</code>，地址： <a href="http://localhost:8858/#/dashboard">http://localhost:8858/#/dashboard</a><br><img src="https://s2.loli.net/2023/03/06/QpVRTYtBX6kvj2b.png" alt="image-20230306232020492"><br>这样就成功开启监控页面了，接着我们需要让我们的服务连接到 Sentinel 控制台，老规矩，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. alibaba. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在配置文件中添加 Sentinel 相关信息（实际上 Sentinel 是本地在进行管理，但是我们可以连接到监控页面，这样就可以图形化操作了）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>      <span class="hljs-comment"># 添加监控页面地址即可</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br></code></pre></td></tr></table></figure><p>现在启动我们的服务，然后访问一次服务，这样 Sentinel 中就会存在信息了（懒加载机制，不会一上来就加载）：<br><img src="https://s2.loli.net/2023/03/06/p4KTaDd1wc5BR92.png" alt="image-20230306232031800"><br><img src="https://s2.loli.net/2023/03/06/pzOus21AWqLfr9k.png" alt="image-20230306232038728"><br>现在我们就可以在 Sentinel 控制台中对我们的服务运行情况进行实时监控了，可以看到监控的内容非常的多，包括时间点、QPS (每秒查询率)、响应时间等数据。<br>按照上面的方式，我们将所有的服务全部连接到 Sentinel 管理面板中。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>前面我们完成了对 Sentinel 的搭建与连接，接着我们来看看 Sentinel 的第一个功能，流量控制。<br>我们的机器不可能无限制的接受和处理客户端的请求，如果不加以限制，当发生高并发情况时，系统资源将很快被耗尽。为了避免这种情况，我们就可以添加流量控制（也可以说是限流）当一段时间内的流量到达一定的阈值的时候，新的请求将不再进行处理，这样不仅可以合理地应对高并发请求，同时也能在一定程度上保护服务器不受到外界的恶意攻击。<br>那么要实现限流，正常情况下，我们该采取什么样的策略呢？</p><ul><li>方案一：<strong>快速拒绝</strong>，既然不再接受新的请求，那么我们可以直接返回一个拒绝信息，告诉用户访问频率过高。</li><li>方案二：<strong>预热</strong>，依然基于方案一，但是由于某些情况下高并发请求是在某一时刻突然到来，我们可以缓慢地将阈值提高到指定阈值，形成一个缓冲保护。</li><li>方案三：<strong>排队等待</strong>，不接受新的请求，但是也不直接拒绝，而是进队列先等一下，如果规定时间内能够执行，那么就执行，要是超时就算了。</li></ul><p>针对于是否超过流量阈值的判断，这里我们提 4 种算法：</p><ol><li><p><strong>漏桶算法</strong></p><p>顾名思义，就像一个桶开了一个小孔，水流进桶中的速度肯定是远大于水流出桶的速度的，这也是最简单的一种限流思路：</p><p><img src="https://s2.loli.net/2023/03/06/dMZVz3kDRxYaHg5.png" alt="image-20230306232054430"></p><p>我们知道，桶是有容量的，所以当桶的容量已满时，就装不下水了，这时就只有丢弃请求了。</p><p>利用这种思想，我们就可以写出一个简单的限流算法。</p></li><li><p><strong>令牌桶算法</strong></p><p>只能说有点像信号量机制。现在有一个令牌桶，这个桶是专门存放令牌的，每隔一段时间就向桶中丢入一个令牌（速度由我们指定）当新的请求到达时，将从桶中删除令牌，接着请求就可以通过并给到服务，但是如果桶中的令牌数量不足，那么不会删除令牌，而是让此数据包等待。</p><p><img src="https://s2.loli.net/2023/03/06/F1RxtgBZNQvWpw8.png" alt="image-20230306232102462"></p><p>可以试想一下，当流量下降时，令牌桶中的令牌会逐渐积累，这样如果突然出现高并发，那么就能在短时间内拿到大量的令牌。</p></li><li><p><strong>固定时间窗口算法</strong></p><p>我们可以对某一个时间段内的请求进行统计和计数，比如在<code>14:15</code>到<code>14:16</code>这一分钟内，请求量不能超过<code>100</code>，也就是一分钟之内不能超过<code>100</code>次请求，那么就可以像下面这样进行划分：</p><p><img src="https://s2.loli.net/2023/03/06/XRnKgCivsqFE2ax.png" alt="image-20230306232111506"></p><p>虽然这种模式看似比较合理，但是试想一下这种情况：</p><ul><li>14:15:59的时候来了 100 个请求</li><li>14:16:01的时候又来了 100 个请求</li></ul><p>出现上面这种情况，符合固定时间窗口算法的规则，所以这 200 个请求都能正常接受，但是，如果你反应比较快，应该发现了，我们其实希望的是 60 秒内只有 100 个请求，但是这种情况却是在 3 秒内出现了 200 个请求，很明显已经违背了我们的初衷。</p><p>因此，当遇到临界点时，固定时间窗口算法存在安全隐患。</p></li><li><p><strong>滑动时间窗口算法</strong></p><p>相对于固定窗口算法，滑动时间窗口算法更加灵活，它会动态移动窗口，重新进行计算：</p><p><img src="https://s2.loli.net/2023/03/06/8MyG3WDo1wSBb5Y.png" alt="image-20230306232118585"></p><p>虽然这样能够避免固定时间窗口的临界问题，但是这样显然是比固定窗口更加耗时的。</p></li></ol><p>好了，了解完了我们的限流策略和判定方法之后，我们在 Sentinel 中进行实际测试一下，打开管理页面的簇点链路模块：<br><img src="https://s2.loli.net/2023/03/06/4fPg72OJiwhDycL.png" alt="image-20230306232127628"><br>这里演示对我们的借阅接口进行限流，点击<code>流控</code>，会看到让我们添加流控规则：</p><ul><li>阈值类型：QPS 就是每秒钟的请求数量，并发线程数是按服务当前使用的线程数据进行统计的。</li><li>流控模式：当达到阈值时，流控的对象，这里暂时只用直接。</li><li>流控效果：就是我们上面所说的三种方案。</li></ul><p>这里我们选择<code>QPS</code>、阈值设定为<code>1</code>，流控模式选择<code>直接</code>、流控效果选择<code>快速失败</code>，可以看到，当我们快速地进行请求时，会直接返回失败信息：<br><img src="https://s2.loli.net/2023/03/06/Lrw7ZJNzyDUoYG8.png" alt="image-20230306232135482"><br>这里各位最好自行尝试一下其他的流控效果，熟悉和加深印象。<br>最后我们来看看这些流控模式有什么区别：</p><ul><li>直接：只针对于当前接口。</li><li>关联：当其他接口超过阈值时，会导致当前接口被限流。</li><li>链路：更细粒度的限流，能精确到具体的方法。</li></ul><p>我们首先来看看关联，比如现在我们对自带的<code>/error</code>接口进行限流：<br><img src="https://s2.loli.net/2023/03/06/E9vnJRTPZmzaW8V.png" alt="image-20230306232145053"><br>注意限流是作用于关联资源的，一旦发现关联资源超过阈值，那么就会对当前的资源进行限流，我们现在来测试一下，这里使用 PostMan 的 Runner 连续对关联资源发起请求：<br><img src="https://s2.loli.net/2023/03/06/QgqsxdvYF59P7ne.png" alt="image-20230306232239339"><br>开启 Postman，然后我们会发现借阅服务已经凉凉：<br><img src="https://s2.loli.net/2023/03/06/tnKXB2JUarehk5T.png" alt="image-20230306232253804"><br>当我们关闭掉 Postman 的任务后，恢复正常。<br>最后我们来讲解一下链路模式，它能够更加精准的进行流量控制，链路流控模式指的是，当从指定接口过来的资源请求达到限流条件时，开启限流，这里得先讲解一下<code>@SentinelResource</code>的使用。<br>我们可以对某一个方法进行限流控制，无论是谁在何处调用了它，这里需要使用到<code>@SentinelResource</code>，一旦方法被标注，那么就会进行监控，比如我们这里创建两个请求映射，都来调用 Service 的被监控方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow/&#123;uid&#125;&quot;</span>)<br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow 2/&#123;uid&#125;&quot;</span>)<br>    UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid (uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SentinelResource</span> (<span class="hljs-string">&quot;getBorrow&quot;</span>)   <span class="hljs-comment">//监控此方法，无论被谁执行都在监控范围内，这里给的 value 是自定义名称，这个注解可以加在任何方法上，包括 Controller 中的请求映射方法，跟 HystrixCommand 贼像</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid (uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById (uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream ()<br>                .map (b -&gt; bookClient.getBookById (b.getBid ()))<br>                .collect (Collectors.toList ());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br>      <span class="hljs-comment"># 关闭 Context 收敛，这样被监控方法可以进行不同链路的单独控制</span><br>      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>然后我们在 Sentinel 控制台中添加流控规则，注意是针对此方法，可以看到已经自动识别到 borrow 接口下调用了这个方法：<br><img src="https://s2.loli.net/2023/03/06/FOzJdtoieAxIvPq.png" alt="image-20230306232304858"><br>最后我们在浏览器中对这两个接口都进行测试，会发现，无论请求哪个接口，只要调用了 Service 中的<code>getUserBorrowDetailByUid</code>这个方法，都会被限流。注意限流的形式是后台直接抛出异常，至于怎么处理我们后面再说。<br>那么这个链路选项实际上就是决定只限流从哪个方向来的调用，比如我们只对<code>borrow 2</code>这个接口对<code>getUserBorrowDetailByUid</code>方法的调用进行限流，那么我们就可以为其指定链路：<br><img src="https://s2.loli.net/2023/03/06/UHbcgSWV2exNCu1.png" alt="image-20230306232315010"><br>然后我们会发现，限流效果只对我们配置的链路接口有效，而其他链路是不会被限流的。<br>除了直接对接口进行限流规则控制之外，我们也可以根据当前系统的资源使用情况，决定是否进行限流：<br><img src="https://s2.loli.net/2023/03/06/MHiDyU54L3QsNrc.png" alt="image-20230306232323438"><br>系统规则支持以下的模式：</p><ul><li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load 1 作为启发指标，进行自适应系统保护。当系统 load 1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li><li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul><p>这里就不进行演示了。</p><h3 id="限流和异常处理"><a href="#限流和异常处理" class="headerlink" title="限流和异常处理"></a>限流和异常处理</h3><p>现在我们已经了解了如何进行限流操作，那么限流状态下的返回结果该怎么修改呢，我们看到被限流之后返回的是 Sentinel 默认的数据，现在我们希望自定义改如何操作？<br>这里我们先创建好被限流状态下需要返回的内容，定义一个请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/blocked&quot;</span>)<br>JSONObject <span class="hljs-title function_">blocked</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span> ();<br>    object.put (<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">403</span>);<br>    object.put (<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>    object.put (<span class="hljs-string">&quot;massage&quot;</span>, <span class="hljs-string">&quot;您的请求频率过快，请稍后再试！&quot;</span>);<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在配置文件中将此页面设定为限流页面：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br>      <span class="hljs-comment"># 将刚刚编写的请求映射设定为限流页面</span><br>      <span class="hljs-attr">block-page:</span> <span class="hljs-string">/blocked</span><br></code></pre></td></tr></table></figure><p>这样，当被限流时，就会被重定向到指定页面：<br><img src="https://s2.loli.net/2023/03/06/PfVOQWJrTiZGqh7.png" alt="image-20230306232335949"><br>那么，对于方法级别的限流呢？经过前面的学习我们知道，当某个方法被限流时，会直接在后台抛出异常，那么这种情况我们该怎么处理呢，比如我们之前在 Hystrix 中可以直接添加一个替代方案，这样当出现异常时会直接执行我们的替代方法并返回，Sentinel 也可以。<br>比如我们还是在<code>getUserBorrowDetailByUid</code>方法上进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SentinelResource</span> (value = <span class="hljs-string">&quot;getBorrow&quot;</span>, blockHandler = <span class="hljs-string">&quot;blocked&quot;</span>)   <span class="hljs-comment">//指定 blockHandler，也就是被限流之后的替代解决方案，这样就不会使用默认的抛出异常的形式了</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>    List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid (uid);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById (uid);<br>    List&lt;Book&gt; bookList = borrow<br>            .stream ()<br>            .map (b -&gt; bookClient.getBookById (b.getBid ()))<br>            .collect (Collectors.toList ());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (user, bookList);<br>&#125;<br><span class="hljs-comment">//替代方案，注意参数和返回值需要保持一致，并且参数最后还需要额外添加一个 BlockException</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">blocked</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, BlockException e)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (<span class="hljs-literal">null</span>, Collections.emptyList ());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，一旦被限流将执行替代方案，最后返回的结果就是：<br><img src="https://s2.loli.net/2023/03/06/p1Y53LPihOGZjBV.png" alt="image-20230306232346185"><br>注意<code>blockHandler</code>只能处理限流情况下抛出的异常，包括下面即将要介绍的热点参数限流也是同理，如果是方法本身抛出的其他类型异常，不在管控范围内，但是可以通过其他参数进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br><span class="hljs-meta">@SentinelResource</span> (value = <span class="hljs-string">&quot;test&quot;</span>,<br>        fallback = <span class="hljs-string">&quot;except&quot;</span>,    <span class="hljs-comment">//fallback 指定出现异常时的替代方案</span><br>        exceptionsToIgnore = IOException. class)  <span class="hljs-comment">//忽略那些异常，也就是说这些异常出现时不使用替代方案</span><br>String <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;HelloWorld！&quot;</span>);<br>&#125;<br><span class="hljs-comment">//替代方法必须和原方法返回值和参数一致，最后可以添加一个 Throwable 作为参数接受异常</span><br>String <span class="hljs-title function_">except</span> <span class="hljs-params">(Throwable t)</span>&#123;<br>    <span class="hljs-keyword">return</span> t.getMessage ();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，其他的异常也可以有替代方案了：<br><img src="https://s2.loli.net/2023/03/06/pk1HjSi9VyxwOJQ.png" alt="image-20230306232354931"><br>特别注意这种方式会在没有配置<code>blockHandler</code>的情况下，将 Sentinel 机制内（也就是限流的异常）的异常也一并处理了，如果配置了<code>blockHandler</code>，那么在出现限流时，依然只会执行<code>blockHandler</code>指定的替代方案（因为限流是在方法执行之前进行的）</p><h3 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>我们还可以对某一热点数据进行精准限流，比如在某一时刻，不同参数被携带访问的频率是不一样的：</p><ul><li><a href="http://localhost:8301/test?a=10">http://localhost:8301/test?a=10</a>  访问 100 次</li><li><a href="http://localhost:8301/test?b=10">http://localhost:8301/test?b=10</a>  访问 0 次</li><li><a href="http://localhost:8301/test?c=10">http://localhost:8301/test?c=10</a>  访问 3 次<br>由于携带参数<code>a</code>的请求比较多，我们就可以只对携带参数<code>a</code>的请求进行限流。<br>这里我们创建一个新的测试请求映射：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br><span class="hljs-meta">@SentinelResource</span> (<span class="hljs-string">&quot;test&quot;</span>)   <span class="hljs-comment">//注意这里需要添加@SentinelResource 才可以，用户资源名称就使用这里定义的资源名称</span><br>String <span class="hljs-title function_">findUserBorrows2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;a&quot;, required = false)</span> String a,  </span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam(value = &quot;b&quot;, required = false)</span> String b,  </span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam(value = &quot;c&quot;, required = false)</span> String c)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功！a = &quot;</span> + a + <span class="hljs-string">&quot;, b = &quot;</span> + b + <span class="hljs-string">&quot;, c = &quot;</span> + c;  <br>&#125;<br></code></pre></td></tr></table></figure>启动之后，我们在 Sentinel 里面进行热点配置：<br><img src="https://s2.loli.net/2023/03/06/fIlhGM3jPxb7wgS.png" alt="image-20230306232406587"><br>然后开始访问我们的测试接口，可以看到在携带参数 a 时，当访问频率超过设定值，就会直接被限流，这里是直接在后台抛出异常：<br><img src="https://s2.loli.net/2023/03/06/hskQVKnE2y5PftO.png" alt="image-20230306232452209"><br><img src="https://s2.loli.net/2023/03/06/nC6W5T4OGcJNypA.png" alt="image-20230306232500754"><br>而我们使用其他参数或是不带<code>a</code>参数，那么就不会出现这种问题了：<br><img src="https://s2.loli.net/2023/03/06/WVguflyZ43NxE7j.png" alt="image-20230306232514532"><br>除了直接对某个参数精准限流外，我们还可以对参数携带的指定值单独设定阈值，比如我们现在不仅希望对参数<code>a</code>限流，而且还希望当参数<code>a</code>的值为 10 时，QPS 达到 5 再进行限流，那么就可以设定例外：<br><img src="https://s2.loli.net/2023/03/06/oipjTJBHsMSdDvc.png" alt="image-20230306232525342"><br>这样，当请求携带参数<code>a</code>，且参数<code>a</code>的值为 10 时，阈值将按照我们指定的特例进行计算。</li></ul><h3 id="服务熔断和降级"><a href="#服务熔断和降级" class="headerlink" title="服务熔断和降级"></a>服务熔断和降级</h3><p>还记得我们前所说的服务降级吗，也就是说我们需要在整个微服务调用链路出现问题的时候，及时对服务进行降级，以防止问题进一步恶化。<br><img src="https://s2.loli.net/2023/03/06/AxrzjvtPWJ2YCZI.png" alt="image-20230306232538279"><br>那么，各位是否有思考过，如果在某一时刻，服务 B 出现故障（可能就卡在那里了），而这时服务 A 依然有大量的请求，在调用服务 B，那么，由于服务 A 没办法再短时间内完成处理，新来的请求就会导致线程数不断地增加，这样，CPU 的资源很快就会被耗尽。<br>那么要防止这种情况，就只能进行隔离了，这里我们提两种隔离方案：</p><ol><li><strong>线程池隔离</strong><br>线程池隔离实际上就是对每个服务的远程调用单独开放线程池，比如服务 A 要调用服务 B，那么只基于固定数量的线程池，这样即使在短时间内出现大量请求，由于没有线程可以分配，所以就不会导致资源耗尽了。<br><img src="https://s2.loli.net/2023/03/06/CbYxA3d7w46OlMm.png" alt="image-20230306232549778"></li><li><strong>信号量隔离</strong><br>信号量隔离是使用<code>Semaphore</code>类实现的（如果不了解，可以观看本系列并发编程篇视频教程），思想基本上与上面是相同的，也是限定指定的线程数量能够同时进行服务调用，但是它相对于线程池隔离，开销会更小一些，使用效果同样优秀，也支持超时等。<br>Sentinel 也正是采用的这种方案实现隔离的。<br>好了，说回我们的熔断和降级，当下游服务因为某种原因变得不可用或响应过慢时，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务而是快速返回或是执行自己的替代方案，这便是服务降级。<br><img src="https://s2.loli.net/2023/03/06/gY62LD3vw157WiU.png" alt="image-20230306232602853"><br>整个过程分为三个状态：</li></ol><ul><li>关闭：熔断器不工作，所有请求全部该干嘛干嘛。</li><li>打开：熔断器工作，所有请求一律降级处理。</li><li>半开：尝试进行一下下正常流程，要是还不行继续保持打开状态，否则关闭。<br>那么我们来看看 Sentinel 中如何进行熔断和降级操作，打开管理页面，我们可以自由新增熔断规则：<br><img src="https://s2.loli.net/2023/03/06/7BW6LGXQNl5b1Iv.png" alt="image-20230306232618547"><br>其中，熔断策略有三种模式：</li></ul><ol><li><strong>慢调用比例：</strong> 如果出现那种半天都处理不完的调用，有可能就是服务出现故障，导致卡顿，这个选项是按照最大响应时间（RT）进行判定，如果一次请求的处理时间超过了指定的 RT，那么就被判定为<code>慢调用</code>，在一个统计时长内，如果请求数目大于最小请求数目，并且被判定为<code>慢调用</code>的请求比例已经超过阈值，将触发熔断。经过熔断时长之后，将会进入到半开状态进行试探（这里和 Hystrix 一致）<br>然后修改一下接口的执行，我们模拟一下慢调用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow 2/&#123;uid&#125;&quot;</span>)<br>UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep (<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>重启，然后我们创建一个新的熔断规则：<br><img src="https://s2.loli.net/2023/03/06/ExWIKFSNpPoksiT.png" alt="image-20230306232632385"><br>可以看到，超时直接触发了熔断，进入到阻止页面：<br><img src="https://s2.loli.net/2023/03/06/CmdPgcqvX4a2u9p.png" alt="image-20230306232642387"></li><li><strong>异常比例：</strong> 这个与慢调用比例类似，不过这里判断的是出现异常的次数，与上面一样，我们也来进行一些小测试：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow 2/&#123;uid&#125;&quot;</span>)<br>UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> ();<br>&#125;<br></code></pre></td></tr></table></figure>启动服务器，接着添加我们的熔断规则：<br><img src="https://s2.loli.net/2023/03/06/Dz3EgG9eH4UXTkJ.png" alt="image-20230306232652092"><br>现在我们进行访问，会发现后台疯狂报错，然后就熔断了：<br><img src="https://s2.loli.net/2023/03/06/jSp92ODTRhlxJsn.png" alt="image-20230306232702794"><br><img src="https://s2.loli.net/2023/03/06/FfhalnZdS2ujm1t.png" alt="image-20230306232711467"></li><li><strong>异常数：</strong> 这个和上面的唯一区别就是，只要达到指定的异常数量，就熔断，这里我们修改一下熔断规则：<br><img src="https://s2.loli.net/2023/03/06/CugOUozGA6inB3R.png" alt="image-20230306232720801"><br>现在我们再次不断访问此接口，可以发现，效果跟之前其实是差不多的，只是判断的策略稍微不同罢了：<br><img src="https://s2.loli.net/2023/03/06/XC1VekDfainIpv6.png" alt="image-20230306232738961"><br>那么熔断规则如何设定我们了解了，那么，如何自定义服务降级呢？之前在使用 Hystrix 的时候，如果出现异常，可以执行我们的替代方案，Sentinel 也是可以的。<br>同样的，我们只需要在<code>@SentinelResource</code>中配置<code>blockHandler</code>参数（那这里跟前面那个方法限流的配置不是一毛一样吗？没错，因为如果添加了<code>@SentinelResource</code>注解，那么这里会进行方法级别细粒度的限制，和之前方法级别限流一样，会在降级之后直接抛出异常，如果不添加则返回默认的限流页面，<code>blockHandler</code>的目的就是处理这种 Sentinel 机制上的异常，所以这里其实和之前的限流配置是一个道理，因此下面熔断配置也应该对<code>value</code>自定义名称的资源进行配置，才能作用到此方法上）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow2/&#123;uid&#125;&quot;</span>)<br><span class="hljs-meta">@SentinelResource</span> (value = <span class="hljs-string">&quot;findUserBorrows 2&quot;</span>, blockHandler = <span class="hljs-string">&quot;test&quot;</span>)<br>UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> ();<br>&#125;<br>UserBorrowDetail <span class="hljs-title function_">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, BlockException e)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span> (), Collections.emptyList ());<br>&#125;<br></code></pre></td></tr></table></figure>接着我们对进行熔断配置，注意是对我们添加的<code>@SentinelResource</code>中指定名称的<code>findUserBorrows 2</code>进行配置：<br><img src="https://s2.loli.net/2023/03/06/QkofY5gzwSr6WGn.png" alt="image-20230306232759448"><br>OK，可以看到熔断之后，服务降级之后的效果：<br><img src="https://s2.loli.net/2023/03/06/5kLcAaT6wJgYXGx.png" alt="image-20230306232809712"><br>最后我们来看一下如何让 Feign 的也支持 Sentinel，前面我们使用 Hystrix 的时候，就可以直接对 Feign 的每个接口调用单独进行服务降级，而使用 Sentinel，也是可以的，首先我们需要在配置文件中开启支持：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>之后的步骤其实和之前是一模一样的，首先创建实现类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserClient</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span> ();<br>        user.setName (<span class="hljs-string">&quot;我是替代方案&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>然后直接启动就可以了，中途的时候我们吧用户服务全部下掉，可以看到正常使用替代方案：<br><img src="https://s2.loli.net/2023/03/06/M2yZpJLfs1i9adC.png" alt="image-20230306232821953"><br>这样 Feign 的配置就 OK 了，那么传统的 RestTemplate 呢？我们可以使用<code>@SentinelRestTemplate</code>注解实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@SentinelRestTemplate</span> (blockHandler = <span class="hljs-string">&quot;handleException&quot;</span>, blockHandlerClass = ExceptionUtil. class,<br>    fallback = <span class="hljs-string">&quot;fallback&quot;</span>, fallbackClass = ExceptionUtil. class) <span class="hljs-comment">//这里同样可以设定 fallback 等参数</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span> <span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span> ();<br>&#125;<br></code></pre></td></tr></table></figure>这里就不多做赘述了。</li></ol><hr><p><img src="https://s2.loli.net/2023/03/06/8OCeNap2Vy6X7WH.png" alt="image-20230306232833262"></p><h2 id="Seata-与分布式事务"><a href="#Seata-与分布式事务" class="headerlink" title="Seata 与分布式事务"></a>Seata 与分布式事务</h2><p>重难点内容，坑也多得离谱，最好保持跟 UP 一样的版本，<strong>官方文档：</strong> <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a><br>在前面的阶段中，我们学习过事务，还记得我们之前谈到的数据库事务的特性吗？</p><ul><li><strong>原子性：</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>一致性：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li><strong>隔离性：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li><strong>持久性：</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>那么各位试想一下，在分布式环境下，有可能出现这样一个问题，比如我们下单购物，那么整个流程可能是这样的：先调用库存服务对库存进行减扣 -&gt; 然后订单服务开始下单 -&gt; 最后用户账户服务进行扣款，虽然看似是一个很简单的一个流程，但是如果没有事务的加持，很有可能会由于中途出错，比如整个流程中订单服务出现问题，那么就会导致库存扣了，但是实际上这个订单并没有生成，用户也没有付款。<br><img src="https://s2.loli.net/2023/03/06/AiEXC3wBflPxHGT.png" alt="image-20230306233055869"><br>上面这种情况时间就是一种多服务多数据源的分布式事务模型（比较常见），因此，为了解决这种情况，我们就得实现分布式事务，让这整个流程保证原子性。<br>SpringCloud Alibaba 为我们提供了用于处理分布式事务的组件 Seata。<br><img src="https://s2.loli.net/2023/03/06/jDAy7osQ5YIqruP.png" alt="image-20230306233108567"><br>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。<br>实际上，就是多了一个中间人来协调所有服务的事务。</li></ul><h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a>项目环境搭建</h3><p>这里我们对我们之前的图书管理系统进行升级：</p><ul><li>每个用户最多只能同时借阅 2 本不同的书。</li><li>图书馆中所有的书都有 3 本。</li><li>用户借书流程：先调用图书服务书籍数量-1 -&gt;  添加借阅记录  -&gt;  调用用户服务用户可借阅数量-1<br>那么首先我们对数据库进行修改，这里为了简便，就直接在用户表中添加一个字段用于存储用户能够借阅的书籍数量：<br><img src="https://s2.loli.net/2023/03/06/TvJL2PiWFU4XoaZ.png" alt="image-20230306232857302"><br>然后修改书籍信息，也是直接添加一个字段用于记录剩余数量：<br><img src="https://s2.loli.net/2023/03/06/WjEcGbtkNrZi1CL.png" alt="image-20230306232904202"><br>接着我们去编写一下对应的服务吧，首先是用户服务：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from DB_USER where uid = #&#123;uid&#125;&quot;</span>)<br>    User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select book_count from DB_USER where uid = #&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getUserBookRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>    <span class="hljs-meta">@Update</span> (<span class="hljs-string">&quot;update DB_USER set book_count = #&#123;count&#125; where uid = #&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBookCount</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserById (uid);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserBookRemain (uid);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.updateBookCount (uid, count) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    UserService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserById (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/remain/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">userRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getRemain (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/borrow/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">userBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> service.getRemain (uid);<br>        <span class="hljs-keyword">return</span> service.setRemain (uid, remain - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>然后是图书服务，其实跟用户服务差不多：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookMapper</span> &#123;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from DB_BOOK where bid = #&#123;bid&#125;&quot;</span>)<br>    Book <span class="hljs-title function_">getBookById</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select count from DB_BOOK  where bid = #&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>    <span class="hljs-meta">@Update</span> (<span class="hljs-string">&quot;update DB_BOOK set count = #&#123;count&#125;  where bid = #&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">setRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid, <span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BookMapper mapper;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookById</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getBookById (bid);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.setRemain (bid, count) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getRemain (bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BookService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/&#123;bid&#125;&quot;</span>)<br>    Book <span class="hljs-title function_">findBookById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid)&#123;<br>        <span class="hljs-keyword">return</span> service.getBookById (bid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/remain/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bookRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getRemain (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/borrow/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bookBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> service.getRemain (uid);<br>        <span class="hljs-keyword">return</span> service.setRemain (uid, remain - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>最后完善我们的借阅服务：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span> (value = <span class="hljs-string">&quot;userservice&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/&#123;uid&#125;&quot;</span>)<br>    User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/borrow/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">userBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/remain/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">userRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span> (<span class="hljs-string">&quot;bookservice&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/&#123;bid&#125;&quot;</span>)<br>    Book <span class="hljs-title function_">getBookById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/borrow/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">bookBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/remain/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">bookRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow/&#123;uid&#125;&quot;</span>)<br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow/take/&#123;uid&#125;/&#123;bid&#125;&quot;</span>)<br>    JSONObject <span class="hljs-title function_">borrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid,<br>                      <span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>) <span class="hljs-type">int</span> bid)&#123;<br>        service.doBorrow (uid, bid);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span> ();<br>        object.put (<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>        object.put (<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>        object.put (<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;借阅成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid (uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById (uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream ()<br>                .map (b -&gt; bookClient.getBookById (b.getBid ()))<br>                .collect (Collectors.toList ());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (user, bookList);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doBorrow</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span> &#123;<br>      <span class="hljs-comment">//1. 判断图书和用户是否都支持借阅</span><br>        <span class="hljs-keyword">if</span> (bookClient.bookRemain (bid) &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;图书数量不足&quot;</span>);<br>        <span class="hljs-keyword">if</span> (userClient.userRemain (uid) &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;用户借阅量不足&quot;</span>);<br>      <span class="hljs-comment">//2. 首先将图书的数量-1</span><br>        <span class="hljs-keyword">if</span> (! bookClient.bookBorrow (bid))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅图书时出现错误！&quot;</span>);<br>      <span class="hljs-comment">//3. 添加借阅信息</span><br>        <span class="hljs-keyword">if</span> (mapper.getBorrow (uid, bid) != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;此书籍已经被此用户借阅了！&quot;</span>);<br>        <span class="hljs-keyword">if</span> (mapper.addBorrow (uid, bid) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在录入借阅信息时出现错误！&quot;</span>);<br>      <span class="hljs-comment">//4. 用户可借阅-1</span><br>        <span class="hljs-keyword">if</span> (! userClient.userBorrow (uid))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅时出现错误！&quot;</span>);<br>      <span class="hljs-comment">//完成</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这样，只要我们的图书借阅过程中任何一步出现问题，都会抛出异常。<br>我们来测试一下：<br><img src="https://s2.loli.net/2023/03/06/MPkZb1dA2Khjcty.png" alt="image-20230306233138135"><br>再次尝试借阅，后台会直接报错：<br><img src="https://s2.loli.net/2023/03/06/H43Fy9z76LIvJGd.png" alt="image-20230306233147990"><br>抛出异常，但是我们发现一个问题，借阅信息添加失败了，但是图书的数量依然被-1，也就是说正常情况下，我们是希望中途出现异常之后，之前的操作全部回滚的：<br><img src="https://s2.loli.net/2023/03/06/l9D8aXBxkvnZejw.png" alt="image-20230306233201664"><br>而这里由于是在另一个服务中进行的数据库操作，所以传统的<code>@Transactional</code>注解无效，这时就得借助 Seata 提供分布式事务了。</li></ul><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>要开始实现分布式事务，我们得先从理论上开始下手，我们来了解一下常用的分布式事务解决方案。</p><ol><li><strong>XA 分布式事务协议 - 2 PC（两阶段提交实现）</strong><br>这里的 PC 实际上指的是 Prepare 和 Commit，也就是说它分为两个阶段，一个是准备一个是提交，整个过程的参与者一共有两个角色，一个是事务的执行者，一个是事务的协调者，实际上整个分布式事务的运作都需要依靠协调者来维持：<br><img src="https://s2.loli.net/2023/03/06/BWiUzFrjHAao1kJ.png" alt="image-20230306233211675"><br>在准备和提交阶段，会进行：<ul><li><strong>准备阶段：</strong><br>一个分布式事务是由协调者来开启的，首先协调者会向所有的事务执行者发送事务内容，等待所有的事务执行者答复。<br>各个事务执行者开始执行事务操作，但是不进行提交，并将 undo 和 redo 信息记录到事务日志中。<br>如果事务执行者执行事务成功，那么就告诉协调者成功 Yes，否则告诉协调者失败 No，不能提交事务。</li><li><strong>提交阶段：</strong><br>当所有的执行者都反馈完成之后，进入第二阶段。<br>协调者会检查各个执行者的反馈内容，如果所有的执行者都返回成功，那么就告诉所有的执行者可以提交事务了，最后再释放锁资源。<br>如果有至少一个执行者返回失败或是超时，那么就让所有的执行者都回滚，分布式事务执行失败。<br>虽然这种方式看起来比较简单，但是存在以下几个问题：</li><li>事务协调者是非常核心的角色，一旦出现问题，将导致整个分布式事务不能正常运行。</li><li>如果提交阶段发生网络问题，导致某些事务执行者没有收到协调者发来的提交命令，将导致某些执行者提交某些执行者没提交，这样肯定是不行的。</li></ul></li><li><strong>XA 分布式事务协议 - 3 PC（三阶段提交实现）</strong><br>三阶段提交是在二阶段提交基础上的改进版本，主要是加入了超时机制，同时在协调者和执行者中都引入了超时机制。<br>三个阶段分别进行：<ul><li><strong>CanCommit 阶段：</strong><br>协调者向执行者发送 CanCommit 请求，询问是否可以执行事务提交操作，然后开始等待执行者的响应。<br>执行者接收到请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态，否则返回 No</li><li><strong>PreCommit 阶段：</strong><br>协调者根据执行者的反应情况来决定是否可以进入第二阶段事务的 PreCommit 操作。<br>如果所有的执行者都返回 Yes，则协调者向所有执行者发送 PreCommit 请求，并进入 Prepared 阶段，执行者接收到请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中，如果成功执行，则返回成功响应。<br>如果所有的执行者至少有一个返回 No，则协调者向所有执行者发送 abort 请求，所有的执行者在收到请求或是超过一段时间没有收到任何请求时，会直接中断事务。</li><li><strong>DoCommit 阶段：</strong><br>该阶段进行真正的事务提交。<br>协调者接收到所有执行者发送的成功响应，那么他将从 PreCommit 状态进入到 DoCommit 状态，并向所有执行者发送 doCommit 请求，执行者接收到 doCommit 请求之后，开始执行事务提交，并在完成事务提交之后释放所有事务资源，并最后向协调者发送确认响应，协调者接收到所有执行者的确认响应之后，完成事务（如果因为网络问题导致执行者没有收到 doCommit 请求，执行者会在超时之后直接提交事务，虽然执行者只是猜测协调者返回的是 doCommit 请求，但是因为前面的两个流程都正常执行，所以能够在一定程度上认为本次事务是成功的，因此会直接提交）<br>协调者没有接收至少一个执行者发送的成功响应（也可能是响应超时），那么就会执行中断事务，协调者会向所有执行者发送 abort 请求，执行者接收到 abort 请求之后，利用其在 PreCommit 阶段记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源，执行者完成事务回滚之后，向协调者发送确认消息，协调者接收到参与者反馈的确认消息之后，执行事务的中断。<br>相比两阶段提交，三阶段提交的优势是显而易见的，当然也有缺点：</li><li>3 PC 在 2 PC 的第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。</li><li>一旦参与者无法及时收到来自协调者的信息之后，会默认执行 Commit，这样就不会因为协调者单方面的故障导致全局出现问题。</li><li>但是我们知道，实际上超时之后的 Commit 决策本质上就是一个赌注罢了，如果此时协调者发送的是 abort 请求但是超时未接收，那么就会直接导致数据一致性问题。</li></ul></li><li><strong>TCC（补偿事务）</strong><br>补偿事务 TCC 就是 Try、Confirm、Cancel，它对业务有侵入性，一共分为三个阶段，我们依次来解读一下。<ul><li><strong>Try 阶段：</strong><br>比如我们需要在借书时，将书籍的库存<code>-1</code>，并且用户的借阅量也<code>-1</code>，但是这个操作，除了直接对库存和借阅量进行修改之外，还需要将减去的值，单独存放到冻结表中，但是此时不会创建借阅信息，也就是说只是预先把关键的东西给处理了，预留业务资源出来。</li><li><strong>Confirm 阶段：</strong><br>如果 Try 执行成功无误，那么就进入到 Confirm 阶段，接着之前，我们就该创建借阅信息了，只能使用 Try 阶段预留的业务资源，如果创建成功，那么就对 Try 阶段冻结的值，进行解冻，整个流程就完成了。当然，如果失败了，那么进入到 Cancel 阶段。</li><li><strong>Cancel 阶段：</strong><br>不用猜了，那肯定是把冻结的东西还给人家，因为整个借阅操作压根就没成功。就像你付了款买了东西但是网络问题，导致交易失败，钱不可能不还给你吧。<br>跟 XA 协议相比，TCC 就没有协调者这一角色的参与了，而是自主通过上一阶段的执行情况来确保正常，充分利用了集群的优势，性能也是有很大的提升。但是缺点也很明显，它与业务具有一定的关联性，需要开发者去编写更多的补偿代码，同时并不一定所有的业务流程都适用于这种形式。</li></ul></li></ol><h3 id="Seata-机制简介"><a href="#Seata-机制简介" class="headerlink" title="Seata 机制简介"></a>Seata 机制简介</h3><p>前面我们了解了一些分布式事务的解决方案，那么我们来看一下 Seata 是如何进行分布式事务的处理的。<br><img src="https://s2.loli.net/2023/03/06/LsUq3AvrfhQJPCz.png" alt="image-20230306233227905"><br>官网给出的是这样的一个架构图，那么图中的 RM、TM、TC 代表着什么意思呢？</p><ul><li>RM（Resource Manager）：用于直接执行本地事务的提交和回滚。</li><li>TM（Transaction Manager）：TM 是分布式事务的核心管理者。比如现在我们需要在借阅服务中开启全局事务，来让其自身、图书服务、用户服务都参与进来，也就是说一般全局事务发起者就是 TM。</li><li>TC（Transaction Manager）这个就是我们的 Seata 服务器，用于全局控制，比如在 XA 模式下就是一个协调者的角色，而一个分布式事务的启动就是由 TM 向 TC 发起请求，TC 再来与其他的 RM 进行协调操作。<blockquote><p>TM 请求 TC 开启一个全局事务，TC 会生成一个 XID 作为该全局事务的编号，XID 会在微服务的调用链路中传播，保证将多个微服务的子事务关联在一起；RM 请求 TC 将本地事务注册为全局事务的分支事务，通过全局事务的 XID 进行关联；TM 请求 TC 告诉 XID 对应的全局事务是进行提交还是回滚；TC 驱动 RM 将 XID 对应的自己的本地事务进行提交还是回滚；<br>Seata 支持 4 种事务模式，官网文档： <a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p></blockquote></li><li>AT：本质上就是 2 PC 的升级版，在 AT 模式下，用户只需关心自己的 “业务 SQL”<ol><li>一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</li><li>二阶段如果确认提交的话，因为“业务 SQL”在一阶段已经提交至数据库，所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可，当然如果需要回滚，那么就用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</li></ol></li><li>TCC：和我们上面讲解的思路是一样的。</li><li>XA：同上，但是要求数据库本身支持这种模式才可以。</li><li>Saga：用于处理长事务，每个执行者需要实现事务的正向操作和补偿操作：<br><img src="https://s2.loli.net/2023/03/06/vLTZFS4yn26uabA.png" alt="image-20230306233328901"><br>那么，以 AT 模式为例，我们的程序如何才能做到不对业务进行侵入的情况下实现分布式事务呢？实际上，Seata 客户端，是通过对数据源进行代理实现的，使用的是 DataSourceProxy 类，所以在程序这边，我们只需要将对应的代理类注册为 Bean 即可（0.9 版本之后支持自动进行代理，不用我们手动操作）<br>接下来，我们就以 AT 模式为例进行讲解。</li></ul><h3 id="使用-file-模式部署"><a href="#使用-file-模式部署" class="headerlink" title="使用 file 模式部署"></a>使用 file 模式部署</h3><p>Seata 也是以服务端形式进行部署的，然后每个服务都是客户端，服务端下载地址： <a href="https://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip">https://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip</a><br>把源码也下载一下： <a href="https://github.com/seata/seata/archive/refs/heads/develop.zip">https://github.com/seata/seata/archive/refs/heads/develop.zip</a><br>下载完成之后，放入到 IDEA 项目目录中，添加启动配置，这里端口使用 8868：<br><img src="https://s2.loli.net/2023/03/06/ykH1BSPcxlvY4on.png" alt="image-20230306233336803"><br>Seata 服务端支持本地部署或是基于注册发现中心部署（比如 Nacos、Eureka 等），这里我们首先演示一下最简单的本地部署，不需要对 Seata 的配置文件做任何修改。<br>Seata 存在着事务分组机制：</p><ul><li>事务分组：seata 的资源逻辑，可以按微服务的需要，在应用程序（客户端）对自行定义事务分组，每组取一个名字。</li><li>集群：seata-server 服务端一个或多个节点组成的集群 cluster。应用程序（客户端）使用时需要指定事务逻辑分组与 Seata 服务端集群（默认为 default）的映射关系。<br>为啥要设计成通过事务分组再直接映射到集群？干嘛不直接指定集群呢？获取事务分组到映射集群的配置。这样设计后，事务分组可以作为资源的逻辑隔离单位，出现某集群故障时可以快速 failover，只切换对应分组，可以把故障缩减到服务级别，但前提也是你有足够 server 集群。<br>接着我们需要将我们的各个服务作为 Seate 的客户端，只需要导入依赖即可：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. alibaba. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>然后添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">vgroup-mapping:</span><br>    <span class="hljs-comment"># 这里需要对事务组做映射，默认的分组名为应用名称-seata-service-group，将其映射到 default 集群</span><br>    <span class="hljs-comment"># 这个很关键，一定要配置对，不然会找不到服务</span><br>      <span class="hljs-attr">bookservice-seata-service-group:</span> <span class="hljs-string">default</span><br>    <span class="hljs-attr">grouplist:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-string">localhost:8868</span><br></code></pre></td></tr></table></figure>这样就可以直接启动了，但是注意现在只是单纯地连接上，并没有开启任何的分布式事务。<br>现在我们接着来配置开启分布式事务，首先在启动类添加注解，此注解会添加一个后置处理器将数据源封装为支持分布式事务的代理数据源（虽然官方表示配置文件中已经默认开启了自动代理，但是 UP 主实测 1.4.2 版本下只能打注解的方式才能生效）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAutoDataSourceProxy</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run (BookApplication. class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>接着我们需要在开启分布式事务的方法上添加<code>@GlobalTransactional</code>注解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GlobalTransactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doBorrow</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span> &#123;<br>  <span class="hljs-comment">//这里打印一下 XID 看看，其他的服务业添加这样一个打印，如果一会都打印的是同一个 XID，表示使用的就是同一个事务</span><br>    System.out.println (RootContext.getXID ());<br>    <span class="hljs-keyword">if</span> (bookClient.bookRemain (bid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;图书数量不足&quot;</span>);<br>    <span class="hljs-keyword">if</span> (userClient.userRemain (uid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;用户借阅量不足&quot;</span>);<br>    <span class="hljs-keyword">if</span> (! bookClient.bookBorrow (bid))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅图书时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mapper.getBorrow (uid, bid) != <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;此书籍已经被此用户借阅了！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mapper.addBorrow (uid, bid) &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在录入借阅信息时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (! userClient.userBorrow (uid))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>还没结束，我们前面说了，Seata 会分析修改数据的 sql，同时生成对应的反向回滚 SQL，这个回滚记录会存放在 undo_log 表中。所以要求每一个 Client 都有一个对应的 undo_log 表（也就是说每个服务连接的数据库都需要创建这样一个表，这里由于我们三个服务都用的同一个数据库，所以说就只用在这个数据库中创建 undo_log 表即可），表 SQL 定义如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log`<br>(<br>  `id`            <span class="hljs-type">BIGINT</span> (<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `branch_id`     <span class="hljs-type">BIGINT</span> (<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `xid`           <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `context`       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `rollback_info` LONGBLOB     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_status`    <span class="hljs-type">INT</span> (<span class="hljs-number">11</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_created`   DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_modified`  DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `ext`           <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure>创建完成之后，我们现在就可以启动三个服务了，我们来测试一下当出现异常的时候是不是会正常回滚：<br><img src="https://s2.loli.net/2023/03/06/NIe9QFW3jf1DdnV.png" alt="image-20230306233351571"><br><img src="https://s2.loli.net/2023/03/06/LwcdO2HuWAhFr5p.png" alt="image-20230306233359914"><br>首先第一次肯定是正常完成借阅操作的，接着我们再次进行请求，肯定会出现异常：<br><img src="https://s2.loli.net/2023/03/06/6VOfsp9UxYJzgKD.png" alt="image-20230306233408870"><br><img src="https://s2.loli.net/2023/03/06/yEQa2qeiNc5npV9.png" alt="image-20230306233417576"><br>如果能在栈追踪信息中看到 seata 相关的包，那么说明分布式事务已经开始工作了，通过日志我们可以看到，出现了回滚操作：<br><img src="https://s2.loli.net/2023/03/06/VtBlx4U1TzcqKra.png" alt="image-20230306233428386"><br>并且数据库中确实是回滚了扣除操作：<br><img src="https://s2.loli.net/2023/03/06/WXn9UPgxBVhdHmb.png" alt="image-20230306233436382"><br>这样，我们就通过 Seata 简单地实现了分布式事务。</li></ul><h3 id="使用-nacos-模式部署"><a href="#使用-nacos-模式部署" class="headerlink" title="使用 nacos 模式部署"></a>使用 nacos 模式部署</h3><p>前面我们实现了本地 Seata 服务的 file 模式部署，现在我们来看看如何让其配合 Nacos 进行部署，利用 Nacos 的配置管理和服务发现机制，Seata 能够更好地工作。<br>我们先单独为 Seata 配置一个命名空间：<br><img src="https://s2.loli.net/2023/03/06/93mXN5dlC2GTLOW.png" alt="image-20230306233444767"><br>我们打开<code>conf</code>目录中的<code>registry. conf</code>配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">registry</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment"># 注册配置</span><br><span class="hljs-comment"># 可以看到这里可以选择类型，默认情况下是普通的 file 类型，也就是本地文件的形式进行注册配置</span><br><span class="hljs-comment"># 支持的类型如下，对应的类型在下面都有对应的配置</span><br><span class="hljs-comment">  # file 、nacos 、eureka、redis、zk、consul、etcd 3、sofa</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><span class="hljs-comment"># 采用 nacos 方式会将 seata 服务端也注册到 nacos 中，这样客户端就可以利用服务发现自动找到 seata 服务</span><br><span class="hljs-comment"># 就不需要我们手动指定 IP 和端口了，不过看似方便，坑倒是不少，后面再说</span><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 应用名称，这里默认就行</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;seata-server&quot;</span><br><span class="hljs-comment">    # Nacos 服务器地址</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost: 8848&quot;</span><br><span class="hljs-comment">    # 这里使用的是 SEATA_GROUP 组，一会注册到 Nacos 中就是这个组</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br><span class="hljs-comment">    # 这里就使用我们上面单独为 seata 配置的命名空间，注意填的是 ID</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;89 fc 2145-4676-48 b 8-9 edd-29 e 867879 bcb&quot;</span><br><span class="hljs-comment">    # 集群名称，这里还是使用 default</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-comment">    # Nacos 的用户名和密码</span><br>    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-comment">  #...</span><br></code></pre></td></tr></table></figure><p>注册信息配置完成之后，接着我们需要将配置文件也放到 Nacos 中，让 Nacos 管理配置，这样我们就可以对配置进行热更新了，一旦环境需要变化，只需要直接在 Nacos 中修改即可。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">config</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment"># 这里我们也使用 nacos</span><br><span class="hljs-comment">  # file、nacos 、apollo、zk、consul、etcd 3</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  # 跟上面一样的配法</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8848&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;89 fc 2145-4676-48 b 8-9 edd-29 e 867879 bcb&quot;</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br>    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><span class="hljs-comment">    # 这个不用改，默认就行</span><br>    <span class="hljs-attr">dataId</span> = <span class="hljs-string">&quot;seataServer. properties&quot;</span><br>  <span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p>接着，我们需要将配置导入到 Nacos 中，我们打开一开始下载的源码<code>script/config-center/nacos</code>目录，这是官方提供的上传脚本，我们直接运行即可（windows 下没对应的 bat 就很蛋疼，可以使用 git 命令行来运行一下），这里我们使用这个可交互的版本：<br><img src="https://s2.loli.net/2023/03/06/1tPwBFn7u3ScCeY.png" alt="image-20230306233500474"><br>按照提示输入就可以了，不输入就使用的默认值，不知道为啥最新版本有四个因为参数过长还导入失败了，就离谱，不过不影响。<br>导入成功之后，可以在对应的命名空间下看到对应的配置（为啥非要一个一个配置项单独搞，就不能写一起吗）：<br><img src="https://s2.loli.net/2023/03/06/8yTQGZluYVe1cg2.png" alt="image-20230306233510973"><br>注意，还没完，我们还需要将对应的事务组映射配置也添加上，DataId 格式为<code>service. vgroupMapping. 事务组名称</code>，比如我们就使用默认的名称，值全部依然使用 default 即可：<br><img src="https://s2.loli.net/2023/03/06/UBchb4zPjHAfCSs.png" alt="image-20230306233521002"><br>现在我们就完成了服务端的 Nacos 配置，接着我们需要对客户端也进行 Nacos 配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br><span class="hljs-comment"># 注册</span><br>  <span class="hljs-attr">registry:</span><br>  <span class="hljs-comment"># 使用 Nacos</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>    <span class="hljs-comment"># 使用 Seata 的命名空间，这样才能正确找到 Seata 服务，由于组使用的是 SEATA_GROUP，配置默认值就是，就不用配了</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-number">89</span> <span class="hljs-string">fc</span> <span class="hljs-number">2145</span><span class="hljs-number">-4676</span><span class="hljs-number">-48</span> <span class="hljs-string">b</span> <span class="hljs-number">8</span><span class="hljs-number">-9</span> <span class="hljs-string">edd-29</span> <span class="hljs-string">e</span> <span class="hljs-number">867879</span> <span class="hljs-string">bcb</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-comment"># 配置</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-number">89</span> <span class="hljs-string">fc</span> <span class="hljs-number">2145</span><span class="hljs-number">-4676</span><span class="hljs-number">-48</span> <span class="hljs-string">b</span> <span class="hljs-number">8</span><span class="hljs-number">-9</span> <span class="hljs-string">edd-29</span> <span class="hljs-string">e</span> <span class="hljs-number">867879</span> <span class="hljs-string">bcb</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br></code></pre></td></tr></table></figure><p>现在我们就可以启动这三个服务了，可以在 Nacos 中看到 Seata 以及三个服务都正常注册了：<br><img src="https://s2.loli.net/2023/03/06/PSbw5TFhm74Wu3n.png" alt="image-20230306233529255"><br><img src="https://s2.loli.net/2023/03/06/nZUcuM2kJ86zgBv.png" alt="image-20230306233538630"><br>接着我们就可以访问一下服务试试看了：<br><img src="https://s2.loli.net/2023/03/06/Fn3R2Jrq1YyleCh.png" alt="image-20230306233545257"><br>可以看到效果和上面是一样的，不过现在我们的注册和配置都继承在 Nacos 中进行了。<br>我们还可以配置一下事务会话信息的存储方式，默认是 file 类型，那么就会在运行目录下创建<code>file_store</code>目录，我们可以将其搬到数据库中存储，只需要修改一下配置即可：<br><img src="https://s2.loli.net/2023/03/06/Cph9zPF2kaSvKdY.png" alt="image-20230306233553931"><br>将<code>store. session. mode</code>和<code>store. mode</code>的值修改为<code>db</code><br>接着我们对数据库信息进行一下配置：</p><ul><li>数据库驱动</li><li>数据库 URL</li><li>数据库用户名密码<br>其他的默认即可：<br><img src="https://s2.loli.net/2023/03/06/dlmYNnARZaxJ5MH.png" alt="image-20230306233612224"><br>接着我们需要将对应的数据库进行创建，创建 seata 数据库，然后直接 CV 以下语句：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span><br><span class="hljs-comment">-- the table to store GlobalSession data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `global_table`<br>(<br>    `xid`                       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `transaction_id`            <span class="hljs-type">BIGINT</span>,<br>    `status`                    TINYINT      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `application_id`            <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>    `transaction_service_group` <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>    `transaction_name`          <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>),<br>    `timeout`                   <span class="hljs-type">INT</span>,<br>    `begin_time`                <span class="hljs-type">BIGINT</span>,<br>    `application_data`          <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">2000</span>),<br>    `gmt_create`                DATETIME,<br>    `gmt_modified`              DATETIME,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`xid`),<br>    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),<br>    KEY `idx_transaction_id` (`transaction_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-comment">-- the table to store BranchSession data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `branch_table`<br>(<br>    `branch_id`         <span class="hljs-type">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `xid`               <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `transaction_id`    <span class="hljs-type">BIGINT</span>,<br>    `resource_group_id` <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>    `resource_id`       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">256</span>),<br>    `branch_type`       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">8</span>),<br>    `status`            TINYINT,<br>    `client_id`         <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">64</span>),<br>    `application_data`  <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">2000</span>),<br>    `gmt_create`        DATETIME (<span class="hljs-number">6</span>),<br>    `gmt_modified`      DATETIME (<span class="hljs-number">6</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`branch_id`),<br>    KEY `idx_xid` (`xid`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-comment">-- the table to store lock data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `lock_table`<br>(<br>    `row_key`        <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `xid`            <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>),<br>    `transaction_id` <span class="hljs-type">BIGINT</span>,<br>    `branch_id`      <span class="hljs-type">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `resource_id`    <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">256</span>),<br>    `table_name`     <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>    `pk`             <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">36</span>),<br>    `status`         TINYINT      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;0: locked ,1: rollbacking&#x27;</span>,<br>    `gmt_create`     DATETIME,<br>    `gmt_modified`   DATETIME,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`row_key`),<br>    KEY `idx_status` (`status`),<br>    KEY `idx_branch_id` (`branch_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `distributed_lock`<br>(<br>    `lock_key`       <span class="hljs-type">CHAR</span> (<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `lock_value`     <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `expire`         <span class="hljs-type">BIGINT</span>,<br>    <span class="hljs-keyword">primary</span> key (`lock_key`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;HandleAllSession&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/03/06/7zvewSLhFmbc8G1.png" alt="image-20230306233627086"><br>完成之后，重启 Seata 服务端即可：<br><img src="https://s2.loli.net/2023/03/06/G7qQoEy8DCX9bLJ.png" alt="image-20230306233752098"><br>看到了数据源初始化成功，现在已经在使用数据库进行会话存储了。<br>如果 Seata 服务端出现报错，可能是我们自定义事务组的名称太长了：<br><img src="https://s2.loli.net/2023/03/06/qoNhgzM2PXpZU9B.png" alt="image-20230306233933641"><br>将<code>globle_table</code>表的字段<code>transaction_server_group</code>长度适当增加一下即可：<br><img src="https://s2.loli.net/2023/03/06/9LnaoUxHzlY1GdV.png" alt="image-20230306233940850"><br>到此，关于基于 nacos 模式下的 Seata 部署，就完成了。<br>虽然我们这里实现了分布式事务，但是还是给各位同学提出一个问题（可以把自己所认为的结果打在弹幕上），就我们目前这样的程序设计，在高并发下，真的安全吗？比如同一时间 100 个同学抢同一个书，但是我们知道同一个书就只有 3 本，如果这时真的同时来了 100 个请求要借书，会正常地只借出 3 本书吗？如果不正常，该如何处理？</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://itbaima.net/<br>title: &quot;柏码 - 让每一行代码都闪耀智慧的光芒！&quot;<br>host: itbaima.net<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><p><a href="https://itbaima.net/">柏码 - 让每一行代码都闪耀智慧的光芒！</a></p>]]></content>
    
    
    <summary type="html">一些关于springcloud alibaba微服务框架中间件的学习记录。</summary>
    
    
    
    <category term="前后端开发" scheme="https://alleyf.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="springcloud" scheme="https://alleyf.github.io/tags/springcloud/"/>
    
    <category term="SpringCloud-Alibaba" scheme="https://alleyf.github.io/tags/SpringCloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud-微服务基础</title>
    <link href="https://alleyf.github.io/2023/11/d5e126511000.html"/>
    <id>https://alleyf.github.io/2023/11/d5e126511000.html</id>
    <published>2023-11-14T01:49:45.000Z</published>
    <updated>2023-11-16T07:39:35.771Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><h1 id="微服务基础"><a href="#微服务基础" class="headerlink" title="微服务基础"></a>微服务基础</h1><p><img src="https://s2.loli.net/2023/03/06/XeofrwYMN5GQnlC.png" alt="image-20230306225143443"></p><p>通过使用SpringBoot框架，我们的项目开发速度可以说是得到了质的提升。同时，我们对于项目的维护和理解，也会更加的轻松。可见，SpringBoot为我们的开发带来了巨大便捷。而这一部分，我们将基于SpringBoot，继续深入到企业实际场景，探讨微服务架构下的SpringCloud。这个部分我们会更加注重于架构设计上的讲解，弱化实现原理方面的研究。</p><h2 id="传统项目转型"><a href="#传统项目转型" class="headerlink" title="传统项目转型"></a>传统项目转型</h2><p>要说近几年最火热的话题，那还得是微服务，那么什么是微服务呢？</p><p>我们可以先从技术的演变开始看起，在我们学习JavaWeb之后，一般的网站开发模式为Servlet+JSP，但是实际上我们在学习了SSM之后，会发现这种模式已经远远落后了，第一，一个公司不可能去招那么多同时会前端+后端的开发人员，就算招到，也并不一定能保证两个方面都比较擅长，相比前后端分开学习的开发人员，显然后者的学习成本更低，专注度更高。因此前后端分离成为了一种新的趋势。通过使用SpringBoot，我们几乎可以很快速地开发一个高性能的单体应用，只需要启动一个服务端，我们整个项目就开始运行了，各项功能融于一体，开发起来也更加轻松。</p><p>但是随着我们项目的不断扩大，单体应用似乎显得有点乏力了。</p><p>随着越来越多的功能不断地加入到一个SpringBoot项目中，随着接口不断增加，整个系统就要在同一时间内响应更多类型的请求，显然，这种扩展方式是不可能无限使用下去的，总有一天，这个SpringBoot项目会庞大到运行缓慢。并且所有的功能如果都集成在单端上，那么所有的请求都会全部汇集到一台服务器上，对此服务器造成巨大压力。</p><p>可以试想一下，如果我们的电脑已经升级到i9-12900K，但是依然在运行项目的时候缓慢，无法同一时间响应成千上万的请求，那么这个问题就已经不是单纯升级机器配置可以解决的了。</p><p><img src="https://s2.loli.net/2023/03/06/dk931jubHw6KifZ.png" alt="image-20230306225152523"></p><p>传统单体架构应用随着项目规模的扩大，实际上会暴露越来越多的问题，尤其是一台服务器无法承受庞大的单体应用部署，并且单体应用的维护也会越来越困难，我们得寻找一种新的开发架构来解决这些问题了。</p><blockquote><p> In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.</p></blockquote><p>Martin Fowler在2014年提出了“微服务”架构，它是一种全新的架构风格。</p><ul><li>微服务把一个庞大的单体应用拆分为一个个的小型服务，比如我们原来的图书管理项目中，有登录、注册、添加、删除、搜索等功能，那么我们可以将这些功能单独做成一个个小型的SpringBoot项目，独立运行。</li><li>每个小型的微服务，都可以独立部署和升级，这样，就算整个系统崩溃，那么也只会影响一个服务的运行。</li><li>微服务之间使用HTTP进行数据交互，不再是单体应用内部交互了，虽然这样会显得更麻烦，但是带来的好处也是很直接的，甚至能突破语言限制，使用不同的编程语言进行微服务开发，只需要使用HTTP进行数据交互即可。</li><li>我们可以同时购买多台主机来分别部署这些微服务，这样，单机的压力就被分散到多台机器，并且每台机器的配置不一定需要太高，这样就能节省大量的成本，同时安全性也得到很大的保证。</li><li>甚至同一个微服务可以同时存在多个，这样当其中一个服务器出现问题时，其他服务器也在运行同样的微服务，这样就可以保证一个微服务的高可用。</li></ul><p><img src="https://s2.loli.net/2023/03/06/xSAhFqJUfmoa1Pv.png" alt="image-20230306225204783"></p><p>当然，这里只是简单的演示一下微服务架构，实际开发中肯定是比这个复杂得多的。</p><p>可见，采用微服务架构，更加能够应对当今时代下的种种考验，传统项目的开发模式，需要进行架构上的升级。</p><h2 id="走进SpringCloud"><a href="#走进SpringCloud" class="headerlink" title="走进SpringCloud"></a>走进SpringCloud</h2><p>前面我们介绍了微服务架构的优点，那么同样的，这些优点的背后也存在着诸多的问题：</p><ul><li>要实现微服务并不是说只需要简单地将项目进行拆分，我们还需要考虑对各个微服务进行管理、监控等，这样我们才能够及时地寻找和排查问题。因此微服务往往需要的是一整套解决方案，包括服务注册和发现、容灾处理、负载均衡、配置管理等。</li><li>它不像单体架构那种方便维护，由于部署在多个服务器，我们不得不去保证各个微服务能够稳定运行，在管理难度上肯定是高于传统单体应用的。</li><li>在分布式的环境下，单体应用的某些功能可能会变得比较麻烦，比如分布式事务。</li></ul><p>所以，为了更好地解决这些问题，SpringCloud正式登场。</p><p>SpringCloud是Spring提供的一套分布式解决方案，集合了一些大型互联网公司的开源产品，包括诸多组件，共同组成SpringCloud框架。并且，它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、熔断机制、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p><p>由于中小型公司没有独立开发自己的分布式基础设施的能力，使用SpringCloud解决方案能够以最低的成本应对当前时代的业务发展。</p><p><img src="https://s2.loli.net/2023/03/06/1ulvL5q4PpbcoGD.png" alt="image-20230306225221575"></p><p>可以看到，SpringCloud整体架构的亮点是非常明显的，分布式架构下的各个场景，都有对应的组件来处理，比如基于Netflix（奈飞）的开源分布式解决方案提供的组件：</p><ul><li>Eureka  -  实现服务治理（服务注册与发现），我们可以对所有的微服务进行集中管理，包括他们的运行状态、信息等。</li><li>Ribbon  -  为服务之间相互调用提供负载均衡算法（现在被SpringCloudLoadBalancer取代）</li><li>Hystrix  -  断路器，保护系统，控制故障范围。暂时可以跟家里电闸的保险丝类比，当触电危险发生时能够防止进一步的发展。</li><li>Zuul   -     api网关，路由，负载均衡等多种作用，就像我们的路由器，可能有很多个设备都连接了路由器，但是数据包要转发给谁则是由路由器在进行（已经被SpringCloudGateway取代）</li><li>Config  -  配置管理，可以实现配置文件集中管理</li></ul><p>那么首先，我们就从注册中心开始说起。</p><hr><h2 id="Eureka-注册中心"><a href="#Eureka-注册中心" class="headerlink" title="Eureka 注册中心"></a>Eureka 注册中心</h2><p>官方文档：<a href="https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/">https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/</a></p><h3 id="微服务项目结构"><a href="#微服务项目结构" class="headerlink" title="微服务项目结构"></a>微服务项目结构</h3><p>现在我们重新设计一下之前的图书管理系统项目，将原有的大型（也许 项目进行拆分，注意项目拆分一定要尽可能保证单一职责，相同的业务不要在多个微服务中重复出现，如果出现需要借助其他业务完成的服务，那么可以使用服务之间相互调用的形式来实现（之后会介绍）：</p><ul><li>登录验证服务：用于处理用户注册、登录、密码重置等，反正就是一切与账户相关的内容，包括用户信息获取等。</li><li>图书管理服务：用于进行图书添加、删除、更新等操作，图书管理相关的服务，包括图书的存储等和信息获取。</li><li>图书借阅服务：交互性比较强的服务，需要和登陆验证服务和图书管理服务进行交互。</li></ul><p>那么既然要将单体应用拆分为多个小型服务，我们就需要重新设计一下整个项目目录结构，这里我们就创建多个子项目，每一个子项目都是一个服务，这样由父项目统一管理依赖，就无需每个子项目都去单独管理依赖了，也更方便一点。</p><p>我们首先创建一个普通的SpringBoot项目：</p><p><img src="https://s2.loli.net/2023/03/06/8qH2jhtfvacbXMw.png" alt="image-20230306225233822"></p><p>然后不需要勾选任何依赖，直接创建即可，项目创建完成并初始化后，我们删除父工程的无用文件，只保留必要文件，像下面这样：</p><p><img src="https://s2.loli.net/2023/03/06/DobOruSEf3PKYyI.png" alt="image-20230306225244561"></p><p>接着我们就可以按照我们划分的服务，进行子工程创建了，创建一个新的Maven项目，注意父项目要指定为我们一开始创建的的项目，子项目命名随意：</p><p><img src="https://s2.loli.net/2023/03/06/mFvb6c34pILHfn7.png" alt="image-20230306225255693"></p><p>子项目创建好之后，接着我们在子项目中创建SpringBoot的启动主类：</p><p><img src="https://s2.loli.net/2023/03/06/fo4FYOqe3vxSAZc.png" alt="image-20230306225306775"></p><p>接着我们点击运行，即可启动子项目了，实际上这个子项目就一个最简单的SpringBoot web项目，注意启动之后最下方有弹窗，我们点击”使用 服务”，这样我们就可以实时查看当前整个大项目中有哪些微服务了：</p><p><img src="https://s2.loli.net/2023/03/06/gf4iAMnUwvjR2WX.png" alt="image-20230306225317877"></p><p><img src="https://s2.loli.net/2023/03/06/C1jah7NwT4GgJdX.png" alt="image-20230306225325584"></p><p>接着我们以同样的方法，创建其他的子项目，注意我们最好将其他子项目的端口设置得不一样，不然会导致端口占用，我们分别为它们创建<code>application.yml</code>文件：</p><p><img src="https://s2.loli.net/2023/03/06/E9x27lSeOfMhrHt.png" alt="image-20230306225335990"></p><p>接着我们来尝试启动一下这三个服务，正常情况下都是可以直接启动的：</p><p><img src="https://s2.loli.net/2023/03/06/nM4ld9jyKzVT3Y5.png" alt="image-20230306225345323"></p><p>可以看到它们分别运行在不同的端口上，这样，就方便不同的程序员编写不同的服务了，提交当前项目代码时的冲突率也会降低。</p><p>接着我们来创建一下数据库，这里还是老样子，创建三个表即可，当然实际上每个微服务单独使用一个数据库服务器也是可以的，因为按照单一职责服务只会操作自己对应的表，这里UP主比较穷，就只用一个数据库演示了：</p><p><img src="https://s2.loli.net/2023/03/06/YewLSsGbTj8aykE.png" alt="image-20230306225353141"></p><p><img src="https://s2.loli.net/2023/03/06/KcRX57MGWVLlNqT.png" alt="image-20230306225402384"></p><p><img src="https://s2.loli.net/2023/03/06/cgdON43mxRDk9Hv.png" alt="image-20230306225416144"></p><p><img src="https://s2.loli.net/2023/03/06/XjmGn3DbqVKk6Cd.png" alt="image-20230306225422365"></p><p>创建好之后，结果如下，一共三张表，各位可以自行添加一些数据到里面，这就不贴出来了：</p><p><img src="https://s2.loli.net/2023/03/06/ac76NjHY5byeknP.png" alt="image-20230306225436945"></p><p>如果各位嫌麻烦的话可以下载<code>.sql</code>文件自行导入。</p><p>接着我们来稍微写一点业务，比如用户信息查询业务，我们先把数据库相关的依赖进行导入，这里依然使用Mybatis框架，首先在父项目中添加MySQL驱动和Lombok依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于不是所有的子项目都需要用到Mybatis，我们在父项目中只进行版本管理即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们就可以在用户服务子项目中添加此依赖了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着添加数据源信息（UP用到是阿里云的MySQL云数据库，各位注意修改一下数据库地址）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://cloudstudy.mysql.cn-chengdu.rds.aliyuncs.com:3306/cloudstudy</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>接着我们来写用户查询相关的业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> uid;<br>    String name;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from DB_USER where uid = #&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserById(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserService service;<br><br>    <span class="hljs-comment">//这里以RESTFul风格为例</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserById(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们访问即可拿到数据：</p><p><img src="https://s2.loli.net/2023/03/06/SC9MUQxdzPmcZij.png" alt="image-20230306225457095"></p><p>同样的方式，我们完成一下图书查询业务，注意现在是在图书管理微服务中编写（别忘了导入Mybatis依赖以及配置数据源）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-type">int</span> bid;<br>    String title;<br>    String desc;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookMapper</span> &#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from DB_BOOK where bid = #&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookService</span> &#123;<br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getBookById(bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">findBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getBookById(bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样进行一下测试：</p><p><img src="https://s2.loli.net/2023/03/06/x9ZOvniJcSp5Cf7.png" alt="image-20230306225506718"></p><p>这样，我们一个完整项目的就拆分成了多个微服务，不同微服务之间是独立进行开发和部署的。</p><h3 id="服务间调用"><a href="#服务间调用" class="headerlink" title="服务间调用"></a>服务间调用</h3><p>前面我们完成了用户信息查询和图书信息查询，现在我们来接着完成借阅服务。</p><p>借阅服务是一个关联性比较强的服务，它不仅仅需要查询借阅信息，同时可能还需要获取借阅信息下的详细信息，比如具体那个用户借阅了哪本书，并且用户和书籍的详情也需要同时出现，那么这种情况下，我们就需要去访问除了借阅表以外的用户表和图书表。</p><p><img src="https://s2.loli.net/2023/03/06/T3zKfpqmYkD9VxI.png" alt="image-20230306225518527"></p><p>但是这显然是违反我们之前所说的单一职责的，相同的业务功能不应该重复出现，但是现在由需要在此服务中查询用户的信息和图书信息，那怎么办呢？我们可以让一个服务去调用另一个服务来获取信息。</p><p><img src="https://s2.loli.net/2023/03/06/jBtM2k7CFZsu4cU.png" alt="image-20230306225530398"></p><p>这样，图书管理微服务和用户管理微服务相对于借阅记录，就形成了一个生产者和消费者的关系，前者是生产者，后者便是消费者。</p><p>现在我们先将借阅关联信息查询完善了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Borrow</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> uid;<br>    <span class="hljs-type">int</span> bid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BorrowMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from DB_BORROW where uid = #&#123;uid&#125;&quot;)</span><br>    List&lt;Borrow&gt; <span class="hljs-title function_">getBorrowsByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from DB_BORROW where bid = #&#123;bid&#125;&quot;)</span><br>    List&lt;Borrow&gt; <span class="hljs-title function_">getBorrowsByBid</span><span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from DB_BORROW where bid = #&#123;bid&#125; and uid = #&#123;uid&#125;&quot;)</span><br>    Borrow <span class="hljs-title function_">getBorrow</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有一个需求，需要查询用户的借阅详细信息，也就是说需要查询某个用户具体借了那些书，并且需要此用户的信息和所有已借阅的书籍信息一起返回，那么我们先来设计一下返回实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBorrowDetail</span> &#123;<br>    User user;<br>    List&lt;Book&gt; bookList;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有一个问题，我们发现User和Book实体实际上是在另外两个微服务中定义的，相当于当前项目并没有定义这些实体类，那么怎么解决呢？</p><p>因此，我们可以将所有服务需要用到的实体类单独放入另一个一个项目中，然后让这些项目引用集中存放实体类的那个项目，这样就可以保证每个微服务的实体类信息都可以共用了：</p><p><img src="https://s2.loli.net/2023/03/06/QbfRFayHmqpLVdE.png" alt="image-20230306225543154"></p><p>然后只需要在对应的类中引用此项目作为依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后新的公共实体类都可以在<code>commons</code>项目中进行定义了，现在我们接着来完成刚刚的需求，先定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BorrowService</span> &#123;<br><br>    UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-comment">//那么问题来了，现在拿到借阅关联信息了，怎么调用其他服务获取信息呢？</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要进行服务远程调用我们需要用到<code>RestTemplate</code>来进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-comment">//RestTemplate支持多种方式的远程调用</span><br>        <span class="hljs-type">RestTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>        <span class="hljs-comment">//这里通过调用getForObject来请求其他服务，并将结果自动进行封装</span><br>        <span class="hljs-comment">//获取User信息</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://localhost:8082/user/&quot;</span>+uid, User.class);<br>        <span class="hljs-comment">//获取每一本书的详细信息</span><br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; template.getForObject(<span class="hljs-string">&quot;http://localhost:8080/book/&quot;</span>+b.getBid(), Book.class))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们再最后完善一下Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在数据库中添加一点借阅信息，测试看看能不能正常获取（注意一定要保证三个服务都处于开启状态，否则远程调用会失败）：</p><p><img src="https://s2.loli.net/2023/03/06/OPw5XMghApNrWKe.png" alt="image-20230306225555557"></p><p>可以看到，结果正常，没有问题，远程调用成功。</p><p>这样，一个简易的图书管理系统的分布式项目就搭建完成了，<strong>这里记得把整个项目压缩打包备份一下</strong>，下一章学习SpringCloud Alibaba也需要进行配置。</p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>前面我们了解了如何对单体应用进行拆分，并且也学习了如何进行服务之间的相互调用，但是存在一个问题，就是虽然服务拆分完成，但是没有一个比较合理的管理机制，如果单纯只是这样编写，在部署和维护起来，肯定是很麻烦的。可以想象一下，如果某一天这些微服务的端口或是地址大规模地发生改变，我们就不得不将服务之间的调用路径大规模的同步进行修改，这是多么可怕的事情。我们需要削弱这种服务之间的强关联性，因此我们需要一个集中管理微服务的平台，这时就要借助我们这一部分的主角了。</p><p>Eureka能够自动注册并发现微服务，然后对服务的状态、信息进行集中管理，这样当我们需要获取其他服务的信息时，我们只需要向Eureka进行查询就可以了。</p><p><img src="https://s2.loli.net/2023/03/06/A2mxhZ5jBkPrOdc.png" alt="image-20230306225607857"></p><p>像这样的话，服务之间的强关联性就会被进一步削弱。</p><p>那么现在我们就来搭建一个Eureka服务器，只需要创建一个新的Maven项目即可，然后我们需要在<strong>父工程中添加一下SpringCloud的依赖管理</strong>，这里选用<code>2021.0.1</code>版本（Spring Cloud 最新的版本命名方式变更了，现在是 <em><strong>YEAR.x</strong></em> 这种命名方式，具体可以在官网查看：<a href="https://spring.io/projects/spring-cloud#learn">https://spring.io/projects/spring-cloud#learn</a>）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们为新创建的项目添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下载内容有点多，首次导入请耐心等待一下。</p><p>接着我们来创建主类，还是一样的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EurekaServerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(EurekaServerApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别着急启动！！！接着我们需要修改一下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span><br><span class="hljs-attr">eureka:</span><br><span class="hljs-comment"># 开启之前需要修改一下客户端设置（虽然是服务端</span><br>  <span class="hljs-attr">client:</span><br>  <span class="hljs-comment"># 由于我们是作为服务端角色，所以不需要获取服务端，改为false，默认为true</span><br><span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 暂时不需要将自己也注册到Eureka</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 将eureka服务端指向自己</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8888/eureka</span><br></code></pre></td></tr></table></figure><p>好了，现在差不多可以启动了，启动完成后，直接输入地址+端口即可访问Eureka的管理后台：</p><p><img src="https://s2.loli.net/2023/03/06/4S9e3gN6ZFTuPbU.png" alt="image-20230306225619725"></p><p>可以看到目前还没有任何的服务注册到Eureka，我们接着来配置一下我们的三个微服务，首先还是需要<strong>导入Eureka依赖</strong>（注意别导错了，名称里面有个starter的才是）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>  <span class="hljs-comment"># 跟上面一样，需要指向Eureka服务端地址，这样才能进行注册</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8888/eureka</span><br></code></pre></td></tr></table></figure><p>OK，无需在启动类添加注解，直接启动就可以了，然后打开Eureka的服务管理页面，可以看到我们刚刚开启的服务：</p><p><img src="https://s2.loli.net/2023/03/06/rXnWBA1zo4OlUSt.png" alt="image-20230306225630173"></p><p>可以看到<code>8082</code>端口上的服务器，已经成功注册到Eureka了，但是这个服务名称怎么会显示为UNKNOWN，我们需要修改一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/06/1o8pmzBXCtixhKu.png" alt="image-20230306225638109"></p><blockquote><p>[!NOTE] Tips<br>application的<strong>name不能大写字母，用小写</strong>。</p></blockquote><p>当我们的服务启动之后，会每隔一段时间跟Eureka发送一次心跳包，这样Eureka就能够感知到我们的服务是否处于正常运行状态。</p><p>现在我们用同样的方法，将另外两个微服务也注册进来：</p><p><img src="https://s2.loli.net/2023/03/06/gkenG9bT4aMIUio.png" alt="image-20230306225648063"></p><p>那么，现在我们<strong>怎么实现服务发现</strong>呢？</p><p>也就是说，我们之前如果需要对其他微服务进行远程调用，那么就必须要知道其他服务的地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://localhost:8082/user/&quot;</span>+uid, User.class);<br></code></pre></td></tr></table></figure><p>而现在有了Eureka之后，我们可以直接向其进行查询，得到对应的微服务地址，这里直接将服务名称替换即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    RestTemplate template;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br><br>        <span class="hljs-comment">//这里不用再写IP，直接写服务名称userservice</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://userservice/user/&quot;</span>+uid, User.class);<br>        <span class="hljs-comment">//这里不用再写IP，直接写服务名称bookservice</span><br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; template.getForObject(<span class="hljs-string">&quot;http://bookservice/book/&quot;</span>+b.getBid(), Book.class))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们手动将RestTemplate声明为一个Bean，然后添加<code>@LoadBalanced</code>注解，这样Eureka就会对服务的调用进行自动发现，<strong>并提供负载均衡</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    RestTemplate <span class="hljs-title function_">template</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以正常调用了：</p><p><img src="https://s2.loli.net/2023/03/06/1SHLTwmIK4ChdaD.png" alt="image-20230306225713484"></p><p>不对啊，不是说有负载均衡的能力吗，怎么个<strong>负载均衡</strong>呢？</p><p>我们先来看看，同一个服务器实际上是可以注册很多个的，但是它们的端口不同，比如我们这里创建多个用户查询服务，我们现在将原有的端口配置修改一下，由IDEA中设定启动参数来决定，这样就可以多创建几个不同端口的启动项了：</p><p><img src="https://s2.loli.net/2023/03/06/ZzmGK4CuSwLVhva.png" alt="image-20230306225723916"></p><p><img src="https://s2.loli.net/2023/03/06/9lPAbiYntQDGNzy.png" alt="image-20230306225741406"></p><p>可以看到，在Eureka中，同一个服务出现了两个实例：</p><p><img src="https://s2.loli.net/2023/03/06/eXGS3wdvL4RAys6.png" alt="image-20230306225750928"></p><p>现在我们稍微修改一下用户查询，然后进行远程调用，看看请求是不是均匀地分配到这两个服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserService service;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我被调用拉！&quot;</span>);<br>        <span class="hljs-keyword">return</span> service.getUserById(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/06/BlRf7T5iVMksb1J.png" alt="image-20230306225801442"></p><p>可以看到，两个实例都能够均匀地被分配请求：</p><p><img src="https://s2.loli.net/2023/03/06/hysYFAeoLrnRWdX.png" alt="image-20230306225808889"></p><p><img src="https://s2.loli.net/2023/03/06/nDpXICZHc4L5EQm.png" alt="image-20230306225818918"></p><p>这样，服务自动发现以及简单的负载均衡就实现完成了，并且，如果某个微服务挂掉了，只要存在其他同样的微服务实例在运行，那么就不会导致整个微服务不可用，极大地保证了安全性。</p><h3 id="注册中心高可用"><a href="#注册中心高可用" class="headerlink" title="注册中心高可用"></a>注册中心高可用</h3><p>各位可否想过这样的一个问题？虽然Eureka能够实现服务注册和发现，但是如果Eureka服务器崩溃了，岂不是所有需要用到服务发现的微服务就GG了？</p><p>为了避免，这种问题，我们也可以像上面那样，搭建Eureka集群，存在多个Eureka服务器，这样就算挂掉其中一个，其他的也还在正常运行，就不会使得服务注册与发现不可用。当然，要是物理黑客直接炸了整个机房，那还是算了吧。</p><p><img src="https://s2.loli.net/2023/03/06/21izKlaCO9oNuYq.png" alt="image-20230306225832945"></p><p>我们来看看如何搭建Eureka集群，这里由于机器配置不高，就搭建两个Eureka服务器组成集群。</p><p>首先我们需要修改一下Eureka服务端的配置文件，这里我们创建两个配置文件，：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8801</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eurekaserver</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>  <span class="hljs-comment"># 由于不支持多个localhost的Eureka服务器，但是又只有本地测试环境，所以就只能自定义主机名称了</span><br>  <span class="hljs-comment"># 主机名称改为eureka01</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka01</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 去掉register-with-eureka选项，让Eureka服务器自己注册到其他Eureka服务器，这样才能相互启用</span><br>    <span class="hljs-attr">service-url:</span><br>    <span class="hljs-comment"># 注意这里填写其他Eureka服务器的地址，不用写自己的</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka02:8802/eureka</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8802</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eurekaserver</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka02</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka01:8801/eureka</span><br></code></pre></td></tr></table></figure><p>这里由于我们修改成自定义的地址，需要在hosts文件中将其解析到172.0.0.1才能回到localhost，Mac下文件路径为<code>/etc/hosts</code>，Windows下为<code>C:\Windows\system32\drivers\etc\hosts</code>：</p><p><img src="https://s2.loli.net/2023/03/06/aGdiPjeRIOfHo7p.png" alt="image-20230306225844111"></p><p>对创建的两个配置文件分别添加启动配置，直接使用<code>spring.profiles.active</code>指定启用的配置文件即可：</p><p><img src="https://s2.loli.net/2023/03/06/WYhxpSvsFU8tVcR.png" alt="image-20230306225853705"></p><p>接着启动这两个注册中心，这两个Eureka管理页面都可以被访问，我们访问其中一个：</p><p><img src="https://s2.loli.net/2023/03/06/fbGgz2dRq43DM8O.png" alt="image-20230306225903831"></p><p><img src="https://s2.loli.net/2023/03/06/nmD6H1BZbr7LYWC.png" alt="image-20230306225916507"></p><p>可以看到下方<code>replicas</code>中已经包含了另一个Eureka服务器的地址，并且是可用状态。</p><p>接着我们需要将我们的微服务配置也进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>    <span class="hljs-comment"># 将两个Eureka的地址都加入，这样就算有一个Eureka挂掉，也能完成注册</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8801/eureka,</span> <span class="hljs-string">http://localhost:8802/eureka</span><br></code></pre></td></tr></table></figure><p>可以看到，服务全部成功注册，并且两个Eureka服务端都显示为已注册：</p><p><img src="https://s2.loli.net/2023/03/06/GDd5BVMTY1t4oQj.png" alt="image-20230306225928923"></p><p>接着我们模拟一下，<strong>将其中一个Eureka服务器关闭掉，可以看到它会直接变成不可用状态</strong>：</p><p><img src="https://s2.loli.net/2023/03/06/8fdxB1PlqVYDRLr.png" alt="image-20230306225938085"></p><p>当然，如果这个时候我们<strong>重启刚刚关闭的Eureka服务器，会自动同步其他Eureka服务器的数据</strong>。</p><hr><h2 id="LoadBalancer-负载均衡"><a href="#LoadBalancer-负载均衡" class="headerlink" title="LoadBalancer 负载均衡"></a>LoadBalancer 负载均衡</h2><p>前面我们讲解了如何对服务进行拆分、如何通过Eureka服务器进行服务注册与发现，那么现在我们来看看，它的负载均衡到底是如何实现的，实际上之前演示的负载均衡是依靠LoadBalancer实现的。</p><p>在2020年前的SpringCloud版本是采用Ribbon作为负载均衡实现，但是2020年的版本之后SpringCloud把Ribbon移除了，进而用自己编写的LoadBalancer替代。</p><p>那么，负载均衡是如何进行的呢？</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>实际上，在添加<code>@LoadBalanced</code>注解之后，会启用拦截器对我们发起的服务调用请求进行拦截（注意这里是针对我们发起的请求进行拦截），叫做<code>LoadBalancerInterceptor</code>，它实现<code>ClientHttpRequestInterceptor</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClientHttpRequestInterceptor</span> &#123;<br>    ClientHttpResponse <span class="hljs-title function_">intercept</span><span class="hljs-params">(HttpRequest request, <span class="hljs-type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是对<code>intercept</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] body, <span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">URI</span> <span class="hljs-variable">originalUri</span> <span class="hljs-operator">=</span> request.getURI();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> originalUri.getHost();<br>    Assert.state(serviceName != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Request URI does not contain a valid hostname: &quot;</span> + originalUri);<br>    <span class="hljs-keyword">return</span> (ClientHttpResponse)<span class="hljs-built_in">this</span>.loadBalancer.execute(serviceName, <span class="hljs-built_in">this</span>.requestFactory.createRequest(request, body, execution));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以打个断点看看实际是怎么在执行的，可以看到：</p><p><img src="https://s2.loli.net/2023/03/06/Qri3UYvIJ7M5KAn.png" alt="image-20230306225949475"></p><p><img src="https://s2.loli.net/2023/03/06/9tBwL1aVHT4MzmI.png" alt="image-20230306230000711"></p><p>服务端会在发起请求时执行这些拦截器。</p><p>那么这个拦截器做了什么事情呢，首先我们要明确，我们给过来的请求地址，并不是一个有效的主机名称，而是服务名称，那么怎么才能得到真正需要访问的主机名称呢，肯定是得找Eureka获取的。</p><p>我们来看看<code>loadBalancer.execute()</code>做了什么，它的具体实现为<code>BlockingLoadBalancerClient</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从上面给进来了服务的名称和具体的请求实体</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">hint</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getHint(serviceId);<br>    LoadBalancerRequestAdapter&lt;T, DefaultRequestContext&gt; lbRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerRequestAdapter</span>(request, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRequestContext</span>(request, hint));<br>    Set&lt;LoadBalancerLifecycle&gt; supportedLifecycleProcessors = <span class="hljs-built_in">this</span>.getSupportedLifecycleProcessors(serviceId);<br>    supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;<br>        lifecycle.onStart(lbRequest);<br>    &#125;);<br>  <span class="hljs-comment">//可以看到在这里会调用choose方法自动获取对应的服务实例信息</span><br>    <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.choose(serviceId, lbRequest);<br>    <span class="hljs-keyword">if</span> (serviceInstance == <span class="hljs-literal">null</span>) &#123;<br>        supportedLifecycleProcessors.forEach((lifecycle) -&gt; &#123;<br>            lifecycle.onComplete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionContext</span>(Status.DISCARD, lbRequest, <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyResponse</span>()));<br>        &#125;);<br>      <span class="hljs-comment">//没有发现任何此服务的实例就抛异常（之前的测试中可能已经遇到了）</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No instances available for &quot;</span> + serviceId);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//成功获取到对应服务的实例，这时就可以发起HTTP请求获取信息了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.execute(serviceId, serviceInstance, lbRequest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，实际上在进行负载均衡的时候，会向Eureka发起请求，选择一个可用的对应服务，然后会返回此服务的主机地址等信息：</p><p><img src="https://s2.loli.net/2023/03/06/zQnj7bcygYJNP1s.png" alt="image-20230306230014040"></p><h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><p>LoadBalancer默认提供了两种负载均衡策略：</p><ul><li>RandomLoadBalancer  -  随机分配策略</li><li><strong>(默认)</strong> RoundRobinLoadBalancer  -  轮询分配策略</li></ul><p>现在我们希望修改默认的负载均衡策略，可以进行指定，比如我们现在希望用户服务采用随机分配策略，我们需要先创建随机分配策略的配置类（不用加<code>@Configuration</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerConfig</span> &#123;<br>  <span class="hljs-comment">//将官方提供的 RandomLoadBalancer 注册为Bean</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">randomLoadBalancer</span><span class="hljs-params">(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要为对应的服务指定负载均衡策略，直接使用注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@LoadBalancerClient(value = &quot;userservice&quot;,      //指定为 userservice 服务，只要是调用此服务都会使用我们指定的策略</span><br><span class="hljs-meta">                    configuration = LoadBalancerConfig.class)</span>   <span class="hljs-comment">//指定我们刚刚定义好的配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    RestTemplate <span class="hljs-title function_">template</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在<code>BlockingLoadBalancerClient</code>中添加断点，观察是否采用我们指定的策略进行请求：</p><p><img src="https://s2.loli.net/2023/03/06/k7p5xmoALuwU82s.png" alt="image-20230306230030016"></p><p><img src="https://s2.loli.net/2023/03/06/KJMa6Ehp8k5SfIy.png" alt="image-20230306230040677"></p><p>发现访问userservice服务的策略已经更改为我们指定的策略了。</p><h3 id="OpenFeign实现负载均衡"><a href="#OpenFeign实现负载均衡" class="headerlink" title="OpenFeign实现负载均衡"></a>OpenFeign实现负载均衡</h3><p>官方文档：<a href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/">https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/</a></p><p>Feign和RestTemplate一样，也是HTTP客户端请求工具，但是它的使用方式更加便捷。首先是依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着在启动类添加<code>@EnableFeignClients</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BorrowApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在我们需要调用其他微服务提供的接口，该怎么做呢？我们直接创建一个对应服务的接口类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span>   <span class="hljs-comment">//声明为userservice服务的HTTP请求客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们直接创建所需类型的方法，比如我们之前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RestTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.getForObject(<span class="hljs-string">&quot;http://userservice/user/&quot;</span>+uid, User.class);<br></code></pre></td></tr></table></figure><p>现在可以直接写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br><br>  <span class="hljs-comment">//路径保证和其他微服务提供的一致即可</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;  <span class="hljs-comment">//参数和返回值也保持一致</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] Tips<br>如果被调用的服务的接口添加了统一的 <code>RequestMapping</code> 地址，则要在 <code>xxxClient</code> 接口方法上<strong>提供完整的路径</strong>。</p></blockquote><p>接着我们直接注入使用（有Mybatis那味了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>UserClient userClient;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>    List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>    <br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>    <span class="hljs-comment">//这里不用再写IP，直接写服务名称bookservice</span><br>    List&lt;Book&gt; bookList = borrow<br>            .stream()<br>            .map(b -&gt; template.getForObject(<span class="hljs-string">&quot;http://bookservice/book/&quot;</span>+b.getBid(), Book.class))<br>            .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>&#125;<br></code></pre></td></tr></table></figure><p>访问，可以看到结果依然是正确的：</p><p><img src="https://s2.loli.net/2023/03/06/koMOYnxtq8UPiac.png" alt="image-20230306230054245"></p><p>并且我们可以观察一下两个用户微服务的调用情况，也是以负载均衡的形式进行的。</p><p>按照同样的方法，我们接着将图书管理服务的调用也改成接口形式：</p><p><img src="https://s2.loli.net/2023/03/06/GiBa7FzQsvkIpdS.png" alt="image-20230306230101467"></p><p>最后我们的Service代码就变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; bookClient.getBookById(b.getBid()))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续访问进行测试：</p><p><img src="https://s2.loli.net/2023/03/06/V5fhk2xLo8bXmWA.png" alt="image-20230306230112322"></p><p>OK，正常。</p><p>当然，Feign也有很多的其他配置选项，这里就不多做介绍了，详细请查阅官方文档。</p><hr><h2 id="Hystrix-服务熔断"><a href="#Hystrix-服务熔断" class="headerlink" title="Hystrix 服务熔断"></a>Hystrix 服务熔断</h2><p>官方文档：<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.5.RELEASE/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients">https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/1.3.5.RELEASE/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients</a></p><p>我们知道，微服务之间是可以进行相互调用的，那么如果出现了下面的情况会导致什么问题？</p><p><img src="https://s2.loli.net/2023/03/06/dUvO3K8oWMZSVHr.png" alt="image-20230306230121344"></p><p>由于位于最底端的服务提供者E发生故障，那么此时会直接导致服务ABCD全线崩溃，就像雪崩了一样。</p><p><img src="https://s2.loli.net/2023/03/06/dDMylZ5ejKoxAVF.png" alt="image-20230306230128050"></p><p>这种问题实际上是不可避免的，由于多种因素，比如网络卡顿、系统故障、硬件问题等，都存在一定可能，会导致这种极端的情况发生。因此，我们需要寻找一个应对这种极端情况的解决方案。</p><p>为了解决分布式系统的雪崩问题，SpringCloud提供了Hystrix熔断器组件，他就像我们家中的保险丝一样，当电流过载就会直接熔断，防止危险进一步发生，从而保证家庭用电安全。可以想象一下，如果整条链路上的服务已经全线崩溃，这时还在不断地有大量的请求到达，需要各个服务进行处理，肯定是会使得情况越来越糟糕的。</p><p>我们来详细看看它的工作机制。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>首先我们来看看服务降级，注意一定要区分开服务降级和服务熔断的区别，服务降级并不会直接返回错误，而是可以提供一个补救措施，正常响应给请求者。这样相当于服务依然可用，但是服务能力肯定是下降了的。</p><p>我们就基于借阅管理服务来进行讲解，我们不开启用户服务和图书服务，表示用户服务和图书服务已经挂掉了。</p><p>这里我们导入Hystrix的依赖（此项目已经停止维护，SpringCloud依赖中已经不自带了，所以说需要自己单独导入）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们需要在启动类添加注解开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableHystrix</span>   <span class="hljs-comment">//启用Hystrix</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(BorrowApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在，由于用户服务和图书服务不可用，所以查询借阅信息的请求肯定是没办法正常响应的，这时我们可以提供一个备选方案，也就是说当服务出现异常时，返回我们的备选方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;onError&quot;)</span>    <span class="hljs-comment">//使用@HystrixCommand来指定备选方案</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br><br>  <span class="hljs-comment">//备选方案，这里直接返回空列表了</span><br>  <span class="hljs-comment">//注意参数和返回值要和上面的一致</span><br>    UserBorrowDetail <span class="hljs-title function_">onError</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(<span class="hljs-literal">null</span>, Collections.emptyList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，虽然我们的服务无法正常运行了，但是依然可以给浏览器正常返回响应数据：</p><p><img src="https://s2.loli.net/2023/03/06/dRqf87xMFgsO4hL.png" alt="image-20230306230144106"></p><p><img src="https://s2.loli.net/2023/03/06/x6Qy3SbkVLYRD4P.png" alt="image-20230306230151243"></p><p>服务降级是一种比较温柔的解决方案，虽然服务本身的不可用，但是能够保证正常响应数据。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当检测出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。当检测到该节点微服务响应正常后恢复调用链路。</p><p>实际上，熔断就是在降级的基础上进一步升级形成的，也就是说，在一段时间内多次调用失败，那么就直接升级为熔断。</p><p>我们可以添加两条输出语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;onError&quot;)</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;开始向其他服务获取信息&quot;</span>);<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br><br>    UserBorrowDetail <span class="hljs-title function_">onError</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务错误，进入备选方法！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(<span class="hljs-literal">null</span>, Collections.emptyList());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们在浏览器中疯狂点击刷新按钮，对此服务疯狂发起请求，可以看到后台：</p><p><img src="https://s2.loli.net/2023/03/06/TLtsu51w6jlNnzJ.png" alt="image-20230306230205508"></p><p>一开始的时候，会正常地去调用Controller对应的方法<code>findUserBorrows</code>，发现失败然后进入备选方法，但是我们发现在持续请求一段时间之后，没有再调用这个方法，而是直接调用备选方案，这便是升级到了熔断状态。</p><p>我们可以继续不断点击，继续不断地发起请求：</p><p><img src="https://s2.loli.net/2023/03/06/ZtQ4nz8hPvHBIRC.png" alt="image-20230306230223193"></p><p>可以看到，过了一段时间之后，会尝试正常执行一次<code>findUserBorrows</code>，但是依然是失败状态，所以继续保持熔断状态。</p><p>所以得到结论，它能够对一段时间内出现的错误进行侦测，当侦测到出错次数过多时，熔断器会打开，所有的请求会直接响应失败，一段时间后，只执行一定数量的请求，如果还是出现错误，那么则继续保持打开状态，否则说明服务恢复正常运行，关闭熔断器。</p><p>我们可以测试一下，开启另外两个服务之后，继续点击：</p><p><img src="https://s2.loli.net/2023/03/06/E6z2t5ZqxlKAjSB.png" alt="image-20230306230235955"></p><p>可以看到，当另外两个服务正常运行之后，当再次尝试调用<code>findUserBorrows</code>之后会成功，于是熔断机制就关闭了，服务恢复运行。</p><p>总结一下：</p><p><img src="https://s2.loli.net/2023/03/06/3oiHLFWO9jVpswK.png" alt="image-20230306230247024"></p><h3 id="OpenFeign实现降级"><a href="#OpenFeign实现降级" class="headerlink" title="OpenFeign实现降级"></a>OpenFeign实现降级</h3><p>Hystrix也可以配合Feign进行降级，我们可以对应接口中定义的远程调用单独进行降级操作。</p><p>比如我们还是以用户服务挂掉为例，那么这个时候肯定是会远程调用失败的，也就是说我们的Controller中的方法在执行过程中会直接抛出异常，进而被Hystrix监控到并进行服务降级。</p><p>而实际上导致方法执行异常的根源就是远程调用失败，所以我们换个思路，既然用户服务调用失败，那么我就给这个远程调用添加一个替代方案，如果此远程调用失败，那么就直接上替代方案。那么怎么实现替代方案呢？我们知道Feign都是以接口的形式来声明远程调用，那么既然远程调用已经失效，我们就自行对其进行实现，创建一个实现类，对原有的接口方法进行替代方案实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>   <span class="hljs-comment">//注意，需要将其注册为Bean，Feign才能自动注入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFallbackClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserClient</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;   <span class="hljs-comment">//这里我们自行对其进行实现，并返回我们的替代方案</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;我是替代方案&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现完成后，我们只需要在原有的接口中指定失败替代实现即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//fallback参数指定为我们刚刚编写的实现类</span><br><span class="hljs-meta">@FeignClient(value = &quot;userservice&quot;, fallback = UserFallbackClient.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在去掉<code>BorrowController</code>的<code>@HystrixCommand</code>注解和备选方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span><br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid(uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在配置文件中<strong>开启熔断支持</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">circuitbreaker:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>启动服务，调用接口试试看：</p><p><img src="https://s2.loli.net/2023/03/06/bieclsNmpqOrdHB.png" alt="image-20230306230301021"></p><p><img src="https://s2.loli.net/2023/03/06/3dn7AlkYGJCmUxw.png" alt="image-20230306230310524"></p><p>可以看到，现在已经采用我们的替代方案作为结果。</p><h3 id="监控页面部署"><a href="#监控页面部署" class="headerlink" title="监控页面部署"></a>监控页面部署</h3><p>除了对服务的降级和熔断处理，我们也可以对其进行<strong>实时监控</strong>，只需要安装监控页面即可，这里我们创建一个新的项目，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着添加配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8900</span><br><span class="hljs-attr">hystrix:</span><br>  <span class="hljs-attr">dashboard:</span><br>    <span class="hljs-comment"># 将localhost添加到白名单，默认是不允许的</span><br>    <span class="hljs-attr">proxy-stream-allow-list:</span> <span class="hljs-string">&quot;localhost&quot;</span><br></code></pre></td></tr></table></figure><p>接着创建主类，注意需要添加<code>@EnableHystrixDashboard</code>注解开启管理页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableHystrixDashboard</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HystrixDashBoardApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(HystrixDashBoardApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动Hystrix管理页面服务，然后我们需要在要进行监控的服务中添加Actuator依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Actuator是SpringBoot程序的监控系统，可以实现健康检查，记录信息等。在使用之前需要引入spring-boot-starter-actuator，并做简单的配置即可。</p></blockquote><p>添加此依赖后，我们可以在IDEA中查看运行情况：</p><p><img src="https://s2.loli.net/2023/03/06/a8XmyswEbW1TrtA.png" alt="image-20230306230322560"></p><p>然后在配置文件中配置Actuator添加暴露：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure><p>接着我们打开刚刚启动的管理页面，地址为：<a href="http://localhost:8900/hystrix/">http://localhost:8900/hystrix/</a></p><p><img src="https://s2.loli.net/2023/03/06/5rbCxLtR1e8DZAu.png" alt="image-20230306230335020"></p><p>在中间填写要监控的服务：比如借阅服务：<a href="http://localhost:8301/actuator/hystrix.stream%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%90%8E%E9%9D%A2%E8%A6%81%E6%B7%BB%E5%8A%A0%60/actuator/hystrix.stream%60%EF%BC%8C%E7%84%B6%E5%90%8E%E7%82%B9%E5%87%BBMonitor">http://localhost:8301/actuator/hystrix.stream，注意后面要添加`/actuator/hystrix.stream`，然后点击Monitor</a> Stream即可进入监控页面：</p><p><img src="https://s2.loli.net/2023/03/06/iRT6cva5jfd7JSK.png" alt="image-20230306230345666"></p><p>可以看到现在都是Loading状态，这是因为还没有开始统计，我们现在尝试调用几次我们的服务：</p><p><img src="https://s2.loli.net/2023/03/06/evLyDl8gVxboiap.png" alt="image-20230306230355084"></p><p>可以看到，在调用之后，监控页面出现了信息：</p><p><img src="https://s2.loli.net/2023/03/06/UtcOjEfdnMGQ7ge.png" alt="image-20230306230402987"></p><p>可以看到5次访问都是正常的，所以显示为绿色，接着我们来尝试将图书服务关闭，这样就会导致服务降级甚至熔断，然后再多次访问此服务看看监控会如何变化：</p><p><img src="https://s2.loli.net/2023/03/06/97by1FDirquwtv2.png" alt="image-20230306230414273"></p><p>可以看到，错误率直接飙升到100%，并且一段时间内持续出现错误，中心的圆圈也变成了红色，我们继续进行访问：</p><p><img src="https://s2.loli.net/2023/03/06/mrVf1qSsDXioIBc.png" alt="image-20230306230501543"></p><p>在出现大量错误的情况下保持持续访问，可以看到此时已经将服务熔断，<code>Circuit</code>更改为 <code>Open</code> 状态，并且图中的圆圈也变得更大，表示压力在持续上升。</p><hr><h2 id="Gateway-路由网关"><a href="#Gateway-路由网关" class="headerlink" title="Gateway 路由网关"></a>Gateway 路由网关</h2><p>官网地址：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/</a></p><p>我们家里的路由器充当的是一个什么角色呢？</p><p>我们知道，如果我们需要连接互联网，那么就需要将手机或是电脑连接到家里的路由器才可以，而路由器则连接光猫，光猫再通过光纤连接到互联网，也就是说，互联网方向发送过来的数据，需要经过路由器才能到达我们的设备。而路由器充当的就是数据包中转站，所有的局域网设备都无法直接与互联网连接，而是需要经过路由器进行中转，我们一般说路由器下的网络是内网，而互联网那一端是外网。</p><p><img src="https://s2.loli.net/2023/03/06/YF5VbcRAz8ZG6nJ.png" alt="image-20230306230515898"></p><p>我们的局域网设备，无法被互联网上的其他设备直接访问，肯定是能够保证到安全性的。并互联网发送过来的数据，需要经过路由器进行解析，识别到底是哪一个设备的数据包，然后再发送给对应的设备。</p><p>而我们的微服务也是这样，一般情况下，可能并不是所有的微服务都需要直接暴露给外部调用，这时我们就可以使用路由机制，添加一层防护，让所有的请求全部通过路由来转发到各个微服务，并且转发给多个相同微服务实例也可以实现负载均衡。</p><p><img src="https://s2.loli.net/2023/03/06/gMwst5OGfvPCTd8.png" alt="image-20230306230524100"></p><p>在之前，路由的实现一般使用Zuul，但是已经停更，而现在新出现了由SpringCloud官方开发的Gateway路由，它相比Zuul不仅性能上得到了一定的提升，并且是官方推出，契合性也会更好，所以我们这里就主要讲解Gateway。</p><h3 id="部署网关"><a href="#部署网关" class="headerlink" title="部署网关"></a>部署网关</h3><p>现在我们来创建一个新的项目，作为我们的网关，这里需要添加两个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一个依赖就是网关的依赖，而第二个则跟其他微服务一样，需要注册到Eureka才能生效，注意别添加Web依赖，使用的是WebFlux框架。</p><p>然后我们来完善一下配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8500</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8801/eureka,</span> <span class="hljs-string">http://localhost:8802/eureka</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br></code></pre></td></tr></table></figure><p>现在就可以启动了：</p><p><img src="https://s2.loli.net/2023/03/06/4puUrkIMBlx3emn.png" alt="image-20230306230532720"></p><p>但是现在还没有配置任何的路由功能，我们接着将路由功能进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>    <span class="hljs-comment"># 配置路由，注意这里是个列表，每一项都包含了很多信息</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">borrow-service</span>   <span class="hljs-comment"># 路由名称</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://borrowservice</span>  <span class="hljs-comment"># 路由的地址，lb表示使用负载均衡到微服务，也可以使用http正常转发</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由规则，断言什么请求会被路由</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/borrow/**</span>  <span class="hljs-comment"># 只要是访问的这个路径，一律都被路由到上面指定的服务</span><br></code></pre></td></tr></table></figure><p>路由规则的详细列表（断言工厂列表）在这里：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories</a>，可以指定多种类型，包括指定时间段、Cookie携带情况、Header携带情况、访问的域名地址、访问的方法、路径、参数、访问者IP等。也可以使用配置类进行配置，但是还是推荐直接配置文件，省事。</p><blockquote><p>[!NOTE] Tips<br><code>Path</code> 要填写<strong>完整的api路径</strong>包括统一的 <code>RequestMapping</code> 路径。</p></blockquote><p>接着启动网关，搭载Arm架构芯片的Mac电脑可能会遇到这个问题：</p><p><img src="https://s2.loli.net/2023/03/06/IuoAzPmXnYHSDv3.png" alt="image-20230306230542772"></p><p>这是因为没有找到适用于此架构的动态链接库，不影响使用，无视即可，希望以后的版本能修复吧。</p><p>可以看到，我们现在可以直接通过路由来访问我们的服务了：</p><p><img src="https://s2.loli.net/2023/03/06/vOl9w4apbQSVAWH.png" alt="image-20230306230551480"></p><p>注意此时依然可以通过原有的服务地址进行访问：</p><p><img src="https://s2.loli.net/2023/03/06/y8KA1UR6tFMj5ch.png" alt="image-20230306230600243"></p><p>这样我们就可以将不需要外网直接访问的微服务全部放到内网环境下，而只依靠网关来对外进行交涉。</p><h3 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h3><p>路由过滤器支持以某种方式修改传入的 HTTP 请求或传出的 HTTP 响应，路由过滤器的范围是某一个路由，跟之前的断言一样，Spring Cloud Gateway 也包含许多内置的路由过滤器工厂，详细列表：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories</a></p><p>比如我们现在希望在请求到达时，在请求头中添加一些信息再转发给我们的服务，那么这个时候就可以使用路由过滤器来完成，我们只需要对配置文件进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">borrow-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://borrowservice</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/borrow/**</span><br>      <span class="hljs-comment"># 继续添加新的路由配置，这里就以书籍管理服务为例</span><br>      <span class="hljs-comment"># 注意-要对齐routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">book-service</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://bookservice</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/book/**</span><br>        <span class="hljs-attr">filters:</span>   <span class="hljs-comment"># 添加过滤器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=Test,</span> <span class="hljs-string">HelloWorld!</span><br>        <span class="hljs-comment"># AddRequestHeader 就是添加请求头信息，其他工厂请查阅官网</span><br></code></pre></td></tr></table></figure><p>接着我们在BookController中获取并输出一下，看看是不是成功添加了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    BookService service;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">findBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid,</span><br><span class="hljs-params">                      HttpServletRequest request)</span>&#123;<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;Test&quot;</span>));<br>        <span class="hljs-keyword">return</span> service.getBookById(bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们通过Gateway访问我们的图书管理服务：</p><p><img src="https://s2.loli.net/2023/03/06/oUf2VFXmrQHiz6C.png" alt="image-20230306230612435"></p><p><img src="https://s2.loli.net/2023/03/06/x3YjDRZfqBQ1TSC.png" alt="image-20230306230621114"></p><p>可以看到这里成功获取到由网关添加的请求头信息了。</p><p>除了针对于某一个路由配置过滤器之外，我们也可以<strong>自定义全局过滤器</strong>，它能够<strong>作用于全局</strong>。但是我们需要通过代码的方式进行编写，比如我们要实现拦截没有携带指定请求参数的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>   <span class="hljs-comment">//需要注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;   <span class="hljs-comment">//只需要实现此方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们编写判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>    <span class="hljs-comment">//先获取ServerHttpRequest对象，注意不是HttpServletRequest</span><br>    <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>    <span class="hljs-comment">//打印一下所有的请求参数</span><br>    System.out.println(request.getQueryParams());<br>    <span class="hljs-comment">//判断是否包含test参数，且参数值为1</span><br>    List&lt;String&gt; value = request.getQueryParams().get(<span class="hljs-string">&quot;test&quot;</span>);<br>    <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span> &amp;&amp; value.contains(<span class="hljs-string">&quot;1&quot;</span>)) &#123;<br>        <span class="hljs-comment">//将ServerWebExchange向过滤链的下一级传递（跟JavaWeb中介绍的过滤器其实是差不多的）</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//直接在这里不再向下传递，然后返回响应</span><br>        <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到结果：</p><p><img src="https://s2.loli.net/2023/03/06/P8ZFIuNardMKvQB.png" alt="image-20230306230634856"></p><p><img src="https://s2.loli.net/2023/03/06/bkd3BCsDxvYNPoX.png" alt="image-20230306230645619"></p><p>成功实现规则判断和拦截操作。</p><p>当然，过滤器肯定是可以存在很多个的，所以我们可以手动指定过滤器之间的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;   <span class="hljs-comment">//实现Ordered接口</span><br>  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>注意 <code>Order</code> 的值<strong>越小优先级越高</strong>，并且无论是在配置文件中编写的单个路由过滤器还是全局路由过滤器，都会受到Order值影响（单个路由的过滤器Order值按<strong>从上往下的顺序从1开始递增</strong>），最终是按照Order值决定哪个过滤器优先执行，当<strong>Order值一样</strong>时 <em>全局路由过滤器</em>执行 <code>优于</code> <em>单独的路由过滤器</em>执行。</p><hr><h2 id="Config-配置中心"><a href="#Config-配置中心" class="headerlink" title="Config 配置中心"></a>Config 配置中心</h2><p>官方文档：<a href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/">https://docs.spring.io/spring-cloud-config/docs/current/reference/html/</a></p><p>经过前面的学习，我们对于一个分布式应用的技术选型和搭建已经了解得比较多了，但是各位有没有发现一个问题，如果我们的微服务项目需要部署很多个实例，那么配置文件我们岂不是得一个一个去改，可能十几个实例还好，要是有几十个上百个呢？那我们一个一个去配置，岂不直接猝死在工位上。</p><p>所以，我们需要一种更加高级的集中化地配置文件管理工具，集中地对配置文件进行配置。</p><blockquote><p>Spring Cloud Config 为分布式系统中的外部配置提供服务器端和客户端支持。使用 Config Server，您可以集中管理所有环境中应用程序的外部配置。</p></blockquote><p><img src="https://s2.loli.net/2023/03/06/Pe3bs6OVMgjR7iu.png" alt="image-20230306230655437"></p><p>实际上Spring Cloud Config就是一个配置中心，所有的服务都可以从配置中心取出配置，而配置中心又可以从GitHub远程仓库中获取云端的配置文件，这样我们只需要修改GitHub中的配置即可对所有的服务进行配置管理了。</p><h3 id="部署配置中心"><a href="#部署配置中心" class="headerlink" title="部署配置中心"></a>部署配置中心</h3><p>这里我们接着创建一个新的项目，并导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>老规矩，启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ConfigApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8700</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">configserver</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8801/eureka,</span> <span class="hljs-string">http://localhost:8802/eureka</span><br></code></pre></td></tr></table></figure><p>先启动一次看看，能不能成功：</p><p><img src="https://s2.loli.net/2023/03/06/9TdormfJkgK258q.png" alt="image-20230306230706452"></p><p>这里我们以本地仓库为例（就不用GitHub了，卡到怀疑人生了），首先在项目目录下创建一个本地Git仓库，打开终端，在桌面上创建一个新的本地仓库：</p><p><img src="https://s2.loli.net/2023/03/06/EIFUo5rVvd4Nc3C.png" alt="image-20230306230726846"></p><p>然后我们在文件夹中随便创建一些配置文件，注意名称最好是{服务名称}-{环境}.yml：</p><p><img src="https://s2.loli.net/2023/03/06/3AO4XzashuPwlRI.png" alt="image-20230306230735629"></p><p>然后我们在配置文件中，添加本地仓库的一些信息（远程仓库同理），详细使用教程：<a href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_git_backend">https://docs.spring.io/spring-cloud-config/docs/current/reference/html/#_git_backend</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">server:</span><br>        <span class="hljs-attr">git:</span><br>        <span class="hljs-comment"># 这里填写的是本地仓库地址，远程仓库直接填写远程仓库地址 http://git...</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">file://$&#123;user.home&#125;/Desktop/config-repo</span><br>          <span class="hljs-comment"># 默认分支设定为你自己本地或是远程分支的名称</span><br>          <span class="hljs-attr">default-label:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>然后启动我们的配置服务器，通过以下格式进行访问：</p><ul><li><a href="http://localhost:8700/%7B%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%7D/%7B%E7%8E%AF%E5%A2%83%7D/%7BGit%E5%88%86%E6%94%AF%7D">http://localhost:8700/{服务名称}/{环境}/{Git分支}</a></li><li><a href="http://localhost:8700/%7BGit%E5%88%86%E6%94%AF%7D/%7B%E6%9C%8D%E5%8A%A1%E5%90%8D%E7%A7%B0%7D-%7B%E7%8E%AF%E5%A2%83%7D.yml">http://localhost:8700/{Git分支}/{服务名称}-{环境}.yml</a></li></ul><p>比如我们要访问图书服务的生产环境代码，可以使用 <a href="http://localhost:8700/bookservice/prod/main">http://localhost:8700/bookservice/prod/main</a> 链接，它会显示详细信息：</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311161450859.png" alt="image.png|650"></p><p>也可以使用 <a href="http://localhost:8700/main/bookservice-prod.yml">http://localhost:8700/main/bookservice-prod.yml</a> 链接，它仅显示配置文件原文：</p><p><img src="https://s2.loli.net/2023/03/06/kUAMsjZaTbHiG9X.png" alt="image-20230306230755591"></p><p>当然，除了使用Git来保存之外，还支持一些其他的方式，详细情况请查阅官网。</p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>服务端配置完成之后，我们接着来配置一下客户端，那么现在我们的服务既然需要从服务器读取配置文件，那么就需要进行一些配置，我们删除原来的<code>application.yml</code>文件（也可以保留，最后无论是远端配置还是本地配置都会被加载），改用<code>bootstrap.yml</code>（在application.yml之前加载，可以实现配置文件远程获取）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>    <span class="hljs-comment"># 名称，其实就是文件名称</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">bookservice</span><br>      <span class="hljs-comment"># 配置服务器的地址</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8700</span><br>      <span class="hljs-comment"># 环境</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">prod</span><br>      <span class="hljs-comment"># 分支</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>配置完成之后，启动图书服务：</p><p><img src="https://s2.loli.net/2023/03/06/7VaosxbqtRm5X4i.png" alt="image-20230306230806269"></p><p>可以看到已经从远端获取到了配置，并进行启动。</p><hr><h2 id="微服务CAP原则"><a href="#微服务CAP原则" class="headerlink" title="微服务CAP原则"></a>微服务CAP原则</h2><p>经过前面的学习，我们对SpringCloud Netflix以及SpringCloud官方整个生态下的组件认识也差不多了，入门教学就到此为止，下一章将开启真正精彩的正片部分，本章的最后我们还是来了解一些理论上的知识。</p><p><img src="https://s2.loli.net/2023/03/06/9k6oeMZIE28T3t7.png" alt="image-20230306230815241"></p><blockquote><p>CAP原则又称CAP定理，指的是在一个分布式系统中，存在Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性），三者不可同时保证，最多只能保证其中的两者。   </p><p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻都是同样的值（所有的节点无论何时访问都能拿到最新的值）</p><p>可用性（A）：系统中非故障节点收到的每个请求都必须得到响应（比如我们之前使用的服务降级和熔断，其实就是一种维持可用性的措施，虽然服务返回的是没有什么意义的数据，但是不至于用户的请求会被服务器忽略）</p><p>分区容错性（P）：一个分布式系统里面，节点之间组成的网络本来应该是连通的，然而可能因为一些故障（比如网络丢包等，这是很难避免的），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中（这样就可能出现某些被分区节点存放的数据访问失败，我们需要来容忍这些不可靠的情况）</p></blockquote><p>总的来说，数据存放的节点数越多，分区容忍性就越高，但是要复制更新的次数就越多，一致性就越难保证。同时为了保证一致性，更新所有节点数据所需要的时间就越长，那么可用性就会降低。</p><p>所以说，只能存在以下三种方案：</p><h3 id="AC-可用性-一致性"><a href="#AC-可用性-一致性" class="headerlink" title="AC 可用性+一致性"></a>AC 可用性+一致性</h3><p>要同时保证可用性和一致性，代表着某个节点数据更新之后，需要立即将结果通知给其他节点，并且要尽可能的快，这样才能及时响应保证可用性，这就对网络的稳定性要求非常高，但是实际情况下，网络很容易出现丢包等情况，并不是一个可靠的传输，如果需要避免这种问题，就只能将节点全部放在一起，但是这显然违背了分布式系统的概念，所以对于我们的分布式系统来说，很难接受。</p><h3 id="CP-一致性-分区容错性"><a href="#CP-一致性-分区容错性" class="headerlink" title="CP 一致性+分区容错性"></a>CP 一致性+分区容错性</h3><p>为了保证一致性，那么就得将某个节点的最新数据发送给其他节点，并且需要等到所有节点都得到数据才能进行响应，同时有了分区容错性，那么代表我们可以容忍网络的不可靠问题，所以就算网络出现卡顿，那么也必须等待所有节点完成数据同步，才能进行响应，因此就会导致服务在一段时间内完全失效，所以可用性是无法得到保证的。</p><h3 id="AP-可用性-分区容错性"><a href="#AP-可用性-分区容错性" class="headerlink" title="AP 可用性+分区容错性"></a>AP 可用性+分区容错性</h3><p>既然CP可能会导致一段时间内服务得不到任何响应，那么要保证可用性，就只能放弃节点之间数据的高度统一，也就是说可以在数据不统一的情况下，进行响应，因此就无法保证一致性了。虽然这样会导致拿不到最新的数据，但是只要数据同步操作在后台继续运行，一定能够在某一时刻完成所有节点数据的同步，那么就能实现<strong>最终一致性</strong>，所以AP实际上是最能接受的一种方案。</p><p>比如我们实现的Eureka集群，它使用的就是AP方案，Eureka各个节点都是平等的，少数节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka客户端在向某个Eureka服务端注册时如果发现连接失败，则会自动切换至其他节点。只要有一台Eureka服务器正常运行，那么就能保证服务可用（A）<strong>，只不过查询到的信息可能不是最新的</strong>（C）</p><h1 id="细节要点"><a href="#细节要点" class="headerlink" title="细节要点"></a>细节要点</h1><ol><li>分模块开发时，不同模块<strong>存在依赖的实体、工具类</strong>等，将其抽取出来放到一个<em>公共模块（commons）</em> 里，哪里需要用就<strong>将该模块作为依赖导入配置文件</strong>中即可。</li><li><strong>添加全参构造后也要添加无参构造</strong>，因为<strong>默认不添加时是有无参构造</strong>的，否则容易后续发生问题。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://itbaima.net/<br>title: &quot;柏码 - 让每一行代码都闪耀智慧的光芒！&quot;<br>host: itbaima.net<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><p><a href="https://itbaima.net/">柏码 - 让每一行代码都闪耀智慧的光芒！</a></p>]]></content>
    
    
    <summary type="html">some notes related with springcloud learning。</summary>
    
    
    
    <category term="前后端开发" scheme="https://alleyf.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="springcloud" scheme="https://alleyf.github.io/tags/springcloud/"/>
    
    <category term="微服务" scheme="https://alleyf.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Paper_Reading_Method</title>
    <link href="https://alleyf.github.io/2023/11/53a88a28555b.html"/>
    <id>https://alleyf.github.io/2023/11/53a88a28555b.html</id>
    <published>2023-11-13T15:40:30.000Z</published>
    <updated>2023-11-18T14:24:23.415Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><h2 id="1-论文主要有那些组成部分及其相应的作用？"><a href="#1-论文主要有那些组成部分及其相应的作用？" class="headerlink" title="1. 论文主要有那些组成部分及其相应的作用？"></a>1. 论文主要有那些组成部分及其相应的作用？</h2><ol><li>论文标题：所有工作的凝练总结</li><li>摘要：包括研究目的，研究方法，研究结果等关键信息</li><li>引言：领域重要性 (研究背景)，国内外研究现状，现存问题，提出的解决方法</li><li>方法论：解决问题所采用的具体实施的方法</li><li>结果：根据方法得到的结果</li><li>引用：文章中对别人文章内容的引用</li></ol><h2 id="2-哪些是重点需要阅读的？"><a href="#2-哪些是重点需要阅读的？" class="headerlink" title="2. 哪些是重点需要阅读的？"></a>2. 哪些是重点需要阅读的？</h2><ol><li>标题：提炼<strong>核心关键词</strong></li><li>摘要：提炼<strong>研究目的，研究方法，研究结果</strong>等</li><li>方法论：提炼<strong>具体解决思路、方法</strong></li><li>结果：提炼<strong>最终研究结果、未来改进和存在的缺陷</strong>等</li></ol><h2 id="3-什么时候泛读，什么时候精读，怎么读？"><a href="#3-什么时候泛读，什么时候精读，怎么读？" class="headerlink" title="3. 什么时候泛读，什么时候精读，怎么读？"></a>3. 什么时候泛读，什么时候精读，怎么读？</h2><blockquote><p>[!NOTE] 什么时候泛（精）读？</p><ol><li>确定课题前：对课题组的研究<strong>大方向相关领域</strong>的论文进行大范围泛读了解<strong>整个领域的研究进程和研究热点及趋势</strong></li><li>确定课题后：对确定的课题对应的<strong>细分研究领域</strong>的相关论文，选择<strong>引用高且较著名的论文进行精读汇报总结</strong></li></ol></blockquote><blockquote><p>[!NOTE] 怎么读？</p><ol><li><strong>泛读</strong>：重点阅读论文<strong>标题，摘要，方法论和结果</strong>，不需要完整通读全文，泛读的时间要求，中文或简单的英文，可能需要花10-15分钟阅读，记录和列表用15分钟；再复杂一点的中文文献，30分也就够了。</li><li><strong>精读</strong>：除了完成泛读的要求，还要<strong>了解研究背景、国内外发展现状、现存问题</strong>，并详细阅读<strong>具体实施方法</strong>，学习运用该方法，可以<strong>尝试复现</strong>对比实验结果，<strong>总结创新点并形成阅读报告</strong>。</li></ol></blockquote><h2 id="国内外研究现状写法"><a href="#国内外研究现状写法" class="headerlink" title="国内外研究现状写法"></a>国内外研究现状写法</h2><p><img src="https://pic1.zhimg.com/80/v2-2235bdaf4135920b8a5f09b67d56ae28_720w.webp"></p><blockquote><ol><li>当国内外学者都<strong>集中在某几个研究方向</strong>时适合采用<strong>关键内容法</strong>写法</li><li>当国内外学者<strong>研究方向都比较发散</strong>，<strong>方向众多</strong>时适合采用<strong>第一种</strong>写法</li></ol></blockquote><p>细分方向研究现状写法：</p><blockquote><p>针对几个主要学者的研究进行以下阐述：<br><em>xx学者采用xx研究方法，开展了xx研究，得到了xx研究成果，具有xx意义，但还存在xx问题。</em></p></blockquote>]]></content>
    
    
    <summary type="html">some keypoints about paperReading</summary>
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Paper" scheme="https://alleyf.github.io/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读模板(最好读英文原文)</title>
    <link href="https://alleyf.github.io/2023/11/fa4d17378db3.html"/>
    <id>https://alleyf.github.io/2023/11/fa4d17378db3.html</id>
    <published>2023-11-13T15:39:46.000Z</published>
    <updated>2023-11-14T02:40:56.963Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><h2 id="第一遍阅读，略读（5-10分钟）"><a href="#第一遍阅读，略读（5-10分钟）" class="headerlink" title="第一遍阅读，略读（5-10分钟）"></a>第一遍阅读，略读（5-10分钟）</h2><ol><li><p>读<strong>title, abstract, and introduction</strong>，并做记录</p><p> 此处填写</p></li><li><p>读 <strong>section 和 sub-section ​</strong>开头, 但是忽略其他</p><p> 此处填写</p></li><li><p>读 conclusions</p><p> 此处填写</p></li><li><p>浏览参考文献，圈出已经读过的和没读的</p><p> 此处填写</p></li><li><p>粗略总结阅读的内容</p><ol><li>这个文章是什么类型。</li><li>和什么其他文章相关？理论基础？</li><li>假设是否有效？</li><li>主要贡献？</li><li>是否写的有条理？</li></ol></li></ol><p>‍</p><hr><h2 id="第二遍阅读，细读但不读细节（1小时）"><a href="#第二遍阅读，细读但不读细节（1小时）" class="headerlink" title="第二遍阅读，细读但不读细节（1小时）"></a>第二遍阅读，细读但不读细节（1小时）</h2><ol><li><p>关注图表和结论，判断是否有读的价值</p></li><li><p>了解背景，必要的话补充相关知识</p><p> 此处填写</p></li><li><p>阅读文章核心点，理解<strong>观点、假设、方法、实验、结论</strong></p><p> 此处填写</p></li></ol><p>‍</p><hr><h2 id="第三遍细致阅读，并尝试复现论文（长时间）"><a href="#第三遍细致阅读，并尝试复现论文（长时间）" class="headerlink" title="第三遍细致阅读，并尝试复现论文（长时间）"></a>第三遍细致阅读，并尝试复现论文（长时间）</h2><ol><li><p>理论部分推导</p><p> 此处填写</p></li><li><p>实验复现或代码复现</p><p> 此处填写</p></li><li><p>对文章进行最后总结并保存相关内容</p><p> 此处填写</p><p> 链接</p></li></ol><blockquote></blockquote>]]></content>
    
    
    <summary type="html">some keypoints about paperReading</summary>
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Paper" scheme="https://alleyf.github.io/tags/Paper/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity</title>
    <link href="https://alleyf.github.io/2023/11/51775ce3788e.html"/>
    <id>https://alleyf.github.io/2023/11/51775ce3788e.html</id>
    <published>2023-11-13T15:37:51.000Z</published>
    <updated>2023-11-14T02:40:56.945Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><p>安全是开发者永远绕不开的话题，一个不安全的网站，往往存在着各种致命漏洞，只要被不法分子稍加利用，就能直接击溃整个网站，甚至破坏网站宝贵的用户数据。而用户的授权校验，则是网站安全系统的典型代表，这也是用户访问网站的第一关，我们需要一个更加安全和可靠的授权校验框架，才能让我们的网站更加稳定。</p><p>SpringSecurity是一个基于Spring开发的非常强大的权限验证框架，其核心功能包括：</p><ul><li>认证 （用户登录）</li><li>授权 （此用户能够做哪些事情）</li><li>攻击防护 （防止伪造身份攻击）</li></ul><h2 id="网络安全基础"><a href="#网络安全基础" class="headerlink" title="网络安全基础"></a>网络安全基础</h2><p>网络安全是当今互联网时代非常重要的一个议题。在信息爆炸的今天，网络安全问题频频发生，给个人和组织带来了严重的损失和威胁，随着技术的发展和互联网的普及，我们越来越意识到网络安全已经成为一个全球性的挑战。本部分，我们会给各位小伙伴介绍网络安全的相关概念，以及常见的Web服务器攻击形式，如果你已经了解相关内容，可以直接跳过本板块。</p><p>其中比较典型的案例有以下几个：</p><p><img src="https://s2.loli.net/2023/07/01/W3oCIbqvLUn492J.png" alt="image-20230701174518205"></p><p>在2017年，一款名叫WannaCry的勒索软件席卷全球，导致全球大量计算机受到影响，得益于全球网络的发达，这款病毒从小规模很快发展至全球范围，勒索病毒是自熊猫烧香以来影响力最大的病毒之一。</p><blockquote><p>WannaCry（又叫Wanna Decryptor），一种“蠕虫式”的<a href="https://baike.baidu.com/item/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/16623990?fromModule=lemma_inlink">勒索病毒</a>软件，大小3.3MB，由不法分子利用<a href="https://baike.baidu.com/item/NSA/1128824?fromModule=lemma_inlink">NSA</a>（National Security Agency，<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%AE%89%E5%85%A8%E5%B1%80/300052?fromModule=lemma_inlink">美国国家安全局</a>）泄露的危险漏洞“EternalBlue”（永恒之蓝）进行传播 [1] 。勒索病毒肆虐，俨然是一场全球性互联网灾难，给广大电脑用户造成了巨大损失。最新统计数据显示，100多个国家和地区超过10万台电脑遭到了勒索病毒攻击、感染。 [2] 勒索病毒是自熊猫烧香以来影响力最大的<a href="https://baike.baidu.com/item/%E7%97%85%E6%AF%92/4811584?fromModule=lemma_inlink">病毒</a>之一。WannaCry勒索病毒全球大爆发，至少150个国家、30万名用户中招，造成损失达80亿美元，已经影响到金融，能源，医疗等众多行业，造成严重的危机管理问题。</p></blockquote><p><img src="https://s2.loli.net/2023/07/01/wBdynQcKU2g7LjN.png" alt="image-20230701175101126"></p><p>除了病毒在网络上传播外，还有非常恶心的DDOS攻击，这种攻击方式成本低，效率高，只要持续一段时间就能导致没有特殊防御的网站无法正常运作：</p><blockquote><p>2022年4月，郑州警方接到报警称，某政府网站平台于近日遭受多次DDoS攻击，导致平台访问量瞬间暴增多倍，造成数十家政府网站和政务新媒体账号无法正常访问。接到报警后，郑州警方立即开展侦查调查，第一时间锁定犯罪嫌疑人张某某，仅22小时就将犯罪嫌疑人张某某抓捕到案。</p><p>经审查，张某某为某医院网络安全部技术维护人员，2022年4月2日，其个人网站被DDoS攻击，导致网站无法登陆。为减少攻击对其个人网站的影响，张某某私自将个人网站域名解析地址变更为某政府网站平台地址，“转嫁”攻击流量，致使该政府网站平台被恶意网络流量攻击，多家政府网站、政务新媒体账号不能正常使用。</p><p>目前，张某某因涉嫌破坏计算机信息系统犯罪被公安机关移送起诉，案件正在进一步侦办中。</p></blockquote><p><img src="https://s2.loli.net/2023/07/01/5aHJDMTiLOSzERn.png" alt="image-20230701175235964"></p><p>信息泄露也是非常严重的网络安全问题，我们的个人信息是我们的隐私，而在网络发达的今天，在各大APP上填写的信息很有可能会被第三方获取，从中谋取利益。</p><blockquote><p>今年早些时候便已发现相关安全漏洞的网络安全专家称， 一个常见漏洞导致了这场有记录以来最大规模的个人数据泄露，也是中国所遭遇最大规模的网络安全事件，造成数据被公开在互联网上，供人取用。</p><p>据这些网络安全专家称，上海警方的这些记录是被安全存储的，其中包含个人姓名、身份证号码、电话号码以及警情信息，涉及近10亿中国公民的数据。他们说，但一个用于管理和访问该数据库的显示界面(dashboard)被设置在一个公开网址上，没有加设密码，任何有相对基本技术知识的人都可以轻松访问、复制或窃取库中的海量信息。</p><p>暗网情报公司Shadowbyte的创始人Vinny Troia说：“他们把这么多数据暴露在外，这太疯狂了。”这家公司专门在网上扫描搜寻存在安全漏洞的数据库，早在今年1月扫描时发现了上海警方的这个数据库。</p></blockquote><p>个人信息数据一旦泄露，相当于别人可以通过网络直接定位你的住址、电话号码、各种社交账号、身份证信息甚至是机票、火车票、酒店开房信息等，做的再绝一定，如果这个酒店被人偷偷放了针孔摄像头，甚至还能根据记录查到你开房视频，这些事情光是想想都可怕，这等同于在互联网上“裸奔”。</p><p>网络安全问题非同小可，而我们作为网站的开发者，更应该首当其冲解决这些潜在问题。接下来，我们会介绍几个常见的Web网站攻击方式，以及在后续使用SpringSecurity时如何去防范这些攻击行为。</p><h3 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h3><p>为了测试我们之前的网站安全性，这里我们基于Mvc框架重新搭建一个采用之前的验证方式的简易网站，首先是登录界面部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录白马银行<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>      用户名：<br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>      密码：<br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;status&#125;&quot;</span>&gt;</span>登录失败，用户名或密码错误！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着是登录之后的首页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>白马银行 - 首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着是Controller部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-comment">//处理登录操作并跳转</span><br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String username,</span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam</span> String password,</span><br><span class="hljs-params">                        HttpSession session,</span><br><span class="hljs-params">                        Model model)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;test&quot;</span>.equals(username) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals(password)) &#123;<br>            session.setAttribute(<span class="hljs-string">&quot;login&quot;</span>, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            model.addAttribute(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//处理首页或是登录界面跳转</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">(HttpSession session)</span>&#123;<br>        <span class="hljs-keyword">if</span>(session.getAttribute(<span class="hljs-string">&quot;login&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以进行简单登录了：</p><p><img src="https://s2.loli.net/2023/07/01/7jW5Nzki8urUhaf.png" alt="image-20230701184920238"></p><p>接着我们在首页加一个转账操作，要求填写转账人账号名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping(&quot;/pay&quot;)</span><br><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String account,</span><br><span class="hljs-params">                      HttpSession session)</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-comment">//登录之后才能转账</span><br>    <span class="hljs-keyword">if</span>(session.getAttribute(<span class="hljs-string">&quot;login&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;转账给&quot;</span>+account+<span class="hljs-string">&quot;成功，交易已完成！&quot;</span>);<br>        object.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;转账给&quot;</span>+account+<span class="hljs-string">&quot;失败，用户未登录！&quot;</span>);<br>        object.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在页面中添加一个简单的转账操作按键：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>白马银行 - 首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>            转账账号：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;pay()&quot;</span>&gt;</span>立即转账<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> account = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;account&quot;</span>).<span class="hljs-property">value</span></span><br><span class="language-javascript">    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/mvc/pay&#x27;</span>, &#123; <span class="hljs-attr">account</span>: account &#125;, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">headers</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span>(data.<span class="hljs-property">success</span>)</span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;转账成功&quot;</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">else</span></span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;转账失败&quot;</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就成功搭建好网络安全的测试项目了，各位小伙伴请将这个项目进行保存，后面需要重复使用。</p><p><img src="https://s2.loli.net/2023/07/01/khHj6YqSJimGKec.png" alt="image-20230701224909319"></p><h3 id="CSRF跨站请求伪造攻击"><a href="#CSRF跨站请求伪造攻击" class="headerlink" title="CSRF跨站请求伪造攻击"></a>CSRF跨站请求伪造攻击</h3><p>CSRF是我们要介绍的第一种攻击形式，这种攻击方式非常好理解。</p><p><img src="https://s2.loli.net/2023/07/01/4ibrwFIPnSE81lx.png" alt="image-20230701181244150"></p><p>在JavaWeb阶段已经了解了Session和Cookie的机制，在一开始的时候，服务端会给浏览器一个名为JSESSIONID的Cookie信息作为会话的唯一凭据，只要用户携带此Cookie访问我们的网站，那么我们就可以认定此会话属于哪个浏览器用户。因此，只要此会话的用户执行了登录操作，那么就可以随意访问个人信息等内容。</p><p>尝试模拟一下这种操作，来编写一个钓鱼网站：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>坤坤炒粉放鸡精视频在线观看<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hiddenIframe&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://localhost:8080/mvc/pay&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;hiddenIframe&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;黑客&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>点击下载全套视频<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个页面并不是我们官方提供的页面，而是不法分子搭建的恶意网站。我们发现此页面中有一个表单，但是表单中的输入框被隐藏了，而我们看到的只有一个按钮，我们不知道这是一个表单，也不知道表单会提交给那个地址，这时整个页面就非常有迷惑性了。如果我们点击此按钮，那么整个表单的数据会以POST的形式发送给我们的服务端（会携带之前登陆我们网站的Cookie信息），但是这里很明显是另一个网站跳转，通过这样的方式，恶意网站就成功地在我们毫不知情的情况下引导我们执行了转账操作，当你发现上当受骗时，钱已经被转走了。</p><p>我们首先作为用户，先在正常的网站进行登录：</p><p><img src="https://s2.loli.net/2023/07/01/4wQ2iB5uhcLMJHa.png" alt="image-20230701233127287"></p><p>接着我们假装自己上当，进入到我们的钓鱼网站：</p><p><img src="https://s2.loli.net/2023/07/01/OstNZg4doCz6S5G.png" alt="image-20230701233202016"></p><p>现在我们毫不知情，如果是正常人思维的话，就会直接点击下载全套视频，恭喜，此时后台已经转账成功了，留下一脸懵逼的你：</p><p><img src="https://s2.loli.net/2023/07/01/mtGLhuNHxPUr6Os.png" alt="image-20230701233317019"></p><p>而这种构建恶意页面，引导用户访问对应网站执行操作的方式称为：<strong>跨站请求伪造</strong>（CSRF，Cross Site Request Forgery）</p><p>显然，我们之前编写的图书管理系统就存在这样的安全漏洞，而SpringSecurity就解决了这样的问题。</p><p>当然，除了通过我们自己SpringSecurity使用去解决之外，随着现在的浏览器不断发展，安全性越来越受到重视，很多浏览器都有SameSite保护机制，当用户在两个不同域名的站点操作时，默认情况下Cookie就会被自动屏蔽：</p><p><img src="https://s2.loli.net/2023/07/01/qiLDnrFyQxpt3UB.png" alt="a3421f74c3cee6b67d214809adb743a5"></p><p>SameSite是一种安全机制，旨在防止跨站点请求伪造（CSRF）攻击，它通过限制第三方Cookie的使用来实现这一目的。在Chrome浏览器中，SameSite默认为Lax，这意味着第三方Cookie只能在用户导航到与原始站点相同的站点时发送。这同样大大提升了用户的安全性，让黑客少了许多可乘之机，不过这个机制对做实施的同学（可能）不太友好。</p><h3 id="SFA会话固定攻击"><a href="#SFA会话固定攻击" class="headerlink" title="SFA会话固定攻击"></a>SFA会话固定攻击</h3><p>这同样是利用Cookie中相同的JSESSIONID进行的攻击，会话固定攻击（Session fixation attack）是一种针对Web应用程序的安全漏洞攻击，攻击者利用这种漏洞，将一个有效的会话ID分配给用户，并诱使用户在该会话中进行操作，然后攻击者可以利用该会话ID获取用户的权限，或者通过此会话继续进行其他攻击。</p><p>简单来说，就是黑客把他的JSESSIONID直接给你，你一旦使用这个ID登录，那么在后端这个ID就被认定为已登录状态，那么也就等同于他直接进入了已登录状态，从而直接访问你账号的任意内容，执行任意操作。</p><p>攻击者通常使用以下几种方式进行会话固定攻击：</p><ol><li>会话传递：攻击者通过URL参数、表单隐藏字段、cookie等方式将会话ID传递给用户。当用户使用该会话ID登录时，攻击者就能利用该会话ID获取用户的权限。</li><li>会话劫持：攻击者利用劫持用户与服务器之间的通信流量，获取到用户的会话ID，然后利用该会话ID冒充用户进行操作。</li><li>会话劫持：攻击者事先获取到会话ID，并将其分配给用户，之后通过其他方式欺骗用户登录该会话。这样，攻击者就可以利用会话ID获取用户的权限。</li></ol><p>这里我们来尝试一下第一种方案，这里我们首先用另一个浏览器访问目标网站，此时需要登录，开始之前记得先清理一下两个浏览器的缓存，否则可能无法生效：</p><p><img src="https://s2.loli.net/2023/07/02/LFchsWkevUwb58E.png" alt="image-20230702001501063"></p><p>这里我们直接记录下这个JSESSIONID，然后将其编写到我们的诈骗网站中，这里有一个恶意脚本，会自动将对应用户的Cookie进行替换，变成我们的JSESSIONID值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>冠希哥全套视频<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">//第三方网站恶意脚本，自动修改Cookie信息</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> = <span class="hljs-string">&quot;JSESSIONID=6AAF677EC2B630704A80D36311F08E01; path=/mvc; domain=localhost&quot;</span></span><br><span class="language-javascript">  <span class="hljs-comment">//然后给你弄到原来的网站</span></span><br><span class="language-javascript">  location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;http://localhost:8080/mvc/&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们访问这个恶意网站，然后再作为用户，去正常访问目标网站进行登录操作：<br>可以看到此时用户的浏览器JSESSIONID值为刚刚恶意网站伪造的值，现在我们来进行登录操作，此时我们回到一开始的浏览器，刷新之后，我们发现这个浏览器同样已经登录成功了，原理其实很简单，相当于让用户直接帮我们登录了，是不是感觉特别危险？</p><p>当然，现在的浏览器同样有着对应的保护机制，Tomcat发送的SESSIONID默认是勾选了 <strong>HttpOnly</strong> 选项的，一旦被设定是无法被随意修改的，当然前提是先得正常访问一次网站才行，否则仍然存在安全隐患。</p><blockquote><p>HttpOnly是Cookie中一个属性，用于<strong>防止</strong>客户端脚本通过<strong>document.cookie属性访问Cookie</strong>，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HttpOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</p></blockquote><p><img src="https://s2.loli.net/2023/07/02/8IaHk2FEMwyoXem.png" alt="image-20230702002624508"></p><p>为了彻底杜绝这个问题，登录成功之后应该重新给用户分配一个新的JSESSIONID才行，而这些都由SpringSecurity帮我们实现了。</p><h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><p>前面我们介绍了两种攻击方式，不过都是从外部干涉，在外部无法干涉的情况下，我们也可以从内部击溃网站，接下来我们隆重介绍XSS跨站脚本攻击方式。</p><p>XSS（跨站脚本攻击）是一种常见的网络安全漏洞，攻击者通过在合法网站中注入恶意脚本代码来攻击用户。当用户访问受到注入攻击的页面时，恶意代码会在用户的浏览器中执行，从而导致攻击者能够窃取用户的敏感信息、诱导用户操作、甚至控制用户的账号。</p><p>XSS攻击常见的方式有三种：</p><ol><li>存储型XSS攻击：攻击者将恶意代码存储到目标网站的数据库中，当其他用户访问包含恶意代码的页面时，恶意代码会被执行。</li><li>反射型XSS攻击：攻击者将恶意代码嵌入到URL中，当用户点击包含恶意代码的URL时，恶意代码会被执行。</li><li>DOM-based XSS攻击：攻击者利用前端JavaScript代码的漏洞，通过修改页面的DOM结构来执行恶意代码。</li></ol><p>在一些社交网站上，用户可以自由发帖，而帖子是以富文本形式进行编辑和上传的，发送给后台的帖子往往是直接以HTML代码的形式，这个时候就会给黑客可乘之机了。</p><p><img src="https://s2.loli.net/2023/07/02/jTcOaNdwDeP9qB2.png" alt="image-20230702003831742"></p><p>正常情况下，用户发帖会向后端上传以下内容，这些是经过转换得到的正常HTML代码，方便后续直接展示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content ql-editor&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>萨达睡觉了大数据<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>撒大大撒大声地<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而现在，黑客不走常规的方式发帖，而是发送以下内容给服务端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content ql-editor&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">οnlοad</span>=<span class="hljs-string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>萨达睡觉了大数据<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>撒大大撒大声地<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到<code>p</code>标签上添加了一段JS恶意脚本，黑客可以利用这种特性，获取用户的各种信息，甚至直接发送到他的后台，这样，我们的个人信息就从网站内部被泄露了。</p><p>XSS漏洞最早被发现是在1996年，由于JavaScript的出现，导致在Web应用程序中存在了一些安全问题。在1997年，高智文(Gareth Owen)也就是“XSS之父”，在他的博客中描述了一种称为“脚本注入”(script injection)的攻击技术，这就是XSS漏洞的前身。从那时起，XSS漏洞便成为了Web应用程序中的一种常见安全漏洞。</p><p><img src="https://s2.loli.net/2023/07/02/DkzJWPxQ5BUl2tC.png" alt="image-20230702004827194"></p><p>这种攻击一般需要前端配合后端进行防御，或者后端对前端发送的内容进行安全扫描并处理。</p><hr><h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><p>我们继续使用之前的测试项目进行教学，首先我们需要导入SpringSecurity的相关依赖，它不仅仅是一个模块，我们可以根据需求导入需要的模块，常用的是以下两个：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们需要配置SpringSecurity，与Mvc一样，需要一个初始化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSecurityWebApplicationInitializer</span> &#123;<br>    <span class="hljs-comment">//不用重写任何内容</span><br>  <span class="hljs-comment">//这里实际上会自动注册一个Filter，SpringSecurity底层就是依靠N个过滤器实现的，我们之后再探讨</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要再创建一个配置类用于配置 SpringSecurity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span>   <span class="hljs-comment">//开启WebSecurity相关功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接着在<strong>根容器</strong>中添加此配置文件即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;MainConfiguration.class, SecurityConfiguration.class&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，SpringSecurity的配置就完成了，我们再次运行项目，会发现无法进入的我们的页面中，无论我们访问哪个页面，都会进入到SpringSecurity为我们提供的一个默认登录页面，之后我们会讲解如何进行配置。</p><p><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311061301339.png"></p><hr><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证是我们网站的第一步，用户需要登录之后才能进入，这一部分我们将详细介绍如何使用SpringSecurity实现用户登录。</p><h3 id="基于内存验证"><a href="#基于内存验证" class="headerlink" title="基于内存验证"></a>基于内存验证</h3><p>首先我们来看看最简单的基于内存的配置，也就是说我们直接以代码的形式配置我们网站的用户和密码，配置方式非常简单，只需要在Security配置类中注册一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span>   <span class="hljs-comment">//UserDetailsService就是获取用户信息的服务</span><br>    <span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title function_">userDetailsService</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//每一个UserDetails就代表一个用户信息，其中包含用户的用户名和密码以及角色</span><br>        <span class="hljs-type">UserDetails</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> User.withDefaultPasswordEncoder()<br>                .username(<span class="hljs-string">&quot;user&quot;</span>)<br>                .password(<span class="hljs-string">&quot;password&quot;</span>)<br>                .roles(<span class="hljs-string">&quot;USER&quot;</span>)  <span class="hljs-comment">//角色目前我们不需要关心，随便写就行，后面会专门讲解</span><br>                .build();<br>        <span class="hljs-type">UserDetails</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> User.withDefaultPasswordEncoder()<br>                .username(<span class="hljs-string">&quot;admin&quot;</span>)<br>                .password(<span class="hljs-string">&quot;password&quot;</span>)<br>                .roles(<span class="hljs-string">&quot;ADMIN&quot;</span>, <span class="hljs-string">&quot;USER&quot;</span>)<br>                .build();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryUserDetailsManager</span>(user, admin); <br>      <span class="hljs-comment">//创建一个基于内存的用户信息管理器作为UserDetailsService</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完成后，我们就可以前往登录界面，进行登录操作了，登录成功后，就可以访问到我们之前的界面了，并且为了防止我们之前提到的会话固定问题，在登录之后，JSESSIONID会得到重新分配，当我们想要退出时，也可以直接访问：<a href="http://localhost:8080/mvc/logout">http://localhost:8080/mvc/logout</a>  地址，我们会进入到一个退出登录界面，退出登录后就需要重新登录才能访问我们的网站了。</p><p>可以发现，在有了SpringSecurity之后，我们网站的登录验证模块相当于直接被接管了，因此，从现在开始，我们的网站不需要再自己编写登录模块了，这里我们可以直接去掉，只留下主页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br><br>    <span class="hljs-comment">//现在所有接口不需要任何验证了，因为Security已经帮我们做了，没登录是根本进不来的</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@PostMapping(&quot;/pay&quot;)</span><br>    <span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">pay</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String account)</span>&#123;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>        System.out.println(<span class="hljs-string">&quot;转账给&quot;</span>+account+<span class="hljs-string">&quot;成功，交易已完成！&quot;</span>);<br>        object.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们的网站就成功用上了更加安全的SpringSecurity框架了。细心的小伙伴可能发现了，我们在配置用户信息的时候，报了黄标，实际上这种方式存储密码并不安全：</p><p><img src="https://s2.loli.net/2023/07/02/yuYe5pODwqBTQh7.png" alt="image-20230702151123338"></p><p>这是因为SpringSecurity的密码校验不推荐直接使用原文进行比较，而是使用加密算法将密码进行加密（更准确地说应该进行Hash处理，此过程是不可逆的，无法解密），最后将用户提供的密码以同样的方式加密后与密文进行比较。对于我们来说，用户提供的密码属于隐私信息，直接明文存储并不好，而且如果数据库内容被窃取，那么所有用户的密码将全部泄露，这是我们不希望看到的结果，我们需要一种既能隐藏用户密码也能完成认证的机制，而Hash处理就是一种很好的解决方案，通过将用户的密码进行Hash值计算，计算出来的结果一般是单向的，无法还原为原文，如果需要验证是否与此密码一致，那么需要以同样的方式加密再比较两个Hash值是否一致，这样就很好的保证了用户密码的安全性。</p><p>因此，我们在配置用户信息的时候，可以使用官方提供的BCrypt加密工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br>    <br>  <span class="hljs-comment">//这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title function_">userDetailsService</span><span class="hljs-params">(PasswordEncoder encoder)</span> &#123;<br>        <span class="hljs-type">UserDetails</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> User<br>                .withUsername(<span class="hljs-string">&quot;user&quot;</span>)<br>                .password(encoder.encode(<span class="hljs-string">&quot;password&quot;</span>))   <span class="hljs-comment">//这里将密码进行加密后存储</span><br>                .roles(<span class="hljs-string">&quot;USER&quot;</span>)<br>                .build();<br>      System.out.println(encoder.encode(<span class="hljs-string">&quot;password&quot;</span>));  <span class="hljs-comment">//一会观察一下加密出来之后的密码长啥样</span><br>        <span class="hljs-type">UserDetails</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> User<br>                .withUsername(<span class="hljs-string">&quot;admin&quot;</span>)<br>                .password(encoder.encode(<span class="hljs-string">&quot;password&quot;</span>))   <span class="hljs-comment">//这里将密码进行加密后存储</span><br>                .roles(<span class="hljs-string">&quot;ADMIN&quot;</span>, <span class="hljs-string">&quot;USER&quot;</span>)<br>                .build();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryUserDetailsManager</span>(user, admin);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们存储的密码就是更加安全的密码了：</p><p><img src="https://s2.loli.net/2023/07/02/Vacp97MlgfNrYnR.png" alt="image-20230702152150157"></p><p><img src="https://s2.loli.net/2023/07/02/tk5pGDrNHWfaJXU.png" alt="image-20230702152216162"></p><p>这样，一个简单的权限校验就配置完成了，是不是感觉用起来还是挺简单的？</p><p>不过，可能会有小伙伴发现，所有的POST请求都被403了：</p><p><img src="https://s2.loli.net/2023/07/02/F94URzLh6oIBrCJ.png" alt="image-20230702183040922"></p><p>这是因为SpringSecurity自带了 <strong>csrf</strong> 防护，需求我们在POST请求中携带页面中的 <strong>csrfToken</strong> 才可以，否则一律进行拦截操作，这里我们可以将其嵌入到页面中，随便找一个地方添加以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">th:id</span>=<span class="hljs-string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着在axios发起请求时，携带这个input的value值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> account = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;account&quot;</span>).<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> csrf = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;_csrf&quot;</span>).<span class="hljs-property">value</span><br>    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/mvc/pay&#x27;</span>, &#123;<br>        <span class="hljs-attr">account</span>: account,<br>        <span class="hljs-attr">_csrf</span>: csrf   <span class="hljs-comment">//携带此信息即可，否则会被拦截</span><br>    &#125;, &#123;<br>      ...<br></code></pre></td></tr></table></figure><p>如果后续各位小伙伴遇到那种需要在form表单中提交的情况，也可以直接像下面这样给塞到表单里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/xxxx&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>  ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">th:name</span>=<span class="hljs-string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实际上现在的浏览器已经很安全了，完全不需要使用自带的csrf防护，后面我们会讲解如何通过配置<strong>关闭csrf防护</strong>。这里温馨提醒一下，在后续各位小伙伴跟我们的实战项目时，如果遇到诸如<strong>401、403这种错误时，优先查看你的SpringSecurity配置是否错误</strong>。</p><blockquote><p>从Spring Security 4.0开始，<strong>默认情况下会启用CSRF保护</strong>，以防止CSRF攻击应用程序，Spring Security CSRF会针对PATCH，POST，PUT和DELETE方法的请求（不仅仅只是登陆请求，这里指的是任何请求路径）进行防护，而这里的登陆表单正好是一个POST类型的请求。在默认配置下，无论是否登陆，页面中只要发起了PATCH，POST，PUT和DELETE请求一定会被拒绝，并返回<strong>403</strong>错误（注意，这里是个究极大坑，这个没有任何提示，直接403，因此如果你不知道的话根本不清楚是什么问题，就一直卡这里了）**，需要在请求的时候加入csrfToken才行，也就是”83421936-b84b-44e3-be47-58bb2c14571a”，正是csrfToken，如果提交的是表单类型的数据，那么表单中必须包含此Token字符串，键名称为”_csrf”；如果是JSON数据格式发送的，那么就需要在请求头中包含此Token字符串。</p></blockquote><h3 id="基于数据库验证"><a href="#基于数据库验证" class="headerlink" title="基于数据库验证"></a>基于数据库验证</h3><p>前面我们已经实现了直接认证的方式，但是实际项目中往往都是将用户信息存储在数据库中，那么如何将其连接到数据库，通过查询数据库中的用户信息来进行用户登录呢？</p><p>官方默认提供了可以直接使用的用户和权限表设计，根本不需要我们来建表，直接在Navicat中执行以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users(username <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,password <span class="hljs-type">varchar</span>(<span class="hljs-number">500</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,enabled <span class="hljs-type">boolean</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> authorities (username <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,authority <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<span class="hljs-keyword">constraint</span> fk_authorities_users <span class="hljs-keyword">foreign</span> key(username) <span class="hljs-keyword">references</span> users(username));<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index ix_auth_username <span class="hljs-keyword">on</span> authorities (username,authority);<br></code></pre></td></tr></table></figure><p>接着我们添加Mybatis和MySQL相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们编写配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//数据源配置</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledDataSource</span>(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>,<br>                <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title function_">userDetailsService</span><span class="hljs-params">(DataSource dataSource,</span><br><span class="hljs-params">                                                 PasswordEncoder encoder)</span> &#123;<br>        <span class="hljs-type">JdbcUserDetailsManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcUserDetailsManager</span>(dataSource);<br>      <span class="hljs-comment">//仅首次启动时创建一个新的用户用于测试，后续无需创建</span><br>   manager.createUser(User.withUsername(<span class="hljs-string">&quot;user&quot;</span>)<br>                      .password(encoder.encode(<span class="hljs-string">&quot;password&quot;</span>)).roles(<span class="hljs-string">&quot;USER&quot;</span>).build());<br>        <span class="hljs-keyword">return</span> manager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动后，可以看到两张表中已经自动添加好对应的数据了：</p><p><img src="https://s2.loli.net/2023/07/02/VG19mSConefsilH.png" alt="image-20230702181131252"></p><p><img src="https://s2.loli.net/2023/07/02/6uqerwFo13p9jxJ.png" alt="image-20230702181119809"></p><p>我们可以直接尝试进行登录，使用方式和之前是完全一样的：</p><p><img src="https://s2.loli.net/2023/07/02/dVM5ltzF1ua8Y3E.png" alt="image-20230702181211157"></p><p>这样，当我们下次需要快速创建一个用户登录的应用程序时，直接使用这种方式就能快速完成了，是不是感觉特别方便。</p><p>无论是我们上节课认识的 <code>InMemoryUserDetailsManager</code> 还是现在认识的 <code>JdbcUserDetailsManager</code> ，他们都是实现自 <code>UserDetailsManager</code> 接口，这个接口中有着一套完整的增删改查操作，方便我们直接对用户进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDetailsManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>  <span class="hljs-comment">//创建一个新的用户</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createUser</span><span class="hljs-params">(UserDetails user)</span>;<br><br>  <span class="hljs-comment">//更新用户信息</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(UserDetails user)</span>;<br><br>  <span class="hljs-comment">//删除用户</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(String username)</span>;<br><br>  <span class="hljs-comment">//修改用户密码</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">changePassword</span><span class="hljs-params">(String oldPassword, String newPassword)</span>;<br><br>  <span class="hljs-comment">//判断是否存在指定用户</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">userExists</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用UserDetailsManager对象，我们就能快速执行用户相关的管理操作，比如我们可以直接在网站上添加一个快速重置密码的接口，首先需要配置一下JdbcUserDetailsManager，为其添加一个AuthenticationManager用于原密码的校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    ...<br><br>    <span class="hljs-comment">//手动创建一个AuthenticationManager用于处理密码校验</span><br>    <span class="hljs-keyword">private</span> AuthenticationManager <span class="hljs-title function_">authenticationManager</span><span class="hljs-params">(UserDetailsManager manager,</span><br><span class="hljs-params">                                                        PasswordEncoder encoder)</span>&#123;<br>        <span class="hljs-type">DaoAuthenticationProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaoAuthenticationProvider</span>();<br>        provider.setUserDetailsService(manager);<br>        provider.setPasswordEncoder(encoder);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProviderManager</span>(provider);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> UserDetailsManager <span class="hljs-title function_">userDetailsService</span><span class="hljs-params">(DataSource dataSource,</span><br><span class="hljs-params">                                                 PasswordEncoder encoder)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">JdbcUserDetailsManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcUserDetailsManager</span>(dataSource);<br>      <span class="hljs-comment">//为UserDetailsManager设置AuthenticationManager即可开启重置密码的时的校验</span><br>        manager.setAuthenticationManager(authenticationManager(manager, encoder));<br>        <span class="hljs-keyword">return</span> manager;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接着我们编写一个快速重置密码的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping(&quot;/change-password&quot;)</span><br><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">changePassword</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String oldPassword,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@RequestParam</span> String newPassword)</span> &#123;<br>    manager.changePassword(oldPassword, encoder.encode(newPassword));<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    object.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在主界面中添加一个重置密码的操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        修改密码：<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;oldPassword&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;旧密码&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;newPassword&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;新密码&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;change()&quot;</span>&gt;</span>修改密码<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> oldPassword = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;oldPassword&quot;</span>).<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> newPassword = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;newPassword&quot;</span>).<span class="hljs-property">value</span><br>    <span class="hljs-keyword">const</span> csrf = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;_csrf&quot;</span>).<span class="hljs-property">value</span><br>    axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/mvc/change-password&#x27;</span>, &#123;<br>        <span class="hljs-attr">oldPassword</span>: oldPassword,<br>        <span class="hljs-attr">newPassword</span>: newPassword,<br>        <span class="hljs-attr">_csrf</span>: csrf<br>    &#125;, &#123;<br>        <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>        &#125;<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">alert</span>(data.<span class="hljs-property">success</span> ? <span class="hljs-string">&quot;密码修改成功&quot;</span> : <span class="hljs-string">&quot;密码修改失败，请检查原密码是否正确&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以在首页进行修改密码操作了：</p><p><img src="https://s2.loli.net/2023/07/03/akAtDrPeMdc6N3b.png" alt="image-20230703001525592"></p><p>当然，这种方式的权限校验虽然能够直接使用数据库，但是存在一定的局限性，只适合快速搭建Demo使用，不适合实际生产环境下编写，下一节我们将介绍如何实现自定义验证，以应对各种情况。</p><h3 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h3><p>有些时候，我们的数据库可能并不会像SpringSecurity默认的那样进行设计，而是采用自定义的表结构，这种情况下，上面两种方式就很难进行验证了，此时我们得编写自定义验证，来应对各种任意变化的情况。</p><p>既然需要自定义，那么我们就需要自行实现UserDetailsService或是功能更完善的UserDetailsManager接口，这里为了简单，我们直接选择前者进行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们需要去实现这个<code>loadUserByUsername</code>方法，表示在验证的时候通过自定义的方式，根据给定的用户名查询用户，并封装为<code>UserDetails</code>对象返回，然后由SpringSecurity将我们返回的对象与用户登录的信息进行核验，基本流程实际上跟之前是一样的，只是现在由我们自己来提供用户查询方式。</p><p>现在我们在数据库中创建一个自定义的用户表：</p><p><img src="https://s2.loli.net/2023/07/03/ln4uZ1TFIe7qaCK.png" alt="image-20230703181046326"></p><p>随便插入一点数据：</p><p><img src="https://s2.loli.net/2023/07/03/tToR2JPykeuCK73.png" alt="image-20230703152719655"></p><p>接着我们自行编写对应的查询操作，首先创建一个对应的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是根据用户名查询用户的Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from user where username = #&#123;username&#125;&quot;)</span><br>    Account <span class="hljs-title function_">findUserByName</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们在配置类上添加相应的包扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScans(&#123;</span><br><span class="hljs-meta">        @ComponentScan(&quot;com.example.controller&quot;),</span><br><span class="hljs-meta">        @ComponentScan(&quot;com.example.service&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@MapperScan(&quot;com.example.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们来到Service这边进行一下完善，从数据库中进行查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> mapper.findUserByName(username);<br>        <span class="hljs-keyword">if</span>(account == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>        <span class="hljs-keyword">return</span> User<br>                .withUsername(username)<br>                .password(account.getPassword())<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就通过自定义的方式实现了数据库信息查询，并完成用户登录操作。</p><hr><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>前面我们介绍了如果将SpringSecurity作为我们的登录校验框架，并且实现了三种方式的校验，但是光是这样，自由度还远远不够，在实际开发场景中，我们还会面对各种各样的需求，这一部分我们接着来进行更加深层次的配置。</p><h3 id="自定义登录界面"><a href="#自定义登录界面" class="headerlink" title="自定义登录界面"></a>自定义登录界面</h3><p>虽然SpringSecurity为我们提供了一个还行的登录界面，但是很多情况下往往都是我们使用自定义的登录界面，这个时候就需要进行更多的配置了，我们还是以之前图书管理系统使用的模版为例。</p><p>下载好模版后，我们将其中的两个页面和资源文件放到类路径下：</p><p><img src="https://s2.loli.net/2023/07/03/hpZs1DLESojHJue.png" alt="image-20230703180438190"></p><p>接着我们配置对应页面的Controller控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们在登录之后，就可以展示前端模版页面了：</p><p><img src="https://s2.loli.net/2023/07/03/Zns4Vwb7zPLc6SQ.png" alt="image-20230703182321093"></p><p>不过现在依然是默认进入到SpringSecurity默认的登录界面，现在我们来配置自定义的登录界面，将我们的前端模版中的登录页面作为SpringSecurity的默认登录界面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>  ...<br>  <br><span class="hljs-comment">//如果你学习过SpringSecurity 5.X版本，可能会发现新版本的配置方式完全不一样</span><br>    <span class="hljs-comment">//新版本全部采用lambda形式进行配置，无法再使用之前的and()方法进行连接了</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> http<br>                <span class="hljs-comment">//以下是验证请求拦截和放行配置</span><br>                .authorizeHttpRequests(auth -&gt; &#123;<br>                    auth.anyRequest().authenticated();    <span class="hljs-comment">//将所有请求全部拦截，一律需要验证</span><br>                &#125;)<br>                <span class="hljs-comment">//以下是表单登录相关配置</span><br>                .formLogin(conf -&gt; &#123;<br>                    conf.loginPage(<span class="hljs-string">&quot;/login&quot;</span>);   <span class="hljs-comment">//将登录页设置为我们自己的登录页面</span><br>                    conf.loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>); <span class="hljs-comment">//登录表单提交的地址，可以自定义</span><br>                    conf.defaultSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//登录成功后跳转的页面</span><br>                    conf.permitAll();    <span class="hljs-comment">//将登录相关的地址放行，否则未登录的用户连登录界面都进不去</span><br>                  <span class="hljs-comment">//用户名和密码的表单字段名称，不过默认就是这个，可以不配置，除非有特殊需求</span><br>                    conf.usernameParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>                    conf.passwordParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>                &#125;)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要配置登陆页面的地址和登陆请求发送的地址，这里登陆页面填写为<code>/login</code>，登陆请求地址为<code>/doLogin</code>，登陆页面我们刚刚已经自己编写Controller来实现了，登陆请求提交处理由SpringSecurity 提供，只需要写路径就可以了。现在访问我们的网站，就可以进入到自定义的登录界面了：</p><p><img src="https://s2.loli.net/2023/07/03/c38kewdxtn1j2V6.png" alt="image-20230703184425313"></p><p>但是我们发现，我们的页面只有一个纯文本，这是因为在获取静态资源的时候，所有的静态资源默认情况下也会被拦截，因此全部被302重定向到登录页面，这显然是不对的：</p><p><img src="https://s2.loli.net/2023/07/03/6vXlPZprzjJLEeq.png" alt="image-20230703184641792"></p><p>因此，现在我们需要将所有的静态资源也给放行，否则登录界面都没法正常展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">.authorizeHttpRequests(auth -&gt; &#123;<br>      auth.requestMatchers(<span class="hljs-string">&quot;/static/**&quot;</span>).permitAll();   <span class="hljs-comment">//将所有的静态资源放行，一定要添加在全部请求拦截之前</span><br>      auth.anyRequest().authenticated();    <span class="hljs-comment">//将所有请求全部拦截，一律需要验证</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>再次访问我们的网站，就可以看到正常显示的登录界面了：</p><p><img src="https://s2.loli.net/2023/07/03/LmZbihzD4vYB5GF.png" alt="image-20230703185027927"></p><blockquote><p>因此，如果各位小伙伴后续在编写项目过程中发现有302的情况，一定要先检查<strong>是否因为没有放行导致被SpringSecurity给拦截</strong>了，别再遇到302一脸懵逼了。</p></blockquote><p>接着我们来配置登录操作，这里我们只需要配置一下登录的地址和登录按钮即可，当然，跟之前一样，要把CSRF的输入框也加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;doLogin&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Email Address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ad-input&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ad-input&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">th:name</span>=<span class="hljs-string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ad-auth-btn&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ad-btn ad-login-member&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们就可以尝试进行登录操作了：</p><p><img src="https://s2.loli.net/2023/07/03/P2LS8uNRQ64WEvT.png" alt="image-20230703185916404"></p><p>可以看到，现在我们可以成功地登录到主页了。</p><p>退出登录也是同样的操作，我们只需要稍微进行一下配置就可以实现，我们首先继续完善配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    ...<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> http<br>                ...<br>                <span class="hljs-comment">//以下是退出登录相关配置</span><br>                .logout(conf -&gt; &#123;<br>                    conf.logoutUrl(<span class="hljs-string">&quot;/doLogout&quot;</span>);   <span class="hljs-comment">//退出登录地址，跟上面一样可自定义</span><br>                    conf.logoutSuccessUrl(<span class="hljs-string">&quot;/login&quot;</span>);  <span class="hljs-comment">//退出登录成功后跳转的地址，这里设置为登录界面</span><br>                    conf.permitAll();<br>                &#125;)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来稍微魔改一下页面中的退出登录按钮：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;doLogout&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">th:name</span>=<span class="hljs-string">&quot;$&#123;_csrf.getParameterName()&#125;&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;_csrf.token&#125;&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fas fa-sign-out-alt&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> logout<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们点击右上角的退出按钮就可以退出了：</p><p><img src="https://s2.loli.net/2023/07/03/yM8TOAxYPf3iqFs.png" alt="image-20230703190714519"></p><p>不过，可能会有小伙伴觉得，我们现在无论提交什么请求都需要Csrf校验，有些太麻烦了，实际上现在浏览器已经很安全了，没必要防御到这种程度，我们也可以直接在配置中<strong>关闭csrf校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>   ...<br>      <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> http<br>                ...<br>                <span class="hljs-comment">//以下是csrf相关配置</span><br>                .csrf(conf -&gt; &#123;<br>                    conf.disable();   <span class="hljs-comment">//此方法可以直接关闭全部的csrf校验，一步到位</span><br>                    conf.ignoringRequestMatchers(<span class="hljs-string">&quot;/xxx/**&quot;</span>);   <span class="hljs-comment">//此方法可以根据情况忽略某些地址的csrf校验</span><br>                &#125;)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就不需要再往页面中嵌入CSRF相关的输入框了，发送请求时也不会进行校验，至此，我们就完成了简单的自定义登录界面配置。</p><h3 id="记住我功能"><a href="#记住我功能" class="headerlink" title="记住我功能"></a>记住我功能</h3><p>我们的网站还有一个重要的功能，就是记住我，也就是说我们可以在登陆之后的一段时间内，无需再次输入账号和密码进行登陆，相当于服务端已经记住当前用户，再次访问时就可以免登陆进入，这是一个非常常用的功能。</p><p>我们之前在JavaWeb阶段，使用本地Cookie存储的方式实现了记住我功能，但是这种方式并不安全，同时在代码编写上也比较麻烦，那么能否有一种更加高效的记住我功能实现呢？</p><p>SpringSecurity为我们提供了一种优秀的实现，它为每个已经登陆的浏览器分配一个携带Token的Cookie，并且此Cookie默认会被保留14天，只要我们不清理浏览器的Cookie，那么下次携带此Cookie访问服务器将无需登陆，直接继续使用之前登陆的身份，这样显然比我们之前的写法更加简便。并且我们需要进行简单配置，即可开启记住我功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    ...<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> http<br>                ...<br>                .rememberMe(conf -&gt; &#123;<br>                    conf.alwaysRemember(<span class="hljs-literal">false</span>);  <span class="hljs-comment">//这里不要开启始终记住，我们需要配置为用户自行勾选</span><br>                    conf.rememberMeParameter(<span class="hljs-string">&quot;remember-me&quot;</span>);   <span class="hljs-comment">//记住我表单字段，默认就是这个，可以不配置</span><br>                    conf.rememberMeCookieName(<span class="hljs-string">&quot;xxxx&quot;</span>);  <span class="hljs-comment">//记住我设置的Cookie名字，也可以自定义，不过没必要</span><br>                &#125;)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完成后，我们需要修改一下前端页面中的表单，将记住我勾选框也作为表单的一部分进行提交：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ad-checkbox&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remember-me&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ad-checkbox&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Remember Me<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们来尝试勾选记住我选项进行登录：</p><p><img src="https://s2.loli.net/2023/07/04/3wOt7CldbFP8yHz.png" alt="image-20230704211415804"></p><p>此时提交的表单中就已经包含记住我字段了，我们会发现，服务端返回给我们了一个记住我专属的Cookie信息：</p><p><img src="https://s2.loli.net/2023/07/04/NB129h7IKRycXvL.png" alt="image-20230704211611369"></p><p>这个Cookie信息的过期时间并不是仅会话，而是默认保存一段时间，因此，我们关闭浏览器后下次再次访问网站时，就不需要我们再次进行登录操作了，而是直接继续上一次的登录状态。</p><p>当然，由于记住我信息是存放在内存中的，我们需要保证服务器一直处于运行状态，如果关闭服务器的话，记住我信息会全部丢失，因此，如果我们希望记住我能够一直持久化保存，我们就需要进一步进行配置。我们需要创建一个<strong>基于JDBC的TokenRepository</strong>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> PersistentTokenRepository <span class="hljs-title function_">tokenRepository</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>    <span class="hljs-type">JdbcTokenRepositoryImpl</span> <span class="hljs-variable">repository</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTokenRepositoryImpl</span>();<br>  <span class="hljs-comment">//在启动时自动在数据库中创建存储记住我信息的表，仅第一次需要，后续不需要</span><br>    repository.setCreateTableOnStartup(<span class="hljs-literal">true</span>);<br>    repository.setDataSource(dataSource);<br>    <span class="hljs-keyword">return</span> repository;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后添加此仓库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">.rememberMe(conf -&gt; &#123;<br>     conf.rememberMeParameter(<span class="hljs-string">&quot;remember-me&quot;</span>);<br>     conf.tokenRepository(repository);      <span class="hljs-comment">//设置刚刚的记住我持久化存储库</span><br>     conf.tokenValiditySeconds(<span class="hljs-number">3600</span> * <span class="hljs-number">7</span>);   <span class="hljs-comment">//设置记住我有效时间为7天</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这样，我们就成功配置了数据库持久化存储记住我信息，即使我们重启服务器也不会导致数据丢失。当我们登录之后，数据库中会自动记录相关的信息：</p><p><img src="https://s2.loli.net/2023/07/04/kIJpuWdiEGqUKBx.png" alt="image-20230704220701000"></p><hr><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>用户登录后，可能会根据用户当前是身份进行角色划分，比如我们最常用的QQ，一个QQ群里面，有群主、管理员和普通群成员三种角色，其中群主具有最高权限，群主可以管理整个群的任何板块，并且具有解散和升级群的资格，而管理员只有群主的一部分权限，只能用于日常管理，普通群成员则只能进行最基本的聊天操作。</p><p><img src="https://s2.loli.net/2023/07/04/e1IXMRgawYoGvSQ.png" alt="image-20230704222032360"></p><p>对于我们来说，用户的一个操作实际上就是在访问我们提供的<code>接口</code>(编写的对应访问路径的Servlet），比如登陆，就需要调用<code>/login</code>接口，退出登陆就要调用&#x2F;<code>logout</code>接口，而我们之前的图书管理系统中，新增图书、删除图书，所有的操作都有着对应的Servlet来进行处理。因此，从我们开发者的角度来说，决定用户能否使用某个功能，只需要决定用户是否能够访问对应的Servlet即可。</p><p>我们可以大致像下面这样进行划分：</p><ul><li>群主：<code>/login</code>、<code>/logout</code>、<code>/chat</code>、<code>/edit</code>、<code>/delete</code>、<code>/upgrade</code></li><li>管理员：<code>/login</code>、<code>/logout</code>、<code>/chat</code>、<code>/edit</code></li><li>普通群成员：<code>/login</code>、<code>/logout</code>、<code>/chat</code></li></ul><p>也就是说，我们需要做的就是指定哪些请求可以由哪些用户发起。</p><p>SpringSecurity为我们提供了两种授权方式：</p><blockquote><ul><li>基于权限的授权：只要拥有某权限的用户，就可以访问某个路径。</li><li>基于角色的授权：根据用户属于哪个角色来决定是否可以访问某个路径。</li></ul></blockquote><p>两者只是概念上的不同，实际上使用起来效果差不多。这里我们就先演示以角色方式来进行授权。</p><h3 id="基于角色授权"><a href="#基于角色授权" class="headerlink" title="基于角色授权"></a>基于角色授权</h3><p>现在我们希望创建两个角色，普通用户和管理员，普通用户只能访问index页面，而管理员可以访问任何页面。</p><p>首先我们需要对数据库中的角色表进行一些修改，添加一个用户角色字段，并创建一个新的用户，Test用户的角色为user，而Admin用户的角色为admin。</p><p>接着我们需要配置SpringSecurity，决定哪些角色可以访问哪些页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">.authorizeHttpRequests(auth -&gt; &#123;<br>    <span class="hljs-comment">//静态资源依然全部可以访问</span><br>    auth.requestMatchers(<span class="hljs-string">&quot;/static/**&quot;</span>).permitAll();<br>    <span class="hljs-comment">//只有具有以下角色的用户才能访问路径&quot;/&quot;</span><br>    auth.requestMatchers(<span class="hljs-string">&quot;/&quot;</span>).hasAnyRole(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    <span class="hljs-comment">//其他所有路径必须角色为admin才能访问</span><br>    auth.anyRequest().hasRole(<span class="hljs-string">&quot;admin&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>接着我们需要稍微修改一下验证逻辑，我们在数据库中的用户表上添加一个新的字段，用于表示角色：</p><p><img src="https://s2.loli.net/2023/07/04/1pkfGS9LrsPtjFx.png" alt="image-20230704222733082"></p><p>修改一下对应的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String username;<br>    String password;<br>    String role;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们在查询用户时，需要添加其对应的角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> mapper.findUserByName(username);<br>    <span class="hljs-keyword">if</span>(account == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);<br>    <span class="hljs-keyword">return</span> User<br>            .withUsername(username)<br>            .password(account.getPassword())<br>            .roles(account.getRole())   <span class="hljs-comment">//添加角色，一个用户可以有一个或多个角色</span><br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以了，我们重启服务器登录看看：</p><p><img src="https://s2.loli.net/2023/07/03/Zns4Vwb7zPLc6SQ.png" alt="image-20230703182321093"></p><p>目前依然是可以正常登录的，但是我们随便访问一个其他的页面，就会被拦截并自动退回到登录界面：</p><p><img src="https://s2.loli.net/2023/07/04/8aoGrM9mpYt6Xie.png" alt="image-20230704223248124"></p><p>这是因为我们前面配置的是user角色，那么这个角色只能访问首页，其他的都不行，所以就会被自动拦截掉了。现在我们可以到数据库中对这个用户的角色进行修改，看看修改后是否能够访问到其他页面：</p><p><img src="https://s2.loli.net/2023/07/04/l9YkDaRJdtrmSZj.png" alt="image-20230704223503682"></p><p>这样就可以访问其他页面不会被拦截了，不过因为我们没配置这个路径，所以出来的是404页面。</p><p>通过使用角色控制页面的访问，我们就可以让某些用户只能访问部分页面。</p><h3 id="基于权限授权"><a href="#基于权限授权" class="headerlink" title="基于权限授权"></a>基于权限授权</h3><p>基于权限的授权与角色类似，需要以<code>hasAnyAuthority</code>或<code>hasAuthority</code>进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">.authorizeHttpRequests(auth -&gt; &#123;<br>    <span class="hljs-comment">//静态资源依然全部可以访问</span><br>    auth.requestMatchers(<span class="hljs-string">&quot;/static/**&quot;</span>).permitAll();<br>    <span class="hljs-comment">//基于权限和基于角色其实差别并不大，使用方式是相同的</span><br>    auth.anyRequest().hasAnyAuthority(<span class="hljs-string">&quot;page:index&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>实际上权限跟角色相比只是粒度更细，由于使用方式差不多，这里不多做阐述。</p><h3 id="使用注解权限判断"><a href="#使用注解权限判断" class="headerlink" title="使用注解权限判断"></a>使用注解权限判断</h3><p>除了直接配置以外，我们还可以以注解形式直接配置，首先需要在配置类（注意这里是在Mvc的配置类上添加，因为这里只针对Controller进行过滤，所有的Controller是由Mvc配置类进行注册的，如果需要为Service或其他Bean也启用权限判断，则需要在Security的配置类上添加）上开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-meta">@EnableMethodSecurity</span>   <span class="hljs-comment">//开启方法安全校验</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以在我们想要进行权限校验的方法上添加注解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@PreAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)</span>  <span class="hljs-comment">//直接使用hasRole方法判断是否包含某个角色</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过添加<code>@PreAuthorize</code>注解，在执行之前判断判断权限，如果没有对应的权限或是对应的角色，将无法访问页面。</p><p>这里其实是使用的就是我们之前讲解的SpEL表达式，我们可以直接在这里使用权限判断相关的方法，如果有忘记SpEL如何使用的可以回顾我们的Spring6核心篇。所有可以进行权限判断的方法在<code>SecurityExpressionRoot</code>类中有定义，各位小伙伴可以自行前往查看。</p><p>同样的还有<code>@PostAuthorize</code>注解，但是它是在方法执行之后再进行拦截：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostAuthorize(&quot;hasRole(&#x27;user&#x27;)&quot;)</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了Controller以外，只要是由Spring管理的Bean都可以使用注解形式来控制权限，我们可以在任意方法上添加这个注解，只要不具备表达式中指定的访问权限，那么就无法执行方法并且会返回403页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@PreAuthorize(&quot;hasAnyRole(&#x27;user&#x27;)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;成功执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与具有相同功能的还有<code>@Secured</code>但是它不支持SpEL表达式的权限表示形式，并且需要添加”ROLE_”前缀，这里就不做演示了。</p><p>我们还可以使用<code>@PreFilter</code>和<code>@PostFilter</code>对<strong>集合类型的参数或返回值进行过滤</strong>。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreFilter(&quot;filterObject.equals(&#x27;lbwnb&#x27;)&quot;)</span>   <span class="hljs-comment">//filterObject代表集合中每个元素，只要满足条件的元素才会留下</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(List&lt;String&gt; list)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;成功执行&quot;</span>+list);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;yyds&quot;</span>);<br>    service.test(list);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与<code>@PreFilter</code>类似的<code>@PostFilter</code>这里就不做演示了，它用于处理返回值，使用方法是一样的。</p><p>当有多个集合时，需要使用<code>filterTarget</code>进行指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreFilter(value = &quot;filterObject.equals(&#x27;lbwnb&#x27;)&quot;, filterTarget = &quot;list2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(List&lt;String&gt; list, List&lt;String&gt; list2)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;成功执行&quot;</span>+list);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="内部机制探究"><a href="#内部机制探究" class="headerlink" title="内部机制探究"></a>内部机制探究</h2><p>**注意：本小节内容作为选学内容，但是难度比前两章的源码部分简单得多。</p><h3 id="授权校验流程"><a href="#授权校验流程" class="headerlink" title="授权校验流程"></a>授权校验流程</h3><p>最后我们再来聊一下SpringSecurity的实现原理，它本质上是依靠N个Filter实现的，也就是一个完整的过滤链（注意这里是过滤器，不是拦截器）</p><p>我们就从<code>AbstractSecurityWebApplicationInitializer</code>开始下手，我们来看看它配置了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此方法会在启动时被调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beforeSpringSecurityFilterChain(servletContext);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.configurationClasses != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">AnnotationConfigWebApplicationContext</span> <span class="hljs-variable">rootAppContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigWebApplicationContext</span>();<br>        rootAppContext.register(<span class="hljs-built_in">this</span>.configurationClasses);<br>        servletContext.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextLoaderListener</span>(rootAppContext));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.enableHttpSessionEventPublisher()) &#123;<br>        servletContext.addListener(<span class="hljs-string">&quot;org.springframework.security.web.session.HttpSessionEventPublisher&quot;</span>);<br>    &#125;<br><br>    servletContext.setSessionTrackingModes(<span class="hljs-built_in">this</span>.getSessionTrackingModes());<br>  <span class="hljs-comment">//重点在这里，这里插入了关键的FilterChain</span><br>    <span class="hljs-built_in">this</span>.insertSpringSecurityFilterChain(servletContext);<br>    <span class="hljs-built_in">this</span>.afterSpringSecurityFilterChain(servletContext);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSpringSecurityFilterChain</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">filterName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;springSecurityFilterChain&quot;</span>;<br>  <span class="hljs-comment">//创建了一个DelegatingFilterProxy对象，它本质上也是一个Filter，但是是多个Filter的集合</span><br>    <span class="hljs-type">DelegatingFilterProxy</span> <span class="hljs-variable">springSecurityFilterChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingFilterProxy</span>(filterName);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">contextAttribute</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getWebApplicationContextAttribute();<br>    <span class="hljs-keyword">if</span> (contextAttribute != <span class="hljs-literal">null</span>) &#123;<br>        springSecurityFilterChain.setContextAttribute(contextAttribute);<br>    &#125;<br><span class="hljs-comment">//通过ServletContext注册DelegatingFilterProxy这个Filter</span><br>    <span class="hljs-built_in">this</span>.registerFilter(servletContext, <span class="hljs-literal">true</span>, filterName, springSecurityFilterChain);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看看，<code>DelegatingFilterProxy</code>在做什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个是初始化方法，它由GenericFilterBean（父类）定义，在afterPropertiesSet方法中被调用</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFilterBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>.delegateMonitor) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.delegate == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.targetBeanName == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.targetBeanName = <span class="hljs-built_in">this</span>.getFilterName();<br>            &#125;<br><br>            <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.findWebApplicationContext();<br>            <span class="hljs-keyword">if</span> (wac != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-comment">//耐心点，套娃很正常</span><br>                <span class="hljs-built_in">this</span>.delegate = <span class="hljs-built_in">this</span>.initDelegate(wac);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title function_">initDelegate</span><span class="hljs-params">(WebApplicationContext wac)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">targetBeanName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getTargetBeanName();<br>    Assert.state(targetBeanName != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No target bean name set&quot;</span>);<br>  <span class="hljs-comment">//这里通过WebApplicationContext获取了一个Bean</span><br>    <span class="hljs-type">Filter</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> (Filter)wac.getBean(targetBeanName, Filter.class);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isTargetFilterLifecycle()) &#123;<br>        delegate.init(<span class="hljs-built_in">this</span>.getFilterConfig());<br>    &#125;<br><br>  <span class="hljs-comment">//返回Filter</span><br>    <span class="hljs-keyword">return</span> delegate;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要添加一个断点来查看到底获取到了什么Bean。</p><p>通过断点调试，我们发现这里放回的对象是一个FilterChainProxy类型的，并且调用了它的初始化方法。</p><p>我们倒回去看，当Filter返回之后，<code>DelegatingFilterProxy</code>的一个成员变量<code>delegate</code>被赋值为得到的Filter，也就是FilterChainProxy对象，接着我们来看看，<code>DelegatingFilterProxy</code>是如何执行doFilter方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">Filter</span> <span class="hljs-variable">delegateToUse</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.delegate;<br>    <span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//非正常情况，这里省略...</span><br>    &#125;<br><span class="hljs-comment">//这里才是真正的调用，别忘了delegateToUse就是初始化的FilterChainProxy对象</span><br>    <span class="hljs-built_in">this</span>.invokeDelegate(delegateToUse, request, response, filterChain);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeDelegate</span><span class="hljs-params">(Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>  <span class="hljs-comment">//最后实际上调用的是FilterChainProxy的doFilter方法</span><br>    delegate.doFilter(request, response, filterChain);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们接着来看，<code>FilterChainProxy</code>的doFilter方法又在干什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">clearContext</span> <span class="hljs-operator">=</span> request.getAttribute(FILTER_APPLIED) == <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (!clearContext) &#123;<br>      <span class="hljs-comment">//真正的过滤在这里执行</span><br>        <span class="hljs-built_in">this</span>.doFilterInternal(request, response, chain);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/05/LVxihksHZu2qN6X.png" alt="image-20230705005303736"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-type">FirewalledRequest</span> <span class="hljs-variable">firewallRequest</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.firewall.getFirewalledRequest((HttpServletRequest)request);<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">firewallResponse</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.firewall.getFirewalledResponse((HttpServletResponse)response);<br>  <span class="hljs-comment">//这里获取了一个Filter列表，实际上SpringSecurity就是由N个过滤器实现的，这里获取的都是SpringSecurity提供的过滤器</span><br>  <span class="hljs-comment">//但是请注意，经过我们之前的分析，实际上真正注册的Filter只有DelegatingFilterProxy</span><br>  <span class="hljs-comment">//而这里的Filter列表中的所有Filter并没有被注册，而是在这里进行内部调用</span><br>    List&lt;Filter&gt; filters = <span class="hljs-built_in">this</span>.getFilters((HttpServletRequest)firewallRequest);<br>  <span class="hljs-comment">//只要Filter列表不是空，就依次执行内置的Filter</span><br>    <span class="hljs-keyword">if</span> (filters != <span class="hljs-literal">null</span> &amp;&amp; filters.size() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(LogMessage.of(() -&gt; &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Securing &quot;</span> + requestLine(firewallRequest);<br>            &#125;));<br>        &#125;<br><span class="hljs-comment">//这里创建一个虚拟的过滤链，过滤流程是由SpringSecurity自己实现的</span><br>        FilterChainProxy.<span class="hljs-type">VirtualFilterChain</span> <span class="hljs-variable">virtualFilterChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterChainProxy</span>.VirtualFilterChain(firewallRequest, chain, filters);<br>      <span class="hljs-comment">//调用虚拟过滤链的doFilter</span><br>        virtualFilterChain.doFilter(firewallRequest, firewallResponse);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(LogMessage.of(() -&gt; &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No security for &quot;</span> + requestLine(firewallRequest);<br>            &#125;));<br>        &#125;<br><br>        firewallRequest.reset();<br>        chain.doFilter(firewallRequest, firewallResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看一下虚拟过滤链的doFilter是怎么处理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//看似没有任何循环，实际上就是一个循环，是一个递归调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>  <span class="hljs-comment">//判断是否已经通过全部的内置过滤器，定位是否等于当前大小</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.currentPosition == <span class="hljs-built_in">this</span>.size) &#123;<br>        <span class="hljs-keyword">if</span> (FilterChainProxy.logger.isDebugEnabled()) &#123;<br>            FilterChainProxy.logger.debug(LogMessage.of(() -&gt; &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Secured &quot;</span> + FilterChainProxy.requestLine(<span class="hljs-built_in">this</span>.firewalledRequest);<br>            &#125;));<br>        &#125;<br><br>        <span class="hljs-built_in">this</span>.firewalledRequest.reset();<br>      <span class="hljs-comment">//所有的内置过滤器已经完成，按照正常流程走DelegatingFilterProxy的下一个Filter</span><br>      <span class="hljs-comment">//也就是说这里之后就与DelegatingFilterProxy没有任何关系了，该走其他过滤器就走其他地方配置的过滤器，SpringSecurity的过滤操作已经结束</span><br>        <span class="hljs-built_in">this</span>.originalChain.doFilter(request, response);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//定位自增</span><br>        ++<span class="hljs-built_in">this</span>.currentPosition;<br>      <span class="hljs-comment">//获取当前定位的Filter</span><br>        <span class="hljs-type">Filter</span> <span class="hljs-variable">nextFilter</span> <span class="hljs-operator">=</span> (Filter)<span class="hljs-built_in">this</span>.additionalFilters.get(<span class="hljs-built_in">this</span>.currentPosition - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (FilterChainProxy.logger.isTraceEnabled()) &#123;<br>            FilterChainProxy.logger.trace(LogMessage.format(<span class="hljs-string">&quot;Invoking %s (%d/%d)&quot;</span>, nextFilter.getClass().getSimpleName(), <span class="hljs-built_in">this</span>.currentPosition, <span class="hljs-built_in">this</span>.size));<br>        &#125;<br><span class="hljs-comment">//执行内部过滤器的doFilter方法，传入当前对象本身作为Filter，执行如果成功，那么一定会再次调用当前对象的doFilter方法</span><br>      <span class="hljs-comment">//可能最不理解的就是这里，执行的难道不是内部其他Filter的doFilter方法吗，怎么会让当前对象的doFilter方法递归调用呢？</span><br>      <span class="hljs-comment">//没关系，下面我们接着了解了其中一个内部过滤器就明白了</span><br>        nextFilter.doFilter(request, response, <span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们差不多已经了解了整个SpringSecurity的实现机制了，那么我们来随便看一个内部的过滤器在做什么。</p><p>比如用于处理登陆的过滤器<code>UsernamePasswordAuthenticationFilter</code>，它继承自<code>AbstractAuthenticationProcessingFilter</code>，我们来看看它是怎么进行过滤的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-built_in">this</span>.doFilter((HttpServletRequest)request, (HttpServletResponse)response, chain);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>  <span class="hljs-comment">//如果不是登陆请求，那么根本不会理这个请求</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.requiresAuthentication(request, response)) &#123;<br>      <span class="hljs-comment">//直接调用传入的FilterChain的doFilter方法</span><br>      <span class="hljs-comment">//而这里传入的正好是VirtualFilterChain对象</span><br>      <span class="hljs-comment">//这下知道为什么上面说是递归了吧</span><br>        chain.doFilter(request, response);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果是登陆请求，那么会执行登陆请求的相关逻辑，注意执行过程中出现任何问题都会抛出异常</span><br>      <span class="hljs-comment">//比如用户名和密码错误，我们之前也已经测试过了，会得到一个BadCredentialsException</span><br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//进行认证</span><br>            <span class="hljs-type">Authentication</span> <span class="hljs-variable">authenticationResult</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.attemptAuthentication(request, response);<br>            <span class="hljs-keyword">if</span> (authenticationResult == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-built_in">this</span>.sessionStrategy.onAuthentication(authenticationResult, request, response);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.continueChainBeforeSuccessfulAuthentication) &#123;<br>                chain.doFilter(request, response);<br>            &#125;<br><br>          <span class="hljs-comment">//如果一路绿灯，没有报错，那么验证成功，执行successfulAuthentication</span><br>            <span class="hljs-built_in">this</span>.successfulAuthentication(request, response, chain, authenticationResult);<br>        &#125; <span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException var5) &#123;<br>            <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>, var5);<br>          <span class="hljs-comment">//验证失败，会执行unsuccessfulAuthentication</span><br>            <span class="hljs-built_in">this</span>.unsuccessfulAuthentication(request, response, var5);<br>        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException var6) &#123;<br>            <span class="hljs-built_in">this</span>.unsuccessfulAuthentication(request, response, var6);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们来看看successfulAuthentication和unsuccessfulAuthentication分别做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>  <span class="hljs-comment">//向SecurityContextHolder添加认证信息，我们可以通过SecurityContextHolder对象获取当前登陆的用户</span><br>    SecurityContextHolder.getContext().setAuthentication(authResult);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.debug(LogMessage.format(<span class="hljs-string">&quot;Set SecurityContextHolder to %s&quot;</span>, authResult));<br>    &#125;<br><br>  <span class="hljs-comment">//记住我实现</span><br>    <span class="hljs-built_in">this</span>.rememberMeServices.loginSuccess(request, response, authResult);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.eventPublisher != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.eventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InteractiveAuthenticationSuccessEvent</span>(authResult, <span class="hljs-built_in">this</span>.getClass()));<br>    &#125;<br><br>  <span class="hljs-comment">//调用默认的或是我们自己定义的AuthenticationSuccessHandler的onAuthenticationSuccess方法</span><br>  <span class="hljs-comment">//这个根据我们配置文件决定</span><br>  <span class="hljs-comment">//到这里其实页面就已经直接跳转了</span><br>    <span class="hljs-built_in">this</span>.successHandler.onAuthenticationSuccess(request, response, authResult);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>  <span class="hljs-comment">//登陆失败会直接清理掉SecurityContextHolder中的认证信息</span><br>    SecurityContextHolder.clearContext();<br>    <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Failed to process authentication request&quot;</span>, failed);<br>    <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Cleared SecurityContextHolder&quot;</span>);<br>    <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Handling authentication failure&quot;</span>);<br>  <span class="hljs-comment">//登陆失败的记住我处理</span><br>    <span class="hljs-built_in">this</span>.rememberMeServices.loginFail(request, response);<br>  <span class="hljs-comment">//同上，调用默认或是我们自己定义的AuthenticationFailureHandler</span><br>    <span class="hljs-built_in">this</span>.failureHandler.onAuthenticationFailure(request, response, failed);<br>&#125;<br></code></pre></td></tr></table></figure><p>了解了整个用户验证实现流程，其实其它的过滤器是如何实现的也就很容易联想到了，SpringSecurity的过滤器从某种意义上来说，更像是一个处理业务的Servlet，它做的事情不像是拦截，更像是完成自己对应的职责，只不过是使用了过滤器机制进行实现罢了，从而将所有的验证提前到进入Controller之前。</p><p>最后附上完整的过滤器清单，这里列出14个常见的内部过滤器：</p><table><thead><tr><th>过滤器名称</th><th>职责</th></tr></thead><tbody><tr><td>DisableEncodeUrlFilter</td><td>禁止 HttpServletResponse 对 URL 进行编码，以防止在 URL 中包含 Session ID，此类 URL 不被视为 URL，因为会话 ID 可能会在 HTTP 访问日志等内容中泄露。</td></tr><tr><td>WebAsyncManagerIntegrationFilter</td><td>实现了对SecurityContext与WebAsyncManager的集成，使 Controller 中能够线程安全地获取到用户上下文认证信息。</td></tr><tr><td>SecurityContextHolderFilter</td><td>通过HttpSessionSecurityContextRepository接口从Session中读取SecurityContext或是直接创建新的，然后存入到SecurityContextHolder中，最后请求结束时会进行清理。</td></tr><tr><td>HeaderWriterFilter</td><td>给HTTP响应添加一些Header属性，如：X-Frame-Options、X-XSS-Protection、X-Content-Type-Options等。</td></tr><tr><td>CsrfFilter</td><td>针对Csrf相关校验。</td></tr><tr><td>LogoutFilter</td><td>对退出登录的请求进行处理，执行登出操作。</td></tr><tr><td>UsernamePasswordAuthenticationFilter</td><td>对登录的请求进行处理，执行登录操作。</td></tr><tr><td>ConcurrentSessionFilter</td><td>检查SessionRegistry保存的Session信息是否过期。</td></tr><tr><td>RequestCacheAwareFilter</td><td>缓存Request请求，可以用于恢复因登录而打断的请求。</td></tr><tr><td>SecurityContextHolderAwareRequestFilter</td><td>对ServletRequest进行进一步包装，让Request具有更加丰富的内容。</td></tr><tr><td>RememberMeAuthenticationFilter</td><td>针对于记住我Cookie进行校验。</td></tr><tr><td>AnonymousAuthenticationFilter</td><td>未验证成功的情况下进行匿名登录操作。</td></tr><tr><td>SessionManagementFilter</td><td>Session管理相关。</td></tr><tr><td>ExceptionTranslationFilter</td><td>异常转换处理，比如最常见的AccessDenied之类的。</td></tr></tbody></table><h3 id="安全上下文"><a href="#安全上下文" class="headerlink" title="安全上下文"></a>安全上下文</h3><p>用户登录之后，怎么获取当前已经登录用户的信息呢？通过使用SecurityContextHolder就可以很方便地得到SecurityContext对象了，我们可以直接使用SecurityContext对象来获取当前的认证信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext();<br>        <span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> context.getAuthentication();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) authentication.getPrincipal();<br>        System.out.println(user.getUsername());<br>        System.out.println(user.getAuthorities());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过SecurityContext我们就可以快速获取当前用户的名称和授权信息等：</p><p><img src="https://s2.loli.net/2023/07/06/uPjdsgbhv9NqA8B.png" alt="image-20230706215806040"></p><p>除了这种方式以外，我们还可以直接从Session中获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@SessionAttribute(&quot;SPRING_SECURITY_CONTEXT&quot;)</span> SecurityContext context)</span>&#123;<br>    <span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> context.getAuthentication();<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) authentication.getPrincipal();<br>    System.out.println(user.getUsername());<br>    System.out.println(user.getAuthorities());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意SecurityContextHolder是有一定的存储策略的，SecurityContextHolder中的SecurityContext对象会在一开始请求到来时被设定，至于存储方式其实是由存储策略决定的，如果我们这样编写，那么在默认情况下是无法获取到认证信息的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;   <span class="hljs-comment">//创建一个子线程去获取</span><br>        <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext();<br>        <span class="hljs-type">Authentication</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span> context.getAuthentication();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) authentication.getPrincipal();   <span class="hljs-comment">//NPE</span><br>        System.out.println(user.getUsername());<br>        System.out.println(user.getAuthorities()); <br>    &#125;).start();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是因为SecurityContextHolder的存储策略默认是<code>MODE_THREADLOCAL</code>，它是基于ThreadLocal实现的，<code>getContext()</code>方法本质上调用的是对应的存储策略实现的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> strategy.getContext();<br>&#125;<br></code></pre></td></tr></table></figure><p>SecurityContextHolderStrategy有三个实现类：</p><ul><li>GlobalSecurityContextHolderStrategy：全局模式，不常用</li><li>ThreadLocalSecurityContextHolderStrategy：基于ThreadLocal实现，线程内可见</li><li>InheritableThreadLocalSecurityContextHolderStrategy：基于InheritableThreadLocal实现，线程和子线程可见</li></ul><p>因此，如果上述情况需要在子线程中获取，那么需要修改SecurityContextHolder的存储策略，在初始化的时候设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在子线程中也可以获取认证信息了。</p><p>因为用户的验证信息是基于SecurityContext进行判断的，我们可以直接修改SecurityContext的内容，来手动为用户进行登陆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/auth&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">auth</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext();  <span class="hljs-comment">//获取SecurityContext对象（当前会话肯定是没有登陆的）</span><br>    <span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(<span class="hljs-string">&quot;Test&quot;</span>, <span class="hljs-literal">null</span>,<br>            AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">&quot;ROLE_user&quot;</span>));  <span class="hljs-comment">//手动创建一个UsernamePasswordAuthenticationToken对象，也就是用户的认证信息，角色需要添加ROLE_前缀，权限直接写</span><br>    context.setAuthentication(token);  <span class="hljs-comment">//手动为SecurityContext设定认证信息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Login success！&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在未登陆的情况下，访问此地址将直接进行手动登陆，再次访问<code>/index</code>页面，可以直接访问，说明手动设置认证信息成功。</p><blockquote><p>疑惑：SecurityContext这玩意不是默认线程独占吗，那每次请求都是一个新的线程，按理说上一次的SecurityContext对象应该没了才对啊，为什么再次请求依然能够继续使用上一次SecurityContext中的认证信息呢？</p></blockquote><p>SecurityContext的生命周期：请求到来时从Session中取出，放入SecurityContextHolder中，请求结束时从SecurityContextHolder取出，并放到Session中，实际上就是依靠Session来存储的，一旦会话过期验证信息也跟着消失。</p><h3 id="安全上下文持久化过滤器"><a href="#安全上下文持久化过滤器" class="headerlink" title="安全上下文持久化过滤器"></a>安全上下文持久化过滤器</h3><p>SecurityContextHolderFilter也是内置的Filter，它就是专门用于处理SecurityContext的，这里先说一下大致流程，以便我们后续更加方便地理解：</p><blockquote><p>当过滤器链执行到SecurityContextHolderFilter时，它会从HttpSession中把SecurityContext对象取出来（是存在Session中的，跟随会话的消失而消失），然后放入SecurityContextHolder对象中。请求结束后，再把SecurityContext存入HttpSession中，并清除SecurityContextHolder内的SecurityContext对象。</p></blockquote><p>我们还是直接进入到源码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>   <span class="hljs-comment">//开始套娃</span><br>doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span><br><span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>   <span class="hljs-comment">//防止重复的安全请求，不需要关心，一般是直接走下面</span><br><span class="hljs-keyword">if</span> (request.getAttribute(FILTER_APPLIED) != <span class="hljs-literal">null</span>) &#123;<br>chain.doFilter(request, response);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>request.setAttribute(FILTER_APPLIED, Boolean.TRUE);<br>   <span class="hljs-comment">//这里通过SecurityContextRepository的loadDeferredContext获取到SecurityContext对象的Supplier</span><br>Supplier&lt;SecurityContext&gt; deferredContext = <span class="hljs-built_in">this</span>.securityContextRepository.loadDeferredContext(request);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>loadDeferredContext</code>的实现细节，其中SecurityContextRepository的实现类是DelegatingSecurityContextRepository类，这个类中维护了多个SecurityContextRepository实现类，而其本身并没有实现<code>loadDeferredContext</code>方法，而是靠内部维护的其他SecurityContextRepository实现类来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DeferredSecurityContext <span class="hljs-title function_">loadDeferredContext</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>   <span class="hljs-comment">//DeferredSecurityContext是一个支持延时生成的SecurityContext，本质是一个SecurityContext的Supplier</span><br><span class="hljs-type">DeferredSecurityContext</span> <span class="hljs-variable">deferredSecurityContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-comment">//遍历内部维护的其他SecurityContextRepository实现，一般包含以下两个：</span><br>   <span class="hljs-comment">//1. HttpSessionSecurityContextRepository</span><br>   <span class="hljs-comment">//2. RequestAttributeSecurityContextRepository</span><br><span class="hljs-keyword">for</span> (SecurityContextRepository delegate : <span class="hljs-built_in">this</span>.delegates) &#123;<br>     <span class="hljs-comment">//这个if-else语句其实为了添加多个SecurityContextRepository提供的SecurityContext并将其组成一个链状结构的DelegatingDeferredSecurityContext（至于为什么，我们接着往下看）</span><br><span class="hljs-keyword">if</span> (deferredSecurityContext == <span class="hljs-literal">null</span>) &#123;<br>deferredSecurityContext = delegate.loadDeferredContext(request);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">DeferredSecurityContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> delegate.loadDeferredContext(request);<br>deferredSecurityContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingDeferredSecurityContext</span>(deferredSecurityContext, next);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> deferredSecurityContext;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们来看第一个HttpSessionSecurityContextRepository，它是第一个被遍历的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DeferredSecurityContext <span class="hljs-title function_">loadDeferredContext</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>Supplier&lt;SecurityContext&gt; supplier = () -&gt; readSecurityContextFromSession(request.getSession(<span class="hljs-literal">false</span>));  <span class="hljs-comment">//从Session中取出SecurityContext</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupplierDeferredSecurityContext</span>(supplier, <span class="hljs-built_in">this</span>.securityContextHolderStrategy);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SPRING_SECURITY_CONTEXT_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SPRING_SECURITY_CONTEXT&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">springSecurityContextKey</span> <span class="hljs-operator">=</span> SPRING_SECURITY_CONTEXT_KEY;<br><br><span class="hljs-keyword">private</span> SecurityContext <span class="hljs-title function_">readSecurityContextFromSession</span><span class="hljs-params">(HttpSession httpSession)</span> &#123;<br>...<br>   <span class="hljs-comment">//实际上这里就是从Session中通过键“SPRING_SECURITY_CONTEXT”取出的SecurityContext</span><br>   <span class="hljs-comment">//跟我们上一节使用的是完全一样的，这下就很清晰了</span><br>   <span class="hljs-comment">//如果用户没有登录验证，那么这里获取到的SecurityContext就是null了</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">contextFromSession</span> <span class="hljs-operator">=</span> httpSession.getAttribute(<span class="hljs-built_in">this</span>.springSecurityContextKey);<br>...<br><span class="hljs-keyword">return</span> (SecurityContext) contextFromSession;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后返回回去的是一个SupplierDeferredSecurityContext对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SupplierDeferredSecurityContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeferredSecurityContext</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LogFactory.getLog(SupplierDeferredSecurityContext.class);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Supplier&lt;SecurityContext&gt; supplier;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SecurityContextHolderStrategy strategy;<br><br><span class="hljs-keyword">private</span> SecurityContext securityContext;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> missingContext;<br><br>SupplierDeferredSecurityContext(Supplier&lt;SecurityContext&gt; supplier, SecurityContextHolderStrategy strategy) &#123;<br><span class="hljs-built_in">this</span>.supplier = supplier;<br><span class="hljs-built_in">this</span>.strategy = strategy;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//在获取SecurityContext时会进行一次初始化</span><br>init();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.securityContext;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGenerated</span><span class="hljs-params">()</span> &#123;<br>init();<br>    <span class="hljs-comment">//初始化后判断是否为未登录的SecurityContext</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.missingContext;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//如果securityContext不为null表示已经初始化过了</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.securityContext != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//直接通过supplier获取securityContext对象</span><br><span class="hljs-built_in">this</span>.securityContext = <span class="hljs-built_in">this</span>.supplier.get();<br>    <span class="hljs-comment">//如果securityContext对象为null，那么就标记missingContext</span><br><span class="hljs-built_in">this</span>.missingContext = (<span class="hljs-built_in">this</span>.securityContext == <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.missingContext) &#123;<br>      <span class="hljs-comment">//当missingContext为真时，说明没有securityContext（一般是未登录的情况）</span><br>      <span class="hljs-comment">//那么就创建一个空的securityContext，不包含任何认证信息</span><br><span class="hljs-built_in">this</span>.securityContext = <span class="hljs-built_in">this</span>.strategy.createEmptyContext();<br>      <span class="hljs-comment">//日志无视就好</span><br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(LogMessage.format(<span class="hljs-string">&quot;Created %s&quot;</span>, <span class="hljs-built_in">this</span>.securityContext));<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接着是第二个被遍历的实现RequestAttributeSecurityContextRepository类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DeferredSecurityContext <span class="hljs-title function_">loadDeferredContext</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>Supplier&lt;SecurityContext&gt; supplier = () -&gt; getContext(request);<br>   <span class="hljs-comment">//同样是返回SupplierDeferredSecurityContext对象</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupplierDeferredSecurityContext</span>(supplier, <span class="hljs-built_in">this</span>.securityContextHolderStrategy);<br>&#125;<br><br><span class="hljs-keyword">private</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>   <span class="hljs-comment">//通过HttpServletRequest的Attribute获取SecurityContext</span><br>   <span class="hljs-comment">//由于一般情况下没有设定过，因此得到的就是null</span><br><span class="hljs-keyword">return</span> (SecurityContext) request.getAttribute(<span class="hljs-built_in">this</span>.requestAttributeName);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，两个SecurityContext就会以链式存放在DelegatingDeferredSecurityContext对象中，一并返回了，它的内部长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatingDeferredSecurityContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeferredSecurityContext</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DeferredSecurityContext previous;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DeferredSecurityContext next;<br><br>DelegatingDeferredSecurityContext(DeferredSecurityContext previous, DeferredSecurityContext next) &#123;<br><span class="hljs-built_in">this</span>.previous = previous;<br><span class="hljs-built_in">this</span>.next = next;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//在获取SecurityContext时，会首先从最前面的开始获取</span><br><span class="hljs-type">SecurityContext</span> <span class="hljs-variable">securityContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.previous.get();<br>      <span class="hljs-comment">//如果最前面的SecurityContext是已登录的，那么直接返回这个SecurityContext</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.previous.isGenerated()) &#123;<br><span class="hljs-keyword">return</span> securityContext;<br>&#125;<br>      <span class="hljs-comment">//否则继续看后面的，也许后面的会有已登录的（实在没有就直接返回一个空的SecurityContext了）</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.next.get();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGenerated</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.previous.isGenerated() &amp;&amp; <span class="hljs-built_in">this</span>.next.isGenerated();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>兜了这么大一圈，现在回到一开始的Filter中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span><br><span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>...<br>   Supplier&lt;SecurityContext&gt; deferredContext = <span class="hljs-built_in">this</span>.securityContextRepository.loadDeferredContext(request);<br>   <span class="hljs-comment">//拿到最终的SecurityContext的Supplier后，继续下面的语句</span><br><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//向securityContextHolderStrategy中设置我们上面得到的DeferredSecurityContext</span><br><span class="hljs-built_in">this</span>.securityContextHolderStrategy.setDeferredContext(deferredContext);<br>     <span class="hljs-comment">//请求前的任务已完成，继续其他过滤器了</span><br>chain.doFilter(request, response);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>     <span class="hljs-comment">//请求结束后，清理掉securityContextHolderStrategy中的DeferredSecurityContext</span><br><span class="hljs-built_in">this</span>.securityContextHolderStrategy.clearContext();<br>request.removeAttribute(FILTER_APPLIED);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们再来看一下我们之前通过SecurityContextHolder是如何获取到SecurityContext的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityContextHolder</span> &#123;<br>...<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">strategyName</span> <span class="hljs-operator">=</span> System.getProperty(SYSTEM_PROPERTY);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SecurityContextHolderStrategy strategy;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">initializeCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">//类加载时会进行一次初始化</span><br>initialize();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//初始化会将对应的SecurityContextHolderStrategy对象给创建</span><br>initializeStrategy();<br>initializeCount++;<br>&#125;<br><br>  <span class="hljs-comment">//初始化SecurityContextHolderStrategy对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeStrategy</span><span class="hljs-params">()</span> &#123;<br>...<br><span class="hljs-comment">// 尝试加载系统配置中设定的Strategy实现类，默认是MODE_THREADLOCAL</span><br><span class="hljs-keyword">try</span> &#123;<br>Class&lt;?&gt; clazz = Class.forName(strategyName);<br>Constructor&lt;?&gt; customStrategy = clazz.getConstructor();<br>      <span class="hljs-comment">// 这里直接根据配置中的类名，用反射怒艹一个对象出来</span><br>strategy = (SecurityContextHolderStrategy) customStrategy.newInstance();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>ReflectionUtils.handleReflectionException(ex);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//清除Context中的内容，实际上就是清理SecurityContextHolderStrategy中的内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span> &#123;<br>strategy.clearContext();<br>&#125;<br><br><span class="hljs-comment">//获取SecurityContext对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取SecurityContext实际上也是通过SecurityContextHolderStrategy根据策略来获取</span><br><span class="hljs-keyword">return</span> strategy.getContext();<br>&#125;<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，实际上SecurityContextHolder获取SecurityContext对象，就是通过SecurityContextHolderStrategy根据策略来获取，我们直接来看SecurityContextHolderStrategy的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalSecurityContextHolderStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SecurityContextHolderStrategy</span> &#123;<br><br>  <span class="hljs-comment">//内部维护一个ThreadLocal对象，按线程存储对应的DeferredSecurityContext</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Supplier&lt;SecurityContext&gt;&gt; contextHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//清理实际上是直接清理掉ThreadLocal中存的对象</span><br>contextHolder.remove();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SecurityContext <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取也很简单，直接通过Supplier拿到需要的SecurityContext对象</span><br><span class="hljs-keyword">return</span> getDeferredContext().get();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Supplier&lt;SecurityContext&gt; <span class="hljs-title function_">getDeferredContext</span><span class="hljs-params">()</span> &#123;<br>Supplier&lt;SecurityContext&gt; result = contextHolder.get();<br>    <span class="hljs-comment">//如果存储的DeferredSecurityContext为null，这里临时创建一个空的SecurityContext并保存</span><br><span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">SecurityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> createEmptyContext();<br>result = () -&gt; context;<br>contextHolder.set(result);<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br>...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，整个流程其实就很清楚了，项目启动时，SecurityContextHolder会自动根据配置创建对应的SecurityContextHolderStrategy对象。当我们的请求到来之后，首先会经过SecurityContextHolderFilter，然后在这个阶段，通过SecurityContextRepository来将不同地方存储（一般是Session中存储）的SecurityContext对象取出并封装为DefferdSecurityContext，然后将其添加到一开始创建好的SecurityContextHolderStrategy对象中，这样，我们的Controller在处理时就能直接从SecurityContextHolder取出SecurityContext对象了，最后在处理结束返回响应时，SecurityContextHolderFilter也会将SecurityContextHolderStrategy存储的DefferdSecurityContext清除掉，至此，一个完整流程结束。</p><hr><h1 id="SpringSecurity常用配置"><a href="#SpringSecurity常用配置" class="headerlink" title="SpringSecurity常用配置"></a>SpringSecurity常用配置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.springsecurity.config;  <br>  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;  <br><span class="hljs-keyword">import</span> org.springframework.security.authentication.AuthenticationManager;  <br><span class="hljs-keyword">import</span> org.springframework.security.authentication.ProviderManager;  <br><span class="hljs-keyword">import</span> org.springframework.security.authentication.dao.DaoAuthenticationProvider;  <br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;  <br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  <br><span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  <br><span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;  <br><span class="hljs-keyword">import</span> org.springframework.security.provisioning.UserDetailsManager;  <br><span class="hljs-keyword">import</span> org.springframework.security.web.SecurityFilterChain;  <br><span class="hljs-keyword">import</span> org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;  <br><span class="hljs-keyword">import</span> org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;  <br>  <br><span class="hljs-keyword">import</span> javax.sql.DataSource;  <br>  <br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-meta">@EnableWebSecurity</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;  <br>  <br>  <br>    <span class="hljs-comment">//手动创建一个AuthenticationManager用于处理密码校验  </span><br>    <span class="hljs-keyword">private</span> AuthenticationManager <span class="hljs-title function_">authenticationManager</span><span class="hljs-params">(UserDetailsManager manager,  </span><br><span class="hljs-params">                                                        PasswordEncoder encoder)</span> &#123;  <br>        <span class="hljs-type">DaoAuthenticationProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaoAuthenticationProvider</span>();  <br>        provider.setUserDetailsService(manager);  <br>        provider.setPasswordEncoder(encoder);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProviderManager</span>(provider);  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//这里将BCryptPasswordEncoder直接注册为Bean，Security会自动进行选择  </span><br>    <span class="hljs-meta">@Bean</span>  <br>    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span> &#123;  <br><span class="hljs-comment">//        System.out.println(new BCryptPasswordEncoder().encode(&quot;123456&quot;));  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BCryptPasswordEncoder</span>();  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-meta">@Bean</span>  <br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http, PersistentTokenRepository repository)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">return</span> http  <br>                .authorizeHttpRequests(authorize -&gt; &#123;  <br>                    authorize.requestMatchers(<span class="hljs-string">&quot;/assets/**&quot;</span>).permitAll();   <span class="hljs-comment">//将所有的静态资源放行，一定要添加在全部请求拦截之前  </span><br><span class="hljs-comment">//                    authorize.requestMatchers(&quot;/&quot;).hasAnyRole(&quot;user&quot;, &quot;admin&quot;);  </span><br><span class="hljs-comment">//                    authorize.anyRequest().hasRole(&quot;admin&quot;);  </span><br>                    authorize.anyRequest().authenticated();  <br>                &#125;)  <br><span class="hljs-comment">//                登录相关配置  </span><br>                .formLogin(conf -&gt; &#123;  <br>                    conf.loginPage(<span class="hljs-string">&quot;/login&quot;</span>);  <br>                    conf.loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);  <br>                    conf.failureUrl(<span class="hljs-string">&quot;/login?error&quot;</span>);  <br>                    conf.defaultSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);  <br>                    conf.permitAll();  <br>                    conf.usernameParameter(<span class="hljs-string">&quot;username&quot;</span>);  <br>                    conf.passwordParameter(<span class="hljs-string">&quot;password&quot;</span>);  <br>                &#125;)  <br>                <span class="hljs-comment">//以下是退出登录相关配置  </span><br>                .logout(conf -&gt; &#123;  <br>                    conf.logoutUrl(<span class="hljs-string">&quot;/doLogout&quot;</span>);   <span class="hljs-comment">//退出登录地址，跟上面一样可自定义  </span><br>                    conf.logoutSuccessUrl(<span class="hljs-string">&quot;/login&quot;</span>);  <span class="hljs-comment">//退出登录成功后跳转的地址，这里设置为登录界面  </span><br>                    conf.permitAll();  <br>                &#125;)  <br>                <span class="hljs-comment">//以下是csrf相关配置  </span><br>                .csrf(conf -&gt; &#123;  <br>                    conf.disable();   <span class="hljs-comment">//此方法可以直接关闭全部的csrf校验，一步到位  </span><br><span class="hljs-comment">//                    conf.ignoringRequestMatchers(&quot;/xxx/**&quot;);   //此方法可以根据情况忽略某些地址的csrf校验  </span><br>                &#125;)  <br>                .rememberMe(conf -&gt; &#123;  <br>                    conf.rememberMeParameter(<span class="hljs-string">&quot;remember-me&quot;</span>);  <br>                    conf.tokenRepository(repository);  <br>                    conf.tokenValiditySeconds(<span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);  <br>                &#125;)  <br>                .build();  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//    基于数据库的记住我，防止基于内存服务器重启将失效  </span><br>    <span class="hljs-meta">@Bean</span>  <br>    <span class="hljs-keyword">public</span> PersistentTokenRepository <span class="hljs-title function_">tokenRepository</span><span class="hljs-params">(DataSource dataSource)</span> &#123;  <br>        <span class="hljs-type">JdbcTokenRepositoryImpl</span> <span class="hljs-variable">repository</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTokenRepositoryImpl</span>();  <br><span class="hljs-comment">//        repository.setCreateTableOnStartup(true);  </span><br>        repository.setDataSource(dataSource);  <br>        <span class="hljs-keyword">return</span> repository;  <br>    &#125;  <br><span class="hljs-comment">//    @Bean  </span><br><span class="hljs-comment">//    public UserDetailsService userDetailsService(DataSource dataSource,  </span><br><span class="hljs-comment">//                                                 PasswordEncoder encoder) &#123;  </span><br><span class="hljs-comment">//        JdbcUserDetailsManager manager = new JdbcUserDetailsManager(dataSource);  </span><br><span class="hljs-comment">//        //仅首次启动时创建一个新的用户用于测试，后续无需创建  </span><br><span class="hljs-comment">////        manager.createUser(User.withUsername(&quot;user&quot;)  </span><br><span class="hljs-comment">////                .password(encoder.encode(&quot;123123&quot;)).roles(&quot;USER&quot;).build());  </span><br><span class="hljs-comment">//        //为UserDetailsManager设置AuthenticationManager即可开启重置密码的时的校验  </span><br><span class="hljs-comment">////        manager.setAuthenticationManager(authenticationManager(manager, encoder));  </span><br><span class="hljs-comment">//        return manager;  </span><br><span class="hljs-comment">//    &#125;  </span><br>  <br><span class="hljs-comment">//    @Bean   //UserDetailsService就是获取用户信息的服务  </span><br><span class="hljs-comment">//    public UserDetailsService userDetailsService(PasswordEncoder encoder) &#123;  </span><br><span class="hljs-comment">//        //每一个UserDetails就代表一个用户信息，其中包含用户的用户名和密码以及角色  </span><br><span class="hljs-comment">//        UserDetails user = User  </span><br><span class="hljs-comment">//                .withUsername(&quot;user&quot;)  </span><br><span class="hljs-comment">//                .password(encoder.encode(&quot;123123&quot;))  </span><br><span class="hljs-comment">//                .roles(&quot;USER&quot;)  //角色目前我们不需要关心，随便写就行，后面会专门讲解  </span><br><span class="hljs-comment">//                .build();  </span><br><span class="hljs-comment">//        UserDetails admin = User  </span><br><span class="hljs-comment">//                .withUsername(&quot;admin&quot;)  </span><br><span class="hljs-comment">//                .password(encoder.encode(&quot;123123&quot;))  </span><br><span class="hljs-comment">//                .roles(&quot;ADMIN&quot;, &quot;USER&quot;)  </span><br><span class="hljs-comment">//                .build();  </span><br><span class="hljs-comment">//        return new InMemoryUserDetailsManager(user, admin);  </span><br><span class="hljs-comment">//        //创建一个基于内存的用户信息管理器作为UserDetailsService  </span><br><span class="hljs-comment">//    &#125;  </span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>自定义验证：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.springsecurity.service.impl;  <br>  <br><span class="hljs-keyword">import</span> com.example.springsecurity.entity.User;  <br><span class="hljs-keyword">import</span> com.example.springsecurity.mapper.UserMapper;  <br><span class="hljs-keyword">import</span> jakarta.annotation.Resource;  <br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;  <br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;  <br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;  <br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 自定义SpringSecurity认证校验规则 */</span><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;  <br>    <span class="hljs-meta">@Resource</span>  <br>    UserMapper mapper;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.getUserByUsername(username);  <br><span class="hljs-comment">//        System.out.println(user);  </span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> org.springframework.security.core.userdetails.User  <br>                .withUsername(user.getName())  <br>                .password(user.getPwd())  <br>                .roles(user.getRole())  <br>                .build();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://itbaima.net/<br>title: &quot;柏码 - 让每一行代码都闪耀智慧的光芒！&quot;<br>host: itbaima.net<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><p><a href="https://itbaima.net/">柏码 - 让每一行代码都闪耀智慧的光芒！</a></p>]]></content>
    
    
    <summary type="html">a lot of notes dealing with SpringSecurity</summary>
    
    
    
    <category term="前后端开发" scheme="https://alleyf.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JWT" scheme="https://alleyf.github.io/tags/JWT/"/>
    
    <category term="SpingSecurity" scheme="https://alleyf.github.io/tags/SpingSecurity/"/>
    
  </entry>
  
  <entry>
    <title>周会</title>
    <link href="https://alleyf.github.io/2023/11/47f9bf6ba53a.html"/>
    <id>https://alleyf.github.io/2023/11/47f9bf6ba53a.html</id>
    <published>2023-11-13T14:02:25.000Z</published>
    <updated>2023-11-18T14:44:37.158Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><hr><h1 id="2023-10-7（项目例会）"><a href="#2023-10-7（项目例会）" class="headerlink" title="2023-10-7（项目例会）"></a>2023-10-7（项目例会）</h1><ol><li>从开始就将每个任务细节想好怎么做，防止后续出现问题</li><li>学习任何技术，了解其特点，包括优劣势，帮助后续技术选型架构，保证针对需求最合适</li><li>多读论文，写论文投稿，根据反馈意见不断修改调整，提高自己撰写论文能力水平，为毕业论文打好基础</li></ol><hr><h1 id="2023-10-13（学术例会）"><a href="#2023-10-13（学术例会）" class="headerlink" title="2023-10-13（学术例会）"></a>2023-10-13（学术例会）</h1><h3 id="1-基于实体关系对齐的知识融合"><a href="#1-基于实体关系对齐的知识融合" class="headerlink" title="1. 基于实体关系对齐的知识融合"></a>1. 基于实体关系对齐的知识融合</h3><h2 id="2-UIE-结合大模型基底进行信息抽取1-法律法规知识图谱与司法案件知识图谱双图谱，探究两者之间的关系进行知识融合2-首先，通过聆听开始两位学长的学术汇报分享以及后续各位老师和学长学姐们对国家自然科学基金项目的讨论，让我对知识图谱领域有了一定的认知和了解，为未来的学术学习和研究指明了方向。"><a href="#2-UIE-结合大模型基底进行信息抽取1-法律法规知识图谱与司法案件知识图谱双图谱，探究两者之间的关系进行知识融合2-首先，通过聆听开始两位学长的学术汇报分享以及后续各位老师和学长学姐们对国家自然科学基金项目的讨论，让我对知识图谱领域有了一定的认知和了解，为未来的学术学习和研究指明了方向。" class="headerlink" title="### 2. UIE 结合大模型基底进行信息抽取1. 法律法规知识图谱与司法案件知识图谱双图谱，探究两者之间的关系进行知识融合2. 首先，通过聆听开始两位学长的学术汇报分享以及后续各位老师和学长学姐们对国家自然科学基金项目的讨论，让我对知识图谱领域有了一定的认知和了解，为未来的学术学习和研究指明了方向。"></a><img src="C:\Users\alleyf\AppData\Roaming\Typora\typora-user-images\image-20231013193947905.png" alt="image-20231013193947905"><br>### 2. UIE 结合大模型基底进行信息抽取<br><img src="C:\Users\alleyf\AppData\Roaming\Typora\typora-user-images\image-20231013194845768.png" alt="image-20231013194845768"><br><img src="C:\Users\alleyf\AppData\Roaming\Typora\typora-user-images\image-20231013200303506.png" alt="image-20231013200303506"><br><img src="C:\Users\alleyf\AppData\Roaming\Typora\typora-user-images\image-20231013203344354.png" alt="image-20231013203344354"><br>1. 法律法规知识图谱与司法案件知识图谱双图谱，探究两者之间的关系进行知识融合<br>2. 首先，通过聆听开始两位学长的学术汇报分享以及后续各位老师和学长学姐们对国家自然科学基金项目的讨论，让我对知识图谱领域有了一定的认知和了解，为未来的学术学习和研究指明了方向。</h2><h1 id="2023-10-15（项目例会）"><a href="#2023-10-15（项目例会）" class="headerlink" title="2023-10-15（项目例会）"></a>2023-10-15（项目例会）</h1><ol><li>已学内容<ul><li>学习 Java 初级中级和高级知识点（多态，Lambda 表达式，反射，注解，JDBC，多线程等）</li><li>学习 Idea 和 Navicat 的使用（熟悉 Java 程序编写和数据库软件的常见操作）</li><li>了解国家自然科学基金面上项目研究内容（了解研究背景，研究内容，技术路线等）</li></ul></li><li>下周计划<ul><li>学习 Spring 相关知识点</li><li>阅读实验室研究方向相关学术综述论文</li></ul></li><li>思考感悟<ul><li>类对象非静态方法才存在多态，类方法（即静态方法）不存在多态（被子类重写叫隐藏）。</li><li>IO 中有很多输入输出流，包括字节流、字符流、缓存流、数据流和对象流等要注意区分。</li><li>泛型提高复用性，对类、方法等使用泛型可以提高泛化能力，减少重复逻辑实现。</li><li>Lambda 表达式即匿名方法，通过作用域函数型接口代替匿名类来简化代码，通常结合 Stream 流使用提高开发效率。</li><li>Stream 流是函数型接口的具体实践为集合类流水线的方式处理其中元素，首先将集合转换为 Stream 然后经过中间一系列筛选或转换，最后得到需要的结果。</li><li>多线程可以充分利用 CPU 进行多任务并行执行，但要注意线程安全，可以通过 Synchronized 和 Lock 锁实现同步效果，多线程开发中应当使用 Vector、HashTable 等线程安全的容器，内部已经实现了同步保证线程安全。</li><li>JDBC 是实现 Java 与数据库进行交互的方式，可以在 Java 中使用 SQL 语句完成数据库的相关操作，实现持久存储的特定任务。</li><li>反射通过获取唯一的类对象从而创建实例或者获取类的属性和方法并对其进行操作，可以通过反射解析获取到注解中的信息，基于此他们在 Spring 框架的原理实现当中发挥着重要作用</li></ul></li><li>指导建议：</li></ol><ul><li>idea 调试方法，lambda 调试方法</li><li>学习过程中做 Demo</li><li>学习 Spring 框架，核心是 IOC 和 AOP</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://zhuanlan.zhihu.com/p/75307407#二、有哪些图神经网络？<br>title: &quot;图神经网络（Graph Neural Networks，GNN）综述&quot;<br>description: &quot;本篇文章是我在2019年8月阅读完论文“ Wu, Zonghan , et al. &amp;#34;A Comprehensive Survey on Graph Neural Networks.&amp;#34; (2019).“”后的翻译与笔记，写下这篇文章后不久便意外地转换了研究方向，如今已不再研…&quot;<br>host: zhuanlan.zhihu.com<br>image: https://pic1.zhimg.com/v2-ca0a86e8f4730d6a07127b687ad1bf7a_720w.jpg?source=172ae18b<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/75307407#%E4%BA%8C%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9F">图神经网络（Graph Neural Networks，GNN）综述 - 知乎</a></p><hr><h1 id="2023-10-20（学术例会）"><a href="#2023-10-20（学术例会）" class="headerlink" title="2023-10-20（学术例会）"></a>2023-10-20（学术例会）</h1><h3 id="1-知识图谱综述（张龙）"><a href="#1-知识图谱综述（张龙）" class="headerlink" title="1. 知识图谱综述（张龙）"></a>1. 知识图谱综述（张龙）</h3><h4 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h4><p>标题：<a href="https://arxiv.org/pdf/2002.00388.pdf">A Survey on Knowledge Graphs: Representation, Acquisition, and Applications</a><br>期刊：AAAI 2020<br>作者：Shaoxiong Ji, Shirui Pan, Erik Cambria, Pekka Marttinen, Philip S. Yu</p><h4 id="阅读理由"><a href="#阅读理由" class="headerlink" title="阅读理由"></a>阅读理由</h4><p>阅读该论文的理由，该论文有什么值得看的价值，可以获取到哪些有用的信息，我需要从中学习到的东西（<strong>创新点、研究方向、领域背景、方法论等</strong>）<br><strong>推荐理由</strong>：本文详细介绍了知识图谱表示学习、知识获取与完成、时间知识图谱、知识感知应用等方面的技术和未来的研究方向。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>梳理各个重点的作用，相互联系</li><li>绘制相应流程图</li><li>不需要详细阐述具体某个原理性知识，聚焦综述</li><li>多个参考文献则写在最后，并在文中引用</li></ul><h4 id="主要研究方向"><a href="#主要研究方向" class="headerlink" title="主要研究方向"></a>主要研究方向</h4><ol><li><p>知识获取<br>从非结构化文本和其他结构化或半结构化源中构建知识图谱</p><ol><li>知识图谱补全：用于扩展现有知识图谱<ul><li>基于嵌入的排序</li><li>关系路径推理</li><li>逻辑规则推理</li><li>元关系学习</li></ul></li><li>实体识别&#x2F;获取&#x2F;发现：用于从又本中友现面可头体的新知识。 <ul><li>实体识别</li><li>消除歧义</li><li>实体类型</li><li>实体对齐</li></ul></li><li>关系提取</li></ol></li><li><p>知识表示学习</p><ol><li>表示空间<ul><li>点态空间、流形、复向量空间、高斯分布和离散空间</li></ul></li><li>评分函数<ul><li>基于距离和相似性匹配的评分函数</li></ul></li><li>编码模型<ul><li>对事实的语义交互建立模型：线性&#x2F;双线性模型、因子分解和神经网络</li></ul></li><li>嵌入辅助信息<ul><li>外部信息：文本、视觉和类型信息</li></ul></li></ol></li><li><p>时间知识图谱</p></li><li><p>知识感知应用</p></li></ol><h3 id="大模型数据集研究（何雨欣）"><a href="#大模型数据集研究（何雨欣）" class="headerlink" title="大模型数据集研究（何雨欣）"></a>大模型数据集研究（何雨欣）</h3><p>[[司法领域大模型调研一]]</p><ol><li>CIFA 数据集</li><li>复旦大学 DISC 数据集<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310201112594.png" alt="image.png"><blockquote><p>大模型数据集存在什么问题</p></blockquote></li></ol><h3 id="国自然科学基金"><a href="#国自然科学基金" class="headerlink" title="国自然科学基金"></a>国自然科学基金</h3><p>几个大部分（科学问题）</p><ol><li>知识图谱构建</li><li>双图谱融合协同增强</li><li>大模型与图谱双向促进</li></ol><blockquote><p>每个科学问题其中可以阐述一些应用。</p></blockquote><hr><h1 id="2023-10-22（项目例会）"><a href="#2023-10-22（项目例会）" class="headerlink" title="2023-10-22（项目例会）"></a>2023-10-22（项目例会）</h1><blockquote><p>[!NOTE] 周会总结</p><ol><li>已学内容：<ul><li>JavaWeb 相关核心知识内容（Tomcat 服务器，数据库基础，Lombok，Mybatis，Maven，Servlet，Cookie，Session 等）</li><li>司法大模型相关调研工作（国内研究现状和存在问题）</li></ul></li><li>下周计划：<ul><li>学习 Spring 核心知识（IOC、AOP）</li><li>继续调研完善司法大模型应用现状</li></ul></li><li>学习感悟：<ul><li><strong>Tomcat 服务器</strong>：他是一个 Web 应用服务器，可以快速部署我们的 Web 项目，并交由 Tomcat 进行管理，我下载了该服务器并进行了测试，<strong>需要先将应用程序打包为 war 包并放入 webapp 文件夹</strong>，在启动 tomcat 服务时会自动解压 war 包从而提供服务。常见的 web 服务器还有 apache，nginx，IIS 等。</li><li><strong>数据库基础</strong>：学习了包括 DDL（数据库定义语言，建【create database repository】删【drop database repository】库，增【create table tname（fn type cons）】删【drop table】改【alter table】表等指令），DML（数据库操纵语言，增【insert into table（）values（）】删【delete from table】改【update table set】数据），DQL（数据库查询语言，单表多表查询【多表查询包括 inner join 返回两个表笛卡尔积交集数据、left join 返回左表所有记录和交集数据、right join 返回所有右表记录和交集数据】、排序【order by field asc|desc】聚集【count、sum、avg、max、min】分组【group by field】分页【limit （起始位置）, 数量】），DCL（数据库控制语言，如创建用户并授权），索引，事务（ACID）</li><li><strong>Lombok</strong>：通过注解自动化生成 Java 类的样板代码，比如@Data 注解自动生成 getter、setter、equals、hashCode 和 toString 方法，达到简洁，高效的目的。</li><li><strong>Mybatis</strong>：它是一个 ORM 半自动框架，将关系型数据库中的数据映射到对象模型中，从而实现数据库操作与对象操作的无缝转换，使用方式：<em>依赖注入&gt;配置文件编写&gt;mapper 接口（通过注解执行 sql 指令）</em></li><li><strong>Maven</strong>：它是一个项目管理工具，方便管理项目依赖、构建项目、运行测试、生成文档等，pom 全局配置文件的依赖主要由 <code>groupId，artifactId 和 version</code> 组成，常用 <code>clean、test、package</code> 等生命周期函数清理 target 文件夹，运行测试方法，打包成 jar 包等。</li><li><strong>Servlet</strong>：它用于动态网页响应，通过 <code>@WebServlet</code> 进行注册，在 WebServlet 注解中配置路由，初始化参数，然后继承 <code>HttpServlet</code> 重写 doGet&#x2F;doPost 等方法对请求进行处理并作出响应，还可以进行重定向和请求转发等操作，实现动态网页数据交互。其中较为关键的 <code>ServletContext</code> 对象，它是属于属于整个 Web 应用程序的，可以用于全局数据传递（<code>set/getAttribute</code>），请求转发（<code>getRequestDispatcher</code>）等。</li><li><strong>Cookie</strong>和<strong>Session</strong>：都是在 Web 开发中用于跟踪用户状态和保持用户信息的两种常见机制。<ol><li>Cookie（HTTP Cookie）是<strong>服务器发送到用户浏览器</strong>并存储在用户本地计算机上，由浏览器管理，包含了一些关于用户的信息，例如用户的身份认证、偏好设置等。可以<strong>设置过期时间，关闭浏览器后仍然保留，并且不同页面之间共享</strong>。</li><li>Session 是<strong>服务器端的机制，由服务器进行管理</strong>，用于在服务器上存储和跟踪用户的状态信息。当用户访问网站时，服务器会为该用户创建一个<strong>唯一的会话标识（Session ID）</strong>，并将该标识存储在服务器上。然后，服务器将 Session ID 通常通过 Cookie 发送给浏览器，与 Cookie 不同的是<strong>Session 数据存储在服务器用户无法直接修改</strong>，并且浏览器关闭后会<strong>自动销毁</strong>。</li></ol></li></ul></li><li>指导建议：</li></ol><ul><li>sessionID 除了浏览器不同会重新生成，还有别的方式吧</li><li>汇报重点做了什么有什么思考想法见解，比如学完了什么学了多少，我认为什么比较重要，进行简洁总结，根据听讲人介绍，不需要介绍知识点，范围程度理解。</li></ul></blockquote><hr><h1 id="2023-10-27（学术例会）"><a href="#2023-10-27（学术例会）" class="headerlink" title="2023-10-27（学术例会）"></a>2023-10-27（学术例会）</h1><h2 id="结构感知预训练语言模型-SAILER"><a href="#结构感知预训练语言模型-SAILER" class="headerlink" title="结构感知预训练语言模型 SAILER"></a>结构感知预训练语言模型 <a href="https://github.com/CSHaitao/SAILER">SAILER</a></h2><h2 id="汇报人：杨东波解决方法：-SAILER-采用编码器-解码器架构来建模和捕获事实与案例文档的其他部分之间的依赖关系。-SAILER-利用推理和决策段落中的法律知识来增强对关键的法律要素的理解总结：本文提出了一种新的结构感知预训练语言模型-SAILER，用于法律的案例检索。SAILER-的核心思想是充分利用法律的案例文档的结构关系进行预训练。通过重构关键法律的要素和判决结果：SAILER-生成了更好的法律的案例表征，具有更强的判别能力。通过对四个基准法律的数据集进行广泛的实验-SAILER-在低资源和全资源环境下都取得了显著的改进。在未来，我们希望探索将更多的专业知识，如法律的知识图和法律文章，纳入预先训练的语言模型，以更好地检索法律的案例。注意：1-汇报人，来源，作者，作者信息，期刊来源2-markdown-的需要上传到-gitlab-上直接预览讲解-LegalGNN-Legal-Information-Enhanced-GraphNeural-Network-for-Recommendation汇报人：康志求-国基金讨论1-大模型生成数据，提升数据质量。大模型生成数据作为训练数据，即便存在问题也可以说明，存在幻觉问题。2-司法数据集已经有很多公开的数据集了，并不存在数据稀疏。3-大模型对知识图谱数据的获取方面有哪些研究。4-司法数据隐私安全方面，联邦学习是否可以解决。5-数据时效性，数据动态更新问题，如何更新，更新效率，高低频案件变化问题。6-时序知识图谱看能否运用。"><a href="#汇报人：杨东波解决方法：-SAILER-采用编码器-解码器架构来建模和捕获事实与案例文档的其他部分之间的依赖关系。-SAILER-利用推理和决策段落中的法律知识来增强对关键的法律要素的理解总结：本文提出了一种新的结构感知预训练语言模型-SAILER，用于法律的案例检索。SAILER-的核心思想是充分利用法律的案例文档的结构关系进行预训练。通过重构关键法律的要素和判决结果：SAILER-生成了更好的法律的案例表征，具有更强的判别能力。通过对四个基准法律的数据集进行广泛的实验-SAILER-在低资源和全资源环境下都取得了显著的改进。在未来，我们希望探索将更多的专业知识，如法律的知识图和法律文章，纳入预先训练的语言模型，以更好地检索法律的案例。注意：1-汇报人，来源，作者，作者信息，期刊来源2-markdown-的需要上传到-gitlab-上直接预览讲解-LegalGNN-Legal-Information-Enhanced-GraphNeural-Network-for-Recommendation汇报人：康志求-国基金讨论1-大模型生成数据，提升数据质量。大模型生成数据作为训练数据，即便存在问题也可以说明，存在幻觉问题。2-司法数据集已经有很多公开的数据集了，并不存在数据稀疏。3-大模型对知识图谱数据的获取方面有哪些研究。4-司法数据隐私安全方面，联邦学习是否可以解决。5-数据时效性，数据动态更新问题，如何更新，更新效率，高低频案件变化问题。6-时序知识图谱看能否运用。" class="headerlink" title="汇报人：杨东波解决方法：- SAILER 采用编码器-解码器架构来建模和捕获事实与案例文档的其他部分之间的依赖关系。- SAILER 利用推理和决策段落中的法律知识来增强对关键的法律要素的理解总结：本文提出了一种新的结构感知预训练语言模型 SAILER，用于法律的案例检索。SAILER 的核心思想是充分利用法律的案例文档的结构关系进行预训练。通过重构关键法律的要素和判决结果：SAILER 生成了更好的法律的案例表征，具有更强的判别能力。通过对四个基准法律的数据集进行广泛的实验 SAILER 在低资源和全资源环境下都取得了显著的改进。在未来，我们希望探索将更多的专业知识，如法律的知识图和法律文章，纳入预先训练的语言模型，以更好地检索法律的案例。注意：1. 汇报人，来源，作者，作者信息，期刊来源2. markdown 的需要上传到 gitlab 上直接预览讲解## LegalGNN: Legal Information Enhanced GraphNeural Network for Recommendation汇报人：康志求## 国基金讨论1. 大模型生成数据，提升数据质量。大模型生成数据作为训练数据，即便存在问题也可以说明，存在幻觉问题。2. 司法数据集已经有很多公开的数据集了，并不存在数据稀疏。3. 大模型对知识图谱数据的获取方面有哪些研究。4. 司法数据隐私安全方面，联邦学习是否可以解决。5. 数据时效性，数据动态更新问题，如何更新，更新效率，高低频案件变化问题。6. 时序知识图谱看能否运用。"></a>汇报人：杨东波<br>解决方法：<br>- SAILER 采用<strong>编码器-解码器</strong>架构来建模和捕获事实与案例文档的其他部分之间的依赖关系。<br>- SAILER 利用推理和决策段落中的法律知识来增强对关键的法律要素的理解<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310271407567.png?token=AWSLQP63CRUJLPXZ2RYZXFDFHNKC2" alt="image.png"><br>总结：<br>本文提出了一种新的结构感知预训练语言模型 SAILER，用于法律的案例检索。SAILER 的核心思想是充分<strong>利用法律的案例文档的结构关系进行预训练</strong>。通过<strong>重构关键法律的要素和判决结果</strong>：SAILER 生成了更好的法律的案例表征，具有更强的判别能力。通过对四个基准法律的数据集进行广泛的实验 SAILER 在低资源和全资源环境下都取得了显著的改进。在未来，我们希望探索将更多的专业知识，如法律的知识图和法律文章，纳入预先训练的语言模型，以更好地检索法律的案例。<br>注意：<br>1. 汇报人，来源，作者，作者信息，期刊来源<br>2. markdown 的需要上传到 gitlab 上直接预览讲解<br>## LegalGNN: Legal Information Enhanced GraphNeural Network for Recommendation<br>汇报人：康志求<br>## 国基金讨论<br>1. 大模型生成数据，提升数据质量。大模型生成数据作为训练数据，即便存在问题也可以说明，存在幻觉问题。<br>2. 司法数据集已经有很多公开的数据集了，并不存在数据稀疏。<img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310271652068.png" alt="image.png"><br>3. 大模型对知识图谱数据的获取方面有哪些研究。<br>4. 司法数据隐私安全方面，联邦学习是否可以解决。<br>5. 数据时效性，数据动态更新问题，如何更新，更新效率，高低频案件变化问题。<br>6. 时序知识图谱看能否运用。</h2><h1 id="2023-10-29（项目例会）"><a href="#2023-10-29（项目例会）" class="headerlink" title="2023-10-29（项目例会）"></a>2023-10-29（项目例会）</h1><blockquote><p>[!NOTE] 周会总结</p><ol><li>已学内容：<ul><li>SpringIOC、AOP 和 EL 表达式等</li><li>调研国基金项目研究背景</li></ul></li><li>下周计划：<ul><li>继续学习 Spring 剩余内容，包括 springboot (含 MWC 设计思想)，整合 mybatis</li><li>进一步调研国基金国内外研究现状部分</li></ul></li><li>学习感悟：<ul><li><strong>Spring 方面</strong>：Spring 框架通过模块化的设计和丰富的集成服务相较于传统的 javaweb 更加灵活、方便，易于扩展和维护，核心在于 IOC 容器代替原来直接 new 的方式实现对象的创建、依赖关系的管理和生命周期的控制，只需要更改 bean 即可修改逻辑功能避免重构原有大量代码。其次，AOP 通过代理原有的方法实现不同的增强效果，目的在于不破坏原有代码的基础上进行增强处理，例如：spring 的异步任务的实现底层就是进行了 AOP 增强添加了一个新的线程。而 SpEL 表达式则可以让我们更加灵活的使用 Spring，可以实现 bean 的属性注入、获取和管理等。</li><li><strong>国基金方面</strong>：之前调研的大多是司法知识图谱构建应用方面的研究现状，对基础数据方面的现状调研的还不够全面，可以从大模型与知识图谱数据协同构建、数据隐私安全、数据时效及更新等方面展开进一步调研。</li></ul></li><li>指导建议：<ul><li>学习 SpringBoot 结合 Mybatis 进行学习实践</li></ul></li></ol></blockquote><hr><h1 id="2023-11-03（学术例会）"><a href="#2023-11-03（学术例会）" class="headerlink" title="2023-11-03（学术例会）"></a>2023-11-03（学术例会）</h1><h2 id="事件抽取"><a href="#事件抽取" class="headerlink" title="事件抽取"></a>事件抽取</h2><h2 id="汇报人：王忆宁-抽取范式1-PipeLine：顺序抽取-识别触发词》触发词分类》论元识别》论元分类，即便存在误差传播，但是能够有效识别触发词，因此适用于司法领域。-2-联合抽取：关注于抽取论元能够挖掘潜在的关系，但是容易忽略触发词，但司法领域触发词至关重要，所以该方法不适用于司法领域事件抽取。-根据模型类型分类1-基于-CNN2-基于-RNN3-基于-GNN4-基于Transformer（目前最核心）-特定场景1-文档级别事件抽取-与句子级事件抽取-SEE-相比，有两个挑战：-论元分散：一个事件的论元可能分散在文档中的多个句子中，这意味着不能从单个句子中抽取一个事件记录；-多事件：一个文档可能同时包含多个事件，这需要对事件之间的相豆依赖性进行整体建模。2-少样本学习-给定触发词，完成触发词分类-纯文本数据联合进行触发词识别和分类-更接近实际应用-3-零样本学习-语义相似度-迁移学习（文本隐含-TE-和问答查询-QA-4-增量学习-解决灾难性遗忘问题（学习系统在适应新类型时，通常会在旧类型上出现显著的性能下降）：通过提出的知识整合网络解决了灾难性遗忘和语义模糊问题，在增量-ED-上实现了有效的性能。-结论-深度学习优于机器学习和模式匹配-BERT-的突出效果（上下文信息的语义关联-文档级别-外部资源提升效果-联合抽取和-pipeline-抽取的优劣-Exploring-the-Feasibility-of-ChatGPT-for-Event-Extraction-面临场景without-fine-tuning-zero-shot-场景，主要关注事件检测任务-实验结果结果显示，EEQA-在-F-1-中表现最好，而-ChatGPT-则落后于-Text-2-Event-和-EEQA。ChatGPT-的-Recall-与-Text-2-Event-t-5-基-相当，但其精度明显较低。作者观察到-ChatGPT-提取了更多的事件触发器，这可能是因为它缺乏对某些事件定义的清晰理解。-结论在长尾和复杂场景中，ChatGPT-的平均性能仅为特定于任务的模型（如-EEQA-的-51-04-。可用性测侧试实验表明，ChatGPT-不够健壮，提示符的持续改进并不能带来稳定的性能改进，这可能会导致糟糕的用户体验。此外，ChatGPT-对不同的提示样式非常敏感。-LegalGNN-Legal-Information-Enhanced-Graph-Neural-Network-for-Recommendation汇报人：康志求-模型结构-结论将节点和内部之间的结构关系联合起来-国基金项目1-将各个关键点搜索相关文献进行总结。2-调研关于司法领域的-KG-与-LLM-相互作用的文献，有则加之，无责阐述与司法相关的关系作为创新点。"><a href="#汇报人：王忆宁-抽取范式1-PipeLine：顺序抽取-识别触发词》触发词分类》论元识别》论元分类，即便存在误差传播，但是能够有效识别触发词，因此适用于司法领域。-2-联合抽取：关注于抽取论元能够挖掘潜在的关系，但是容易忽略触发词，但司法领域触发词至关重要，所以该方法不适用于司法领域事件抽取。-根据模型类型分类1-基于-CNN2-基于-RNN3-基于-GNN4-基于Transformer（目前最核心）-特定场景1-文档级别事件抽取-与句子级事件抽取-SEE-相比，有两个挑战：-论元分散：一个事件的论元可能分散在文档中的多个句子中，这意味着不能从单个句子中抽取一个事件记录；-多事件：一个文档可能同时包含多个事件，这需要对事件之间的相豆依赖性进行整体建模。2-少样本学习-给定触发词，完成触发词分类-纯文本数据联合进行触发词识别和分类-更接近实际应用-3-零样本学习-语义相似度-迁移学习（文本隐含-TE-和问答查询-QA-4-增量学习-解决灾难性遗忘问题（学习系统在适应新类型时，通常会在旧类型上出现显著的性能下降）：通过提出的知识整合网络解决了灾难性遗忘和语义模糊问题，在增量-ED-上实现了有效的性能。-结论-深度学习优于机器学习和模式匹配-BERT-的突出效果（上下文信息的语义关联-文档级别-外部资源提升效果-联合抽取和-pipeline-抽取的优劣-Exploring-the-Feasibility-of-ChatGPT-for-Event-Extraction-面临场景without-fine-tuning-zero-shot-场景，主要关注事件检测任务-实验结果结果显示，EEQA-在-F-1-中表现最好，而-ChatGPT-则落后于-Text-2-Event-和-EEQA。ChatGPT-的-Recall-与-Text-2-Event-t-5-基-相当，但其精度明显较低。作者观察到-ChatGPT-提取了更多的事件触发器，这可能是因为它缺乏对某些事件定义的清晰理解。-结论在长尾和复杂场景中，ChatGPT-的平均性能仅为特定于任务的模型（如-EEQA-的-51-04-。可用性测侧试实验表明，ChatGPT-不够健壮，提示符的持续改进并不能带来稳定的性能改进，这可能会导致糟糕的用户体验。此外，ChatGPT-对不同的提示样式非常敏感。-LegalGNN-Legal-Information-Enhanced-Graph-Neural-Network-for-Recommendation汇报人：康志求-模型结构-结论将节点和内部之间的结构关系联合起来-国基金项目1-将各个关键点搜索相关文献进行总结。2-调研关于司法领域的-KG-与-LLM-相互作用的文献，有则加之，无责阐述与司法相关的关系作为创新点。" class="headerlink" title="汇报人：王忆宁### 抽取范式1. PipeLine：顺序抽取-&gt;识别触发词》触发词分类》论元识别》论元分类，即便存在误差传播，但是能够有效识别触发词，因此适用于司法领域。   2. 联合抽取：关注于抽取论元能够挖掘潜在的关系，但是容易忽略触发词，但司法领域触发词至关重要，所以该方法不适用于司法领域事件抽取。   ### 根据模型类型分类1. 基于 CNN2. 基于 RNN3. 基于 GNN4. 基于Transformer（目前最核心）### 特定场景1. 文档级别事件抽取- 与句子级事件抽取 (SEE)相比，有两个挑战：()论元分散：一个事件的论元可能分散在文档中的多个句子中，这意味着不能从单个句子中抽取一个事件记录；()多事件：一个文档可能同时包含多个事件，这需要对事件之间的相豆依赖性进行整体建模。2. 少样本学习- 给定触发词，完成触发词分类- 纯文本数据联合进行触发词识别和分类(更接近实际应用)3. 零样本学习- 语义相似度- 迁移学习（文本隐含 TE 和问答查询 QA)?4. 增量学习- 解决灾难性遗忘问题（学习系统在适应新类型时，通常会在旧类型上出现显著的性能下降）：通过提出的知识整合网络解决了灾难性遗忘和语义模糊问题，在增量 ED 上实现了有效的性能。### 结论- 深度学习优于机器学习和模式匹配- BERT 的突出效果（上下文信息的语义关联&#x2F;文档级别)- 外部资源提升效果- 联合抽取和 pipeline 抽取的优劣## Exploring the Feasibility of ChatGPT for Event Extraction### 面临场景without fine-tuning, zero-shot 场景，主要关注事件检测任务### 实验结果结果显示，EEQA 在 F 1 中表现最好，而 ChatGPT 则落后于 Text 2 Event 和 EEQA。ChatGPT 的 Recall 与 Text 2 Event (t 5 基)相当，但其精度明显较低。作者观察到 ChatGPT 提取了更多的事件触发器，这可能是因为它缺乏对某些事件定义的清晰理解。### 结论在长尾和复杂场景中，ChatGPT 的平均性能仅为特定于任务的模型（如 EEQA)的 51.04%。可用性测侧试实验表明，ChatGPT 不够健壮，提示符的持续改进并不能带来稳定的性能改进，这可能会导致糟糕的用户体验。此外，ChatGPT 对不同的提示样式非常敏感。## LegalGNN: Legal Information Enhanced Graph Neural Network for Recommendation汇报人：康志求### 模型结构### 结论将节点和内部之间的结构关系联合起来## 国基金项目1. 将各个关键点搜索相关文献进行总结。2. 调研关于司法领域的 KG 与 LLM 相互作用的文献，有则加之，无责阐述与司法相关的关系作为创新点。"></a>汇报人：王忆宁<br><img src="https://cdn.jsdelivr.net/gh/Alleyf/PictureMap/web_icons/2023-11-03-09-56-44.png" alt="image.png"><br>### 抽取范式<br>1. <strong>PipeLine</strong>：顺序抽取-&gt;<strong>识别触发词》触发词分类》论元识别》论元分类</strong>，即便存在误差传播，但是能够有效识别触发词，因此适用于司法领域。<br>   <img src="https://cdn.jsdelivr.net/gh/Alleyf/PictureMap/web_icons/2023-11-03-10-05-50.png" alt="image.png"><br>2. <strong>联合抽取</strong>：关注于<strong>抽取论元能够挖掘潜在的关系</strong>，但是容易<strong>忽略触发词</strong>，但司法领域触发词至关重要，所以该方法不适用于司法领域事件抽取。<br>   <img src="https://cdn.jsdelivr.net/gh/Alleyf/PictureMap/web_icons/2023-11-03-10-06-30.png" alt="image.png"><br>### 根据模型类型分类<br>1. 基于 CNN<br>2. 基于 RNN<br>3. 基于 GNN<br>4. 基于<strong>Transformer（目前最核心）</strong><br>### 特定场景<br><strong>1. 文档级别事件抽取</strong><br>- 与句子级事件抽取 (SEE)相比，有两个挑战：()论元分散：一个事件的论元可能分散在文档中的多个句子中，这意味着不能从单个句子中抽取一个事件记录；()多事件：一个文档可能同时包含多个事件，这需要对事件之间的相豆依赖性进行整体建模。<br><strong>2. 少样本学习</strong><br>- 给定触发词，完成触发词分类<br>- 纯文本数据联合进行触发词识别和分类<br>(更接近实际应用)<br><strong>3. 零样本学习</strong><br>- 语义相似度<br>- 迁移学习（文本隐含 TE 和问答查询 QA)?<br><strong>4. 增量学习</strong><br>- 解决灾难性遗忘问题（学习系统在适应新类型时，通常会在旧类型上出现显著的性能下降）：通过提出的知识整合网络解决了灾难性遗忘和语义模糊问题，在增量 ED 上实现了有效的性能。<br>### 结论<br>- 深度学习优于机器学习和模式匹配<br>- BERT 的突出效果（上下文信息的语义关联&#x2F;文档级别)<br>- 外部资源提升效果<br>- 联合抽取和 pipeline 抽取的优劣<br>## Exploring the Feasibility of ChatGPT for Event Extraction<br>### 面临场景<br>without fine-tuning, zero-shot 场景，主要关注事件检测任务<br>### 实验结果<br><img src="https://cdn.jsdelivr.net/gh/Alleyf/PictureMap/web_icons/2023-11-03-10-26-40.png" alt="image.png"><br>结果显示，EEQA 在 F 1 中表现最好，而 ChatGPT 则落后于 Text 2 Event 和 EEQA。ChatGPT 的 Recall 与 Text 2 Event (t 5 基)相当，但其精度明显较低。作者观察到 ChatGPT 提取了更多的事件触发器，这可能是因为它缺乏对某些事件定义的清晰理解。<br>### 结论<br>在长尾和复杂场景中，ChatGPT 的平均性能仅为特定于任务的模型（如 EEQA)的 51.04%。可用性测侧试实验表明，ChatGPT 不够健壮，提示符的持续改进并不能带来稳定的性能改进，这可能会导致糟糕的用户体验。此外，ChatGPT 对不同的提示样式非常敏感。<br>## LegalGNN: Legal Information Enhanced Graph Neural Network for Recommendation<br>汇报人：康志求<br>### 模型结构<br><img src="https://cdn.jsdelivr.net/gh/Alleyf/PictureMap/web_icons/202311031113671.png" alt="image.png"><br><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311031116097.png" alt="202311031116097.png"><br>### 结论<br>将节点和内部之间的结构关系联合起来<br>## 国基金项目<br>1. 将各个关键点搜索相关文献进行总结。<br>2. 调研关于司法领域的 KG 与 LLM 相互作用的文献，有则加之，无责阐述与司法相关的关系作为创新点。</h2><h1 id="2023-11-05（项目例会）"><a href="#2023-11-05（项目例会）" class="headerlink" title="2023-11-05（项目例会）"></a>2023-11-05（项目例会）</h1><blockquote><p>[!NOTE] 周会总结</p><ol><li>已学内容：<ul><li>学习 SpringBoot（SpringMVC、拦截器、Swagger、Json 格式化、日志、JPA、MyBatisPlus）</li></ul></li><li>下周计划：<ul><li>学习 SpringBoot 剩余部分内容（SpringSecurity、Jwt）并做相应的 Demo</li></ul></li><li>学习感悟：<ul><li>SpringBoot 相当于是把 Spring 框架里的很多依赖和 Web 容器（Tomcat）整合了起来，原来 Spring 需要写很多配置文件，而 SpringBoot 直接提供了默认的配置，按需修改即可，大大简化应用开发流程。为了解耦应用程序不同模块的逻辑功能，使用 MVC 思想进行设计，分为模型、视图和控制层，各司其职保证程序具有较强的可读、可扩展、可维护性。</li><li>在 SpringBoot 中可以很方便的使用各种中间件，比如数据库、消息队列、缓存和搜索引擎等，从而满足各种客制化需求。</li></ul></li><li>指导建议：<ul><li>根据学长给的 demo 完成相应项目的实践</li></ul></li></ol></blockquote><hr><h1 id="2023-11-10（学术例会）"><a href="#2023-11-10（学术例会）" class="headerlink" title="2023-11-10（学术例会）"></a>2023-11-10（学术例会）</h1><h2 id="Contrastive-Data-and-Learning-for-Natural-Language"><a href="#Contrastive-Data-and-Learning-for-Natural-Language" class="headerlink" title="Contrastive Data and Learning for Natural Language"></a>Contrastive Data and Learning for Natural Language</h2><h2 id="Processing汇报人：林广生-联合抽取和流水线抽取抽取方式优点缺点研究热度流水线抽取模块化设计；实现简单错误传播；上下文信息利用不足联合抽取减少错误传播；上下文利用；效率提升模型复杂-ERICA-Improving-Entity-and-Relation-Understanding-for-Pre-trained-Language-Models-via-Contrastive-Learning-Legal-Elements-Extraction-via-Label-Recross-Attention-and-Contrastive-Learning-对比学习对比式学习着重于学习同类实例之间的共同特征，区分非同类实例之间的不同之处。与生成式学习比较，对比式学习不需要关注实例上繁琐的细节，只需要在抽象语义级别的特征空间上学会对数据的区分即可，因此模型以及其优化变得更加简单，且泛化能力更强。-对比学习的目标是学习一个编码器，此编码器对同类数据进行相似的编码，并使不同类的数据的编码结果尽可能的不同。-LawBench-Benchmarking-Legal-Knowledge-of-Large-Language-Models汇报人：胥岚林-思维链-IF存在问题：1-仅有现状的罗列，没有阐述现存什么问题，目前的解决方法或是解决了什么问题，还存在什么问题，我们拟研究解决哪些问题。2-对现有内容进行总结，总分结构，阐述清楚各个部分的逻辑关系。3-行文结构：-现领域存在什么关键问题-介绍那些国内外学者研究解决了哪些问题-还存在什么问题有待解决，我们拟研究解决哪些问题"><a href="#Processing汇报人：林广生-联合抽取和流水线抽取抽取方式优点缺点研究热度流水线抽取模块化设计；实现简单错误传播；上下文信息利用不足联合抽取减少错误传播；上下文利用；效率提升模型复杂-ERICA-Improving-Entity-and-Relation-Understanding-for-Pre-trained-Language-Models-via-Contrastive-Learning-Legal-Elements-Extraction-via-Label-Recross-Attention-and-Contrastive-Learning-对比学习对比式学习着重于学习同类实例之间的共同特征，区分非同类实例之间的不同之处。与生成式学习比较，对比式学习不需要关注实例上繁琐的细节，只需要在抽象语义级别的特征空间上学会对数据的区分即可，因此模型以及其优化变得更加简单，且泛化能力更强。-对比学习的目标是学习一个编码器，此编码器对同类数据进行相似的编码，并使不同类的数据的编码结果尽可能的不同。-LawBench-Benchmarking-Legal-Knowledge-of-Large-Language-Models汇报人：胥岚林-思维链-IF存在问题：1-仅有现状的罗列，没有阐述现存什么问题，目前的解决方法或是解决了什么问题，还存在什么问题，我们拟研究解决哪些问题。2-对现有内容进行总结，总分结构，阐述清楚各个部分的逻辑关系。3-行文结构：-现领域存在什么关键问题-介绍那些国内外学者研究解决了哪些问题-还存在什么问题有待解决，我们拟研究解决哪些问题" class="headerlink" title="Processing汇报人：林广生### 联合抽取和流水线抽取抽取方式优点缺点研究热度流水线抽取模块化设计；实现简单错误传播；上下文信息利用不足联合抽取减少错误传播；上下文利用；效率提升模型复杂## ERICA: Improving Entity and Relation Understanding for Pre-trained Language Models via Contrastive Learning## Legal Elements Extraction via Label Recross Attention and Contrastive Learning## 对比学习对比式学习着重于学习同类实例之间的共同特征，区分非同类实例之间的不同之处。与生成式学习比较，对比式学习不需要关注实例上繁琐的细节，只需要在抽象语义级别的特征空间上学会对数据的区分即可，因此模型以及其优化变得更加简单，且泛化能力更强。&gt; 对比学习的目标是学习一个编码器，此编码器对同类数据进行相似的编码，并使不同类的数据的编码结果尽可能的不同。## LawBench: Benchmarking Legal Knowledge of Large Language Models汇报人：胥岚林## 思维链## IF存在问题：1. 仅有现状的罗列，没有阐述现存什么问题，目前的解决方法或是解决了什么问题，还存在什么问题，我们拟研究解决哪些问题。2. 对现有内容进行总结，总分结构，阐述清楚各个部分的逻辑关系。3. 行文结构：   - 现领域存在什么关键问题   - 介绍那些国内外学者研究解决了哪些问题   - 还存在什么问题有待解决，我们拟研究解决哪些问题"></a>Processing<br>汇报人：林广生<br>### 联合抽取和流水线抽取<br>抽取方式优点缺点研究热度<br>流水线抽取模块化设计；实现简单<br>错误传播；上下文信息利用不足<br>联合抽取<br>减少错误传播；上下文利用；效率提升<br>模型复杂<br>## ERICA: Improving Entity and Relation Understanding for Pre-trained Language Models via Contrastive Learning<br>## Legal Elements Extraction via Label Recross Attention and Contrastive Learning<br>## 对比学习<br><img src="https://pic3.zhimg.com/80/v2-379099fa00fca7e8750bf6abe849d3aa_720w.jpg"><br>对比式学习着重于学习同类实例之间的共同特征，区分非同类实例之间的不同之处。<br>与生成式学习比较，对比式学习不需要关注实例上繁琐的细节，只需要在抽象语义级别的特征空间上学会对数据的区分即可，因此模型以及其优化变得更加简单，且泛化能力更强。<br>&gt; <strong>对比学习</strong>的目标是学习一个编码器，此编码器<strong>对同类数据进行相似的编码，并使不同类的数据的编码结果尽可能的不同</strong>。<br>## LawBench: Benchmarking Legal Knowledge of Large Language Models<br>汇报人：胥岚林<br><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311101005057.png" alt="image.png"><br><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311101011752.png" alt="image.png"><br>## 思维链<br><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311101024984.png" alt="image.png"><br><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311101025392.png" alt="image.png"><br><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311101027445.png" alt="image.png"><br><img src="http://s3j0z30xc.hn-bkt.clouddn.com/pics/202311101042892.png" alt="image.png"><br>## IF<br>存在问题：<br>1. 仅有现状的罗列，没有阐述现存什么问题，目前的解决方法或是解决了什么问题，还存在什么问题，我们拟研究解决哪些问题。<br>2. 对现有内容进行总结，总分结构，阐述清楚各个部分的逻辑关系。<br>3. 行文结构：<br>   - 现领域存在什么关键问题<br>   - 介绍那些国内外学者研究解决了哪些问题<br>   - 还存在什么问题有待解决，我们拟研究解决哪些问题</h2><h1 id="2023-11-12-（项目例会）"><a href="#2023-11-12-（项目例会）" class="headerlink" title="2023-11-12 （项目例会）"></a>2023-11-12 （项目例会）</h1><blockquote><p>[!NOTE] 周会总结</p><ol><li>已学内容：<ul><li>学习 SpringSecurity，并且进行 SpringBoot+Vue 的项目实战（SpringSecurity、Redis、Mybatis、RabbitMQ，项目不含用户管理、权限管理、菜单管理、日志管理等）已完成80%</li></ul></li><li>下周计划：<ul><li>继续完成未完成的项目实战并学习 Java 高级特性（Concurrent、NIO、Lambda、Stream、Optional 等）或 SpringCloud。</li></ul></li><li>学习感悟：<ul><li>通过项目实战的实践练习，让我了解了一般项目的基本结构组成，并且熟练了前面学习的 SpringSecurity、SpringMVC、Mybatis、Mail、Slf 4 j、Swagger 等组件的联合运用，但是由于是首次使用还不是很熟练，有很多配置要想都配置全面实际上还是比较复杂，要注意 bean 之间的不能循环依赖、Mybatis 的 DTO 的属性名必须与数据表的字段名一致之类的小坑，后面需要多加练习巩固已学的知识才能更熟练灵活的运用。一些 java 高级特性比如 Concurrent、NIO、Lambda、Stream、Optional 等在项目开发中还是非常有用的，所以不知道接下来是先学习熟悉这些还是直接学 SpringCloud。</li></ul></li><li>指导建议：<ul><li>学习 SpringCloud，在学习过程中运用到哪些高级特性就去顺便学习了</li></ul></li></ol></blockquote><h1 id="2023-11-17-（学术例会）"><a href="#2023-11-17-（学术例会）" class="headerlink" title="2023-11-17 （学术例会）"></a>2023-11-17 （学术例会）</h1><h2 id="CPEE-Civil-Case-Judgment-Prediction-centering-on-the-Trial-Mode-of-Essential-Elements"><a href="#CPEE-Civil-Case-Judgment-Prediction-centering-on-the-Trial-Mode-of-Essential-Elements" class="headerlink" title="CPEE:Civil Case Judgment Prediction centering on the Trial Mode of Essential Elements"></a>CPEE:Civil Case Judgment Prediction centering on the Trial Mode of Essential Elements</h2><blockquote><p>主讲人：xzt</p></blockquote><p>民事案件判决预测</p><p>解决思路：</p><pre><code class=" mermaid">graph LR;A[1案由预测]--&gt;B;B[2法条预测]--&gt;C;C[3判决预测]--&gt;A;</code></pre><p><img src="http://qnpicmap.fcsluck.top/pics/202311171603430.png" alt="image.png"><br><img src="http://qnpicmap.fcsluck.top/pics/202311171605743.png" alt="image.png"></p><p>本文提出了一种基于法律要素的民事案件判决预测方法CPEE（Civil Case Judgment Prediction centering on the Trial Mode of Essential Elements）。该方法主要包括三个步骤：案由预测、法条预测和判决预测。</p><p>在案由预测中，作者使用了一个双向LSTM模型来根据案件事实描述来预测案由。在法条预测中，作者使用了一个基于注意力机制的LSTM模型来根据案件事实描述和相关法律规定来预测适用的法条。在判决预测中，作者使用了一个多任务学习模型来预测判决结果。</p><p>为了评估CPEE方法的性能，作者使用了一个包含真实民事案件数据的数据集进行实验。实验结果表明，CPEE方法在案由预测、法条预测和判决预测方面都取得了较好的性能。同时，作者还进行了对比实验，并展示了CPEE与其他方法相比的优势。</p><p>总之，本文提出的CPEE方法可以有效地进行民事案件判决预测，并具有一定的实际应用价值。但是仍然存在一些改进空间，例如进一步优化模型结构和算法以提高性能，并考虑更多因素对判决结果的影响。</p><h2 id="Boosting-Factual-Correctness-of-Abstractive-mmarization-with-Knowledge-Graph"><a href="#Boosting-Factual-Correctness-of-Abstractive-mmarization-with-Knowledge-Graph" class="headerlink" title="Boosting Factual Correctness of Abstractive mmarization with Knowledge Graph"></a>Boosting Factual Correctness of Abstractive mmarization with Knowledge Graph</h2><p>(Microsoft Cognitive Services Group,NAACL 2021)</p><blockquote><p>主讲人：hwx</p></blockquote><p>现状与问题：</p><ol><li>生成式摘要的一个突出问题是事实不一致。它指的是<strong>摘要有时歪曲或捏造</strong>文章中<br>的事实的幻觉现象。（生成幻觉）</li><li>另外大多数现有的生成式模型在训练以及评估的过程中都<strong>采用关注摘要的token级<br>准确性</strong>，而<strong>忽略了摘要与原文之间语义级的一致性</strong>。因此，生成的摘要在ROUG<br>这样的token级别度量中可能评分很高，但缺乏事实一致性。（衡量摘要效果，评估）</li></ol><p>解决方案：<br>1.1 事实感知模型</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311171409197.png" alt="image.png"></p><p>1.2 事实纠正模型</p><p>除开构建事实感知模型，为了更好地利用现有的摘要系统，提出了一个事实校正模型FC,以提<br>高生成式摘要模型生成的任何摘要的事实一致性。FC将修正过程定义为一个seq2seq问题：给定一篇文章和一个候选摘要，模型生成一个修正后的摘要，与文章更加一致。<br>利用现有摘要模型，通过正负样本训练纠正幻觉摘要</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311171414126.png" alt="image.png"></p><p>2.1 衡量事实准确度<br>采用了FactCC(Evaluating the factual consistency of abstractive text summarization,EMNLP2020，该模型是训练出来的),一个基于0t的事实一致性评估器，该模型输出0到1之间的分数（二分类模型)，分数越高表示输入文章和摘要之间的一致性越好。</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311171417752.png" alt="image.png"></p><p>实验结果<br><img src="http://qnpicmap.fcsluck.top/pics/202311171420083.png" alt="image.png"></p><p>检查FASum模型是否仅仅通过复制文章的更多部分来提高事实一致性。FASUM达到了与参考摘要最接近的新颖n-gram比率，并且高于BOTTOMUP和UNILM。表明FASUM可以在确保事实一致性的同时生成高度生成式的摘要。</p><p>2.2 无模型事实一致性衡量（不采用FCC模型进行评估，无需训练评估模型）</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311171431197.png" alt="image.png"></p><h2 id="G-Eval-NLG-Evaluation-using-GPT-4-with-Better-Human-Alignment"><a href="#G-Eval-NLG-Evaluation-using-GPT-4-with-Better-Human-Alignment" class="headerlink" title="G-Eval:NLG Evaluation using GPT-4 with Better Human Alignment"></a>G-Eval:NLG Evaluation using GPT-4 with Better Human Alignment</h2><p>(Microsoft Cognitive Services Research,arXiv:2303.16634,2023)</p><blockquote><p>主讲人：hwx</p></blockquote><blockquote><p>该模型用于评估NLG自然语言生成模型生成结果，相较于BLUE,ROUGE评估方法更合理准确。</p></blockquote><p>现状与问题：</p><ul><li>传统的一些文本评价指标，如BLUE,ROUGE与人类判断的相关性相对较低，特别是对于开放式生成任务。</li><li>此外，这些指标需要相关的参考输出，为新任务收集这些输出的成本很高。</li><li>考虑LLM作为无参考的NLG评估者。其想法是在假设LLM已经学会为高质量和流畅的文本分配更高的慨率的情况下，在没有任何参考目标的情况下使用LLM根据候选输出的生成概率对其进行评分。</li></ul><p><img src="http://qnpicmap.fcsluck.top/pics/202311171441567.png" alt="image.png"></p><p>实验结果：</p><p><img src="http://qnpicmap.fcsluck.top/pics/202311171446102.png" alt="image.png"></p><h2 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h2><p>修改建议：<br>    1. 更加精简，把前后几部分逻辑关系梳理清楚，语言更加贴切。</p><p>mermaid的语法教程</p><p> Mermaid 是一种用于绘制流程图、时序图、甘特图等各种图表的工具，它使用简洁的文本语法来描述图表结构。以下是一些常用的 Mermaid 语法示例和说明：</p><ol><li><p>流程图</p><pre><code class=" mermaid">graph LR    A--&gt;B    B--&gt;C    C--&gt;D</code></pre><p>这个例子中，<code>graph</code> 表示创建一个流程图，<code>LR</code> 表示从左到右的布局方式。箭头 <code>--&gt;</code> 表示连接两个节点。</p></li><li><p>时序图</p><pre><code class=" mermaid">sequenceDiagram    A-&gt;&gt;B: 请求数据    B--&gt;&gt;A: 返回数据</code></pre><p>这个例子中，<code>sequenceDiagram</code> 表示创建一个时序图。箭头 <code>-&gt;&gt;</code> 表示消息发送方向。</p></li><li><p>甘特图</p><pre><code class=" mermaid">gantt    title 项目计划表        section 项目A        任务1 :a1, 2022-01-01, 30d        任务2 :after a1, 20d    section 项目B        任务3 :2022-02-01 , 12d    section 其他任务        任务4 :2022-01-20 , 8d</code></pre><p>这个例子中，<code>gantt</code> 表示创建一个甘特图。使用 <code>section</code> 来定义不同的项目或阶段，每个任务可以指定开始时间、持续时间等。</p></li></ol><p>以上是 Mermaid 的一些基本语法示例，你可以根据需要参考 Mermaid 官方文档了解更多高级用法和配置</p>]]></content>
    
    
    <summary type="html">一些关于组会的概要记录。</summary>
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="AIGC" scheme="https://alleyf.github.io/tags/AIGC/"/>
    
    <category term="KG" scheme="https://alleyf.github.io/tags/KG/"/>
    
    <category term="NLP" scheme="https://alleyf.github.io/tags/NLP/"/>
    
    <category term="LLM" scheme="https://alleyf.github.io/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot_Vue项目实战</title>
    <link href="https://alleyf.github.io/2023/11/9f9a776a7dab.html"/>
    <id>https://alleyf.github.io/2023/11/9f9a776a7dab.html</id>
    <published>2023-11-08T05:08:25.000Z</published>
    <updated>2023-11-16T03:32:41.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spingboot-Vue-前后端分离实战项目"><a href="#Spingboot-Vue-前后端分离实战项目" class="headerlink" title="Spingboot+Vue 前后端分离实战项目"></a>Spingboot+Vue 前后端分离实战项目</h1><p><img src="https://picsum.photos/800/250">  </p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><blockquote><p>采用 SpringBoot 3 + Vue 3 实现的前后端分离模版项目，集成多种技术栈，并且基于 JWT 校验方案。  </p></blockquote><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>项目已上传至 <font color="#ff0000">Github 仓库</font>，如有需要可自行下载使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://github.com/Alleyf/SpingBoot-Vue/tree/master<br>title: &quot;GitHub - Alleyf/SpingBoot-Vue: A Demo for SpringBoot with Vue.&quot;<br>description: &quot;A Demo for SpringBoot with Vue. Contribute to Alleyf/SpingBoot-Vue development by creating an account on GitHub.&quot;<br>host: github.com<br>favicon: https://github.githubassets.com/favicons/favicon.svg<br>image: https://opengraph.githubassets.com/a9e35993db96532eecc54692cabfb8c305216983dce49278cab1b52a560daef6/Alleyf/SpingBoot-Vue<br></code></pre></td></tr></table></figure><p><a href="https://github.com/Alleyf/SpingBoot-Vue/tree/master">GitHub - Alleyf&#x2F;SpingBoot-Vue: A Demo for SpringBoot with Vue.</a></p><h2 id="后端功能"><a href="#后端功能" class="headerlink" title="后端功能"></a>后端功能</h2><p>用户注册、用户登录、重置密码等基础功能以及对应接口  </p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ol><li>前端</li></ol><ul><li>Vue 前端框架  </li><li>ElementUI 前端 UI 组件库  </li><li>Vue-Router 路由管理  </li><li>Axios 异步请求框架  </li><li>VueUse 适配黑暗模式  </li><li>unplugin-auto-import 按需引入，减少打包后体积</li></ul><ol start="2"><li>后端</li></ol><ul><li>SpringBoot 后端框架  </li><li>Mybatis 数据持久层框架  </li><li>Redis 验证码存储、限流 IP、请求次数存储  </li><li>Knife 4 j 接口文档生成  </li><li>SpringSecurity 权限认证校验  </li><li>JWT 生成 token 鉴权  </li><li>RabbitMQ 积压邮件发送，由监听器统一处理  </li><li>FastJson 后端统一用 Json 格式返回信息  </li><li>Slf 4 j 日志打印实现</li></ul><h2 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>添加如下 filter，此处实现根据 ip 限流 3 秒内请求超过 10 次则限制访问 30 秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <br><span class="hljs-meta">@Order(Const.ORDER_LIMIT)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowLimitFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpFilter</span> &#123;  <br>    <span class="hljs-meta">@Resource</span>  <br>    StringRedisTemplate stringRedisTemplate;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> request.getRemoteAddr();  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.limitFlowByIp(ip))  <br>            chain.doFilter(request, response);  <br>        <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-built_in">this</span>.writeBlockMessage(response);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeBlockMessage</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        response.setStatus(HttpServletResponse.SC_FORBIDDEN);  <br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);  <br>        response.getWriter().write(Result.forbidden(<span class="hljs-string">&quot;操作频繁，请稍后再试&quot;</span>).toJson());  <br>    &#125;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据IP进行限流，同一IP三秒内超出10次拉入限流名单30秒     *     * <span class="hljs-doctag">@param</span> ip 限流IP  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否限流布尔值，为真则通过，为假则限制访问  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">limitFlowByIp</span><span class="hljs-params">(String ip)</span> &#123;  <br>        <span class="hljs-keyword">synchronized</span> (ip.intern()) &#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">countKey</span> <span class="hljs-operator">=</span> Const.FLOW_LIMIT_COUNT + ip;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">blockKey</span> <span class="hljs-operator">=</span> Const.FLOW_LIMIT_BLOCK + ip;  <br>            <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(stringRedisTemplate.hasKey(blockKey))) &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br><span class="hljs-comment">//            ip限流检查  </span><br>                <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(stringRedisTemplate.hasKey(countKey))) &#123;  <br>                    <span class="hljs-type">long</span> <span class="hljs-variable">increment</span> <span class="hljs-operator">=</span> Optional.ofNullable(stringRedisTemplate.opsForValue().increment(countKey)).orElse(<span class="hljs-number">0L</span>);  <br>                    <span class="hljs-keyword">if</span> (increment &gt; <span class="hljs-number">10</span>) &#123;  <br>                        stringRedisTemplate.opsForValue().set(blockKey, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">30</span>, TimeUnit.SECONDS);  <br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>                    &#125;  <br>                &#125; <span class="hljs-keyword">else</span> &#123;  <br><span class="hljs-comment">//                3s内连续请求将计数请求次数进行限流  </span><br>                    stringRedisTemplate.opsForValue().set(countKey, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);  <br>                &#125;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><h4 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h4><p>springboot 3 使用 swagger 版本接口文档配置：</p><ol><li><code>pom. xml</code> 引入依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    Swagger文档生成框架    --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><code>application. yml</code> 配置静态资源：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">springdoc:</span><br>  <span class="hljs-attr">paths-to-match:</span> <span class="hljs-string">/api/**</span><br>  <span class="hljs-attr">swagger-ui:</span><br>    <span class="hljs-attr">operations-sorter:</span> <span class="hljs-string">alpha</span><br></code></pre></td></tr></table></figure></li><li><code>SecurityConfiguration. java</code> 设置接口文档相关静态资源放行:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> http<br>                .authorizeHttpRequests (conf -&gt; conf<br>                        .requestMatchers (<span class="hljs-string">&quot;/api/auth/**&quot;</span>, <span class="hljs-string">&quot;/error&quot;</span>). permitAll ()<br>                        .requestMatchers (<span class="hljs-string">&quot;/swagger-ui/**&quot;</span>, <span class="hljs-string">&quot;/v 3/api-docs/**&quot;</span>). permitAll ()<br>                        .anyRequest (). hasAnyRole (Const. ROLE_DEFAULT)<br>                )<br></code></pre></td></tr></table></figure></li><li>添加 <code>SwaggerConfig. java</code> swagger 相关配置文件：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Swagger 开发文档相关配置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@SecurityScheme</span> (type = SecuritySchemeType. HTTP, scheme = <span class="hljs-string">&quot;Bearer&quot;</span>,<br>        name = <span class="hljs-string">&quot;Authorization&quot;</span>, in = SecuritySchemeIn. HEADER)<br><span class="hljs-meta">@OpenAPIDefinition</span> (security = &#123; <span class="hljs-meta">@SecurityRequirement</span> (name = <span class="hljs-string">&quot;Authorization&quot;</span>) &#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfiguration</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置文档介绍以及详细信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> OpenAPI</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">springShopOpenAPI</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span> ()<br>                .info (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span> (). title (<span class="hljs-string">&quot;示例项目 API 文档&quot;</span>)<br>                        .description (<span class="hljs-string">&quot;欢迎来到本示例项目 API 测试文档，在这里可以快速进行接口调试&quot;</span>)<br>                        .version (<span class="hljs-string">&quot;1.0&quot;</span>)<br>                        .license (<span class="hljs-keyword">new</span> <span class="hljs-title class_">License</span> ()<br>                                .name (<span class="hljs-string">&quot;项目开源地址&quot;</span>)<br>                                .url (<span class="hljs-string">&quot; https://github.com/Ketuer/SpringBoot-Vue-Template-Jwt&quot;</span> )<br>                        )<br>                )<br>                .externalDocs (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalDocumentation</span> ()<br>                        .description (<span class="hljs-string">&quot;我们的官方网站&quot;</span>)<br>                        .url (<span class="hljs-string">&quot; https://itbaima.net&quot;</span> )<br>                );<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置自定义的 OpenApi 相关信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> OpenApiCustomizer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> OpenApiCustomizer <span class="hljs-title function_">customerGlobalHeaderOpenApiCustomizer</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> api -&gt; <span class="hljs-built_in">this</span>.authorizePathItems (). forEach (api.getPaths ()::addPathItem);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录接口和退出登录接口手动添加一下</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> PathItems</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, PathItem&gt; <span class="hljs-title function_">authorizePathItems</span> <span class="hljs-params">()</span>&#123;<br>        Map&lt;String, PathItem&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put (<span class="hljs-string">&quot;/api/auth/login&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathItem</span> ()<br>                .post (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span> ()<br>                        .tags (List.of (<span class="hljs-string">&quot;登录校验相关&quot;</span>))<br>                        .summary (<span class="hljs-string">&quot;登录验证接口&quot;</span>)<br>                        .addParametersItem (<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryParameter</span> ()<br>                                .name (<span class="hljs-string">&quot;username&quot;</span>)<br>                                .required (<span class="hljs-literal">true</span>)<br>                        )<br>                        .addParametersItem (<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryParameter</span> ()<br>                                .name (<span class="hljs-string">&quot;password&quot;</span>)<br>                                .required (<span class="hljs-literal">true</span>)<br>                        )<br>                        .responses (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiResponses</span> ()<br>                                .addApiResponse (<span class="hljs-string">&quot;200&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiResponse</span> ()<br>                                        .description (<span class="hljs-string">&quot;OK&quot;</span>)<br>                                        .content (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span> (). addMediaType (<span class="hljs-string">&quot;*/*&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaType</span> ()<br>                                                .example (RestBean.success (<span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthorizeVO</span> ()). asJsonString ())<br>                                        ))<br>                                )<br>                        )<br>                )<br>        );<br>        map.put (<span class="hljs-string">&quot;/api/auth/logout&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathItem</span> ()<br>                .get (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span> ()<br>                        .tags (List.of (<span class="hljs-string">&quot;登录校验相关&quot;</span>))<br>                        .summary (<span class="hljs-string">&quot;退出登录接口&quot;</span>)<br>                        .responses (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiResponses</span> ()<br>                                .addApiResponse (<span class="hljs-string">&quot;200&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiResponse</span> ()<br>                                        .description (<span class="hljs-string">&quot;OK&quot;</span>)<br>                                        .content (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Content</span> (). addMediaType (<span class="hljs-string">&quot;*/*&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaType</span> ()<br>                                                .example (RestBean.success ())<br>                                        ))<br>                                )<br>                        )<br>                )<br>        );<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="knife-4-j"><a href="#knife-4-j" class="headerlink" title="knife 4 j"></a>knife 4 j</h4><p>springboot 3 使用 knife 4.1.0 版本接口文档配置：</p><ol><li><code>pom. xml</code> 引入依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">      <span class="hljs-comment">&lt;!--        knife4j接口文档模块--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. github. xiaoymin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>knife 4 j-openapi 3-jakarta-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><code>application. yml</code> 配置静态资源:<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml">   <span class="hljs-comment"># springdoc-openapi 项目配置，访问地址： http://127.0.0.1:8080/doc.html</span><br><span class="hljs-attr">springdoc:</span>  <br>  <span class="hljs-attr">swagger-ui:</span>  <br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/swagger-ui.</span> <span class="hljs-string">html</span>  <br>    <span class="hljs-attr">tags-sorter:</span> <span class="hljs-string">alpha</span>  <br>    <span class="hljs-attr">operations-sorter:</span> <span class="hljs-string">alpha</span>  <br>  <span class="hljs-attr">api-docs:</span>  <br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/v</span> <span class="hljs-number">3</span><span class="hljs-string">/api-docs</span>  <br>  <span class="hljs-attr">group-configs:</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;default&#x27;</span>  <br>      <span class="hljs-attr">paths-to-match:</span> <span class="hljs-string">&#x27;/**&#x27;</span>  <br>      <span class="hljs-attr">packages-to-scan:</span> <span class="hljs-string">com.</span> <span class="hljs-string">example</span>  <br><span class="hljs-comment"># knife 4 j 的增强配置，不需要增强可以不配  </span><br><span class="hljs-attr">knife 4 j:</span>  <br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <br>  <span class="hljs-attr">setting:</span>  <br>    <span class="hljs-attr">language:</span> <span class="hljs-string">zh_cn</span><br></code></pre></td></tr></table></figure></li><li><code>SecurityConfiguration. java</code> 设置接口文档相关静态资源放行:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> http  <br>          .authorizeHttpRequests (conf -&gt; &#123;  <br>              <span class="hljs-comment">//配置请求路径，允许所有请求  </span><br>              conf.requestMatchers (<span class="hljs-string">&quot;/api/auth/**&quot;</span>, <span class="hljs-string">&quot;/error&quot;</span>, <span class="hljs-string">&quot;/doc. html&quot;</span>, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;/v 3/api-docs/**&quot;</span>). permitAll ()  <br>                      <span class="hljs-comment">//其他请求需要认证  </span><br>                      .anyRequest (). authenticated ();  <br>          &#125;)  <br></code></pre></td></tr></table></figure></li><li>添加 <code>Knife 4 jConfig. java</code> knife 4 j 相关配置文件：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * Copyright (c) alleyf 2023-11. 适度编码益脑，沉迷编码伤身，合理安排时间，享受快乐生活。 */</span>  <br><span class="hljs-keyword">package</span> com. example. config;  <br><span class="hljs-keyword">import</span> io. swagger. v <span class="hljs-number">3.</span> oas. models. ExternalDocumentation;  <br><span class="hljs-keyword">import</span> io. swagger. v <span class="hljs-number">3.</span> oas. models. OpenAPI;  <br><span class="hljs-keyword">import</span> io. swagger. v <span class="hljs-number">3.</span> oas. models. info. Info;  <br><span class="hljs-keyword">import</span> io. swagger. v <span class="hljs-number">3.</span> oas. models. info. License;  <br><span class="hljs-keyword">import</span> org. springframework. context. annotation. Bean;  <br><span class="hljs-keyword">import</span> org. springframework. context. annotation. Configuration;  <br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Knife</span> <span class="hljs-number">4</span> jConfig &#123;  <br>    <span class="hljs-meta">@Bean</span>  <br>    <span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">springShopOpenAPI</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span> ()  <br>                .info (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span> (). title (<span class="hljs-string">&quot;SPDemoGo&quot;</span>)  <br>                        .description (<span class="hljs-string">&quot;SPDemoGoAPI 文档&quot;</span>)  <br>                        .version (<span class="hljs-string">&quot;v 1&quot;</span>)  <br>                        .license (<span class="hljs-keyword">new</span> <span class="hljs-title class_">License</span> (). name (<span class="hljs-string">&quot;Apache 2.0&quot;</span>). url (<span class="hljs-string">&quot; http://springdoc.org&quot;</span> )))  <br>                .externalDocs (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExternalDocumentation</span> ()  <br>                        .description (<span class="hljs-string">&quot;外部文档&quot;</span>)  <br>                        .url (<span class="hljs-string">&quot; https://springshop.wiki.github.org/docs&quot;</span> ));  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ol><li>redis 本地安装好需要修改配置文件设置 requirepass <code>password</code> 密码，才可以在 idea 里远程连接使用。</li><li>vue 中的 form 表单一定要动态绑定 <code>:model</code>，如果添加了字段验证 <code>:rules</code>，还必须为每个 <code>el-form-item</code> 指定 <code>prop</code> 为 <code>model</code> 的键。</li><li><em>RabbitMQ 发送 Map</em>等复杂消息时，需要添加（反）序列化消息转换器，否则刷屏消息转换报错，添加消息转换器步骤如下：<ul><li>添加 jackson 依赖： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-comment">&lt;!--        jackson--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. fasterxml. jackson. core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>在 <code>MailQueueListener</code> 中注册 <code>MessageConverter</code> bean： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-meta">@Bean</span>  <br><span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverterer</span> <span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-comment">// 创建一个 Jackson 2 JsonMessageConverter 对象  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson</span> <span class="hljs-number">2</span> JsonMessageConverter ();  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>Bean</strong> 不要被循环或重复导入。</li><li>使用 <strong>mybatis</strong> 时由于没有给 <code>DTO</code> 实体的<strong>属性添加与数据表对应的字段注释</strong>，因此<strong>属性名必须与字段名</strong>一致。</li><li><code>@RequestParam</code> 一般用于 <strong>Get</strong> 请求路径传参，<code>@RequestBody</code> 一般用于 <strong>Post</strong> 请求 <em>Json</em> 传递请求体数据（<em>也可以用@RequestParam 传参但必须请求头注明 url 编码为表单格式</em>）。</li><li>内部结束 <strong>setInterval</strong> 定时器： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> coldTimer = <span class="hljs-built_in">setInterval</span> (<span class="hljs-function">() =&gt;</span> &#123;  <br>  coldTime. value &gt; <span class="hljs-number">0</span> ? coldTime. value-- : <span class="hljs-built_in">clearInterval</span> (coldTimer)  &#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure></li><li><em>fastjson 2</em> 在使用时，要注意返回 json 格式化的工具类 <code>Result</code> 必须加上 <code>@Data、@AllArgsConstructor</code> 注解才能使用，否则返回的 json 格式化数据一直为<strong>空（null）</strong></li><li>SpringBoot 从 <code>2.5. x</code> 版本后开始支持<code>java17</code>，采用 <code>java17</code> 才能使用 <code>Map/List.of</code> 快速创建哈希表或列表，才能在<em>服务处显示端口号</em>并且开启 Actuator 后可以<strong>查看 Actuator 运行状态</strong>。</li><li>springboot 最大并发数：<a href="https://zhuanlan.zhihu.com/p/654602186">SpringBoot 最大连接数及最大并发数是多少？？？ - 知乎</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://zhuanlan.zhihu.com/p/654602186<br>title: &quot;SpringBoot 最大连接数及最大并发数是多少？？？&quot;<br>description: &quot;每个 Spring Boot 版本和内置容器不同，结果也不同，这里以 Spring Boot 2.7.10 版本 + 内置 Tomcat 容器举例。概序在 SpringBoot 2.7.10 版本中内置 Tomcat 版本是 9.0.73，SpringBoot 内置 Tomcat 的默认设置如下： Tomcat 的…&quot;<br>host: zhuanlan. zhihu. com<br></code></pre></td></tr></table></figure></li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="http://qnpicmap.fcsluck.top/pics/202311131742836.png" alt="image.png"></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p><img src="http://qnpicmap.fcsluck.top/pics/202311131744814.png" alt="image.png"></p><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p><img src="http://qnpicmap.fcsluck.top/pics/202311131744882.png" alt="image.png"></p><h3 id="黑暗模式"><a href="#黑暗模式" class="headerlink" title="黑暗模式"></a>黑暗模式</h3><p><img src="http://qnpicmap.fcsluck.top/pics/202311131745890.png" alt="image.png"></p><h2 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h2><ul><li><input disabled="" type="checkbox"> 实现用户管理</li><li><input disabled="" type="checkbox"> 实现权限管理</li><li><input disabled="" type="checkbox"> 实现菜单管理</li><li><input disabled="" type="checkbox"> 实现日志管理</li><li><input disabled="" type="checkbox"> 发挥想象，完善为一个有创意的平台</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://itbaima.net/<br>title: &quot;柏码 - 让每一行代码都闪耀智慧的光芒！&quot;<br>host: itbaima.net<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><p><a href="https://itbaima.net/">柏码 - 让每一行代码都闪耀智慧的光芒！</a></p>]]></content>
    
    
    <summary type="html">A Demo for SpringBoot with Vue.</summary>
    
    
    
    <category term="前后端开发" scheme="https://alleyf.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="SpringBoot" scheme="https://alleyf.github.io/tags/SpringBoot/"/>
    
    <category term="Vue" scheme="https://alleyf.github.io/tags/Vue/"/>
    
    <category term="Mysql" scheme="https://alleyf.github.io/tags/Mysql/"/>
    
    <category term="Redis" scheme="https://alleyf.github.io/tags/Redis/"/>
    
    <category term="RabbiMQ" scheme="https://alleyf.github.io/tags/RabbiMQ/"/>
    
    <category term="JWT" scheme="https://alleyf.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>司法领域KG-LLM调研四</title>
    <link href="https://alleyf.github.io/2023/11/f62aae04555b.html"/>
    <id>https://alleyf.github.io/2023/11/f62aae04555b.html</id>
    <published>2023-11-07T05:08:27.000Z</published>
    <updated>2023-11-17T09:40:37.313Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://picsum.photos/800/250"></p><h1 id="调研任务"><a href="#调研任务" class="headerlink" title="调研任务"></a>调研任务</h1><ol><li>将各个关键点搜索相关文献进行总结。</li><li>调研关于司法领域的KG与LLM相互作用的文献，有则加之，无责阐述与司法相关的关系作为创新点。</li></ol><h1 id="知识图谱增强大模型"><a href="#知识图谱增强大模型" class="headerlink" title="知识图谱增强大模型"></a>知识图谱增强大模型</h1><h2 id="1-KG强化LLM预训练"><a href="#1-KG强化LLM预训练" class="headerlink" title="1.KG强化LLM预训练"></a>1.KG强化LLM预训练</h2><p>知识图谱通常包含从高度可信的来源进行提取、处理并经过人工评估审查的信息。LLM仅使用单独的自然语言文本可能导致信息覆盖范围有限，因此，来自知识图谱的结构化显式信息可以被融入到LLM预训练语料库中，从而提高LLM的可靠性与泛化性能，有助于解决大模型的幻觉问题。为此国内外学者对此方向进行多种研究。</p><ol><li><a href="https://aclanthology.org/2022.naacl-main.113.pdf">Fedor Moiseev</a>提出了一种通过直接在知识图谱（KG）的事实三元组上训练 T5 模型来将KG结构化知识注入LLM的方法。此方法在 Wikidata KG 上预训练的模型优于 FreebaseQA 和 WikiHop 上的 T5 基线，在管理训练数据时不需要知识图谱和文本语料库之间的对齐，有助于处理行业规模的知识图。</li><li><a href="https://arxiv.org/pdf/2210.04726.pdf">Cicero Nogueira dos Santos</a>我们提出了一种训练软提示的新方法，通过使用同一组 KP 来提高 LM 在三个不同任务中的性能：问答、事实检查和关系分类，从而证明了以实体为中心的 KP 可以被视为一种通用的知识库嵌入方法，可用于扩展 LM 的世界知识。</li><li>将外部特定领域知识（例如 UMLS）注入预训练语言模型 (LM) 可以提高其处理专业领域内任务的能力，<a href="https://aclanthology.org/2021.acl-short.72.pdf">刘方宇</a>提出了一种有效的迁移学习方案，利用通用领域翻译来提高领域专业表示模型的跨语言能力解决了将特定领域知识从资源丰富的语言转移到资源贫乏的语言的挑战。</li><li><a href="https://aclanthology.org/2022.findings-naacl.115.pdf">Barlas Oguz</a>提出 UniK-QA统一结构化和非结构化信息源的预训练LLM在生成和QA任务上性能有所提高。 </li><li><a href="https://aclanthology.org/2021.naacl-main.288.pdf">Pat Verga</a>通过将向量表示的可解释性神经符号知识库在预训练和微调期间增强到LLM，显著强化了模型在知识密集型QA任务中的性能。</li></ol><h2 id="2-KG微调更新LLM"><a href="#2-KG微调更新LLM" class="headerlink" title="2.KG微调更新LLM"></a>2.KG微调更新LLM</h2><p>有许多研究运用知识图谱来拓展和优化提示生成，相较于传统的手工方法，这种方式在提示数量、质量和多样性方面都有显著的增加。<br>2. <a href="https://aclanthology.org/2021.emnlp-main.355.pdf">侯越先</a>整合KG等外部显示知识帮助提示工程，尤其是通过提供实体的附加上下文（例如属性、Khop 邻居），以帮助 LLM 生成更好的预测。<br>3. <a href="https://dl.acm.org/doi/10.1145/3485447.3511998">张宁豫</a>使用 KnowPrompt 这样的方法将KG中关系标签之间的语义和先验知识合并到关系提取的提示调整中，增强提示构建过程并通过结构化约束优化其表示。<br>4. 可以通过 KG 2 Instruction技术将知识图谱的转化成指令用于微调，<a href="https://arxiv.org/pdf/2301.11332.pdf">叶宏彬</a>通过OntoPrompt将本体用于提示微调。<br>5. <a href="https://dl.acm.org/doi/10.1145/3491102.3502087">Yoonjoo Lee</a>凭借有意义的学习模式和KG的大量遍历路径的支持，实现低成本KG单轮和多轮脚手架提示。<br>6. <a href="https://arxiv.org/pdf/2301.10405.pdf">Siyuan Cheng</a>提出编辑 KGE 模型允许直接修改LLM的知识以适应特定任务，从而提高编辑过程的效率和准确性，并且 KGE 能在不影响整体性能的情况下更新特定事实进而更新LLM。<br>7. <a href="http://export.arxiv.org/pdf/2104.08164v1.pdf">Nicola De Cao</a>提出通过知识图谱的三元组对大语言模型进行编辑从而实现知识更新，<a href="https://export.arxiv.org/pdf/2208.02743v3.pdf">Mojtaba Nayyeri</a>将大语言模型跟知识图谱通过表示学习进行融合。</p><h2 id="3-KG增强LLM推理和可解释性"><a href="#3-KG增强LLM推理和可解释性" class="headerlink" title="3.KG增强LLM推理和可解释性"></a>3.KG增强LLM推理和可解释性</h2><p>事实上，研究表明，从通用数据集训练中获得的知识主要是关于流行实体的。然而，对于特定领域的知识，可能有一些LLM尚未可知的潜在的重要知识，包括无法纳入LLM的私人和业务关键知识。LLM可以通过检索增强方法来获取外部知识，从而解决知识中断的问题。知识图谱可以表示和生成思维链，将知识从大模型中解耦出来，通过结构化更好的思维链提升大模型的推理和可解释能力，可以对医疗、法律等专精垂域知识库上的可解释推理问答提供新思路。</p><ol><li><a href="https://arxiv.org/pdf/2306.16092.pdf">崔家喜</a>使用外挂知识库的方式增强大模型输出的效果，将用户输入的问题放入知识库中进行检索，并将相关的文档片段取出后与原始输入问题进行合并等操作后，将其作为新的输入送入大模型中，这样能够减轻 LLM 输出的“幻觉”问题。</li><li><a href="https://arxiv.org/abs/2310.08975">鄂海红</a>在利用大模型强大的学习能力以及自然语言理解能力的同时，利用知识图谱的准确性和可解释性来弥补了大模型可能的幻觉现象以及本身的黑盒短板，将知识从大模型中解耦出来，实现可解释推理问答的LLM+KG新范式。</li><li><a href="https://arxiv.org/pdf/2306.01061.pdf">Wang-Chiew Tan</a>整合不同的显性知识，包括非结构化知识（例如段落）和结构化知识（例如知识图谱和数据库），以增强LLM，实现半参数LLM。</li><li><a href="https://arxiv.org/abs/2305.13269">Xingxuan Li</a>提出了知识链(CoK-Li)，它通过查询生成器从知识库获取结构化知识来执行知识引导推理。</li><li><a href="https://arxiv.org/abs/2306.06427">Jianing Wang</a> 还从知识库中检索结构化知识。它从事实性和忠实性方面估计推理链，并提示模型重新思考不可靠的推理，从而减轻 CoK-Li 中的知识检索错误。 </li><li><a href="https://arxiv.org/abs/2308.13259">Keheng Wang</a>提出KD-CoT通过多轮 QA 方法解决事实推理问题。他们设计了一个反馈增强检索器，用于检索每轮 QA 中的相关外部知识，以校准推理过程。</li></ol><h1 id="大模型增强知识图谱"><a href="#大模型增强知识图谱" class="headerlink" title="大模型增强知识图谱"></a>大模型增强知识图谱</h1><h2 id="1-LLM辅助KG自动建模"><a href="#1-LLM辅助KG自动建模" class="headerlink" title="1.LLM辅助KG自动建模"></a>1.LLM辅助KG自动建模</h2><ol><li><a href="https://aclanthology.org/2022.acl-long.371.pdf">Wenxuan Zhou</a>提出了一个统一的预训练多语言表示模型 Prix-LM ，用于多语言知识库的构建和完成，通过随意的LM 目标进行训练，利用单语言知识三元组和跨语言链接，它将不同语言的知识库中的知识嵌入到共享的表示空间中，这有利于在语言之间转移互补知识，可以捕获、传播和丰富多语言知识库中的知识。</li></ol><h2 id="2-LLM促进KG融合更新"><a href="#2-LLM促进KG融合更新" class="headerlink" title="2.LLM促进KG融合更新"></a>2.LLM促进KG融合更新</h2><ol><li><a href="https://export.arxiv.org/pdf/2206.14268v3.pdf">Shibo Hao</a>提出了一种应用GPT-3的方法，以输入实体对和手动种子提示自动生成一个加权的提示 en- semble。然后，再次使用PLM进行搜索，并将排名靠前的实体对与集合体进行配对，以使KG完成补全。</li><li><a href="https://arxiv.org/pdf/2305.15597.pdf">Pengcheng Jiang</a>提出 TAGREAL，它自动生成高质量的查询提示并从大型文本语料库中检索支持信息，以探测 PLM 中的知识以完成知识图谱补全。</li></ol><h2 id="3-LLM增强KG知识表示"><a href="#3-LLM增强KG知识表示" class="headerlink" title="3.LLM增强KG知识表示"></a>3.LLM增强KG知识表示</h2><ol><li><a href="https://arxiv.org/abs/2310.11220.pdf">Jiho Kim</a>提出了 KG-GPT，这是一个利用 LLM 来完成使用 KG 的任务的多功能框架。 KG-GPT 通过句子分割、图检索和推理三个步骤分别用于分割句子、检索相关图组件和得出逻辑结论，该模型表现出较强竞争力和稳健的性能，甚至优于几个完全监督的模型。</li></ol><h1 id="评测基准"><a href="#评测基准" class="headerlink" title="评测基准"></a>评测基准</h1><p>司法大模型综合评价方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://paperswithcode.com/paper/a-comprehensive-evaluation-of-large-language-1<br>title: &quot;Papers with Code - A Comprehensive Evaluation of Large Language Models on Legal Judgment Prediction&quot;<br>description: &quot;Implemented in one code library.&quot;<br>host: paperswithcode.com<br>image: https://raw.githubusercontent.com/srhthu/lm-compeval-legal/master/resources/static/fig_setting_example_v2.jpg<br></code></pre></td></tr></table></figure><ol><li><a href="https://paperswithcode.com/paper/a-comprehensive-evaluation-of-large-language-1">A Comprehensive Evaluation of Large Language Models on Legal Judgment Prediction | Papers With Code</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://paperswithcode.com/paper/legalbench-a-collaboratively-built-benchmark<br>title: &quot;Papers with Code - LegalBench: A Collaboratively Built Benchmark for Measuring Legal Reasoning in Large Language Models&quot;<br>description: &quot;🏆 SOTA for Legal Reasoning on LegalBench (Rule-recall) (Balanced Accuracy metric)&quot;<br>host: paperswithcode.com<br>image: https://production-media.paperswithcode.com/thumbnails/paper/2308.11462.jpg<br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://paperswithcode.com/paper/legalbench-a-collaboratively-built-benchmark">LegalBench: A Collaboratively Built Benchmark for Measuring Legal Reasoning in Large Language Models | Papers With Code</a></li></ol><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><blockquote><p>以上均为KG与LLM相互增强的部分国内外研究现状，目前尚未调研到有关司法领域的KG与LLM相互增强协同运用的研究，只是提到可以将两者结合运用到司法领域，但是已有部分企业做了相关产品，如<a href="https://www.msn.cn/zh-cn/news/other/llms-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1-spotlight%E9%A2%86%E5%9F%9F%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83%E5%8A%A0%E9%80%9F%E5%85%AC%E5%AE%89%E6%99%BA%E8%83%BD%E5%8C%96/ar-AA1juWnn">LLMs+知识图谱！Spotlight领域大模型产品发布加速公安智能化</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.brightendata.cn/product/spotlight<br>title: &quot;悦点科技-让数据创造价值&quot;<br>description: &quot;悦点科技是国内领先的企业级数据分析和数据平台服务软件企业，利用数据编织（Data Fabric）和知识图谱（Knowledge Graph）技术帮助客户构建知识图谱和数据分析平台，链接各类异构数据，挖掘数据内在价值，让数据更好的用于决策&quot;<br>host: www.brightendata.cn<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><ol><li><a href="https://www.brightendata.cn/product/spotlight">悦点科技-让数据创造价值</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.gongdao.com/coretech.html?page=intelligence<br>title: &quot;共道科技-专业的法律科技服务商&quot;<br>description: &quot;共道网络科技有限公司（简称：共道科技）于2018年成立于浙江杭州，是由阿里巴巴集团和杭州市城投集团共同设立的的互联网科技公司。公司通过应用互联网、云计算、区块链、机器智能等技术，为法院和市场监督管理局等司法和行政执法部门提供数智化解决方案，并为金融企业、知识产权权利人等企业级客户提供一站式纠纷解决等法律服务。&quot;<br>host: www.gongdao.com<br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://www.gongdao.com/coretech.html?page=intelligence">共道科技-专业的法律科技服务商</a></li></ol>]]></content>
    
    
    <summary type="html">some overview about law KG and LLM。</summary>
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="KG" scheme="https://alleyf.github.io/tags/KG/"/>
    
    <category term="NLP" scheme="https://alleyf.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>司法领域大模型调研三</title>
    <link href="https://alleyf.github.io/2023/11/50d043e5b3de.html"/>
    <id>https://alleyf.github.io/2023/11/50d043e5b3de.html</id>
    <published>2023-11-01T06:14:51.000Z</published>
    <updated>2023-11-13T05:42:15.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方向参考"><a href="#方向参考" class="headerlink" title="方向参考"></a>方向参考</h1><ol><li>大模型生成数据，提升数据质量。大模型生成数据作为训练数据，即便存在问题也可以说明，存在幻觉问题。</li><li>司法数据集已经有很多公开的数据集了，并不存在数据稀疏。</li><li>大模型对知识图谱数据的获取方面有哪些研究。</li><li>司法数据隐私安全方面，联邦学习是否可以解决。</li><li>数据时效性，数据动态更新问题，如何更新，更新效率，高低频案件变化问题。</li><li>时序知识图谱看能否运用。</li></ol><hr><h1 id="调研任务"><a href="#调研任务" class="headerlink" title="调研任务"></a>调研任务</h1><blockquote><p>研究现状：<br>    1. 数据集构建和信息抽取<br>    2. 知识图谱（重点在更新）<br>    3. 知识图谱和大模型相互促进<br>研究内容：<br>    1. 数据集构建与信息抽取<br>    2. 司法知识图谱构建<br>    3. 图谱融合和动态更新<br>    4. 知识图谱与大模型相互作用</p></blockquote><hr><h1 id="知识图谱与大模型相互增强与协同运用"><a href="#知识图谱与大模型相互增强与协同运用" class="headerlink" title="知识图谱与大模型相互增强与协同运用"></a>知识图谱与大模型相互增强与协同运用</h1><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/GNpj5fw72Er32ZwvWCfObFcRZ88HsBNZCjFrPU0gdnxKv8Y0nBIxYbo8QKibyDYe9ZwRRxfQBadVy8rUKN18CyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"></p><h2 id="知识图谱增强大模型"><a href="#知识图谱增强大模型" class="headerlink" title="知识图谱增强大模型"></a>知识图谱增强大模型</h2><h3 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h3><blockquote><p>希望利用<strong>知识图谱</strong>中的<strong>确定性知识</strong>提升大模型回答问题的<strong>可靠性</strong>，增强对答案的<strong>可解释性</strong>，并帮助大模型确定自身的<strong>能力边界</strong>。在这一过程中，研究者需要不断探索知识图谱增强大模型的有效方式，并需对结果进行客观、准确的评估。</p></blockquote><h3 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h3><ol><li>**知识图谱作为预训练数据[3]**：由于自然语言文本本身可能只提供有限的信息覆盖，而知识图谱可以为语言模型提供结构化的事实知识，集成知识图谱的语言模型（预）训练方法，使得向模型注入世界知识和实时更新知识更加方便。这种融合了知识图谱信息的语言模型，在知识密集型 QA 任务上展示了具有竞争力的结果，证明了这种方法在提升语言模型的能力具有重要意义。</li><li>**监督微调[2]**：可以通过 KG 2 Instruction技术将知识图谱的转化成指令用于微调，还可以通过 OntoPrompt 将本体用于提示微调；</li><li>**知识融合和更新[2]**：可以通过知识图谱的三元组对大语言模型进行编辑从而实现知识更新[Cao 2021]，并且可以将大语言模型跟知识图谱通过表示学习进行融合[Nayyeri  2023]，以及将一个大模型的知识迁移给另外一个大模型[Choi 2022]；</li><li><strong>模型推理[2]<strong>：</strong>借助外挂知识库&#x2F;图谱知识增强提升 LLM 效果[1]<strong>：目前比较主流的方式为使用</strong>外挂知识库</strong>的方式增强大模型输出的效果。具体为：将用户输入的问题转换为向量后，将该问题<strong>向量放入知识库中进行检索</strong>，并将相关的<strong>文档片段</strong>取出后与<strong>原始输入问题</strong>进行合并等操作后，将其作为新的输入送入大模型中。这样在输入端就对 LLM 的输出进行了一些限制，能够减轻 LLM 输出的“<em>幻觉</em>”问题。另外的，这种<strong>文本知识库</strong>也可以替换为<strong>图数据库</strong>，即将文本信息转换为图数据后进行检索。<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/GNpj5fw72EoNLcgjjszm2DrnaibS4IYrJ4OChnFNYIAmWiazrb5d52HCnKWfWu32ZaSJrAx2vCwHia4Vt8vzaDmFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1"><br>另外，**构建提示模板[3]**：目前使用知识图谱来丰富和微调提示模板，从而在提示的数量、质量和多样性上比手动的方法更具优势，已有方法证明了通过图谱构建的提示模板进行推理比传统方法更具竞争力，但目前该方法仍存在挑战与机遇：<br> 1）生成上下文感知的写作提示，分析不同提示之间的关系，形成具有关联关系的提示模板。<br> 2）动态生成和用户交互的提示模板，由于知识图谱提供了知识的透明表示，因此可以很容易地将从知识图谱生成的提示追溯到它们的底层源。<br> 3）将知识图谱集成到提示模板中，增强模型生成内容的可行度。<br> 4）知识图谱可以创建询问问题的提示，从而触发知识图谱复杂推理能力和中间推理步骤。<br>此外，还可以通过知识图谱生成提示[Chen 2022]或者指令[Du, 2022]用于增强模型的推理能力。此外，思维链可以指导大模型推理[2]，知识图谱可以表示和生成思维链，通过结构化更好的思维链提升大模型的推理能力。</li><li><strong>增强可解释性</strong>：包括用KG来理解LLM所学到的知识并解释LLM推理过程。</li></ol><hr><h2 id="大模型增强知识图谱"><a href="#大模型增强知识图谱" class="headerlink" title="大模型增强知识图谱"></a>大模型增强知识图谱</h2><h3 id="愿景-1"><a href="#愿景-1" class="headerlink" title="愿景"></a>愿景</h3><blockquote><p>利用大模型的<strong>外溢技术</strong>对于提升知识图谱构建任务的<strong>性能和效率</strong>有帮助，研究者还可以充分利用大模型出色的<strong>泛化能力</strong>、以及在一些基础任务上的出色性能来自动构建一些<strong>高质量的知识图谱资源</strong>。这些资源从长远来看，对于文本处理的各项任务而言更有意义。大模型的出色泛化能力可以帮助快速形成一定规模、一定质量的行业知识图谱，为后续可行的“大模型+行业”模式提供重要基础支撑。</p></blockquote><h3 id="研究现状-1"><a href="#研究现状-1" class="headerlink" title="研究现状"></a>研究现状</h3><ol><li>**知识自动建模[4]**：可以为知识抽取生成标注数据，利用大语言模型的知识理解能力，可以设计通用信息抽取方法，利用一个模型抽取实体、关系、属性值、事件，大语言模型还可以做零样本知识生成，利用通用信息抽取得到的三元组，通过人工校对形成大标注数据还可以用于训练监督模型</li><li>**知识融合的自动化 [5] 于冲突解决 [6] ：</li><li>**知识图谱的知识表示学习[7]**：</li><li><strong>本体模式的构建</strong>：该部分包括三方面分别为：<ul><li>从知识图谱中挖掘约束和规则：现有构建知识图谱的方法通常使用 pipeline 的方式，这种方法容易造成<strong>误差传播</strong>问题，通过<strong>引入自动化的规则和约束</strong>来限制构建图谱时错误信息的引入可以<strong>提升数据的质量</strong>。如何生成这些约束和规则是一个根本性的挑战，在此背景下，大语言模型带来了新的机遇：<br>   1）从输入文本中提取<strong>上下文信息</strong>的能力；<br>   2）在训练过程中使用上下文提取信息；<br>   3）通过<strong>归纳推理生成新的规则</strong>。<br>   4）理解词汇信息，<strong>协调同义词和一词多义</strong>现象；<br>   5）提供<strong>规则的解释和生成候选</strong>以及反事实样例。</li><li>本体优化：本体优化包含很多主题：<em>知识补全、错误知识检测和修复和知识规范化</em>等，开发基于大语言模型的本体细化工具仍然存在以下挑战：<br>   1）利用文本及其本体的图结构和逻辑；<br>   2）结合符合推理和大语言模型推理。</li><li>本体对齐：单个本体的<strong>知识通常是不完整的</strong>，许多真实世界的应用通常依赖于跨领域的知识。本体对齐的主要挑战是评估基于大语言模型的本体对齐系统。</li></ul></li></ol><h2 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h2><h3 id="知识图谱运用于大模型"><a href="#知识图谱运用于大模型" class="headerlink" title="知识图谱运用于大模型"></a>知识图谱运用于大模型</h3><ol><li><em>外挂知识库</em>引起的问题：<ol><li><strong>检索长度造成的敏感度问题</strong>：检索样本数量的增多，LLM 输入的长度也随之扩大。而已经有相关研究表明，随着 LLM 输入长度的增加，LLM 对输入文本两端的文本敏感，而对输入文本靠近中间的文本越来越不敏感。</li><li><strong>非对称检索问题</strong>：外挂知识库在非对称检索上的效果并不是很好，简单来说就是向量化模型很难将问题和答案映射到统一向量空间。</li><li><strong>外挂知识库的局限性</strong>：外挂知识库只从输入端对“幻觉”问题进行一定的限制，这样可能还会使得大模型的输出存在一些“幻觉”问题，并未从输出端对“幻觉”问题的限制。</li></ol></li></ol><h3 id="大模型运用于知识图谱"><a href="#大模型运用于知识图谱" class="headerlink" title="大模型运用于知识图谱"></a>大模型运用于知识图谱</h3><ol><li>从大模型进行<em>知识抽取提取三元组</em>遇到的挑战：<br> 1）由于实体名称的重复性，需要进行<strong>实体消歧</strong>；<br> 2）由于大语言模型读<strong>长尾实体记忆的不精确</strong>性，导致产生错误的信息；<br> 3）大语言模型面临着<strong>高精度</strong>的要求；<br> 4）大语言模型的输出不提供出处，为核验该<strong>信息的准确性</strong>带来了信息的挑战。</li></ol><h3 id="个性问题"><a href="#个性问题" class="headerlink" title="个性问题"></a>个性问题</h3><h4 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h4><h4 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h4><ol><li><strong>知识表示与推理</strong>：<br>知识图谱提供了具有明确关系的知识的结构化表示，支持推理和推断。有学者认为大语言模型中“参数化”的知识是基于统计的，并不是真正的理解和推理，并且由于缺乏明确的知识表征，模型会生成看似合理但却荒谬的结果。</li><li><strong>高精度方法</strong>：<br>知识图谱的成功在于其可以精确地提供关于实体的事实信息，如 YAGO，可以提供 95%以上的正确信息。同样知识图谱在用于生产环境时需要较高的精度，例如 Google 的 Knowledge Vault 未能成功落地也是因为其精度达不到要求的 99%。目前基于 BERT 或 GPT 等的方法不能满足以上要求，这知识计算科学家仍然需要探索基于大语言模型的高精度的方法。</li><li><strong>数值计算</strong>：<br>对于语言模型来说，完成数值计算工作是一项具有挑战性的任务，该挑战同样适用于知识图谱补全任务。在基于 Wikidata 的数字事实来评估语言模型数值计算能力中，没有一个模型能准确地得到结果，尽管已有的模型在数值处理的能力上表现不俗，但考虑到数值具有不同的度量和类型，使得该任务难度进一步升级，因此，修改模型来处理数值的问题仍未被解决，以至于利用大语言模型来完成数值知识图谱的补全看起来是不现实的。</li><li><strong>长尾知识</strong>：<br>在对大语言模型的调查过程中发现，使用 Wikidata 中随机的知识对模型进行测试时，模型的性能会急剧的恶化，尤其是在遇到长尾的实体时。这种情况的出现，究其原因就是在预训练过程中实体和关系出现的频率是不一样的，模型对长尾的信息是难以保持精准记忆的。相反，知识图谱在提供长尾实体的知识上具有天然的优势，因此可以进一步提升大语言模型在知识计算任务中的回忆能力。</li><li><strong>偏见、公平等</strong>：<br>一部分学者认为大语言模型会使训练数据中的偏见持续存在并放大，从而导致有偏见的输出。而另一部分学者认为偏见不是大语言模型中所固有的特征，而是训练数据集中嵌入的社会偏见，他们强调了在训练数据中消除偏见和开发能够缓解偏见技术的重要性。知识图谱在构建过程中同样会嵌入“偏见”，并且会被运用到各种下游任务中。除了偏见和公平外，还有侵犯版权和错误信息等问题。与显式知识相比，大语言模型中“参数化”偏见知识更难以被去除或修改。（种族歧视）大模型对黑人有偏见，画黑人医生给儿童治病结果大部分生成结果都是白人医生。</li><li><strong>可解释性</strong>：<br>在可解释性的场景中，知识图谱通常是首选的。对大语言模型持有怀疑态度的学者们认为：大模型是一个黑盒，缺乏可解释性，很难理解他们是如何产生结果的。但支持者们虽然承认了大模型可解释性差的问题，但却通过最近的一些研究，如注意力机制、模型内省等技术可以在一定程度提升模型的可解释性。思维链技术、问题解耦和答案归因等方法，是最近在大语言模型可解释性方法研究中的一些热点话题。</li></ol><h3 id="共性问题"><a href="#共性问题" class="headerlink" title="共性问题"></a>共性问题</h3><h2 id="协同完成复杂知识处理任务"><a href="#协同完成复杂知识处理任务" class="headerlink" title="协同完成复杂知识处理任务"></a>协同完成复杂知识处理任务</h2><ul><li>大语言模型平台可以利用知识图谱平台生成的符号化知识对企业中的各种知识进行集成，对大语言模型平台的指令进行分解，完成复杂任务（比如说微软 Office 365 Copilot）。</li><li>知识图谱平台和大语言模型平台协同完成复杂问题的知识问答，这里可以发挥大语言模型的语义理解能力和知识量大的优势，同时发挥基于知识图谱的问答系统的知识精确性和答案可解释性的优势。</li><li>知识图谱平台用于沉淀大模型平台中任务驱动的关键知识，用于完成需要精确、可解释的问答和行动。</li></ul><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://mp.weixin.qq.com/s/SfG-d-VBdI7hkgRikNtm9Q">任飞亮—大模型与知识图谱研究中的若干问题思考</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU2NjAxNDYwMg==&mid=2247502433&idx=1&sn=917ed3ac22e689d8ed2441135969667a&chksm=fcb06d84cbc7e492746845c60ec4e3ca69cd5883169339967cc999e855f4caba94b0b3004dcf&scene=178&cur_album_id=3073566525166419969#rd">漆桂林—知识图谱和大语言模型的共存之道</a></li><li><a href="https://arxiv.org/abs/2308.06374">Jeff Pan、陈矫彦等——大语言模型与知识图谱的机遇与挑战</a></li><li><a href="https://arxiv.org/pdf/2307.16648.pdf">Giglou-LLMs4OL: Large Language Models for Ontology Learning</a> ^5d9062</li><li><a href="https://arxiv.org/pdf/2307.11772.pdf">Zhang-AutoAlign: Fully Automatic and Effective<br>Knowledge Graph Alignment enabled by Large<br>Language Models</a></li><li><a href="https://arxiv.org/pdf/2304.01664.pdf">Wang-An Embedding-based Approach to<br>Inconsistency-tolerant Reasoning with<br>Inconsistent Ontologies</a></li><li><a href="https://arxiv.org/pdf/2306.08302.pdf">Pan-Unifying Large Language Models and<br>Knowledge Graphs: A Roadmap</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方向参考&quot;&gt;&lt;a href=&quot;#方向参考&quot; class=&quot;headerlink&quot; title=&quot;方向参考&quot;&gt;&lt;/a&gt;方向参考&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;大模型生成数据，提升数据质量。大模型生成数据作为训练数据，即便存在问题也可以说明，存在幻觉问题。&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="NLP，KG" scheme="https://alleyf.github.io/tags/NLP%EF%BC%8CKG/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 简记</title>
    <link href="https://alleyf.github.io/2023/10/7ca8ec33c92b.html"/>
    <id>https://alleyf.github.io/2023/10/7ca8ec33c92b.html</id>
    <published>2023-10-31T07:04:18.000Z</published>
    <updated>2023-11-14T07:40:34.902Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2023/07/10/VBkHuWr83jzpnXe.png" alt="image-20230710170222399"></p><h1 id="走进SpringBoot一站式开发"><a href="#走进SpringBoot一站式开发" class="headerlink" title="走进SpringBoot一站式开发"></a>走进SpringBoot一站式开发</h1><p><strong>前置课程：</strong>《Spring6核心内容》《SpringMvc6》《SpringSecurity6》《Java-9-17新特性篇》</p><p>**提醒：好奇能不能不学SSM直接SpringBoot，这里声明一下，SpringBoot只是用于快速创建SSM项目的脚手架，就像是个外壳一样，离开了SSM核心内容就是个空壳，不要本末倒置了。</p><p>Spring Boot让您可以轻松地创建独立的、生产级别的Spring应用程序，并“直接运行”这些应用程序。SpringBoot为大量的第三方库添加了支持，能够做到开箱即用，简化大量繁琐配置，用最少的配置快速构建你想要的项目。在2023年，SpringBoot迎来了它的第三个大版本，随着SpringBoot 3的正式发布，整个生态也迎来了一次重大革新。</p><p>目前的最新版本以及对应的维护情况：</p><p><img src="https://s2.loli.net/2023/07/10/qnjY5MdRrOemFaQ.png" alt="image-20230710174659973"></p><p>可以看到，曾经的SpringBoot 2.5版本将会在2023年8月底终止商业支持，届时将不会再对这类旧版本进行任何维护，因此，将我们的老版本SpringBoot项目进行升级已经迫在眉睫，目前最强的3.1正式版会维护到2025年中旬。</p><p>在3.X之后的变化相比2.X可以说是相当大，尤其是其生态下的SpringSecurity框架，旧版本项目在升级之后API已经完全发生改变；以及内置Tomcat服务器的升级，Servlet也升级到5以上，从<code>javax</code>全新升级到<code>jakarta</code>新包名；包括在3.X得到的大量新特性，如支持GraalVM打包本地镜像运行等；并且Java版本也强制要求为17版本。迁移到新版本不仅可以享受到免费维护支持，也可以感受Java17带来的全新体验。</p><p>介绍了这么多，我们首先还是来看看SpringBoot功能有哪些：</p><ul><li>能够创建独立的Spring应用程序</li><li>内嵌Tomcat、Jetty或Undertow服务器（无需单独部署WAR包，打包成Jar本身就是一个可以运行的应用程序）</li><li>提供一站式的“starter”依赖项，以简化Maven配置（需要整合什么框架，直接导对应框架的starter依赖）</li><li>尽可能自动配置Spring和第三方库（除非特殊情况，否则几乎不需要进行任何配置）</li><li>提供生产环境下相关功能，如指标、运行状况检查和外部化配置</li><li>没有任何代码生成，也不需要任何XML配置（XML是什么，好吃吗）</li></ul><p>SpringBoot是现在最主流的开发框架，国内的公司基本都在使用，也是我们出去找工作一定要会的框架，它提供了一站式的开发体验，能够大幅度提高我们的开发效率。</p><p><img src="https://s2.loli.net/2022/11/22/hDGo7m9uBlgVn5A.png" alt="image-20221122175719997"></p><p>在SSM阶段，当我们需要搭建一个基于Spring全家桶的Web应用程序时，我们不得不做大量的依赖导入和框架整合相关的Bean定义，光是整合框架就花费了我们大量的时间，但是实际上我们发现，整合框架其实基本都是一些固定流程，我们每创建一个新的Web应用程序，基本都会使用同样的方式去整合框架，我们完全可以将一些重复的配置作为约定，只要框架遵守这个约定，为我们提供默认的配置就好，这样就不用我们再去配置了，约定优于配置！</p><p>而SpringBoot正是将这些过程大幅度进行了简化，它可以自动进行配置，我们只需要导入对应的启动器（starter）依赖即可。</p><hr><p>完成本阶段的学习，基本能够胜任部分网站系统的后端开发工作，也建议同学们学习完SpringBoot之后寻找合适的队友去参加计算机相关的高校竞赛，这里有一些推荐：</p><p><strong>项目类：</strong></p><p>建议：按照目前国内的环境，项目类竞赛并不会注重你编码水平有多牛，也不会注重你的项目用到了多牛的技术，这些评委老师技术怎么样我不多说，他们只会在乎你项目制作的功能怎么样，展示效果怎么样，有没有什么创新点，至于其他的，哪怕代码写成一坨屎都不会管你。并且项目最好是有专利证书或者软著，尤其是企业合作项目，已经投入生产的，特别吃香。如果你是白手起家的项目，即使你再努力地去做，也不可能打得过人家强大的项目背景。</p><table><thead><tr><th>比赛名称</th><th>难度</th><th>含金量</th><th>备注</th></tr></thead><tbody><tr><td>创新创业大赛</td><td>⭐️⭐️⭐️⭐️⭐️</td><td>⭐️⭐️⭐️⭐️</td><td>这比赛没点背景很难，最好是专利项目或是企业合作项目</td></tr><tr><td>挑战杯</td><td>⭐️⭐️⭐️⭐️⭐️</td><td>⭐️⭐️⭐️⭐️</td><td>网传这是PPT大赛，不知真实性如何</td></tr><tr><td>中国大学生计算机设计大赛</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>这个比赛相对来说比较好拿奖，项目一定要有亮点</td></tr></tbody></table><p><strong>算法类：</strong></p><p>建议：这种竞赛越早开始培养越好，因为要背很多的题板和算法，很多人都是初中或者高中就开始打竞赛了，像团队类型的竞赛，如果自己比较菜，就去找大佬抱大腿吧，十个臭皮匠都顶不了诸葛亮；个人类型的竞赛也要多刷力扣，多背算法题，临时抱佛脚也是没有用的。</p><table><thead><tr><th>比赛名称</th><th>难度</th><th>含金量</th><th>备注</th></tr></thead><tbody><tr><td>蓝桥杯</td><td>⭐️⭐️⭐️</td><td>⭐️⭐️⭐️</td><td>蓝桥杯建议参加前端&#x2F;Java组，稍微简单一点，去C++就是找死</td></tr><tr><td>CCPC 天梯赛</td><td>⭐️⭐️⭐️⭐️</td><td>⭐️⭐️⭐️⭐️</td><td>不多说</td></tr><tr><td>ICPC ACM 大学生程序设计竞赛</td><td>⭐️⭐️⭐️⭐️⭐️</td><td>⭐️⭐️⭐️⭐️⭐️</td><td>这个难度非常大，最好是有大佬带，靠自己慢慢去学很难</td></tr></tbody></table><p>打竞赛的过程是很辛苦的，付出很有可能没有回报，很多竞赛没有绝对的公平，多多少少有一些利益关系在里面，但是多参加一些竞赛哪怕没有得奖，还是可以收获到很多的，如果你通过这些比赛学到了很多，实际上得不得奖已经不重要了，自己内心的强大的才是真正的强大。</p><hr><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><blockquote><ul><li><strong>springboot版本和maven版本和jdk版本有一定的依赖关系</strong>，否则会导致扫描不到bean，springboot版本越高要求maven版本也要越高，谨记这个小bug。</li><li>maven和jdk依赖关系如下：</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://maven.apache.org/docs/history.html<br>title: &quot;Maven – Maven Releases History&quot;<br>host: maven.apache.org<br></code></pre></td></tr></table></figure><p>要感受SpringBoot带来的快速开发体验，我们就从创建一个项目开始。</p><h3 id="极速创建项目"><a href="#极速创建项目" class="headerlink" title="极速创建项目"></a>极速创建项目</h3><p>在过去，我们创建一个SSM项目，需要先导入各种依赖，进行大量的配置，而现在，有了SpringBoot，我们可以享受超快的项目创建体验，只需要前往官网进行少量配置就能快速为你生成一个SpringBoot项目模版：<a href="https://start.spring.io/">https://start.spring.io/</a></p><p><img src="https://s2.loli.net/2023/07/11/V6lBrtp5QvbPyKk.png" alt="image-20230711124041648"></p><p>不过，为了方便，IDEA已经将这个工具集成到内部了，我们可以直接在IDEA中进行创建，效果是一样的，首先在新建项目阶段，选择 Spring Initializr 类型：</p><p><img src="https://s2.loli.net/2023/07/11/Ol3Tqh21V8pjyLW.png" alt="image-20230711124216094"></p><p>接着我们就可以配置项目的语言，并且选择项目需要使用的模块，这里我们简单选择两个依赖：</p><p><img src="https://s2.loli.net/2023/07/11/rzJblifUQomV4Ed.png" alt="image-20230711124332819"></p><p>如果一开始不清楚自己需要哪些模块，我们也可以后续自己手动添加对应模块的starter依赖，使用非常简单。</p><p>项目自动生成之后，可以看到Spring相关的依赖已经全部自动导入：</p><p><img src="https://s2.loli.net/2023/07/11/2P9wIJGdYluk8Hz.png" alt="image-20230711124949017"></p><p>并且也自动为我们创建了一个主类用于运行我们的SpringBoot项目：</p><p><img src="https://s2.loli.net/2023/07/11/ZSAbwpurQKYDN6O.png" alt="image-20230711125025254"></p><p>我们可以一键启动我们的SpringBoot项目：</p><p><img src="https://s2.loli.net/2023/07/11/1YvbfCkoIWEBg4X.png" alt="image-20230711125447493"></p><p>只不过由于我们没有添加任何有用的模块，也没有编写什么操作，因此启动之后项目就直接停止了。</p><h3 id="常用模块快速整合"><a href="#常用模块快速整合" class="headerlink" title="常用模块快速整合"></a>常用模块快速整合</h3><p>前面我们说了，SpringBoot的核心思想就是约定大于配置，能在一开始默认的就直接默认，不用我们自己来进行配置，我们只需要配置某些特殊的部分即可，这一部分我们就来详细体验一下。</p><p>我们来尝试将我们之前使用过的模块进行一下快速整合，可以看到在一开始的时候，我们没有勾选其他的依赖，因此这里只导入了最基本的<code>spring-boot-starter</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所有的SpringBoot依赖都是以starter的形式命名的，之后我们需要导入其他模块也是导入<code>spring-boot-starter-xxxx</code>这种名称格式的依赖。</p><p>首先我们还是从SpringMvc相关依赖开始。SpringBoot为我们提供了包含内置Tomcat服务器的Web模块，我们只需要导入依赖就能直接运行服务器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们不需要进行任何配置，直接点击启动：</p><p><img src="https://s2.loli.net/2023/07/11/Hz1dVPqpe3vJsuR.png" alt="image-20230711133113516"></p><p>它真的做到了开箱即用，我们现在可以直接访问这个网站：</p><p><img src="https://s2.loli.net/2023/07/11/7GELtUH3Kj5ld1w.png" alt="image-20230711133224425"></p><p>可以看到成功响应了404页面，相比之前的大量配置，可以说方便了很多，我们到目前为止仅仅是导入了一个依赖，就可以做到直接启动我们的Web服务器并正常访问。</p><p>SpringBoot支持自动包扫描，我们不需要编写任何配置，直接在任意路径（但是不能跑到主类所在包外面去了）下创建的组件（如Controller、Service、Component、Configuration等）都可以生效，比如我们这里创建一个测试的Controller试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启之后，可以看到直接就能访问到，而这期间我们只是创建了对应的Controller却没有进行任何配置，这真的太方便了：</p><p><img src="https://s2.loli.net/2023/07/13/2jrxoswhNpASPil.png" alt="image-20230713225914578"></p><p>包括一个对象现在也可以直接以JSON形式返回给客户端，无需任何配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> sid;<br>    String name;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setName(<span class="hljs-string">&quot;小明&quot;</span>);<br>    student.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>    student.setSid(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> student;<br>&#125;<br></code></pre></td></tr></table></figure><p>![image-20230715171140388](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230715171140388.png)</p><p>最后浏览器能够直接得到<code>application/json</code>的响应数据，就是这么方便，这都得归功于SpringBoot对应的start帮助我们自动将处理JSON数据的Converter进行了配置，我们不需要再单独去配置Converter了。不过SpringBoot官方默认使用的是<code>Jackson</code>和<code>Gson</code> 的HttpMessageConverter来进行配置，不是我们之前教程中使用的FastJSON框架。</p><p>我们最后来看看这个Start包含了哪些依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>里面包含了以下内容：</p><ul><li>spring-boot-starter  基础依赖starter</li><li>spring-boot-starter-json  配置JSON转换的starter</li><li>spring-boot-starter-tomcat   内置Tomcat服务器</li><li>spring-web、spring-webmvc    不用多说了吧，之前已经讲过了</li></ul><p>如果需要像之前一样添加WebMvc的配置类，方法是一样的，直接创建即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只需要添加Configuration用于注册配置类，不需要其他任何注解，已经自动配置好了</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerInterceptor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">return</span> HandlerInterceptor.<span class="hljs-built_in">super</span>.preHandle(request, response, handler);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在SSM阶段编写的大量配置，到现在已经彻底不需要了。</p><p>同样的，我们来看看SpringSecurity框架如何进行整合，也是非常简单，我们只需要直接导入即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入完成后，再次访问网站，就可以看到熟悉的登录界面了：</p><p><img src="https://s2.loli.net/2023/07/15/1dJaDbqlyUgnFBt.png" alt="image-20230715182059681"></p><p>我们没有进行任何配置，而是对应的Starter帮助我们完成了默认的配置，并且在启动时，就已经帮助我们配置了一个随机密码的用户可以直接登录使用：</p><p><img src="https://s2.loli.net/2023/07/15/a4QbGBtMdZP6qec.png" alt="image-20230715182323772"></p><p>密码直接展示在启动日志中，而默认用户名称为<code>user</code>我们可以直接登录：</p><p><img src="https://s2.loli.net/2023/07/15/StwKT5JLdG3Vacv.png" alt="image-20230715182448770"></p><p>同样没有进行任何配置，我们只需要添加对应的starter就能做到开箱即用，并且内置一套默认配置，自动帮助我们创建一个测试用户，方便我们快速搭建项目，同样的，如果要进行额外配置，我们只需要直接添加配置类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//依然只需要Configuration注解即可，不需要其他配置</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>  <span class="hljs-comment">//配置方式跟之前SSM阶段是一样的</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> http<br>                .authorizeHttpRequests(auth -&gt; &#123;<br>                    auth.anyRequest().authenticated();<br>                &#125;)<br>                .formLogin(conf -&gt; &#123;<br>                    conf.loginPage(<span class="hljs-string">&quot;/login&quot;</span>);<br>                    conf.loginProcessingUrl(<span class="hljs-string">&quot;/doLogin&quot;</span>);<br>                    conf.defaultSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);<br>                    conf.permitAll();<br>                &#125;)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们也可以快速整合之前使用的模版引擎，比如Thymeleaf框架，直接上对应的Starter即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在默认情况下，我们需要在<code>resources</code>目录下创建两个目录：</p><p><img src="https://s2.loli.net/2023/07/15/HfGt61A7OqVDesz.png" alt="image-20230715225833930"></p><p>这两个目录是默认配置下需要的，名字必须是这个：</p><ul><li><code>templates</code> - 所有模版文件都存放在这里</li><li><code>static</code> - 所有静态资源都存放在这里</li></ul><p>我们只需要按照上面的样子放入我们之前的前端模版，就可以正常使用模版引擎了，同样不需要进入任何的配置，当然，如果各位小伙伴觉得不方便，我们后续也可以进行修改。</p><p>我们不需要在controller中写任何内容，它默认会将index.html作为首页文件，我们直接访问服务器地址就能展示首页了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><span class="hljs-comment">//什么都不用写</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/15/thnN29vz4fuYRFW.png" alt="image-20230715230152860"></p><p>这都是得益于约定大于配置的思想，开箱即用的感觉就是这么舒服，不过肯定有小伙伴好奇那现在要怎么才能像之前一样自己写呢，这个肯定还是跟之前一样的呗，该怎么写就怎么写。</p><p>我们最后再来看看Mybatis如何进行整合，同样只需要一个starter即可，这里顺便把MySQL的驱动加上：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意这里的<code>mybatis-spring-boot-starter</code>版本需要我们自己指定，因为它没有被父工程默认管理。</p><p><img src="https://s2.loli.net/2023/07/15/yWAUnZufkxH8CFp.png" alt="image-20230715231142842"></p><p>启动服务器时，我们发现这里出现了问题，导致无法启动。这是因为我们没有配置数据源导致的，虽然SpringBoot采用约定大于配置的思想，但是数据库信息只有我们自己清楚，而且变化多样，根本没有办法提前完成约定，所以说这里我们还是需要再配置文件中编写，至于如何编写配置文件我们会在下一节中进行讲解。</p><h3 id="自定义运行器"><a href="#自定义运行器" class="headerlink" title="自定义运行器"></a>自定义运行器</h3><p>在项目中，可能会遇到这样一个问题：我们需要在项目启动完成之后，紧接着执行一段代码。</p><p>我们可以编写自定义的ApplicationRunner来解决，它会在项目启动完成后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义执行！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以使用CommandLineRunner，它也支持使用@Order或是实现Ordered接口来支持优先级执行。</p><p>这个功能比较简单，不多做介绍了。</p><h3 id="配置文件介绍"><a href="#配置文件介绍" class="headerlink" title="配置文件介绍"></a>配置文件介绍</h3><p>前面我们已经体验了SpringBoot带来的快捷开发体验，不过我们发现有些东西还是需要我们自己来编写配置才可以，不然SpringBoot项目无法正常启动，我们来看看如何编写配置。我们可以直接在<code>application.properties</code>中进行配置编写，它是整个SpringBoot的配置文件，比如要修改服务器的默认端口：</p><p><img src="https://s2.loli.net/2023/07/15/E3nsZG7DcaSzOBY.png" alt="image-20230715232124133"></p><p>这些配置其实都是各种Starter提供的，部分配置在Starter中具有默认值，我们即使不配置也会使用默认值，比如这里的8080就是我们服务器的默认端口，我们也可以手动修改它，来变成我们需要的。</p><p>除了配置已经存在的选项，我们也可以添加自定义的配置，来方便我们程序中使用，比如我们这里创建一个测试数据：</p><p><img src="https://s2.loli.net/2023/07/15/HJWz7PIl6Sgk1nx.png" alt="image-20230715234130924"></p><p>我们可以直接在程序中通过<code>@Value</code>来访问到（跟我们之前Spring基础篇讲的是一样的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;test.data&#125;&quot;)</span><br>    <span class="hljs-type">int</span> data;   <span class="hljs-comment">//直接从配置中去取</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件除了使用<code>properties</code>格式以外，还有一种叫做<code>yaml</code>格式，它的语法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">一级目录:</span><br>    <span class="hljs-string">二级目录:</span><br>      <span class="hljs-string">三级目录1:</span> <span class="hljs-string">值</span><br>      <span class="hljs-string">三级目录2:</span> <span class="hljs-string">值</span><br>      <span class="hljs-string">三级目录List:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-string">元素1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">元素2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">元素3</span><br></code></pre></td></tr></table></figure><p>我们可以看到，每一级目录都是通过缩进（不能使用Tab，只能使用空格）区分，并且键和值之间需要添加冒号+空格来表示。</p><p>SpringBoot也支持这种格式的配置文件，我们可以将<code>application.properties</code>修改为<code>application.yml</code>或是<code>application.yaml</code>来使用YAML语法编写配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>现在我们来尝试为之前的数据源进行一下配置，这样才能正常启动我们的服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">spring:<br>  datasource:<br>    url: jdbc:mysql:<span class="hljs-comment">//localhost:3306/test</span><br>    username: root<br>    password: <span class="hljs-number">123456</span><br>    driver-class-name: com.mysql.cj.jdbc.Driver<br></code></pre></td></tr></table></figure><p>配置完成后，我们就可以正常启动服务器了。</p><p>这里我们接续来测试一下MyBatis的配置，想要在SpringBoot中使用Mybatis也很简单，不需要进行任何配置，我们直接编写Mapper即可，这里我们随便创建一个表试试看：</p><p><img src="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png" alt="image-20230716000431492"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    String email;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在SpringBoot整合之后，我们只需要直接在配置类上添加<code>@MapperScan</code>注解即可，跟我们之前的使用方法是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&quot;com.example.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>  ...<br></code></pre></td></tr></table></figure><p>不过，为了方便，我们也可以直接为需要注册为Mapper的接口添加<code>@Mapper</code>注解，来表示这个接口作为Mapper使用：</p><p><img src="https://s2.loli.net/2023/07/16/lTrXepw1c38IdSv.png" alt="image-20230716000755756"></p><p>这样，即使不配置MapperScan也能直接注册为Mapper正常使用，是不是感觉特别方便？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> mapper.findUserById(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>访问接口测试一下：</p><p><img src="https://s2.loli.net/2023/07/16/PSfpylWGCs3bzZj.png" alt="image-20230716001311316"></p><p>最后，我们再来介绍一下常见的配置项，比如SpringSecurity和SpringBootMvc配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-comment">#  Spring Mvc相关配置</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">static-path-pattern:</span> <span class="hljs-string">/static/**</span>   <span class="hljs-comment">#静态资源解析地址</span><br>  <span class="hljs-comment"># Spring Security 相关配置</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">filter:</span><br>      <span class="hljs-attr">order:</span> <span class="hljs-number">-100</span> <span class="hljs-comment">#Spring Security 过滤器优先级</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;admin&#x27;</span>   <span class="hljs-comment">#默认登录用户名</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">&#x27;123456&#x27;</span>   <span class="hljs-comment">#默认登录密码</span><br>      <span class="hljs-attr">roles:</span>    <span class="hljs-comment">#默认用户的角色</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">admin</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">user</span><br></code></pre></td></tr></table></figure><p>更多的配置我们可以在后续的学习中继续认识，这些配置其实都是由Starter提供的，确实极大程度简化了我们对于框架的使用。</p><h3 id="轻松打包运行"><a href="#轻松打包运行" class="headerlink" title="轻松打包运行"></a>轻松打包运行</h3><p>前面我们介绍了一个SpringBoot如何快捷整合其他框架以及进行配置编写，我们接着来看如何打包我们的SpringBoot项目使其可以正常运行，SpringBoot提供了一个非常便捷的打包插件，能够直接将我们的项目打包成一个jar包，然后使用java命令直接运行，我们直接点击Maven中的：</p><p><img src="https://s2.loli.net/2023/07/16/oI6YjqUurZznw3C.png" alt="image-20230716155322915"></p><p>点击之后项目会自动打包构建：</p><p><img src="https://s2.loli.net/2023/07/16/2dToslkFHXxujOa.png" alt="image-20230716155412252"></p><p>打包完成之后，会在target目录下出现一个打包好的jar文件：</p><p><img src="https://s2.loli.net/2023/07/16/itQxlHTL5hsjIme.png" alt="image-20230716155622849"></p><p>我们可以直接在命令行中运行这个程序，在CMD中进入到target目录，然后输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java -jar demo-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>这样就可以直接运行了：</p><p><img src="https://s2.loli.net/2023/07/16/7bjyil3RgfuNLsZ.png" alt="image-20230716155834628"></p><p>现在，我们的SpringBoot项目就可以快速部署到任何计算机了，只要能够安装JRE环境，都可以通过命令一键运行。</p><p>当然，可能也会有小伙伴好奇，怎么才能像之前一样在我们的Tomcat服务器中运行呢？我们也可以将其打包为War包的形式部署到我们自己环境中的Tomcat服务器或是其他任何支持Servlet的服务器中，但是这种做法相对比较复杂，不太推荐采用这种方式进行项目部署，不过我们这里还是介绍一下。</p><p>首先我们需要排除掉<code>spring-boot-starter-web</code>中自带的Tomcat服务器依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后自行添加Servlet依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后将打包方式修改为war包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们需要修改主类，将其继承SpringBoot需要的Initializer（又回到SSM阶段那烦人的配置了，所以说一点不推荐这种部署方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SpringBootServletInitializer</span> &#123;  <span class="hljs-comment">//继承专用的初始化器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DemoApplication.class, args);<br>    &#125;<br><br>  <span class="hljs-comment">//重写configure方法，完成启动类配置</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title function_">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> &#123;<br>        <span class="hljs-keyword">return</span> builder.sources(DemoApplication.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们再次运行Maven 的package指令就可以打包为war包了：</p><p><img src="https://s2.loli.net/2023/07/16/eycOMVRfZHmLnWX.png" alt="image-20230716161834726"></p><p>我们可以直接将其部署到Tomcat服务器中（如何部署已经在JavaWeb篇介绍过了）</p><p><img src="https://s2.loli.net/2023/07/16/CiNpxywXOso32kH.png" alt="image-20230716161921180"></p><p>接着启动服务器就能正常访问了：</p><p><img src="https://s2.loli.net/2023/07/16/3hp6guwVt2aGKlQ.png" alt="image-20230716162008831"></p><p><img src="https://s2.loli.net/2023/07/16/VDiRhqgNam8cleI.png" alt="image-20230716162030102"></p><p>如果各位小伙伴需要在IDEA中进行调试运行，我们需要像之前一样配置一个Tomcat运行环境：</p><p><img src="https://s2.loli.net/2023/07/16/Fn5kxeECwhuoWBl.png" alt="image-20230716162119751"></p><p>这样就可以跟之前一样使用外部Tomcat服务器了：</p><p><img src="https://s2.loli.net/2023/07/16/xK8sgwWoAIB61qk.png" alt="image-20230716162156347"></p><p>最后，我们需要特别介绍一下新的特性，在SpringBoot3之后，特别对GraalVM进行了支持：</p><blockquote><p>GraalVM 是一种通用的虚拟机，最初由 Oracle 开发。它支持多种编程语言（例如 Java、JavaScript、Python 等），可以在不同的环境中运行，并提供高性能和低内存消耗。</p><p>GraalVM的核心是一个即时编译器，它能够将各种语言的代码直接编译成本地机器码，以获得更高的性能。此外，GraalVM 还提供了一个强大的运行时环境，包括垃圾回收器、即时编译器、线程管理器等，可以提供更好的性能和可扩展性。</p><p>GraalVM 的一个重要特性是它的跨语言互操作性。GraalVM 可以使不同语言之间的互操作更加容易。例如，你可以在 Java 代码中直接调用 JavaScript 函数，或者在 JavaScript 代码中直接调用 Java 类。这使得在不同语言之间共享和复用代码变得更加容易。</p><p>总的来说，GraalVM 是一个开创性的技术，可以提供出色的性能和灵活性，同时也为多语言开发提供了更好的支持。它是一个非常有潜力的工具，可以用于构建高效的应用程序和解决方案。</p></blockquote><p><img src="https://s2.loli.net/2023/07/16/qJiMVGeDnhf7HYu.png" alt="image-20230716160131837"></p><p>简而言之，我们的SpringBoot项目除了打包为传统的Jar包基于JVM运行之外，我们也可以将其直接编译为操作系统原生的程序来进行使用（这样会大幅提升程序的运行效率，但是由于编译为操作系统原生程序，这将无法支持跨平台）</p><p>首先我们需要安装GraalVM的环境才可以，这跟安装普通JDK的操作是完全一样的，下载地址：<a href="https://github.com/graalvm/graalvm-ce-builds/releases/tag/jdk-17.0.7">https://github.com/graalvm/graalvm-ce-builds/releases/tag/jdk-17.0.7</a></p><p><img src="https://s2.loli.net/2023/07/16/Y8VBnQPL4mHit7N.png" alt="image-20230716162524422"></p><p>下载好对应系统架构的GraalVM环境之后，就可以安装部署了，首先我们需要为GraalVM配置环境变量，将GRAALVM_HOME作为环境变量指向你的安装目录的bin目录下，接着我们就可以开始进行打包了（注意，SpringBoot项目必须在创建的时候添加了Native支持才可以，否则无法正常打包）</p><p>注意，一定要将<code>GRAALVM_HOME</code>配置到环境变量中，否则会报错：</p><p><img src="https://s2.loli.net/2023/07/16/lCjUpPYWhkm6eTq.png" alt="image-20230716163645399"></p><p>一切无误后，我们直接在IDEA中或是命令行中输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn -Pnative -DskipTests native:compile<br></code></pre></td></tr></table></figure><p>接着会自动安装<code>native-image</code>组件，然后进行本地镜像的编译（建议挂梯，不然卡一天都下不动）</p><p><img src="https://s2.loli.net/2023/07/16/fxzCEJbmluGn8jy.png" alt="image-20230716164025545"></p><p>编译过程中比较消耗资源，建议CPU选择6核及以上，不然速度会很慢，编译完成之后如下图：</p><p><img src="https://s2.loli.net/2023/07/16/9JekL4VAB7EOdrf.png" alt="image-20230716164317582"></p><p>这样一个系统原生的SpringBoot项目就打包好了，我们可以直接运行这个程序：</p><p><img src="https://s2.loli.net/2023/07/16/MTu4GCmsogfaeRO.png" alt="image-20230716165228609"></p><p>不过由于Mybatis目前不支持Native-Image，所以只能期待有朝一日这些框架都能够完整支持原生镜像，让我们的程序运行效率更上一层楼。</p><p>至此，关于SpringBoot的快速上手教程就全部结束了，其实只要SSM阶段学的扎实，到了Boot阶段之后也是轻轻松松，下一部分我们将隆重介绍一下SpringBoot的日志模块。</p><hr><h2 id="日志系统介绍"><a href="#日志系统介绍" class="headerlink" title="日志系统介绍"></a>日志系统介绍</h2><p>SpringBoot为我们提供了丰富的日志系统，它几乎是开箱即用的。我们在之前学习SSM时，如果不配置日志，就会报错，但是到了SpringBoot阶段之后似乎这个问题就不见了，日志打印得也非常统一，这是为什么呢？</p><h3 id="日志门面和日志实现"><a href="#日志门面和日志实现" class="headerlink" title="日志门面和日志实现"></a>日志门面和日志实现</h3><p>我们首先要区分一下，什么是日志门面（Facade）什么是日志实现，我们之前学习的JUL实际上就是一种日志实现，我们可以直接使用JUL为我们提供的日志框架来规范化打印日志。</p><p>而日志门面，如Slf4j，是把不同的日志系统的实现进行了具体的抽象化，只提供了统一的日志使用接口，使用时只需要按照其提供的接口方法进行调用即可，由于它只是一个接口，并不是一个具体的可以直接单独使用的日志框架，所以最终日志的格式、记录级别、输出方式等都要通过接口绑定的具体的日志系统来实现，这些具体的日志系统就有log4j、logback、java.util.logging等，它们才实现了具体的日志系统的功能。</p><p>日志门面和日志实现就像JDBC和数据库驱动一样，一个是画大饼的，一个是真的去做饼的。</p><p><img src="https://s2.loli.net/2023/03/06/MGg1EHxtuvswV8d.png" alt="img"></p><p>但是现在有一个问题就是，不同的框架可能使用了不同的日志框架，如果这个时候出现众多日志框架并存的情况，我们现在希望的是所有的框架一律使用日志门面（Slf4j）进行日志打印，这时该怎么去解决？我们不可能将其他框架依赖的日志框架替换掉，直接更换为Slf4j吧，这样显然不现实。</p><p>这时，可以采取类似于偷梁换柱的做法，只保留不同日志框架的接口和类定义等关键信息，而将实现全部定向为Slf4j调用。相当于有着和原有日志框架一样的外壳，对于其他框架来说依然可以使用对应的类进行操作，而具体如何执行，真正的内心已经是Slf4j的了。</p><p><img src="https://s2.loli.net/2023/03/06/o1bMPITBcgetVYa.png" alt="img"></p><p>所以，SpringBoot为了统一日志框架的使用，做了这些事情：</p><ul><li>直接将其他依赖以前的日志框架剔除</li><li>导入对应日志框架的Slf4j中间包</li><li>导入自己官方指定的日志实现，并作为Slf4j的日志实现层</li></ul><h3 id="打印项目日志信息"><a href="#打印项目日志信息" class="headerlink" title="打印项目日志信息"></a>打印项目日志信息</h3><p>SpringBoot使用的是 <em>Slf4j</em> 作为<strong>日志门面</strong>，Logback（<a href="http://logback.qos.ch/">Logback</a> 是log4j 框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J）作为日志实现，对应的依赖为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此依赖已经被包含了，所以我们如果需要打印日志，可以像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TestController.class);<br>    logger.info(<span class="hljs-string">&quot;用户访问了一次测试数据&quot;</span>);<br>    <span class="hljs-keyword">return</span> mapper.findUserById(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们使用了Lombok，所以直接一个注解也可以搞定哦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br><br>  <span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    log.info(<span class="hljs-string">&quot;用户访问了一次测试数据&quot;</span>);<br>    <span class="hljs-keyword">return</span> mapper.findUserById(<span class="hljs-number">1</span>);<br>&#125;<br>  <br>  ...<br></code></pre></td></tr></table></figure><p>日志级别从低到高分为<strong>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</strong>，SpringBoot默认只会打印INFO以上级别的信息，效果如下，也是使用同样的格式打印在控制台的：</p><p><img src="https://s2.loli.net/2023/07/16/HCZQndu2YPwINoS.png" alt="image-20230716171120646"></p><blockquote><ul><li>只需要添加 <code>@Slf4j</code>注解即可直接使用 <code>log.info/debug/warn</code>等进行控制台日志打印</li></ul></blockquote><hr><h3 id="配置Logback日志"><a href="#配置Logback日志" class="headerlink" title="配置Logback日志"></a>配置Logback日志</h3><p>Logback官网：<a href="https://logback.qos.ch/">https://logback.qos.ch</a></p><p>和JUL一样，Logback也能实现定制化，我们可以编写对应的配置文件，SpringBoot推荐将配置文件名称命名为<code>logback-spring.xml</code>表示这是SpringBoot下Logback专用的配置，可以使用SpringBoot 的高级Proﬁle功能，它的内容类似于这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最外层由<code>configuration</code>包裹，一旦编写，那么就会替换默认的配置，所以如果内部什么都不写的话，那么会导致我们的SpringBoot项目没有配置任何日志输出方式，控制台也不会打印日志。</p><p>我们接着来看如何配置一个控制台日志打印，我们可以直接导入并使用SpringBoot为我们预设好的日志格式，在<code>org/springframework/boot/logging/logback/defaults.xml</code>中已经帮我们把日志的输出格式定义好了，我们只需要设置对应的<code>appender</code>即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">included</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;clr&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wex&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;wEx&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot;</span> /&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;CONSOLE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_PATTERN&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_PATTERN:-%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS&#125;&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:- &#125; --- [%t] %-40.40logger&#123;39&#125; : %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_LOG_CHARSET&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;FILE_LOG_CHARSET:-$&#123;file.encoding:-UTF-8&#125;&#125;&quot;</span>/&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.startup.DigesterFactory&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.catalina.util.LifecycleBase&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.sshd.common.util.SecurityUtils&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.tomcat.util.net.NioSelectorPool&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.eclipse.jetty.util.component.AbstractLifeCycle&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.hibernate.validator.internal.util.Version&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.boot.actuate.endpoint.jmx&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">included</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入后，我们利用预设的日志格式创建一个控制台日志打印：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  导入其他配置文件，作为预设  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/springframework/boot/logging/logback/defaults.xml&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  Appender作为日志打印器配置，这里命名随意  --&gt;</span><br>    <span class="hljs-comment">&lt;!--  ch.qos.logback.core.ConsoleAppender是专用于控制台的Appender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;CONSOLE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置完成后，我们发现控制台已经可以正常打印日志信息了。</p><p>接着我们来看看如何开启文件打印，我们只需要配置一个对应的Appender即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  ch.qos.logback.core.rolling.RollingFileAppender用于文件日志记录，它支持滚动  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>$&#123;FILE_LOG_CHARSET&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  自定义滚动策略，防止日志文件无限变大，也就是日志文件写到什么时候为止，重新创建一个新的日志文件开始写  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  文件保存位置以及文件命名规则，这里用到了%d&#123;yyyy-MM-dd&#125;表示当前日期，%i表示这一天的第N个日志  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>log/%d&#123;yyyy-MM-dd&#125;-spring-%i.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  到期自动清理日志文件  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">cleanHistoryOnStart</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大日志保留时间  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  最大单个日志文件大小  --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>10MB<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  指定日志输出级别，以及启用的Appender，这里就使用了我们上面的ConsoleAppender  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置完成后，我们可以看到日志文件也能自动生成了。</p><p>我们也可以魔改官方提供的日志格式，官方文档：<a href="https://logback.qos.ch/manual/layouts.html">https://logback.qos.ch/manual/layouts.html</a></p><p>这里需要提及的是MDC机制，Logback内置的日志字段还是比较少，如果我们需要打印有关业务的更多的内容，包括自定义的一些数据，需要借助logback MDC机制，MDC为“Mapped Diagnostic Context”（映射诊断上下文），即将一些运行时的上下文数据通过logback打印出来；此时我们需要借助org.sl4j.MDC类。</p><p>比如我们现在需要记录是哪个用户访问我们网站的日志，只要是此用户访问我们网站，都会在日志中携带该用户的ID，我们希望每条日志中都携带这样一段信息文本，而官方提供的字段无法实现此功能，这时就需要使用MDC机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>   MDC.put(<span class="hljs-string">&quot;reqId&quot;</span>, request.getSession().getId());<br>   log.info(<span class="hljs-string">&quot;用户访问了一次测试数据&quot;</span>);<br>   <span class="hljs-keyword">return</span> mapper.findUserById(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以向日志中传入自定义参数了，我们日志中添加这样一个占位符<code>%X&#123;键值&#125;</code>，名字保持一致：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">%clr([%X&#123;reqId&#125;])&#123;faint&#125; <br></code></pre></td></tr></table></figure><p>这样当我们向MDC中添加信息后，只要是当前线程（本质是 <strong>ThreadLocal</strong> 实现）下输出的日志，都会自动替换占位符。</p><h3 id="自定义Banner展示"><a href="#自定义Banner展示" class="headerlink" title="自定义Banner展示"></a>自定义Banner展示</h3><p>我们在之前发现，实际上Banner部分和日志部分是独立的，SpringBoot启动后，会先打印Banner部分，那么这个Banner部分是否可以自定义呢？答案是可以的。</p><p>我们可以直接来配置文件所在目录下创建一个名为<code>banner.txt</code>的文本文档，内容随便你：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs txt">//                          _ooOoo_                               //<br>//                         o8888888o                              //<br>//                         88&quot; . &quot;88                              //<br>//                         (| ^_^ |)                              //<br>//                         O\  =  /O                              //<br>//                      ____/`---&#x27;\____                           //<br>//                    .&#x27;  \\|     |//  `.                         //<br>//                   /  \\|||  :  |||//  \                        //<br>//                  /  _||||| -:- |||||-  \                       //<br>//                  |   | \\\  -  /// |   |                       //<br>//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //<br>//                  \  .-\__  `-`  ___/-. /                       //<br>//                ___`. .&#x27;  /--.--\  `. . ___                     //<br>//              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //<br>//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //<br>//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //<br>//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //<br>//                           `=---=&#x27;                              //<br>//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //<br>//             佛祖保佑          永无BUG         永不修改             //<br></code></pre></td></tr></table></figure><p>可以使用在线生成网站进行生成自己的个性Banner：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a></p><p>我们甚至还可以使用颜色代码来为文本切换颜色：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$&#123;AnsiColor.BRIGHT_GREEN&#125;  //绿色<br></code></pre></td></tr></table></figure><p>也可以获取一些常用的变量信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$&#123;AnsiColor.YELLOW&#125; 当前 Spring Boot 版本：$&#123;spring-boot.version&#125;<br></code></pre></td></tr></table></figure><p>前面忘了，后面忘了，狠狠赚一笔！</p><hr><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><p>在日常开发中，我们项目会有多个环境。例如开发环境（develop）也就是我们研发过程中疯狂敲代码修BUG阶段，生产环境（production ）项目开发得差不多了，可以放在服务器上跑了。不同的环境下，可能我们的配置文件也存在不同，但是我们不可能切换环境的时候又去重新写一次配置文件，所以我们可以将多个环境的配置文件提前写好，进行自由切换。</p><p>由于SpringBoot只会读取<code>application.properties</code>或是<code>application.yml</code>文件，那么怎么才能实现自由切换呢？SpringBoot给我们提供了一种方式，我们可以通过配置文件指定：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>接着我们分别创建两个环境的配置文件，<code>application-dev.yml</code>和<code>application-prod.yml</code>分别表示开发环境和生产环境的配置文件，比如开发环境我们使用的服务器端口为8080，而生产环境下可能就需要设置为80或是443端口，那么这个时候就需要不同环境下的配置文件进行区分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>这样我们就可以灵活切换生产环境和开发环境下的配置文件了。</p><p>SpringBoot自带的Logback日志系统也是支持多环境配置的，比如我们想在开发环境下输出日志到控制台和文件，而生产环境下只需要输出到文件即可，这时就需要进行环境配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prod&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意<code>springProfile</code>是区分大小写的！</p><p>那如果我们希望生产环境中不要打包开发环境下的配置文件呢，我们目前虽然可以切换开发环境，但是打包的时候依然是所有配置文件全部打包，这样总感觉还欠缺一点完美，因此，打包的问题就只能找Maven解决了，Maven也可以设置多环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--分别设置开发，生产环境--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开发环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 生产环境 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">environment</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，我们需要根据环境的不同，排除其他环境的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-comment">&lt;!--排除配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--先排除所有的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--使用通配符，当然可以定义多个exclude标签进行排除--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据激活条件引入打包所需的配置和文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--引入所需环境的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--根据maven选择环境导入配置文件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;environment&#125;.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，我们可以直接将Maven中的<code>environment</code>属性，传递给SpringBoot的配置文件，在构建时替换为对应的值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">&#x27;@environment@&#x27;</span>  <span class="hljs-comment">#注意YAML配置文件需要加单引号，否则会报错</span><br></code></pre></td></tr></table></figure><p>这样，根据我们Maven环境的切换，SpringBoot的配置文件也会进行对应的切换。</p><p>最后我们打开Maven栏目，就可以自由切换了，直接勾选即可，注意<strong>切换环境之后要重新加载一下Maven项目</strong>，不然不会生效！</p><blockquote><p>[!NOTE] 日志和环境配置总结</p><ul><li>SpringBoot统一使用<strong>SLFJ</strong>日志门面结合 <strong>logback</strong> 日志实现进行打印，只需要添加 <code>@Slf4j注解</code>即可进行 <strong>log</strong> 打印</li><li>编写 <code>logback-spring.xml</code> 文件进行日志信息自定义配置，可配置<strong>日志样式、类型、有效期、大小</strong>等。</li><li>编写<code>banner.txt</code>文件可自定义程序启动时的<strong>banner样式</strong></li><li>多环境配置需要编写<code>application.yml</code>设置<em>spring-&gt;profiles-&gt;active</em>属性进行环境切换，按需添加不同环境（<strong>dev、prod</strong>等）</li><li>多环境下可以按照不同环境配置日志打印规则，选择<strong>控制台或文件</strong>记录日志。</li><li>可以通过配置<code>pol.xml</code>文件的<em>profiles和build下的resources</em>设置多环境下根据当前使用环境<strong>打包对应配置文件过滤其他文件</strong></li></ul></blockquote><hr><h2 id="常用框架介绍"><a href="#常用框架介绍" class="headerlink" title="常用框架介绍"></a>常用框架介绍</h2><p>前面我们介绍了SpringBoot项目的基本搭建，相信各位小伙伴已经体验到SpringBoot 3带来的超强便捷性了，不过光靠这些还不够，我们还需要了解更多框架来丰富我们的网站，通过了解其他的SpringBoot整合框架，我们就可以在我们自己的Web服务器上实现更多更高级的功能，同时也是为了给我们后续学习前后端分离项目做准备。</p><h3 id="邮件发送模块"><a href="#邮件发送模块" class="headerlink" title="邮件发送模块"></a>邮件发送模块</h3><p>都什么年代了，还在发传统邮件，我们来看看电子邮件。</p><p>我们在注册很多的网站时，都会遇到邮件或是手机号验证，也就是通过你的邮箱或是手机短信去接受网站发给你的注册验证信息，填写验证码之后，就可以完成注册了，同时，网站也会绑定你的手机号或是邮箱。</p><p>那么，像这样的功能，我们如何实现呢？SpringBoot已经给我们提供了封装好的邮件模块使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在学习邮件发送之前，我们需要先了解一下什么是电子邮件。</p><blockquote><p>电子邮件也是一种通信方式，是互联网应用最广的服务。通过网络的电子邮件系统，用户可以以非常低廉的价格（不管发送到哪里，都只需负担网费，实际上就是把信息发送到对方服务器而已）、非常快速的方式，与世界上任何一个地方的电子邮箱用户联系。</p></blockquote><p>虽说方便倒是方便，虽然是曾经的霸主，不过现在这个时代，QQ微信横行，手机短信和电子邮箱貌似就只剩收验证码这一个功能了。</p><p>要在Internet上提供电子邮件功能，必须有专门的电子邮件服务器。例如现在Internet很多提供邮件服务的厂商：新浪、搜狐、163、QQ邮箱等，他们都有自己的邮件服务器。这些服务器类似于现实生活中的邮局，它主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。</p><p>所有的用户都可以在电子邮件服务器上申请一个账号用于邮件发送和接收，那么邮件是以什么样的格式发送的呢？实际上和Http一样，邮件发送也有自己的协议，也就是约定邮件数据长啥样以及如何通信。</p><p><img src="https://s2.loli.net/2023/07/16/sL56YdmgGblfFjo.png" alt="image-20230716172901937"></p><p>比较常用的协议有两种：</p><ol><li>SMTP协议（主要用于发送邮件 Simple Mail Transfer Protocol）</li><li>POP3协议（主要用于接收邮件 Post Office Protocol 3）</li></ol><p>整个发送&#x2F;接收流程大致如下：</p><p><img src="https://s2.loli.net/2023/07/16/sOyWQguFonJKXNw.jpg" alt="img"></p><p>实际上每个邮箱服务器都有一个smtp发送服务器和pop3接收服务器，比如要从QQ邮箱发送邮件到163邮箱，那么我们只需要通过QQ邮箱客户端告知QQ邮箱的smtp服务器我们需要发送邮件，以及邮件的相关信息，然后QQ邮箱的smtp服务器就会帮助我们发送到163邮箱的pop3服务器上，163邮箱会通过163邮箱客户端告知对应用户收到一封新邮件。</p><p>而我们如果想要实现给别人发送邮件，那么就需要连接到对应电子邮箱的smtp服务器上，并告知其我们要发送邮件。而SpringBoot已经帮助我们将最基本的底层通信全部实现了，我们只需要关心smtp服务器的地址以及我们要发送的邮件长啥样即可。</p><p>这里以163邮箱 <a href="https://mail.163.com/">https://mail.163.com</a> 为例，我们需要在配置文件中告诉SpringBootMail我们的smtp服务器的地址以及你的邮箱账号和密码，首先我们要去设置中开启smtp&#x2F;pop3服务才可以，开启后会得到一个随机生成的密钥，这个就是我们的密码。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>      <span class="hljs-comment"># 163邮箱的地址为smtp.163.com，直接填写即可</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com/smtp.qq.com</span><br>    <span class="hljs-comment"># 你申请的163邮箱</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">javastudy111@163.com/xxx@qq.com</span><br>    <span class="hljs-comment"># 注意密码是在开启smtp/pop3时自动生成的，记得保存一下，不然就找不到了</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">AZJTOAWZESLMHTNI</span><br></code></pre></td></tr></table></figure><p>配置完成后，接着我们来进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootTestApplicationTests</span> &#123;<br><br>      <span class="hljs-comment">//JavaMailSender是专门用于发送邮件的对象，自动配置类已经提供了Bean</span><br>    <span class="hljs-meta">@Autowired</span><br>    JavaMailSender sender;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-comment">//SimpleMailMessage是一个比较简易的邮件封装，支持设置一些比较简单内容</span><br>        <span class="hljs-type">SimpleMailMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMailMessage</span>();<br>          <span class="hljs-comment">//设置邮件标题</span><br>        message.setSubject(<span class="hljs-string">&quot;【电子科技大学教务处】关于近期学校对您的处分决定&quot;</span>);<br>          <span class="hljs-comment">//设置邮件内容</span><br>        message.setText(<span class="hljs-string">&quot;XXX同学您好，经监控和教务巡查发现，您近期存在旷课、迟到、早退、上课刷抖音行为，&quot;</span> +<br>                <span class="hljs-string">&quot;现已通知相关辅导员，请手写5000字书面检讨，并在2022年4月1日17点前交到辅导员办公室。&quot;</span>);<br>          <span class="hljs-comment">//设置邮件发送给谁，可以多个，这里就发给你的QQ邮箱</span><br>        message.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>          <span class="hljs-comment">//邮件发送者，这里要与配置文件中的保持一致</span><br>        message.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>          <span class="hljs-comment">//OK，万事俱备只欠发送</span><br>        sender.send(message);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要添加附件等更多功能，可以使用MimeMessageHelper来帮助我们完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException &#123;<br>      <span class="hljs-comment">//创建一个MimeMessage</span><br>    <span class="hljs-type">MimeMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sender.createMimeMessage();<br>      <span class="hljs-comment">//使用MimeMessageHelper来帮我们修改MimeMessage中的信息</span><br>    <span class="hljs-type">MimeMessageHelper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MimeMessageHelper</span>(message, <span class="hljs-literal">true</span>);<br>    helper.setSubject(<span class="hljs-string">&quot;Test&quot;</span>);<br>    helper.setText(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>    helper.setTo(<span class="hljs-string">&quot;你的QQ号@qq.com&quot;</span>);<br>    helper.setFrom(<span class="hljs-string">&quot;javastudy111@163.com&quot;</span>);<br>      <span class="hljs-comment">//发送修改好的MimeMessage</span><br>    sender.send(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们来尝试为我们的网站实现一个邮件注册功能，首先明确验证流程：请求验证码 -&gt; 生成验证码（临时有效，注意设定过期时间） -&gt; 用户输入验证码并填写注册信息 -&gt; 验证通过注册成功！</p><blockquote><p>[!NOTE] 注意</p><ul><li>最好将 <em>GetMapping</em> 和 <em>PostMapping</em> 分开写，也最好不要和模板混合在一起，否则会很容易由于传参有问题出bug</li></ul></blockquote><hr><h3 id="接口规则校验"><a href="#接口规则校验" class="headerlink" title="接口规则校验"></a>接口规则校验</h3><p>通常我们在使用SpringMvc框架编写接口时，很有可能用户发送的数据存在一些问题，比如下面这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">submit</span><span class="hljs-params">(String username,</span><br><span class="hljs-params">                     String password)</span>&#123;<br>    System.out.println(username.substring(<span class="hljs-number">3</span>));<br>    System.out.println(password.substring(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口中，我们需要将用户名和密码分割然后打印，在正常情况下，因为用户名长度规定不小于5，如果用户发送的数据是没有问题的，那么就可以正常运行，这也是我们所希望的情况，但是如果用户发送的数据并不是按照规定的，那么就会直接报错：</p><p><img src="https://s2.loli.net/2023/07/16/n1FMADOiQCRcGw6.png" alt="image-20230716215850225"></p><p>这个时候，我们就需要在请求进来之前进行校验了，最简单的办法就是判断一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">submit</span><span class="hljs-params">(String username,</span><br><span class="hljs-params">                     String password)</span>&#123;<br>    <span class="hljs-keyword">if</span>(username.length() &gt; <span class="hljs-number">3</span> &amp;&amp; password.length() &gt; <span class="hljs-number">10</span>) &#123;<br>        System.out.println(username.substring(<span class="hljs-number">3</span>));<br>        System.out.println(password.substring(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功!&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求失败&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样就能直接解决问题，但是如果我们的每一个接口都需要这样去进行配置，将会很麻烦，SpringBoot为我们提供了很方便的接口校验框架：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在，我们可以直接使用注解完成全部接口的校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Validated</span>   <span class="hljs-comment">//首先在Controller上开启接口校验</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    ...<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submit</span><span class="hljs-params">(<span class="hljs-meta">@Length(min = 3)</span> String username,  //使用<span class="hljs-meta">@Length</span>注解一步到位</span><br><span class="hljs-params">                         <span class="hljs-meta">@Length(min = 10)</span> String password)</span>&#123;<br>        System.out.println(username.substring(<span class="hljs-number">3</span>));<br>        System.out.println(password.substring(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们的接口校验就可以快速进行配置了，一个接口就能搞定：</p><p><img src="https://s2.loli.net/2023/07/16/EibCc4sHWflywek.png" alt="image-20230716220839816"></p><p>不过这样依然会抛出一个异常，对用户不太友好，我们可以稍微处理一下，这里我们可以直接使用之前在SSM阶段中学习的异常处理Controller来自行处理这类异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidationController</span> &#123;<br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@ExceptionHandler(ConstraintViolationException.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">error</span><span class="hljs-params">(ValidationException e)</span>&#123;<br>        <span class="hljs-keyword">return</span> e.getMessage();   <span class="hljs-comment">//出现异常直接返回消息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/16/7JH6BzOhlUe9gkG.png" alt="image-20230716221420324"></p><p>除了@Length之外，我们也可以使用其他的接口来实现各种数据校验：</p><table><thead><tr><th align="center">验证注解</th><th align="center">验证的数据类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@AssertFalse</td><td align="center">Boolean,boolean</td><td align="center">值必须是false</td></tr><tr><td align="center">@AssertTrue</td><td align="center">Boolean,boolean</td><td align="center">值必须是true</td></tr><tr><td align="center">@NotNull</td><td align="center">任意类型</td><td align="center">值不能是null</td></tr><tr><td align="center">@Null</td><td align="center">任意类型</td><td align="center">值必须是null</td></tr><tr><td align="center">@Min</td><td align="center">BigDecimal、BigInteger、byte、short、int、long、double 以及任何Number或CharSequence子类型</td><td align="center">大于等于@Min指定的值</td></tr><tr><td align="center">@Max</td><td align="center">同上</td><td align="center">小于等于@Max指定的值</td></tr><tr><td align="center">@DecimalMin</td><td align="center">同上</td><td align="center">大于等于@DecimalMin指定的值（超高精度）</td></tr><tr><td align="center">@DecimalMax</td><td align="center">同上</td><td align="center">小于等于@DecimalMax指定的值（超高精度）</td></tr><tr><td align="center">@Digits</td><td align="center">同上</td><td align="center">限制整数位数和小数位数上限</td></tr><tr><td align="center">@Size</td><td align="center">字符串、Collection、Map、数组等</td><td align="center">长度在指定区间之内，如字符串长度、集合大小等</td></tr><tr><td align="center">@Past</td><td align="center">如 java.util.Date, java.util.Calendar 等日期类型</td><td align="center">值必须比当前时间早</td></tr><tr><td align="center">@Future</td><td align="center">同上</td><td align="center">值必须比当前时间晚</td></tr><tr><td align="center">@NotBlank</td><td align="center">CharSequence及其子类</td><td align="center">值不为空，在比较时会去除字符串的首位空格</td></tr><tr><td align="center">@Length</td><td align="center">CharSequence及其子类</td><td align="center">字符串长度在指定区间内</td></tr><tr><td align="center">@NotEmpty</td><td align="center">CharSequence及其子类、Collection、Map、数组</td><td align="center">值不为null且长度不为空（字符串长度不为0，集合大小不为0）</td></tr><tr><td align="center">@Range</td><td align="center">BigDecimal、BigInteger、CharSequence、byte、short、int、long 以及原子类型和包装类型</td><td align="center">值在指定区间内</td></tr><tr><td align="center">@Email</td><td align="center">CharSequence及其子类</td><td align="center">值必须是邮件格式</td></tr><tr><td align="center">@Pattern</td><td align="center">CharSequence及其子类</td><td align="center">值需要与指定的正则表达式匹配</td></tr><tr><td align="center">@Valid</td><td align="center">任何非原子类型</td><td align="center">用于验证对象属性</td></tr></tbody></table><p>虽然这样已经很方便了，但是在遇到对象的时候，依然不太方便，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">submit</span><span class="hljs-params">(Account account)</span>&#123;   <span class="hljs-comment">//直接使用对象接收</span><br>    System.out.println(account.getUsername().substring(<span class="hljs-number">3</span>));<br>    System.out.println(account.getPassword().substring(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时接口是以对象形式接收前端发送的表单数据的，这个时候就没办法向上面一样编写对应的校验规则了，那么现在又该怎么做呢？</p><p>对应对象类型，我们也可以进行验证，方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping(&quot;/submit&quot;)</span>  <span class="hljs-comment">//在参数上添加@Valid注解表示需要验证</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">submit</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> Account account)</span>&#123;<br>    System.out.println(account.getUsername().substring(<span class="hljs-number">3</span>));<br>    System.out.println(account.getPassword().substring(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-meta">@Length(min = 3)</span>   <span class="hljs-comment">//只需要在对应的字段上添加校验的注解即可</span><br>    String username;<br>    <span class="hljs-meta">@Length(min = 10)</span><br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样当受到请求时，就会对对象中的字段进行校验了，这里我们稍微修改一下ValidationController的错误处理，对于<strong>实体类接收参数的验证</strong>，会抛出 <strong>MethodArgumentNotValidException</strong> 异常，这里也进行一下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@ExceptionHandler(&#123;ConstraintViolationException.class, MethodArgumentNotValidException.class&#125;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">error</span><span class="hljs-params">(Exception e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> ConstraintViolationException exception) &#123;<br>        <span class="hljs-keyword">return</span> exception.getMessage();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> MethodArgumentNotValidException exception)&#123;<br>        <span class="hljs-keyword">if</span> (exception.getFieldError() == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;未知错误&quot;</span>;<br>        <span class="hljs-keyword">return</span> exception.getFieldError().getDefaultMessage();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;未知错误&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以正确返回对应的错误信息了。</p><h3 id="接口文档生成（选学）"><a href="#接口文档生成（选学）" class="headerlink" title="接口文档生成（选学）"></a>接口文档生成（选学）</h3><p>在后续学习前后端分离开发中，前端现在由专业的人来做，而我们往往只需要关心后端提供什么接口给前端人员调用，我们的工作被进一步细分了，这个时候为前端开发人员提供一个可以参考的文档是很有必要的。</p><p>但是这样的一个文档，我们也不可能单独写一个项目去进行维护，并且随着我们的后端项目不断更新，文档也需要跟随更新，这显然是很麻烦的一件事情，那么有没有一种比较好的解决方案呢？</p><p>当然有，那就是丝袜哥：Swagger</p><p>Swagger的主要功能如下：</p><ul><li>支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。</li><li>提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。</li></ul><p>结合Spring框架（Spring-doc，官网：<a href="https://springdoc.org/%EF%BC%89%EF%BC%8CSwagger%E5%8F%AF%E4%BB%A5%E5%BE%88%E8%BD%BB%E6%9D%BE%E5%9C%B0%E5%88%A9%E7%94%A8%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%89%AB%E6%8F%8F%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%9D%A5%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%EF%BC%8C%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%BD%93%E6%88%91%E4%BB%AC%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%89%93%E5%BC%80Swagger%E6%8F%90%E4%BE%9B%E7%9A%84%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A3%E3%80%82%E4%BE%9D%E8%B5%96%E5%A6%82%E4%B8%8B%EF%BC%9A">https://springdoc.org/），Swagger可以很轻松地利用注解以及扫描机制，来快速生成在线文档，以实现当我们项目启动之后，前端开发人员就可以打开Swagger提供的前端页面，查看和测试接口。依赖如下：</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springdoc<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>项目启动之后，我们可以直接访问： <a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a>  ，就能看到我们的开发文档了：</p><p><img src="https://s2.loli.net/2023/07/17/yb68Oolm1Xp5qFU.png" alt="image-20230717155121213"></p><p>可以看到这个开发文档中自动包含了我们定义的接口，并且还有对应的实体类也放在了下面。这个页面不仅仅是展示接口，也可以直接在上面进行调试：</p><p><img src="https://s2.loli.net/2023/07/17/whLprBimgTqWxFR.png" alt="image-20230717155400761"></p><p>这就非常方便了，不仅前端人员可以快速查询接口定义，我们自己也可以在线进行接口测试，直接抛弃PostMan之类的软件了。</p><p>虽然Swagger的UI界面已经可以很好地展示后端提供的接口信息了，但是非常的混乱，我们来看看如何配置接口的一些描述信息。首先我们的页面肯定要展示一下这个文档的一些信息，只需要一个Bean就能搞定，<code>SwaggerConfiguration.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> OpenAPI <span class="hljs-title function_">springDocOpenAPI</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAPI</span>().info(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>()<br>                        .title(<span class="hljs-string">&quot;图书管理系统 - 在线API接口文档&quot;</span>)   <span class="hljs-comment">//设置API文档网站标题</span><br>                        .description(<span class="hljs-string">&quot;这是一个图书管理系统的后端API文档，欢迎前端人员查阅！&quot;</span>) <span class="hljs-comment">//网站介绍</span><br>                        .version(<span class="hljs-string">&quot;2.0&quot;</span>)   <span class="hljs-comment">//当前API版本</span><br>                        .license(<span class="hljs-keyword">new</span> <span class="hljs-title class_">License</span>().name(<span class="hljs-string">&quot;我的B站个人主页&quot;</span>)  <span class="hljs-comment">//遵循的协议，这里拿来写其他的也行</span><br>                                .url(<span class="hljs-string">&quot;https://space.bilibili.com/37737161&quot;</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的页面中就会展示自定义的文本信息了：</p><p><img src="https://s2.loli.net/2023/07/17/ZHqL7UsermIbipv.png" alt="image-20230717165850714"></p><p>接着我们来看看如何为一个Controller编写API描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用@Tag注解来添加Controller描述信息</span><br><span class="hljs-meta">@Tag(name = &quot;账户验证相关&quot;, description = &quot;包括用户登录、注册、验证码请求等操作。&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以直接在类名称上面添加<code>@Tag</code>注解，并填写相关信息，来为当前的Controller设置描述信息。接着我们可以为所有的请求映射配置描述信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiResponses(&#123;</span><br><span class="hljs-meta">       @ApiResponse(responseCode = &quot;200&quot;, description = &quot;测试成功&quot;),</span><br><span class="hljs-meta">       @ApiResponse(responseCode = &quot;500&quot;, description = &quot;测试失败&quot;)   //不同返回状态码描述</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Operation(summary = &quot;请求用户数据测试接口&quot;)</span>   <span class="hljs-comment">//接口功能描述</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br><span class="hljs-comment">//请求参数描述和样例</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@Parameter(description = &quot;测试文本数据&quot;, example = &quot;KFCvivo50&quot;)</span> <span class="hljs-meta">@RequestParam</span> String text)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于那些不需要展示在文档中的接口，我们也可以将其忽略掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Hidden</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<strong>实体类</strong>，我们也可以编写对应的API接口文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Schema(description = &quot;用户信息实体类&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@Schema(description = &quot;用户编号&quot;)</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-meta">@Schema(description = &quot;用户名称&quot;)</span><br>    String name;<br>    <span class="hljs-meta">@Schema(description = &quot;用户邮箱&quot;)</span><br>    String email;<br>    <span class="hljs-meta">@Schema(description = &quot;用户密码&quot;)</span><br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以在文档中查看实体类简介以及各个属性的介绍了。</p><p>不过，这种文档只适合在开发环境下生成，如果是生产环境，我们需要关闭文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">springdoc:<br>  api-docs:<br>    enabled: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">注解</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td align="center"><em>@Tag</em></td><td>为RestController添加综合信息</td><td>@Tag(name &#x3D; “账号验证相关接口”, description &#x3D; “包括用户登陆、注册、验证码请求等等！”)</td></tr><tr><td align="center"><em>@Operation</em></td><td>为具体某个接口添加注释信息</td><td>@Operation(summary &#x3D; “请求用户数据测试接口”, description &#x3D; “根据用户id请求获取用户”)   &#x2F;&#x2F;接口功能描述</td></tr><tr><td align="center"><em>@ApiResponses</em></td><td>为接口返回状态码添加描述</td><td>@ApiResponses({@ApiResponse(responseCode &#x3D; “200”, description &#x3D; “测试成功”),@ApiResponse(responseCode &#x3D; “500”, description &#x3D; “测试失败”)   &#x2F;&#x2F;不同返回状态码描述})</td></tr><tr><td align="center"><em>@Parameter</em></td><td>为接口参数添加示例描述</td><td>@Parameter(description &#x3D; “测试用户id数据”, example &#x3D; “1”)</td></tr><tr><td align="center"><em>@Hidden</em></td><td>隐藏接口不进行展示</td><td>@Hidden</td></tr><tr><td align="center"><em>Schema</em></td><td>对实体类添加描述（包括字段）</td><td>@Schema(description &#x3D; “用户信息实体类”)；@Schema(description &#x3D; “用户名”)</td></tr></tbody></table><h3 id="项目运行监控（选学）"><a href="#项目运行监控（选学）" class="headerlink" title="项目运行监控（选学）"></a>项目运行监控（选学）</h3><p>我们的项目开发完成之后，肯定是需要上线运行的，不过在项目的运行过程中，我们可能需要对其进行监控，从而实时观察其运行状态，并在发生问题时做出对应调整，因此，集成项目运行监控就很有必要了。</p><p>SpringBoot框架提供了<code>spring-boot-starter-actuator</code>模块来实现监控效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加好之后，Actuator会自动注册一些接口用于查询当前SpringBoot应用程序的状态，官方文档如下：<a href="https://docs.spring.io/spring-boot/docs/3.1.1/actuator-api/htmlsingle/#overview">https://docs.spring.io/spring-boot/docs/3.1.1/actuator-api/htmlsingle/#overview</a></p><p>默认情况下，所有Actuator自动注册的接口路径都是<code>/actuator/&#123;id&#125;</code>格式的（可在配置文件中修改），比如我们想要查询当前服务器的健康状态，就可以访问这个接口：<a href="http://localhost:8080/actuator/health%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BC%9A%E4%BB%A5JSON%E6%A0%BC%E5%BC%8F%E8%BF%94%E5%9B%9E%E7%BB%99%E6%88%91%E4%BB%AC%EF%BC%9A">http://localhost:8080/actuator/health，结果会以JSON格式返回给我们：</a></p><p><img src="https://s2.loli.net/2023/07/16/h2dYo4sKPSfbGpq.png" alt="image-20230716205752392"></p><p>直接访问：<a href="http://localhost:8080/actuator">http://localhost:8080/actuator</a> 根路径，可以查看当前已经开启的所有接口，默认情况下只开启以下接口：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_links&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;self&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">//actuator自己的信息</span><br>  <span class="hljs-attr">&quot;health-path&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/health/&#123;*path&#125;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;health&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/health&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span>  <span class="hljs-comment">//应用程序健康情况监控</span><br> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>我们可以来修改一下配置文件，让其暴露全部接口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span>   <span class="hljs-comment">#使用*表示暴露全部接口</span><br></code></pre></td></tr></table></figure><p>重启服务器，再次获取可用接口就可以看到全部的信息了，这里就不全部搬出来了，只列举一些常用的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;_links&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">//包含Actuator自己的信息</span><br>    <span class="hljs-attr">&quot;self&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//已注册的Bean信息</span><br>    <span class="hljs-attr">&quot;beans&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/beans&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//应用程序健康情况监控</span><br>    <span class="hljs-attr">&quot;health&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/health&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;health-path&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/health/&#123;*path&#125;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//应用程序运行信息</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/info&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//系统环境相关信息</span><br>    <span class="hljs-attr">&quot;env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/env&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;env-toMatch&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/env/&#123;toMatch&#125;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//日志相关信息</span><br>    <span class="hljs-attr">&quot;loggers&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/loggers&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;loggers-name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/loggers/&#123;name&#125;&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//快速获取JVM堆转储文件</span><br>    <span class="hljs-attr">&quot;heapdump&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/heapdump&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//快速获取JVM线程转储信息</span><br>    <span class="hljs-attr">&quot;threaddump&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/threaddump&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//计划任务相关信息</span><br>    <span class="hljs-attr">&quot;scheduledtasks&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/scheduledtasks&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">//请求映射相关信息</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;href&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://localhost:8080/actuator/mappings&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;templated&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    ...<br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>比如我们可以通过 <a href="http://localhost:8080/actuator/info">http://localhost:8080/actuator/info</a> 接口查看当前系统运行环境信息：</p><p><img src="https://s2.loli.net/2023/07/16/2KyfArzj7uEqliC.png" alt="image-20230716211517338"></p><p>我们发现，这里得到的数据是一个空的，这是因为我们还需要单独开启对应模块才可以：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span><br>  <span class="hljs-comment">#开启某些默认为false的信息</span><br>  <span class="hljs-attr">info:</span><br>    <span class="hljs-attr">env:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">os:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">java:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>再次请求，就能获得运行环境相关信息了，比如这里的Java版本、JVM信息、操作系统信息等：</p><p><img src="https://s2.loli.net/2023/07/16/7tsbxvozYueIlJP.png" alt="image-20230716211648263"></p><p>我们也可以让health显示更加详细的系统状态信息，这里我们开启一下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">management:</span><br><span class="hljs-string">...</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span>  <span class="hljs-comment">#展示详细内容</span><br>    <span class="hljs-attr">env:</span><br>      <span class="hljs-attr">show-values:</span> <span class="hljs-string">always</span>  <span class="hljs-comment">#总是直接展示值</span><br></code></pre></td></tr></table></figure><p>现在就能查看当前系统占用相关信息了，比如下面的磁盘占用、数据库等信息：</p><p><img src="https://s2.loli.net/2023/07/16/Tyxmgv1b4jdqVFG.png" alt="image-20230716212238191"></p><p>包括完整的系统环境信息，比如我们配置的服务器8080端口：</p><p><img src="https://s2.loli.net/2023/07/16/XiorDh692m83KAP.png" alt="image-20230716212456642"></p><p>我们只需要通过这些接口就能快速获取到当前应用程序的运行信息了。</p><p>高级一点的还有<strong>线程转储和堆内存转储文件</strong>直接生成，便于我们对Java程序的运行情况进行分析，这里我们获取一下堆内存转储文件：<a href="http://localhost:8080/actuator/heapdump">http://localhost:8080/actuator/heapdump</a>，文件下载之后直接使用IDEA就能打开：</p><p><img src="https://s2.loli.net/2023/07/16/m8gNK1GjW3UhAnQ.png" alt="image-20230716212801376"></p><p>可以看到其中创建的byte数组对象计数达到了72020个，其中我们自己的TestController对象只有有一个：</p><p><img src="https://s2.loli.net/2023/07/16/BzZtoIM9vGgiArp.png" alt="image-20230716212920673"></p><p>以及对应的线程转储信息，也可以通过<a href="http://localhost:8080/actuator/threaddump">http://localhost:8080/actuator/threaddump</a>直接获取：</p><p><img src="https://s2.loli.net/2023/07/16/LK6TZlDyxIJ7jqX.png" alt="image-20230716214134109"></p><hr><h2 id="实现原理探究（选学）"><a href="#实现原理探究（选学）" class="headerlink" title="实现原理探究（选学）"></a>实现原理探究（选学）</h2><p>注意：难度较大，本版块作为选学内容，在开始前，必须完成SSM阶段源码解析部分的学习。</p><p>我们在前面的学习中切实感受到了SpringBoot为我们带来的便捷，那么它为何能够实现如此快捷的开发模式，starter又是一个怎样的存在，它是如何进行自动配置的，我们现在就开始研究。</p><h3 id="启动原理与实现"><a href="#启动原理与实现" class="headerlink" title="启动原理与实现"></a>启动原理与实现</h3><p>首先我们来看看，SpringBoot项目启动之后，做了什么事情，SpringApplication中的静态<code>run</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;<br>    <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;primarySource&#125;, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>套娃如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(primarySources)).run(args);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，这里直接new了一个新的SpringApplication对象，传入我们的主类作为构造方法参数，并调用了非static的<code>run</code>方法，我们先来看看构造方法里面做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;<br>  ...<br>    <span class="hljs-comment">//资源加载器默认根据前面判断，这里为null</span><br>    <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>  <span class="hljs-comment">//设置主要源，也就是我们的启动主类</span><br>    Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>    <span class="hljs-built_in">this</span>.primarySources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>(Arrays.asList(primarySources));<br>    <span class="hljs-comment">//这里是关键，这里会判断当前SpringBoot应用程序是否为Web项目，并返回当前的项目类型</span><br>    <span class="hljs-comment">//deduceFromClasspath是根据类路径下判断是否包含SpringBootWeb依赖，如果不包含就是NONE类型，包含就是SERVLET类型</span><br>    <span class="hljs-built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>    <span class="hljs-built_in">this</span>.bootstrapRegistryInitializers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-built_in">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>    <span class="hljs-comment">//获取并设置所有ApplicationContextInitializer实现，这些都是应用程序上下文初始化器</span><br>  <span class="hljs-comment">//这个接口用于在 Spring 容器执行 onRefresh 方法刷新之前执行一个回调函数</span><br> <span class="hljs-comment">//通常用于向 SpringBoot 启动的容器中注入一些属性，比如ContextIdApplicationContextInitializer就是</span><br>  <span class="hljs-comment">//将配置中定义的 spring.application.name 属性值设定为应用程序上下文的ID</span><br>    <span class="hljs-built_in">this</span>.setInitializers(<span class="hljs-built_in">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>  <span class="hljs-comment">//设置应用程序监听器</span><br>    <span class="hljs-built_in">this</span>.setListeners(<span class="hljs-built_in">this</span>.getSpringFactoriesInstances(ApplicationListener.class));<br>  <span class="hljs-comment">//找到并设定当前的启动主类</span><br>    <span class="hljs-built_in">this</span>.mainApplicationClass = <span class="hljs-built_in">this</span>.deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> WebApplicationType <span class="hljs-title function_">deduceFromClasspath</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//这里的ClassUtils.isPresent是通过反射机制判断类路径下是否存在对应的依赖</span><br><span class="hljs-keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="hljs-literal">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="hljs-literal">null</span>)<br>&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="hljs-literal">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.REACTIVE;   <span class="hljs-comment">//判断出存在WebFlux依赖且其他不存在，返回WebFlux类型</span><br>&#125;<br>  <span class="hljs-comment">//如果不包含WebFlux相关依赖，就找找有没有Servlet相关依赖，只要发现缺失直接返回NONE普通类型</span><br><span class="hljs-keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;<br><span class="hljs-keyword">if</span> (!ClassUtils.isPresent(className, <span class="hljs-literal">null</span>)) &#123;<br><span class="hljs-keyword">return</span> WebApplicationType.NONE;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> WebApplicationType.SERVLET; <span class="hljs-comment">//否则就是Servlet环境了，返回SERVLET类型（也就是我们之前用到的）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过阅读上面的源码，我们发现<code>getSpringFactoriesInstances</code>这个方法可以一次性获取指定类型已注册的实现类，我们先来研究一下它是怎么做到的。这里就要提到<code>spring.factories</code>文件了，它是 Spring 仿造Java SPI实现的一种类加载机制。它在 META-INF&#x2F;spring.factories 文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是 Spring Boot Starter 实现的基础。</p><p>SPI的常见例子：</p><ul><li>数据库驱动加载接口实现类的加载：JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载：SLF4J加载不同提供商的日志实现类</li></ul><p>说白了就是人家定义接口，但是实现可能有很多种，但是核心只提供接口，需要我们按需选择对应的实现，这种方式是高度解耦的。</p><p>我们可以来看看<code>spring-boot-starter</code>依赖中怎么定义的，其中有一个很关键的点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个<code>spring-boot-autoconfigure</code>是什么东西？实际上这个就是我们整个依赖实现自动配置的关键。打开这个依赖内部，可以看到这里确实有一个<code>spring.factories</code>文件：</p><p><img src="https://s2.loli.net/2023/07/18/65netHWFdMjhlxV.png" alt="image-20230718233851593"></p><p>这个里面定义了很多接口的实现类，比如我们刚刚看到的<code>ApplicationContextInitializer</code>接口：</p><p><img src="https://s2.loli.net/2023/07/18/gN9CZpKEcxurzIq.png" alt="image-20230718234021559"></p><p>不仅仅是<code>spring-boot-starter</code>存在这样的文件，其他很多依赖，比如<code>spring-boot-start-test</code>也有着对应的<code>autoconfigure</code>模块，只不过大部分SpringBoot维护的组件，都默认将其中的<code>spring.factories</code>信息统一写到了<code>spring-boot-autoconfigure</code>和<code>spring-boot-starter</code>中，方便后续维护。</p><p>现在我们清楚，原来这些都是通过一个单独的文件定义的，所以我们来看看<code>getSpringFactoriesInstances</code>方法做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getSpringFactoriesInstances(type, (SpringFactoriesLoader.ArgumentResolver)<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">getSpringFactoriesInstances</span><span class="hljs-params">(Class&lt;T&gt; type, SpringFactoriesLoader.ArgumentResolver argumentResolver)</span> &#123;<br>  <span class="hljs-comment">//这里通过SpringFactoriesLoader加载类路径下的文件</span><br>    <span class="hljs-keyword">return</span> SpringFactoriesLoader.forDefaultResourceLocation(<span class="hljs-built_in">this</span>.getClassLoader()).load(type, argumentResolver);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SpringFactoriesLoader <span class="hljs-title function_">forDefaultResourceLocation</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>  <span class="hljs-comment">//查找所有依赖下的META-INF/spring.factories文件，解析并得到最终的SpringFactoriesLoader对象</span><br>    <span class="hljs-keyword">return</span> forResourceLocation(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>, classLoader);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以<code>getSpringFactoriesInstances</code>其实就是通过读取所有<code>META-INF/spring.factories</code>文件得到的列表，然后实例化指定类型下读取到的所有实现类并返回，这样，我们就清楚SpringBoot这一大堆参与自动配置的类是怎么加载进来的了。</p><p>现在我们回到一开始的地方，目前SpringApplication对象已经构造好了，继续来看看<code>run</code>方法做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <span class="hljs-type">DefaultBootstrapContext</span> <span class="hljs-variable">bootstrapContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createBootstrapContext();<br>    <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-built_in">this</span>.configureHeadlessProperty();<br>  <span class="hljs-comment">//获取所有的SpringApplicationRunListener，并通知启动事件，默认只有一个实现类EventPublishingRunListener</span><br>    <span class="hljs-comment">//EventPublishingRunListener会将初始化各个阶段的事件转发给所有监听器</span><br>    <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRunListeners(args);<br>    listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//环境配置，包括我们之前配置的多环境选择</span><br>        <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(args);<br>        <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>      <span class="hljs-comment">//打印Banner，从这里开始我们就可以切切实实看到运行状了</span><br>        <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.printBanner(environment);<br>      <span class="hljs-comment">//创建ApplicationContext，也就是整个Spring应用程序的IoC容器，SSM阶段已经详细介绍过，注意这里会根据构造时得到的类型，创建不同的ApplicationContext实现类（比如Servlet环境下就是Web容器）</span><br>        context = <span class="hljs-built_in">this</span>.createApplicationContext();<br>        context.setApplicationStartup(<span class="hljs-built_in">this</span>.applicationStartup);<br>      <span class="hljs-comment">//对ApplicationContext进行前置处理，这里会将创建对象时设定的所有ApplicationContextInitializer拿来执行一次initialize方法，这也验证了我们之前的说法，这一步确实是在刷新容器之前进行的</span><br>        <span class="hljs-built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>      <span class="hljs-comment">//执行ApplicationContext的refresh方法，刷新容器初始化所有的Bean，这个也在SSM阶段详细介绍过了</span><br>        <span class="hljs-built_in">this</span>.refreshContext(context);<br>        <span class="hljs-built_in">this</span>.afterRefresh(context, applicationArguments);<br>        <span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToStartup</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>            (<span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass)).logStarted(<span class="hljs-built_in">this</span>.getApplicationLog(), timeTakenToStartup);<br>        &#125;<br>        listeners.started(context, timeTakenToStartup);<br>      <span class="hljs-comment">//因为所有的Bean都已经加载，这里就可以调用全部的自定义Runner实现了</span><br>        <span class="hljs-built_in">this</span>.callRunners(context, applicationArguments);<br>    ...<br>    <span class="hljs-comment">//结束</span><br>    <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，SpringBoot项目就正常启动了。</p><p>我们发现，即使是SpringBoot，也是离不开Spring最核心的ApplicationContext容器，因为它再怎么也是一个Spring项目，即使玩得再高级不还是得围绕IoC容器来进行么。所以说，SSM阶段学习的内容才是真正的核心，而SpringBoot仅仅是对Spring进行的一层强化封装，便于快速创建Spring项目罢了，这也是为什么一直强调不能跳过SSM先学SpringBoot的原因。</p><p>既然都谈到这里了，我们不妨再来看一下这里的ApplicationContext是怎么来的，打开<code>createApplicationContext</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title function_">createApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.applicationContextFactory.create(<span class="hljs-built_in">this</span>.webApplicationType); <span class="hljs-comment">//这个类型已经在new的时候确定了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现在构造方法中<code>applicationContextFactory</code>直接使用的是DEFAULT：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-built_in">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;<br>...<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContextFactory</span> <span class="hljs-variable">DEFAULT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationContextFactory</span>();   <span class="hljs-comment">//使用的是默认实现类</span><br></code></pre></td></tr></table></figure><p>我们继续向下扒DefaultApplicationContextFactory的源码<code>create</code>方法部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">create</span><span class="hljs-params">(WebApplicationType webApplicationType)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (ConfigurableApplicationContext)<span class="hljs-built_in">this</span>.getFromSpringFactories(webApplicationType, ApplicationContextFactory::create, <span class="hljs-built_in">this</span>::createDefaultApplicationContext);  <span class="hljs-comment">//套娃获取ConfigurableApplicationContext实现</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception var3) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unable create a default ApplicationContext instance, you may need a custom ApplicationContextFactory&quot;</span>, var3);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; T <span class="hljs-title function_">getFromSpringFactories</span><span class="hljs-params">(WebApplicationType webApplicationType,</span><br><span class="hljs-params">BiFunction&lt;ApplicationContextFactory, WebApplicationType, T&gt; action, Supplier&lt;T&gt; defaultResult)</span> &#123;<br><span class="hljs-comment">//可以看到，这里又是通过SpringFactoriesLoader获取到所有候选的ApplicationContextFactory实现</span><br>  <span class="hljs-keyword">for</span> (ApplicationContextFactory candidate : SpringFactoriesLoader.loadFactories(ApplicationContextFactory.class,<br>getClass().getClassLoader())) &#123;<br><span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> action.apply(candidate, webApplicationType);<br><span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> result;   <span class="hljs-comment">//如果是Servlet环境，这里会找到实现，直接返回</span><br>&#125;<br>&#125;<br>  <span class="hljs-comment">//如果是普通的SpringBoot项目，连Web环境都没有，那么就直接创建普通的ApplicationContext</span><br><span class="hljs-keyword">return</span> (defaultResult != <span class="hljs-literal">null</span>) ? defaultResult.get() : <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然这里又是SpringFactoriesLoader加载ApplicationContextFactory实现，我们就直接去看有些啥：</p><p><img src="https://s2.loli.net/2023/07/19/Nqd8vguDKtR2XmW.png" alt="image-20230719002638475"></p><p>我们也不出意外地在<code>spring.factories</code>中找到了这两个实现，因为目前是Servlet环境，所以在返回时得到最终的结果，也就是生成的AnnotationConfigServletWebServerApplicationContext对象，也就是说到这里为止，Spring的容器就基本已经确定了，差不多可以开始运行了，下一个部分我们将继续介绍SpringBoot是如何实现自动扫描以及自动配置的。</p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p>既然主类已经在初始阶段注册为Bean，那么在加载时，就会根据注解定义，进行更多的额外操作。所以我们来看看主类上的<code>@SpringBootApplication</code>注解做了什么事情。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>  ...<br></code></pre></td></tr></table></figure><p>我们发现，<code>@SpringBootApplication</code>上添加了<code>@ComponentScan</code>注解，此注解我们此前已经认识过了，但是这里并没有配置具体扫描的包，因此它会自动将声明此接口的类所在的包作为basePackage，所以，当添加<code>@SpringBootApplication</code>之后也就等于直接开启了自动扫描，我们所有的配置都会自动加载，但是一定注意不能在主类之外的包进行Bean定义，否则无法扫描到，需要手动配置。</p><p>我们自己类路径下的配置、还有各种Bean定义如何读取的问题解决了，接着我们来看第二个注解<code>@EnableAutoConfiguration</code>，它就是其他Starter自动配置的核心了，我们来看看它是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>  ...<br></code></pre></td></tr></table></figure><p>这里就是SSM阶段我们认识的老套路了，直接一手<code>@Import</code>，通过这种方式来将一些外部的类进行加载。我们来看看AutoConfigurationImportSelector做了什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeferredImportSelector</span>, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到它实现了很多接口，包括大量的Aware接口，我们在SSM阶段也介绍过，实际上就是为了感知某些必要的对象，在加载时将其存到当前类中。</p><p>其中最核心的是<code>DeferredImportSelector</code>接口，它是<code>ImportSelector</code>的子类，它定义了<code>selectImports</code>方法，用于返回需要加载的类名称，在Spring加载ImportSelector时，会调用此方法来获取更多需要加载的类，并将这些类全部注册为Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    String[] selectImports(AnnotationMetadata importingClassMetadata);<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">default</span> Predicate&lt;String&gt; <span class="hljs-title function_">getExclusionFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到目前为止，我们了解了两种使用<code>@Import</code>有特殊机制的接口：ImportSelector（这里用到的）和ImportBeanDefinitionRegistrar（之前SSM阶段源码有讲）当然还有普通的<code>@Configuration</code>配置类。</p><p>为了后续更好理解我们可以来阅读一下<code>ConfigurationClassPostProcessor</code>的源码，实际上这个后置处理器是Spring中提供的，这是专门用于处理配置类的后置处理器，其中<code>ImportBeanDefinitionRegistrar</code>，还有这里的<code>ImportSelector</code>都是靠它来处理，不过当时Spring阶段没有深入讲解，我们来看看它到底是如何处理<code>@Import</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>...<br>processConfigBeanDefinitions(registry);   <span class="hljs-comment">//常规套娃</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>  <span class="hljs-comment">//注意这个后置处理器继承自BeanDefinitionRegistryPostProcessor</span><br>    <span class="hljs-comment">//所以这个阶段仅仅是已经完成扫描了所有的Bean，得到了所有的BeanDefinition，但是还没有进行任何处理</span><br>   <span class="hljs-comment">//candidate是候选者的意思，一会会将标记了@Configuration的类作为ConfigurationClass加入到configCandidates中</span><br>    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  <span class="hljs-comment">//直接取出所有已注册Bean的名称</span><br>    String[] candidateNames = registry.getBeanDefinitionNames();<br>    <span class="hljs-keyword">for</span> (String beanName : candidateNames) &#123;<br>       <span class="hljs-comment">//依次拿到对应的Bean定义，然后进行判断</span><br>       <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDef</span> <span class="hljs-operator">=</span> registry.getBeanDefinition(beanName);<br>       <span class="hljs-keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="hljs-literal">null</span>) &#123;<br>          ...<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-built_in">this</span>.metadataReaderFactory)) &#123;   <span class="hljs-comment">//判断是否为打了 @Configuration 的配置类，如果是就加入到候选列表中</span><br>          configCandidates.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(beanDef, beanName));<br>       &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果一个打了 @Configuration 的类都没发现，直接返回</span><br>    <span class="hljs-keyword">if</span> (configCandidates.isEmpty()) &#123;<br>       <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 对所有的配置类依据 @Order 进行排序</span><br>    configCandidates.sort((bd1, bd2) -&gt; &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());<br>       <span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());<br>       <span class="hljs-keyword">return</span> Integer.compare(i1, i2);<br>    &#125;);<br>    ...<br>    <span class="hljs-comment">// 这里使用do-while语句依次解析所有的配置类</span><br>    <span class="hljs-type">ConfigurationClassParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationClassParser</span>(<br>          <span class="hljs-built_in">this</span>.metadataReaderFactory, <span class="hljs-built_in">this</span>.problemReporter, <span class="hljs-built_in">this</span>.environment,<br>          <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.componentScanBeanNameGenerator, registry);<br>    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);<br>    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(configCandidates.size());<br>    <span class="hljs-keyword">do</span> &#123;<br>       <span class="hljs-type">StartupStep</span> <span class="hljs-variable">processConfig</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.config-classes.parse&quot;</span>);<br>       <span class="hljs-comment">//这里就会通过Parser解析配置类中大部分内容，包括我们之前遇到的@Import注解</span><br> parser.parse(candidates);<br> parser.validate();<br>       <span class="hljs-comment">//解析完成后读取到所有的配置类</span><br>       Set&lt;ConfigurationClass&gt; configClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());<br> configClasses.removeAll(alreadyParsed);<br>       ... <br>       <span class="hljs-comment">//将上面读取的配置类加载为Bean</span><br>       <span class="hljs-built_in">this</span>.reader.loadBeanDefinitions(configClasses);<br>       ...<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!candidates.isEmpty());<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们就接着来看，<code>ConfigurationClassParser</code>是如何进行解析的，直接进入<code>parse</code>方法的关键部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">//处理 @Conditional 相关注解处理，后面会讲</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;<br>        ...<br>        &#125;<br>        ConfigurationClassParser.<span class="hljs-type">SourceClass</span> <span class="hljs-variable">sourceClass</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.asSourceClass(configClass, filter);<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">//这里就是最核心了</span><br>            sourceClass = <span class="hljs-built_in">this</span>.doProcessConfigurationClass(configClass, sourceClass, filter);<br>        &#125; <span class="hljs-keyword">while</span>(sourceClass != <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-built_in">this</span>.configurationClasses.put(configClass, configClass);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们再来看最核心的<code>doProcessConfigurationClass</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title function_">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span><br>    ...<br>    processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-literal">true</span>);    <span class="hljs-comment">// 处理Import注解</span><br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processImports</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span><br><span class="hljs-params">            Collection&lt;SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> checkForCircularImports)</span> &#123;<br>  ...<br>        <span class="hljs-keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;<br>          <span class="hljs-comment">//检查是否存在循环导入情况</span><br>            <span class="hljs-built_in">this</span>.problemReporter.error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularImportProblem</span>(configClass, <span class="hljs-built_in">this</span>.importStack));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.importStack.push(configClass);<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">//依次遍历所有@Import注解中添加的类</span><br>                <span class="hljs-keyword">for</span> (SourceClass candidate : importCandidates) &#123;<br>                    <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;<br>                        <span class="hljs-comment">// 如果是ImportSelector类型，则加载类，并完成实例化</span><br>                        Class&lt;?&gt; candidateClass = candidate.loadClass();<br>                        <span class="hljs-type">ImportSelector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, <span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);<br>                      ...<br>                        <span class="hljs-comment">// 如果是DeferredImportSelector（延迟导入）则通过deferredImportSelectorHandler进行处理</span><br>                        <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DeferredImportSelector deferredImportSelector) &#123;<br>                            <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果是普通的ImportSelector则直接执行selectImports方法得到需要额外导入的类名称</span><br>                            String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());<br>                            Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);<br>                          <span class="hljs-comment">//递归处理这里得到的全部类</span><br>                            processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, <span class="hljs-literal">false</span>);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;<br>                        <span class="hljs-comment">// 判断是否为ImportBeanDefinitionRegistrar类型，SSM阶段已经讲解过了</span><br>                        Class&lt;?&gt; candidateClass = candidate.loadClass();<br>                        <span class="hljs-type">ImportBeanDefinitionRegistrar</span> <span class="hljs-variable">registrar</span> <span class="hljs-operator">=</span><br>                                ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, <span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);<br>                        <span class="hljs-comment">//往configClass丢ImportBeanDefinitionRegistrar信息进去，之后再处理</span><br>                        configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果以上类型都不是，则不使用特殊机制，单纯导入为普通的配置类进行处理</span><br>                        <span class="hljs-built_in">this</span>.importStack.registerImport(<br>                                currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());<br>                        processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不难注意到，虽然这里特别处理了<code>ImportSelector</code>对象，但是还针对<code>ImportSelector</code>的子接口<code>DeferredImportSelector</code>进行了额外处理，Deferred是延迟的意思，它是一个延迟执行的<code>ImportSelector</code>，并不会立即进处理，而是丢进DeferredImportSelectorHandler，并且在我们上面提到的<code>parse</code>方法的最后进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;<br>     ...<br>    <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.process();  <span class="hljs-comment">//执行DeferredImportSelector的process方法，这里依然会进行上面的processImports操作，只不过被延迟到这个位置执行了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>DeferredImportSelector</code>正好就有一个<code>process</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">ublic <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">default</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DeferredImportSelector</span>.Group&gt; getImportGroup() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Group</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(AnnotationMetadata metadata, DeferredImportSelector selector)</span>;<br><br>        Iterable&lt;DeferredImportSelector.Group.Entry&gt; selectImports();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>          ...<br></code></pre></td></tr></table></figure><p>最后经过ConfigurationClassParser处理完成后，通过<code>parser.getConfigurationClasses()</code>就能得到通过配置类导入那些额外的配置类或是特殊的类。最后将这些配置类全部注册BeanDefinition，然后就可以交给接下来的Bean初始化过程去处理了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.reader.loadBeanDefinitions(configClasses);<br></code></pre></td></tr></table></figure><p>最后我们再去看<code>loadBeanDefinitions</code>是如何运行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> &#123;<br>    ConfigurationClassBeanDefinitionReader.<span class="hljs-type">TrackedConditionEvaluator</span> <span class="hljs-variable">trackedConditionEvaluator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConfigurationClassBeanDefinitionReader</span>.TrackedConditionEvaluator();<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> configurationModel.iterator();<br>    <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>        <span class="hljs-type">ConfigurationClass</span> <span class="hljs-variable">configClass</span> <span class="hljs-operator">=</span> (ConfigurationClass)var3.next();<br>        <span class="hljs-built_in">this</span>.loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitionsForConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, ConfigurationClassBeanDefinitionReader.TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;<br>    <span class="hljs-keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>            <span class="hljs-built_in">this</span>.registerBeanDefinitionForImportedConfigurationClass(configClass);  <span class="hljs-comment">//注册配置类自己</span><br>        &#125;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> configClass.getBeanMethods().iterator();<br>        <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;<br>            <span class="hljs-type">BeanMethod</span> <span class="hljs-variable">beanMethod</span> <span class="hljs-operator">=</span> (BeanMethod)var3.next();<br>            <span class="hljs-built_in">this</span>.loadBeanDefinitionsForBeanMethod(beanMethod); <span class="hljs-comment">//注册@Bean注解标识的方法</span><br>        &#125;<br>        <span class="hljs-comment">//注册@ImportResource引入的XML配置文件中读取的bean定义</span><br>        <span class="hljs-built_in">this</span>.loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());<br>        <span class="hljs-comment">//注册configClass中经过解析后保存的所有ImportBeanDefinitionRegistrar，注册对应的BeanDefinition</span><br>        <span class="hljs-built_in">this</span>.loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，整个<code>@Configuration</code>配置类的底层配置流程我们就大致了解了。接着我们来看AutoConfigurationImportSelector是如何实现自动配置的，可以看到内部类AutoConfigurationGroup的process方法，它是父接口的实现，因为父接口是<code>DeferredImportSelector</code>，根据前面的推导，很容易得知，实际上最后会调用<code>process</code>方法获取所有的自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> &#123;<br>    Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector, () -&gt; &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Only %s implementations are supported, got %s&quot;</span>, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName());<br>    &#125;);<br>    <span class="hljs-comment">//获取所有的Entry，其实就是读取来查看有哪些自动配置类</span><br>    AutoConfigurationImportSelector.<span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> ((AutoConfigurationImportSelector)deferredImportSelector).getAutoConfigurationEntry(annotationMetadata);<br>    <span class="hljs-built_in">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> autoConfigurationEntry.getConfigurations().iterator();<br><br>    <span class="hljs-keyword">while</span>(var4.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">importClassName</span> <span class="hljs-operator">=</span> (String)var4.next();<br>        <span class="hljs-built_in">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);<br>    &#125;<br>  <span class="hljs-comment">//这里结束之后，entries中就有上面获取到的自动配置类了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>getAutoConfigurationEntry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>    <span class="hljs-comment">//这里判断是否开启了自动配置，你想的没错，自动配置是可以关的</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//根据注解定义获取一些属性</span><br>        <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAttributes(annotationMetadata);<br>        <span class="hljs-comment">//获取所有需要自动配置的类</span><br>        List&lt;String&gt; configurations = <span class="hljs-built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>        <span class="hljs-comment">//移除掉重复的自动配置类</span><br>        configurations = removeDuplicates(configurations);<br>      <span class="hljs-comment">//获取需要排除掉的自动配置类</span><br>    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>    checkExcludedClasses(configurations, exclusions);<br>    configurations.removeAll(exclusions);<br>      ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着往里面看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;<br>  <span class="hljs-comment">//这里继续套娃</span><br>        List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, <span class="hljs-built_in">this</span>.getBeanClassLoader()).getCandidates();<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里终于找到了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImportCandidates <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;?&gt; annotation, ClassLoader classLoader)</span> &#123;<br>        Assert.notNull(annotation, <span class="hljs-string">&quot;&#x27;annotation&#x27; must not be null&quot;</span>);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> decideClassloader(classLoader);<br>  <span class="hljs-comment">//这里直接获取 META-INF/spring/注解类名.imports 中的所有内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">location</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;META-INF/spring/%s.imports&quot;</span>, annotation.getName());<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以直接找到：</p><p><img src="https://s2.loli.net/2023/07/25/9DI71nqt8JaK4Tl.png" alt="image-20230725234543027"></p><p>可以看到有很多自动配置类，实际上SpringBoot的starter都是依靠自动配置类来实现自动配置的，我们可以随便看一个，比如用于自动配置Mybatis框架的MybatisAutoConfiguration自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span><br><span class="hljs-meta">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    ...<br>      <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> SqlSessionTemplate <span class="hljs-title function_">sqlSessionTemplate</span><span class="hljs-params">(SqlSessionFactory sqlSessionFactory)</span> &#123;<br>        ...<br>    &#125;<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到里面直接将SqlSessionFactory和SqlSessionTemplate注册为Bean了，由于这个自动配置类在上面的一套流程中已经加载了，这样就不需要我们手动进行注册这些Bean了。不过这里有一个非常有意思的 @Conditional 注解，它可以根据条件来判断是否注册这个Bean，比如 @ConditionalOnMissingBean 注解就是当这个Bean不存在的时候，才会注册，如果这个Bean已经被其他配置类给注册了，那么这里就不进行注册。</p><p>经过这一套流程，简而言之就是SpringBoot读取<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件来确定要加载哪些自动配置类来实现的全自动化，真正做到添加依赖就能够直接完成配置和运行，至此，SpringBoot的原理部分就探究完毕了。</p><h3 id="自定义Starter项目"><a href="#自定义Starter项目" class="headerlink" title="自定义Starter项目"></a>自定义Starter项目</h3><p>我们仿照Mybatis来编写一个自己的starter，Mybatis的starter包含两个部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  starter本身只做依赖集中管理，不编写任何代码  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module.name</span>&gt;</span>org.mybatis.spring.boot.starter<span class="hljs-tag">&lt;/<span class="hljs-name">module.name</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  编写的专用配置模块   --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因此我们也将我们自己的starter这样设计，我们设计三个模块：</p><ul><li>spring-boot-hello：基础业务功能模块</li><li>spring-boot-starter-hello：启动器</li><li>spring-boot-autoconifgurer-hello：自动配置依赖</li></ul><p>首先是基础业务功能模块，这里我们随便创建一个类就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动器主要做依赖管理，这里就不写任何代码，只写pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconifgurer-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入autoconfigurer模块作为依赖即可，接着我们去编写autoconfigurer模块，首先导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-hello<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着创建一个HelloWorldAutoConfiguration作为自动配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnWebApplication</span><br><span class="hljs-meta">@EnableConfigurationProperties(HelloWorldProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldAutoConfiguration</span> &#123;<br><br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(<span class="hljs-built_in">this</span>.getClass().getName());<br><br>    <span class="hljs-meta">@Autowired</span><br>    HelloWorldProperties properties;<br><br>    <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> HelloWorldService <span class="hljs-title function_">helloWorldService</span><span class="hljs-params">()</span>&#123;<br>        logger.info(<span class="hljs-string">&quot;自定义starter项目已启动！&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;读取到自定义配置：&quot;</span>+properties.getValue());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloWorldService</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的配置读取类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;hello.world&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorldProperties</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(String value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着再编写<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件，并将我们的自动配置类添加即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">com.test.autoconfigure.HelloWorldAutoConfiguration</span><br></code></pre></td></tr></table></figure><p>最后再Maven根项目执行<code>install</code>安装到本地仓库，完成。接着就可以在其他项目中使用我们编写的自定义starter了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://zhuanlan.zhihu.com/p/425864811<br>title: &quot;详细对比 JPA、MyBatis-Plus 的差异&quot;<br>description: &quot;用了多年 Hibernate，在2022年新项目做技术选型时，仔细对标了JPA和MyBatis-Plus的差异。 目前主流的持久层有以下几种： ● Spring JDBC Template 对底层JDBC操作的简单封装，包装了连接获取和释放，以及异常处理…&quot;<br>host: zhuanlan.zhihu.com<br>image: https://pica.zhimg.com/v2-eabb989cacb1af3c9ac9c2a84b710307_720w.jpg?source=172ae18b<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/22/yM9WDH5TS4a6I7e.png" alt="image-20230722114717716"></p><h1 id="深入SpringBoot数据交互"><a href="#深入SpringBoot数据交互" class="headerlink" title="深入SpringBoot数据交互"></a>深入SpringBoot数据交互</h1><p>本章我们将深入讲解SpringBoot的数据交互，使用更多方便好用的持久层框架。</p><h2 id="JDBC交互框架"><a href="#JDBC交互框架" class="headerlink" title="JDBC交互框架"></a>JDBC交互框架</h2><p>除了我们前面一直认识的Mybatis之外，实际上Spring官方也提供了一个非常方便的JDBC操作工具，它同样可以快速进行增删改查。首先我们还是通过starter将依赖导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>导入完成之后就可以轻松使用了。</p><h3 id="JDBC模版类"><a href="#JDBC模版类" class="headerlink" title="JDBC模版类"></a>JDBC模版类</h3><p>Spring JDBC为我们提供了一个非常方便的<code>JdbcTemplate</code>类，它封装了常用的JDBC操作，我们可以快速使用这些方法来实现增删改查，这里我们还是配置一下MySQL数据源信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>我们要操作数据库，最简单直接的方法就是使用JdbcTemplate来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>JdbcTemplate template;<br></code></pre></td></tr></table></figure><p>它给我们封装了很多方法使用，比如我们要查询数据库中的一条记录：</p><p><img src="https://s2.loli.net/2023/07/16/ygRp98mDKafXkw1.png" alt="image-20230716000431492"></p><p>我们可以使用<code>queryForMap</code>快速以Map为结果的形式查询一行数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    Map&lt;String, Object&gt; map = template.queryForMap(<span class="hljs-string">&quot;select * from user where id = ?&quot;</span>, <span class="hljs-number">1</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>非常方便：</p><p><img src="https://s2.loli.net/2023/07/20/ijczpNxh4fXoQKv.png" alt="image-20230720215124918"></p><p>我们也可以编写自定义的Mapper用于直接得到查询结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    String email;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> template.queryForObject(<span class="hljs-string">&quot;select * from user where id = ?&quot;</span>,<br>        (r, i) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(r.getInt(<span class="hljs-number">1</span>), r.getString(<span class="hljs-number">2</span>), r.getString(<span class="hljs-number">3</span>), r.getString(<span class="hljs-number">4</span>)), <span class="hljs-number">1</span>);<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然除了这些之外，它还提供了<code>update</code>方法适用于各种情况的查询、更新、删除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> template.update(<span class="hljs-string">&quot;insert into user values(2, &#x27;admin&#x27;, &#x27;654321@qq.com&#x27;, &#x27;123456&#x27;)&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;更新了 &quot;</span>+update+<span class="hljs-string">&quot; 行&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，如果是那种非常小型的项目，甚至是测试用例的话，都可以快速使用JdbcTemplate快速进行各种操作。</p><h3 id="JDBC简单封装"><a href="#JDBC简单封装" class="headerlink" title="JDBC简单封装"></a>JDBC简单封装</h3><p>对于一些插入操作，Spring JDBC为我们提供了更方便的SimpleJdbcInsert工具，它可以实现更多高级的插入功能，比如我们的表主键采用的是自增ID，那么它支持插入后返回自动生成的ID，这就非常方便了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    DataSource source;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//这个类需要自己创建对象</span><br>        <span class="hljs-type">SimpleJdbcInsert</span> <span class="hljs-variable">simple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleJdbcInsert</span>(source)<br>                .withTableName(<span class="hljs-string">&quot;user&quot;</span>)   <span class="hljs-comment">//设置要操作的表名称</span><br>                .usingGeneratedKeyColumns(<span class="hljs-string">&quot;id&quot;</span>);    <span class="hljs-comment">//设置自增主键列</span><br>        Map&lt;String, Object&gt; user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">2</span>);  <span class="hljs-comment">//插入操作需要传入一个Map作为数据</span><br>        user.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;bob&quot;</span>);<br>        user.put(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;112233@qq.com&quot;</span>);<br>        user.put(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> simple.executeAndReturnKey(user);   <span class="hljs-comment">//最后得到的Numver就是得到的自增主键</span><br>        System.out.println(number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以快速进行插入操作并且返回自增主键了，还是挺方便的。</p><p><img src="https://s2.loli.net/2023/07/20/xMeBEY3sdKVGmly.png" alt="image-20230720224314223"></p><p>当然，虽然SpringJDBC给我们提供了这些小工具，但是其实只适用于简单小项目，稍微复杂一点就不太适合了</p><hr><h2 id="JPA框架"><a href="#JPA框架" class="headerlink" title="JPA框架"></a>JPA框架</h2><p><img src="https://s2.loli.net/2023/07/20/mq4Ut7BMI5XTDoN.png" alt="image-20230720230734488"></p><ul><li>用了Mybatis之后，你看那个JDBC，真是太逊了。</li><li>这么说，你的项目很勇哦？</li><li>开玩笑，我的写代码超勇的好不好。</li><li>阿伟，你可曾幻想过有一天你的项目里不再有SQL语句？</li><li>不再有SQL语句？那我怎么和数据库交互啊？</li><li>我看你是完全不懂哦</li><li>懂，懂什么啊？</li><li>你想懂？来，到我项目里来，我给你看点好康的。</li><li>好康？是什么新框架哦？</li><li>什么新框架，比新框架还刺激，还可以让你的项目登duang郎哦。</li></ul><p>​在我们之前编写的项目中，我们不难发现，实际上大部分的数据库交互操作，到最后都只会做一个事情，那就是把数据库中的数据映射为Java中的对象。比如我们要通过用户名去查找对应的用户，或是通过ID查找对应的学生信息，在使用Mybatis时，我们只需要编写正确的SQL语句就可以直接将获取的数据映射为对应的Java对象，通过调用Mapper中的方法就能直接获得实体类，这样就方便我们在Java中数据库表中的相关信息了。</p><p>​但是以上这些操作都有一个共性，那就是它们都是通过某种条件去进行查询，而最后的查询结果，都是一个实体类，所以你会发现你写的很多SQL语句都是一个套路<code>select * from xxx where xxx=xxx</code>，实际上对于这种简单SQL语句，我们完全可以弄成一个模版来使用，那么能否有一种框架，帮我们把这些相同的套路给封装起来，直接把这类相似的SQL语句给屏蔽掉，不再由我们编写，而是让框架自己去组合拼接。</p><h3 id="认识SpringData-JPA"><a href="#认识SpringData-JPA" class="headerlink" title="认识SpringData JPA"></a>认识SpringData JPA</h3><p>首先我们来看一个国外的统计：</p><p><img src="https://s2.loli.net/2023/03/06/XaoLIPrjDKzO9Tx.png" alt="image-20230306224859664"></p><p>不对吧，为什么Mybatis这么好用，这么强大，却只有10%的人喜欢呢？然而事实就是，在国外JPA几乎占据了主导地位，而Mybatis并不像国内那样受待见，所以你会发现，JPA都有SpringBoot的官方直接提供的starter，而Mybatis没有，直到SpringBoot 3才开始加入到官方模版中。</p><p>那么，什么是JPA？</p><blockquote><p>JPA（Java Persistence API）和JDBC类似，也是官方定义的一组接口，但是它相比传统的JDBC，它是为了实现ORM而生的，即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间形成一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了。</p><p>其中比较常见的JPA实现有：</p><ol><li>Hibernate：Hibernate是JPA规范的一个具体实现，也是目前使用最广泛的JPA实现框架之一。它提供了强大的对象关系映射功能，可以将Java对象映射到数据库表中，并提供了丰富的查询语言和缓存机制。</li><li>EclipseLink：EclipseLink是另一个流行的JPA实现框架，由Eclipse基金会开发和维护。它提供了丰富的特性，如对象关系映射、缓存、查询语言和连接池管理等，并具有较高的性能和可扩展性。</li><li>OpenJPA：OpenJPA是Apache基金会的一个开源项目，也是JPA规范的一个实现。它提供了高性能的JPA实现和丰富的特性，如延迟加载、缓存和分布式事务等。</li><li>TopLink：TopLink是Oracle公司开发的一个对象关系映射框架，也是JPA规范的一个实现。虽然EclipseLink已经取代了TopLink成为Oracle推荐的JPA实现，但TopLink仍然得到广泛使用。</li></ol></blockquote><p>在之前，我们使用JDBC或是Mybatis来操作数据，通过直接编写对应的SQL语句来实现数据访问，但是我们发现实际上我们在Java中大部分操作数据库的情况都是读取数据并封装为一个实体类，因此，为什么不直接将实体类直接对应到一个数据库表呢？也就是说，一张表里面有什么属性，那么我们的对象就有什么属性，所有属性跟数据库里面的字段一一对应，而读取数据时，只需要读取一行的数据并封装为我们定义好的实体类既可以，而具体的SQL语句执行，完全可以交给框架根据我们定义的映射关系去生成，不再由我们去编写，因为这些SQL实际上都是千篇一律的。</p><p>而实现JPA规范的框架一般最常用的就是<code>Hibernate</code>，它是一个重量级框架，学习难度相比Mybatis也更高一些，而SpringDataJPA也是采用Hibernate框架作为底层实现，并对其加以封装。</p><p>官网：<a href="https://spring.io/projects/spring-data-jpa">https://spring.io/projects/spring-data-jpa</a></p><h3 id="使用JPA快速上手"><a href="#使用JPA快速上手" class="headerlink" title="使用JPA快速上手"></a>使用JPA快速上手</h3><p>同样的，我们只需要导入stater依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们可以直接创建一个类，比如用户类，我们只需要把一个账号对应的属性全部定义好即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们可以通过注解形式，在属性上添加数据库映射关系，这样就能够让JPA知道我们的实体类对应的数据库表长啥样，这里用到了很多注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span>   <span class="hljs-comment">//表示这个类是一个实体类</span><br><span class="hljs-meta">@Table(name = &quot;account&quot;)</span>    <span class="hljs-comment">//对应的数据库中表名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>   <span class="hljs-comment">//生成策略，这里配置为自增</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span>    <span class="hljs-comment">//对应表中id这一列</span><br>    <span class="hljs-meta">@Id</span>     <span class="hljs-comment">//此属性为主键</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span>   <span class="hljs-comment">//对应表中username这一列</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span>   <span class="hljs-comment">//对应表中password这一列</span><br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来修改一下配置文件，把日志打印给打开：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-comment">#开启SQL语句执行日志信息</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">hibernate:</span><br>      <span class="hljs-comment">#配置为检查数据库表结构，没有时会自动创建</span><br>      <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br></code></pre></td></tr></table></figure><p><code>ddl-auto</code>属性用于设置自动表定义，可以实现自动在数据库中为我们创建一个表，表的结构会根据我们定义的实体类决定，它有以下几种：</p><ul><li><code>none</code>: 不执行任何操作，数据库表结构需要手动创建。</li><li><code>create</code>: 框架在每次运行时都会删除所有表，并重新创建。</li><li><code>create-drop</code>: 框架在每次运行时都会删除所有表，然后再创建，但在程序结束时会再次删除所有表。</li><li><code>update</code>: 框架会检查数据库表结构，如果与实体类定义不匹配，则会做相应的修改，以保持它们的一致性。</li><li><code>validate</code>: 框架会检查数据库表结构与实体类定义是否匹配，如果不匹配，则会抛出异常。</li></ul><p>这个配置项的作用是为了避免手动管理数据库表结构，使开发者可以更方便地进行开发和测试，但在生产环境中，更推荐使用数据库迁移工具来管理表结构的变更。</p><p>我们可以在日志中发现，在启动时执行了如下SQL语句：</p><p><img src="https://s2.loli.net/2023/07/20/kABZVhJ8vjKSqzT.png" alt="image-20230720235136506"></p><p>我们的数据库中对应的表已经自动创建好了。</p><p>我们接着来看如何访问我们的表，我们需要创建一个Repository实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意JpaRepository有两个泛型，前者是具体操作的对象实体，也就是对应的表，后者是ID的类型，接口中已经定义了比较常用的数据库操作。编写接口继承即可，我们可以直接注入此接口获得实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br>AccountRepository repository;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    account.setUsername(<span class="hljs-string">&quot;小红&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;1234567&quot;</span>);<br>    System.out.println(repository.save(account).getId());   <span class="hljs-comment">//使用save来快速插入数据，并且会返回插入的对象，如果存在自增ID，对象的自增id属性会自动被赋值，这就很方便了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://s2.loli.net/2023/07/20/ksI3J5eidzTrvyL.png" alt="image-20230720235640148"></p><p>同时，查询操作也很方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//默认通过通过ID查找的方法，并且返回的结果是Optional包装的对象，非常人性化</span><br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2023/07/20/TRHOWbop267Al4Q.png" alt="image-20230720235949290"></p><p>包括常见的一些计数、删除操作等都包含在里面，仅仅配置应该接口就能完美实现增删改查：</p><p><img src="https://s2.loli.net/2023/07/21/uIBciLqFsH5tdDR.png" alt="image-20230721000050875"></p><p>我们发现，使用了JPA之后，整个项目的代码中没有出现任何的SQL语句，可以说是非常方便了，JPA依靠我们提供的注解信息自动完成了所有信息的映射和关联。</p><blockquote><p><em>相比Mybatis，JPA几乎就是一个全自动的ORM框架，而Mybatis则顶多算是半自动ORM框架。</em></p></blockquote><h3 id="方法名称拼接自定义SQL"><a href="#方法名称拼接自定义SQL" class="headerlink" title="方法名称拼接自定义SQL"></a>方法名称拼接自定义SQL</h3><p>虽然接口预置的方法使用起来非常方便，但是如果我们需要进行<strong>条件查询等操作或是一些判断</strong>，就需要自定义一些方法来实现，同样的，我们不需要编写SQL语句，而是通过方法名称的拼接来实现条件判断，这里列出了所有支持的条件判断名称：</p><table><thead><tr><th>属性</th><th align="center">拼接方法名称示例</th><th align="center">执行的语句</th></tr></thead><tbody><tr><td>Distinct</td><td align="center">findDistinctByLastnameAndFirstname</td><td align="center">select distinct … where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2</td></tr><tr><td>And</td><td align="center">findByLastnameAndFirstname</td><td align="center">… where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2</td></tr><tr><td>Or</td><td align="center">findByLastnameOrFirstname</td><td align="center">… where x.lastname &#x3D; ?1 or x.firstname &#x3D; ?2</td></tr><tr><td>Is，Equals</td><td align="center">findByFirstname<code>,</code>findByFirstnameIs<code>,</code>findByFirstnameEquals</td><td align="center">… where x.firstname &#x3D; ?1</td></tr><tr><td>Between</td><td align="center">findByStartDateBetween</td><td align="center">… where x.startDate between ?1 and ?2</td></tr><tr><td>LessThan</td><td align="center">findByAgeLessThan</td><td align="center">… where x.age &lt; ?1</td></tr><tr><td>LessThanEqual</td><td align="center">findByAgeLessThanEqual</td><td align="center">… where x.age &lt;&#x3D; ?1</td></tr><tr><td>GreaterThan</td><td align="center">findByAgeGreaterThan</td><td align="center">… where x.age &gt; ?1</td></tr><tr><td>GreaterThanEqual</td><td align="center">findByAgeGreaterThanEqual</td><td align="center">… where x.age &gt;&#x3D; ?1</td></tr><tr><td>After</td><td align="center">findByStartDateAfter</td><td align="center">… where x.startDate &gt; ?1</td></tr><tr><td>Before</td><td align="center">findByStartDateBefore</td><td align="center">… where x.startDate &lt; ?1</td></tr><tr><td>IsNull，Null</td><td align="center">findByAge(Is)Null</td><td align="center">… where x.age is null</td></tr><tr><td>IsNotNull，NotNull</td><td align="center">findByAge(Is)NotNull</td><td align="center">… where x.age not null</td></tr><tr><td>Like</td><td align="center">findByFirstnameLike</td><td align="center">… where x.firstname like ?1</td></tr><tr><td>NotLike</td><td align="center">findByFirstnameNotLike</td><td align="center">… where x.firstname not like ?1</td></tr><tr><td>StartingWith</td><td align="center">findByFirstnameStartingWith</td><td align="center">… where x.firstname like ?1（参数与附加<code>%</code>绑定）</td></tr><tr><td>Containing</td><td align="center">findByFirstnameContaining</td><td align="center">… where x.firstname like ?1（参数绑定以<code>%</code>包装）</td></tr><tr><td>OrderBy</td><td align="center">findByAgeOrderByLastnameDesc</td><td align="center">… where x.age &#x3D; ?1 order by x.lastname desc</td></tr><tr><td>Not</td><td align="center">findByLastnameNot</td><td align="center">… where x.lastname &lt;&gt; ?1</td></tr><tr><td></td><td align="center"></td><td align="center"></td></tr><tr><td>NotIn</td><td align="center">findByAgeNotIn(Collection&lt;Age&gt; ages)</td><td align="center">… where x.age not in ?1</td></tr><tr><td>True</td><td align="center">findByActiveTrue</td><td align="center">… where x.active &#x3D; true</td></tr><tr><td>False</td><td align="center">findByActiveFalse</td><td align="center">… where x.active &#x3D; false</td></tr><tr><td>IgnoreCase</td><td align="center">findByFirstnameIgnoreCase</td><td align="center">… where UPPER(x.firstname) &#x3D; UPPER(?1)</td></tr><tr><td>In</td><td align="center">findByAgeIn(Collection&lt;Age&gt; ages)</td><td align="center">… where x.age in ?1</td></tr></tbody></table><p>比如我们想要实现根据用户名模糊匹配查找用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br>    <span class="hljs-comment">//按照表中的规则进行名称拼接，不用刻意去记，IDEA会有提示</span><br>    List&lt;Account&gt; <span class="hljs-title function_">findAllByUsernameLike</span><span class="hljs-params">(String str)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    repository.findAllByUsernameLike(<span class="hljs-string">&quot;%明%&quot;</span>).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/21/mioZaUk7Yj3QDxb.png" alt="image-20230721001035279"></p><p>又比如我们想同时根据用户名和ID一起查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br>    List&lt;Account&gt; <span class="hljs-title function_">findAllByUsernameLike</span><span class="hljs-params">(String str)</span>;<br><br>    Account <span class="hljs-title function_">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String username)</span>;<br>    <span class="hljs-comment">//也可以使用Optional类进行包装，Optional&lt;Account&gt; findByIdAndUsername(int id, String username);</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(repository.findByIdAndUsername(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们想判断数据库中是否存在某个ID的用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br>    List&lt;Account&gt; <span class="hljs-title function_">findAllByUsernameLike</span><span class="hljs-params">(String str)</span>;<br>    Account <span class="hljs-title function_">findByIdAndUsername</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String username)</span>;<br>    <span class="hljs-comment">//使用exists判断是否存在</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">existsAccountById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意自定义条件操作的方法名称一定要遵循规则，不然会出现异常：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Caused by: org.springframework.data.repository.query.QueryCreationException: Could not create query <span class="hljs-keyword">for</span> public abstract  ...<br></code></pre></td></tr></table></figure><p>有了这些操作，我们在编写一些简单SQL的时候就很方便了，用久了甚至直接忘记SQL怎么写。</p><blockquote><p>JPA可以通过<strong>条件属性</strong>进行<strong>拼接</strong>以实现复杂的逻辑功能。</p></blockquote><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在实际开发中，比较常见的场景还有关联查询，也就是我们会在表中添加一个外键字段，而此外键字段又指向了另一个表中的数据，当我们查询数据时，可能会需要将关联数据也一并获取，比如我们想要查询某个用户的详细信息，一般用户简略信息会单独存放一个表，而用户详细信息会单独存放在另一个表中。当然，除了用户详细信息之外，可能在某些电商平台还会有用户的购买记录、用户的购物车，交流社区中的用户帖子、用户评论等，这些都是需要根据用户信息进行关联查询的内容。</p><p><img src="https://s2.loli.net/2023/03/06/WnPEmdR2sDLuwGN.jpg" alt="img"></p><p>我们知道，在JPA中，每张表实际上就是一个实体类的映射，而表之间的关联关系，也可以看作对象之间的依赖关系，比如用户表中包含了用户详细信息的ID字段作为外键，那么实际上就是用户表实体中包括了用户详细信息实体对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_detail&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountDetail</span> &#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;address&quot;)</span><br>    String address;<br><br>    <span class="hljs-meta">@Column(name = &quot;email&quot;)</span><br>    String email;<br><br>    <span class="hljs-meta">@Column(name = &quot;phone&quot;)</span><br>    String phone;<br><br>    <span class="hljs-meta">@Column(name = &quot;real_name&quot;)</span><br>    String realName;<br>&#125;<br></code></pre></td></tr></table></figure><p>而用户信息和用户详细信息之间形成了一对一的关系，那么这时我们就可以直接在类中指定这种关系：</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a><strong>一对一</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;username&quot;)</span><br>    String username;<br><br>    <span class="hljs-meta">@Column(name = &quot;password&quot;)</span><br>    String password;<br><br>    <span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span>   <span class="hljs-comment">//指定存储外键的字段名称</span><br>    <span class="hljs-meta">@OneToOne</span>    <span class="hljs-comment">//声明为一对一关系</span><br>    AccountDetail detail;<br>&#125;<br></code></pre></td></tr></table></figure><p>在修改实体类信息后，我们发现在启动时也进行了更新，日志如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> detail_id <span class="hljs-type">integer</span><br>Hibernate: <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> users_detail (id <span class="hljs-type">integer</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment, address <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), email <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), phone <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), real_name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), <span class="hljs-keyword">primary</span> key (id)) engine<span class="hljs-operator">=</span>InnoDB<br>Hibernate: <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> users <span class="hljs-keyword">add</span> <span class="hljs-keyword">constraint</span> FK7gb021edkxf3mdv5bs75ni6jd <span class="hljs-keyword">foreign</span> key (detail_id) <span class="hljs-keyword">references</span> users_detail (id)<br></code></pre></td></tr></table></figure><p>是不是感觉非常方便！都懒得去手动改表结构了。</p><p>接着我们往用户详细信息中添加一些数据，一会我们可以直接进行查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pageAccount</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>查询后，可以发现，得到如下结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_, accountdet1_.id as id1_1_1_, accountdet1_.address as address2_1_1_, accountdet1_.email as email3_1_1_, accountdet1_.phone as phone4_1_1_, accountdet1_.real_name as real_nam5_1_1_ <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>account0_ left outer join users_detail accountdet1_ on account0_.<span class="hljs-attribute">detail_id</span>=accountdet1_.id where account0_.<span class="hljs-attribute">id</span>=?<br>Account(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">username</span>=Test, <span class="hljs-attribute">password</span>=123456, <span class="hljs-attribute">detail</span>=AccountDetail(id=1, <span class="hljs-attribute">address</span>=四川省成都市青羊区, <span class="hljs-attribute">email</span>=8371289@qq.com, <span class="hljs-attribute">phone</span>=1234567890, <span class="hljs-attribute">realName</span>=本伟))<br></code></pre></td></tr></table></figure><p>也就是，在建立关系之后，我们查询Account对象时，会自动将关联数据的结果也一并进行查询。</p><p>那要是我们只想要Account的数据，不想要用户详细信息数据怎么办呢？我希望在我要用的时候再获取详细信息，这样可以节省一些网络开销，我们可以设置懒加载，这样只有在需要时才会向数据库获取：</p><p><strong>懒加载外键信息：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY)</span>    <span class="hljs-comment">//将获取类型改为LAZY</span><br>AccountDetail detail;<br></code></pre></td></tr></table></figure><p>接着我们测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>   <span class="hljs-comment">//懒加载属性需要在事务环境下获取，因为repository方法调用完后Session会立即关闭</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">pageAccount</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(account -&gt; &#123;<br>        System.out.println(account.getUsername());   <span class="hljs-comment">//获取用户名</span><br>        System.out.println(account.getDetail());  <span class="hljs-comment">//获取详细信息（懒加载）</span><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来看看控制台输出了什么：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Hibernate: select account0_.id as id1_0_0_, account0_.detail_id as detail_i4_0_0_, account0_.password as password2_0_0_, account0_.username as username3_0_0_ <span class="hljs-keyword">from</span><span class="hljs-built_in"> users </span>account0_ where account0_.<span class="hljs-attribute">id</span>=?<br>Test<br>Hibernate: select accountdet0_.id as id1_1_0_, accountdet0_.address as address2_1_0_, accountdet0_.email as email3_1_0_, accountdet0_.phone as phone4_1_0_, accountdet0_.real_name as real_nam5_1_0_ <span class="hljs-keyword">from</span> users_detail accountdet0_ where accountdet0_.<span class="hljs-attribute">id</span>=?<br>AccountDetail(<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">address</span>=四川省成都市青羊区, <span class="hljs-attribute">email</span>=8371289@qq.com, <span class="hljs-attribute">phone</span>=1234567890, <span class="hljs-attribute">realName</span>=卢本)<br></code></pre></td></tr></table></figure><p>可以看到，获取用户名之前，并没有去查询用户的详细信息，而是当我们获取详细信息时才进行查询并返回AccountDetail对象。</p><p>那么我们是否也可以在添加数据时，利用实体类之间的关联信息，一次性添加两张表的数据呢？可以，但是我们需要稍微修改一下级联关联操作设定：</p><p><strong>关联操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;detail_id&quot;)</span><br><span class="hljs-meta">@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)</span> <span class="hljs-comment">//设置关联操作为ALL</span><br>AccountDetail detail;<br></code></pre></td></tr></table></figure><blockquote><p> <code>ALL</code>：所有操作都进行关联操作<br> <code>PERSIST</code>：插入操作时才进行关联操作<br> <code>REMOVE</code>：删除操作时才进行关联操作<br> <code>MERGE</code>：修改操作时才进行关联操作</p></blockquote><p>可以多个并存，接着我们来进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">addAccount</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Account</span> <span class="hljs-variable">account</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    account.setUsername(<span class="hljs-string">&quot;Nike&quot;</span>);<br>    account.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>    <span class="hljs-type">AccountDetail</span> <span class="hljs-variable">detail</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDetail</span>();<br>    detail.setAddress(<span class="hljs-string">&quot;重庆市渝中区解放碑&quot;</span>);<br>    detail.setPhone(<span class="hljs-string">&quot;1234567890&quot;</span>);<br>    detail.setEmail(<span class="hljs-string">&quot;73281937@qq.com&quot;</span>);<br>    detail.setRealName(<span class="hljs-string">&quot;张三&quot;</span>);<br>  account.setDetail(detail);<br>    account = repository.save(account);<br>    System.out.println(<span class="hljs-string">&quot;插入时，自动生成的主键ID为：&quot;</span>+account.getId()+<span class="hljs-string">&quot;，外键ID为：&quot;</span>+account.getDetail().getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到日志结果：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">Hibernate</span>: insert into users_detail (address, email, phone, real_name) values (<span class="hljs-string">?,</span> <span class="hljs-string">?,</span> <span class="hljs-string">?,</span> <span class="hljs-string">?)</span><br><span class="hljs-title class_">Hibernate</span>: insert into users (detail_id, password, username) values (<span class="hljs-string">?,</span> <span class="hljs-string">?,</span> <span class="hljs-string">?)</span><br>插入时，自动生成的主键<span class="hljs-variable constant_">ID</span>为：<span class="hljs-number">6</span>，外键<span class="hljs-variable constant_">ID</span>为：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>结束后会发现数据库中两张表都同时存在数据。</p><p>接着我们来看一对多关联，比如每个用户的成绩信息：</p><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a><strong>一对多</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JoinColumn(name = &quot;uid&quot;)</span>  <span class="hljs-comment">//注意这里的name指的是Score表中的uid字段对应的就是当前的主键，会将uid外键设置为当前的主键</span><br><span class="hljs-meta">@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.REMOVE)</span>   <span class="hljs-comment">//在移除Account时，一并移除所有的成绩信息，依然使用懒加载</span><br>List&lt;Score&gt; scoreList;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;users_score&quot;)</span>   <span class="hljs-comment">//成绩表，注意只存成绩，不存学科信息，学科信息id做外键</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@OneToOne</span>   <span class="hljs-comment">//一对一对应到学科上</span><br>    <span class="hljs-meta">@JoinColumn(name = &quot;cid&quot;)</span><br>    Subject subject;<br><br>    <span class="hljs-meta">@Column(name = &quot;socre&quot;)</span><br>    <span class="hljs-type">double</span> score;<br><br>    <span class="hljs-meta">@Column(name = &quot;uid&quot;)</span><br>    <span class="hljs-type">int</span> uid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;subjects&quot;)</span>   <span class="hljs-comment">//学科信息表</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;cid&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> cid;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta">@Column(name = &quot;teacher&quot;)</span><br>    String teacher;<br><br>    <span class="hljs-meta">@Column(name = &quot;time&quot;)</span><br>    <span class="hljs-type">int</span> time;<br>&#125;<br></code></pre></td></tr></table></figure><p>在数据库中填写相应数据，接着我们就可以查询用户的成绩信息了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">1</span>).ifPresent(account -&gt; &#123;<br>        account.getScoreList().forEach(System.out::println);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功得到用户所有的成绩信息，包括得分和学科信息。</p><p>同样的，我们还可以将对应成绩中的教师信息单独分出一张表存储，并建立多对一的关系，因为多门课程可能由同一个老师教授（千万别搞晕了，一定要理清楚关联关系，同时也是考验你的基础扎不扎实）：</p><h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a><strong>多对一</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ManyToOne(fetch = FetchType.LAZY)</span><br><span class="hljs-meta">@JoinColumn(name = &quot;tid&quot;)</span>   <span class="hljs-comment">//存储教师ID的字段，和一对一是一样的，也会当前表中创个外键</span><br>Teacher teacher;<br></code></pre></td></tr></table></figure><p>接着就是教师实体类了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;teachers&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    String name;<br><br>    <span class="hljs-meta">@Column(name = &quot;sex&quot;)</span><br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们再进行一下测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    repository.findById(<span class="hljs-number">3</span>).ifPresent(account -&gt; &#123;<br>        account.getScoreList().forEach(score -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;课程名称：&quot;</span>+score.getSubject().getName());<br>            System.out.println(<span class="hljs-string">&quot;得分：&quot;</span>+score.getScore());<br>            System.out.println(<span class="hljs-string">&quot;任课教师：&quot;</span>+score.getSubject().getTeacher().getName());<br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>成功得到多对一的教师信息。</p><p>最后我们再来看最复杂的情况，现在我们一门课程可以由多个老师教授，而一个老师也可以教授多个课程，那么这种情况就是很明显的多对多场景，现在又该如何定义呢？我们可以像之前一样，插入一张中间表表示教授关系，这个表中专门存储哪个老师教哪个科目：</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a><strong>多对多</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ManyToMany(fetch = FetchType.LAZY)</span>   <span class="hljs-comment">//多对多场景</span><br><span class="hljs-meta">@JoinTable(name = &quot;teach_relation&quot;,     //多对多中间关联表</span><br><span class="hljs-meta">        joinColumns = @JoinColumn(name = &quot;cid&quot;),    //当前实体主键在关联表中的字段名称</span><br><span class="hljs-meta">        inverseJoinColumns = @JoinColumn(name = &quot;tid&quot;)   //教师实体主键在关联表中的字段名称</span><br><span class="hljs-meta">)</span><br>List&lt;Teacher&gt; teacher;<br></code></pre></td></tr></table></figure><p>接着，JPA会自动创建一张中间表，并自动设置外键，我们就可以将多对多关联信息编写在其中了。</p><blockquote><p>通过<strong>关联表和关联键注解</strong>来实现<em>一对一、一对多、多对一和多对多</em>的多表关联关系</p></blockquote><hr><h3 id="JPQL自定义SQL语句"><a href="#JPQL自定义SQL语句" class="headerlink" title="JPQL自定义SQL语句"></a>JPQL自定义SQL语句</h3><p>虽然SpringDataJPA能够简化大部分数据获取场景，但是难免会有一些特殊的场景，需要使用复杂查询才能够去完成，这时你又会发现，如果要实现，只能用回Mybatis了，因为我们需要自己手动编写SQL语句，过度依赖SpringDataJPA会使得SQL语句不可控。</p><p>使用JPA，我们也可以像Mybatis那样，直接编写SQL语句，不过它是<strong>JPQL语言</strong>，与原生SQL语句很类似，但是它是<strong>面向对象</strong>的，当然我们也可以编写原生SQL语句。</p><p>比如我们要更新用户表中指定ID用户的密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Account, Integer&gt; &#123;<br><br>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-comment">//DML操作需要事务环境，可以不在这里声明，但是调用时一定要处于事务环境下</span><br>    <span class="hljs-meta">@Modifying</span>     <span class="hljs-comment">//表示这是一个DML操作</span><br>    <span class="hljs-meta">@Query(&quot;update Account set password = ?2 where id = ?1&quot;)</span> <span class="hljs-comment">//这里操作的是一个实体类对应的表，参数使用?代表，后面接第n个参数</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updatePasswordById</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String newPassword)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateAccount</span><span class="hljs-params">()</span>&#123;<br>    repository.updatePasswordById(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;654321&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我想使用原生SQL来实现根据用户名称修改密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Modifying</span><br><span class="hljs-meta">@Query(value = &quot;update users set password = :pwd where username = :name&quot;, nativeQuery = true)</span> <span class="hljs-comment">//使用原生SQL，和Mybatis一样，这里使用 :名称 表示参数，当然也可以继续用上面那种方式。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updatePasswordByUsername</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String username,   //我们可以使用<span class="hljs-meta">@Param</span>指定名称</span><br><span class="hljs-params">                             <span class="hljs-meta">@Param(&quot;pwd&quot;)</span> String newPassword)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateAccount</span><span class="hljs-params">()</span>&#123;<br>    repository.updatePasswordByUsername(<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-string">&quot;654321&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过编写<strong>原生SQL</strong>，在一定程度上弥补了<strong>SQL不可控</strong>的问题。</p><p>虽然JPA能够为我们带来非常便捷的开发体验，但是正是因为太便捷了，保姆级的体验有时也会适得其反，尤其是一些国内用到复杂查询业务的项目，可能开发到后期特别庞大时，就只能从底层SQL语句开始进行优化，而由于JPA尽可能地在屏蔽我们对SQL语句的编写，所以后期优化是个大问题，并且Hibernate相对于Mybatis来说，更加重量级。不过，在微服务的时代，单体项目一般不会太大，JPA的劣势并没有太明显地体现出来。</p><blockquote><p>[!NOTE] <strong>JPA与Mybatis对比：</strong></p><ul><li>JPA是全自动化ORM框架，适合简单的增删改查无需编写sql，只能通过方法条件属性拼接实现复杂条件查询导致方法名太长可读性差，也可以通过jpql自定义sql或原生sql但相对麻烦。</li><li>mybatis是半自动化ORM框架，通过注解结合自定义sql实现各种复杂条件查询等各种功能，逻辑可控易于后期优化，但编写sql相对费时费力。</li></ul></blockquote><hr><h2 id="MybatisPlus框架"><a href="#MybatisPlus框架" class="headerlink" title="MybatisPlus框架"></a>MybatisPlus框架</h2><p>前面我们体验了JPA带来的快速开发体验，但是我们发现，面对一些复杂查询时，JPA似乎有点力不从心，反观稍微麻烦一点的Mybatis却能够手动编写SQL，使用起来更加灵活，那么有没有一种既能灵活掌控逻辑又能快速完成开发的持久层框架呢？</p><blockquote><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>MybatisPlus的愿景是成为 MyBatis 最好的搭档，就像 <a href="https://baomidou.com/img/contra.jpg">魂斗罗</a> 中的 1P、2P，基友搭配，效率翻倍。</p></blockquote><p><img src="https://s2.loli.net/2023/07/21/dUAkeOP9FfVarRL.png" alt="img"></p><p>官方网站地址：<a href="https://baomidou.com/">https://baomidou.com</a></p><p>MybatisPlus具有以下特性：</p><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><p>框架整体结构如下：</p><p><img src="https://s2.loli.net/2023/07/21/fwAQGv43HdRnyI7.jpg" alt="framework"></p><p>不过，光说还是不能体会到它带来的便捷性，我们接着就来上手体验一下。</p><h3 id="快速上手-1"><a href="#快速上手-1" class="headerlink" title="快速上手"></a>快速上手</h3><p>跟之前一样，还是添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件依然只需要配置数据源即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>然后依然是实体类，可以直接映射到数据库中的表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;user&quot;)</span>  <span class="hljs-comment">//对应的表名</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span>   <span class="hljs-comment">//对应的主键</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-meta">@TableField(&quot;name&quot;)</span>   <span class="hljs-comment">//对应的字段</span><br>    String name;<br>    <span class="hljs-meta">@TableField(&quot;email&quot;)</span><br>    String email;<br>    <span class="hljs-meta">@TableField(&quot;password&quot;)</span><br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们就可以编写一个Mapper来操作了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br>  <span class="hljs-comment">//使用方式与JPA极其相似，同样是继承一个基础的模版Mapper</span><br>  <span class="hljs-comment">//这个模版里面提供了预设的大量方法直接使用，跟JPA如出一辙</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们就来写一个简单测试用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(mapper.selectById(<span class="hljs-number">1</span>));  <span class="hljs-comment">//同样可以直接selectById，非常快速方便</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个Mapper提供的方法还是很丰富的：</p><p><img src="https://s2.loli.net/2023/07/21/R7fhN5UtAOPFe4M.png" alt="image-20230721133315171"></p><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><p>对于一些复杂查询的情况，MybatisPlus支持我们自己构造 <code>QueryWrapper</code> 用于复杂<strong>条件查询</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();    <span class="hljs-comment">//复杂查询可以使用QueryWrapper来完成</span><br>  wrapper<br>            .select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)    <span class="hljs-comment">//可以自定义选择哪些字段</span><br>            .ge(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">2</span>)     <span class="hljs-comment">//选择判断id大于等于1的所有数据</span><br>            .orderByDesc(<span class="hljs-string">&quot;id&quot;</span>);   <span class="hljs-comment">//根据id字段进行降序排序</span><br>    System.out.println(mapper.selectList(wrapper));   <span class="hljs-comment">//Mapper同样支持使用QueryWrapper进行查询</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用上面的QueryWrapper对象进行查询，也就等价于下面的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name,email,password <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure><p>我们可以在配置中开启SQL日志打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><p>最后得到的结果如下：</p><p><img src="https://s2.loli.net/2023/07/21/FxOfrnERhVPi8tu.png" alt="image-20230721160951500"></p><p>有些时候我们遇到需要批处理的情况，也可以直接使用批处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//支持批处理操作，我们可以一次性删除多个指定ID的用户</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mapper.deleteBatchIds(List.of(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>));<br>    System.out.println(count);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/21/lwaJUF3g2opbWZG.png" alt="image-20230721190139253"></p><p>我们也可以快速进行<strong>分页查询操作</strong>，不过在执行前我们需要先配置一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">paginationInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>      <span class="hljs-comment">//添加分页拦截器到MybatisPlusInterceptor中</span><br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以愉快地使用分页功能了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//这里我们将用户表分2页，并获取第一页的数据</span><br>    Page&lt;User&gt; page = mapper.selectPage(Page.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), Wrappers.emptyWrapper());<br>    System.out.println(page.getRecords());   <span class="hljs-comment">//获取分页之后的数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/21/XMPLWB3N6VpHUkG.png" alt="image-20230721185519292"></p><p>对于数据<strong>更新操作</strong>，我们也可以使用 <code>UpdateWrapper</code> 非常方便的来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;&gt;();<br>    wrapper<br>            .set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;lbw&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1</span>);<br>    System.out.println(mapper.update(<span class="hljs-literal">null</span>, wrapper));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以快速完成更新操作了：</p><p><img src="https://s2.loli.net/2023/07/21/W1e8fFuUwSpi7Cg.png" alt="image-20230721162409308"></p><p>QueryWrapper和UpdateWrapper还有专门支持Java 8新增的Lambda表达式的特殊实现，可以直接以函数式的形式进行编写，使用方法是一样的，这里简单演示几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        LambdaQueryWrapper&lt;User&gt; wrapper = Wrappers<br>                .&lt;User&gt;lambdaQuery()<br>                .eq(User::getId, <span class="hljs-number">2</span>)   <span class="hljs-comment">//比如我们需要选择id为2的用户，前面传入方法引用，后面比的值</span><br>                .select(User::getName, User::getId);   <span class="hljs-comment">//比如我们只需要选择name和id，那就传入对应的get方法引用</span><br>        System.out.println(mapper.selectOne(wrapper));<br>&#125;<br></code></pre></td></tr></table></figure><p>不过感觉可读性似乎没有不用Lambda高啊。</p><h3 id="接口基本操作"><a href="#接口基本操作" class="headerlink" title="接口基本操作"></a>接口基本操作</h3><p>虽然使用MybatisPlus提供的BaseMapper已经很方便了，但是我们的业务中，实际上很多时候也是一样的工作，都是去简单调用底层的Mapper做一个很简单的事情，那么能不能干脆把Service也给弄个模版？MybatisPlus为我们提供了很方便的CRUD接口，直接实现了各种业务中会用到的增删改查操作。</p><p>我们只需要继承即可：</p><p><strong>xxxService继承Iservice：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt; &#123;<br>  <span class="hljs-comment">//除了继承模版，我们也可以把它当成普通Service添加自己需要的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们还需要编写一个实现类，这个实现类就是UserService的实现：<br><strong>xxxServiceImpl 继承ServiceImpl&lt;xxxMapper，xxx&gt;:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>   <span class="hljs-comment">//需要继承ServiceImpl才能实现那些默认的CRUD方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用起来也很方便，整合了超多方法：</p><p><img src="https://s2.loli.net/2023/07/21/l5Vkb9dgtJcyL4R.png" alt="image-20230721181359616"></p><p>比如我们想批量插入一组用户数据到数据库中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    List&lt;User&gt; users = List.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;xxx&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;yyy&quot;</span>));<br>  <span class="hljs-comment">//预设方法中已经支持批量保存了，这相比我们直接用for效率高不少</span><br>    service.saveBatch(users);<br>&#125;<br></code></pre></td></tr></table></figure><p>还有更加方便快捷的保存或更新操作，当数据不存在时（通过主键ID判断）则插入新数据，否则就更新数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    service.saveOrUpdate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;aaa&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以直接使用Service来进行链式查询，写法非常舒服：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> service.query().eq(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1</span>).one();<br>    System.out.println(one);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新版代码生成器"><a href="#新版代码生成器" class="headerlink" title="新版代码生成器"></a>新版代码生成器</h3><p>它能够根据数据库做到代码的一键生成</p><p><img src="https://s2.loli.net/2023/07/21/lGT4g5Y6Heqavsw.png" alt="image-20230721200757985"></p><p>你没看错，整个项目从Mapper到Controller，所有的东西全部都给你生成好了，你只管把需要补充的业务给写了就行，这是真正的把饭给喂到你嘴边的行为，是广大学子的毕设大杀器。</p><p>那么我们就来看看，这玩意怎么去用的，首先我们需要先把整个项目的数据库给创建好，创建好之后，我们继续下一步，这里我们从头开始创建一个项目，感受一下它的强大，首先创建一个普通的SpringBoot项目：</p><p><img src="https://s2.loli.net/2023/07/21/bIZ9D2cA7XsgSoU.png" alt="image-20230721202019230"></p><p>接着我们导入一会需要用到的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity-engine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后再配置一下数据源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><p>接着我们就可以开始编写自动生成脚本了，这里依然选择测试类，用到<code>FastAutoGenerator</code>作为生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>      FastAutoGenerator<br>        <span class="hljs-comment">//首先使用create来配置数据库链接信息</span><br>              .create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceConfig</span>.Builder(dataSource))<br>              .execute();<br>  &#125;<br></code></pre></td></tr></table></figure><p>接着我们配置一下全局设置，这些会影响一会生成的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    FastAutoGenerator<br>            .create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceConfig</span>.Builder(dataSource))<br>            .globalConfig(builder -&gt; &#123;<br>                builder.author(<span class="hljs-string">&quot;lbw&quot;</span>);              <span class="hljs-comment">//作者信息，一会会变成注释</span><br>                builder.commentDate(<span class="hljs-string">&quot;2024-01-01&quot;</span>);  <span class="hljs-comment">//日期信息，一会会变成注释</span><br>                builder.outputDir(<span class="hljs-string">&quot;src/main/java&quot;</span>); <span class="hljs-comment">//输出目录设置为当前项目的目录</span><br>            &#125;)<br>            .execute();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是打包设置，也就是项目的生成的包等等，这里简单配置一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    FastAutoGenerator<br>            ...<br>      <span class="hljs-comment">//打包设置，这里设置一下包名就行，注意跟我们项目包名设置为一致的</span><br>      .packageConfig(builder -&gt; builder.parent(<span class="hljs-string">&quot;com.example&quot;</span>))<br>      .strategyConfig(builder -&gt; &#123;<br>                    <span class="hljs-comment">//设置为所有Mapper添加@Mapper注解</span><br>                    builder<br>                            .mapperBuilder()<br>                            .mapperAnnotation(Mapper.class)<br>                            .build();<br>            &#125;)<br>            .execute();<br>&#125;<br></code></pre></td></tr></table></figure><p>最终完整配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;  <br>    FastAutoGenerator  <br>            .create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceConfig</span>.Builder(source))  <br>            .globalConfig(builder -&gt; &#123;  <br>                builder.author(<span class="hljs-string">&quot;alleyf&quot;</span>);              <span class="hljs-comment">//作者信息，一会会变成注释  </span><br>                builder.commentDate(<span class="hljs-string">&quot;2023-11-04&quot;</span>);  <span class="hljs-comment">//日期信息，一会会变成注释  </span><br>                builder.outputDir(<span class="hljs-string">&quot;src\\main\\java&quot;</span>); <span class="hljs-comment">//输出目录设置为当前项目的目录  </span><br>            &#125;)  <br>            <span class="hljs-comment">//打包设置，这里设置一下包名就行，注意跟我们项目包名设置为一致的  </span><br>            .packageConfig(builder -&gt; builder.parent(<span class="hljs-string">&quot;com.example&quot;</span>))  <br>            .strategyConfig(builder -&gt; &#123;  <br>                <span class="hljs-comment">//设置为所有Mapper添加@Mapper注解  </span><br>                builder  <br>                        .mapperBuilder()  <br>                        .mapperAnnotation(Mapper.class)  <br>                        .build();  <br>            &#125;)  <br>            .execute();  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们就可以直接执行了这个脚本了：</p><p><img src="https://s2.loli.net/2023/07/21/SdDRqZPnNrkeKjG.png" alt="image-20230721203819514"></p><p>现在，可以看到我们的项目中已经出现自动生成代码了：</p><p><img src="https://s2.loli.net/2023/07/21/pKMnwFZEOBmLXDy.png" alt="image-20230721204011913"></p><p>我们也可以直接运行这个项目：</p><p><img src="https://s2.loli.net/2023/07/21/CEdRz5wgaoxUjFJ.png" alt="image-20230721210417345"></p><p>速度可以说是非常之快，一个项目模版就搭建完成了，我们只需要接着写业务就可以了，当然如果需要更多定制化的话，可以在官网查看其他的配置：<a href="https://baomidou.com/pages/981406/">https://baomidou.com/pages/981406/</a></p><p>对于一些有特殊要求的用户来说，我们希望能够以自己的模版来进行生产，怎么才能修改它自动生成的代码模版呢，我们可以直接找到<code>mybatis-plus-generator</code>的源码：</p><p><img src="https://s2.loli.net/2023/07/21/lxaBgGPubOkptCT.png" alt="image-20230721204530505"></p><p>生成模版都在在这个里面有写，我们要做的就是去修改这些模版，变成我们自己希望的样子，由于默认的模版解析引擎为Velocity，我们需要复制以<code>.vm</code>结尾的文件到<code>resource</code>随便一个目录中，然后随便改：</p><p><img src="https://s2.loli.net/2023/07/21/gZlbG9JDIa3kSMO.png" alt="image-20230721210716832"></p><p>接着我们配置一下模版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>    FastAutoGenerator<br>            ...<br>      .strategyConfig(builder -&gt; &#123;<br>                builder<br>                        .mapperBuilder()<br>                        .enableFileOverride()   <span class="hljs-comment">//开启文件重写，自动覆盖新的</span><br>                        .mapperAnnotation(Mapper.class)<br>                        .build();<br>            &#125;)<br>            .templateConfig(builder -&gt; &#123;<br>                builder.mapper(<span class="hljs-string">&quot;/template/mapper.java.vm&quot;</span>);<br>            &#125;)<br>            .execute();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，新生成的代码中就是按照我们自己的模版来定义了:</p><p><img src="https://s2.loli.net/2023/07/21/K6DufSwG3hdqPsr.png" alt="image-20230721211002961"></p><blockquote><p>[!NOTE] MybatisPlus核心用法</p><ul><li><code>pom.xml</code>引入 <strong>mybatisplus 依赖</strong>，并配置<strong>数据源、日志打印</strong>等</li><li>手动编写：<ol><li>编写 <strong>Xxxmapper</strong> 接口继承<code>baseMapper&lt;entity&gt;</code></li><li>编写<strong>IXxxService</strong>接口继承<code>IService&lt;entity&gt;</code></li><li>编写<strong>XxxServiceImpl</strong>继承<code>ServiceImpl&lt;Xxxmapper,entity&gt;</code>并实现 <strong>IXxxService</strong>接口</li></ol></li><li>代码生成器：<ul><li>在测试文件中编写<strong>代码生成器配置代码</strong>，设置<strong>注释信息、生成目录、项目包名</strong>等</li><li>补充<strong>多表关联表和外键</strong>（<em>JoinTable&#x2F;JoinColumn</em>）</li></ul></li><li>根据需要补充复杂逻辑Sql功能，完成Controller逻辑功能</li></ul></blockquote><hr><p><img src="https://s2.loli.net/2023/07/22/z7sUmDCOBxvi3a5.png" alt="image-20230722114659728"></p><h1 id="走进SpringBoot前后端分离"><a href="#走进SpringBoot前后端分离" class="headerlink" title="走进SpringBoot前后端分离"></a>走进SpringBoot前后端分离</h1><p>前后端分离是一种软件架构模式，它将前端和后端的开发职责分开，使得前端和后端可以独立进行开发、测试和部署。在之前，我们都是编写Web应用程序，但是随着时代发展，各种桌面App、手机端App还有小程序层出不穷，这都完全脱离我们之前的开发模式，客户端和服务端的划分越来越明显，前后端分离开发势在必行。</p><p>在前后端分离架构中，前端主要负责展示层的开发，包括用户界面的设计、用户交互的实现等。前端使用一些技术栈，如Vue、React等技术来实现用户界面，同时通过Ajax、Axios等技术与后端进行数据的交互，这样前端无论使用什么技术进行开发，都与后端无关，受到的限制会小很多。</p><p>后端主要负责业务逻辑的处理和数据的存储，包括用户认证、数据验证、数据处理、数据库访问等实际上后端只需要返回前端需要的数据即可，一般使用JSON格式进行返回。</p><p>前后端分离架构的优势包括：</p><ul><li>前后端可以同时独立进行开发，提高开发效率。</li><li>前端可以灵活选择技术栈和框架，提供更好的用户体验。</li><li>后端可以专注于业务逻辑的实现，提高代码的可维护性。</li><li>前后端通过接口进行通信，使得前端和后端可以分别进行部署，提高系统的可扩展性和灵活性。</li></ul><p><img src="https://s2.loli.net/2023/07/22/8Zxp5PVjN7zfn6b.png" alt="image-20230722122002573"></p><p>然而，前后端分离架构也存在一些挑战，包括接口设计的复杂性、前后端协作的沟通成本等。因此，在选择前后端分离架构时，需要综合考虑项目的特点和团队成员的技能，以及开发周期等因素。</p><h2 id="基于Session的分离（有状态）"><a href="#基于Session的分离（有状态）" class="headerlink" title="基于Session的分离（有状态）"></a>基于Session的分离（有状态）</h2><p>基于Cookie的前后端分离是最简单的一种，也是更接近我们之前学习的一种。在之前，我们都是使用SpringSecurity提供的默认登录流程完成验证。</p><p>我们发现，实际上SpringSecurity在登录之后，会利用<strong>Session机制记录用户的登录状态，这就要求我们每次请求的时候都需要携带Cookie才可以，因为Cookie中存储了用于识别的JSESSIONID数据</strong>。因此，要实现前后端分离，我们只需要稍微修改一下就可以实现了，这对于小型的单端应用程序非常友好。</p><h3 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h3><p>考虑到各位小伙伴没有学习过Vue等前端框架，这里我们依然使用前端模版进行魔改。只不过现在我们的前端页面需要单独进行部署，而不是和后端揉在一起，这里我们需要先创建一个前端项目，依赖只需勾选SpringWeb即可，主要用作反向代理前端页面：</p><p><img src="https://s2.loli.net/2023/07/22/A7gTxwv6r89tKh3.png" alt="image-20230722151228110"></p><p>如果各位小伙伴学习了Nginx代理，使用Nginx代理前端项目会更好一些。</p><p>接着我们将所有的前端模版文件全部丢进对应的目录中，创建一个<code>web</code>目录到resource目录下，然后放入我们前端模版的全部文件：</p><p><img src="https://s2.loli.net/2023/07/22/DtLF21ue7RVMQPY.png" alt="image-20230722154349756"></p><p>然后配置一下静态资源代理，现在我们希望的是页面直接被代理，不用我们手动去写Controller来解析视图：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">static-locations:</span> <span class="hljs-string">classpath:/web</span><br></code></pre></td></tr></table></figure><p>然后启动服务器就行了：</p><p><img src="https://s2.loli.net/2023/07/22/65snkmhyjFENTxt.png" alt="image-20230722154452928"></p><p>接着我们就可以随便访问我们的网站了：</p><p><img src="https://s2.loli.net/2023/07/22/GEWekp2IwMZhx5c.png" alt="image-20230722154659328"></p><p>这样前端页面就部署完成了，接着我们还需要创建一个后端项目，用于去编写我们的后端，选上我们需要的一些依赖：</p><p><img src="https://s2.loli.net/2023/07/22/vt52ogbLp8YN1Im.png" alt="image-20230722155049948"></p><p>接着我们需要修改一下后端服务器的端口，因为现在我们要同时开两个服务器，一个是负责部署前端的，一个是负责部署后端的，这样就是标准的前后端分离了，所以说为了防止端口打架，我们就把端口开放在8081上：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br></code></pre></td></tr></table></figure><p>现在启动这两个服务器，我们的学习环境就搭建好了。</p><h3 id="实现登录授权和跨域处理"><a href="#实现登录授权和跨域处理" class="headerlink" title="实现登录授权和跨域处理"></a>实现登录授权和跨域处理</h3><p>在之前，我们的登录操作以及登录之后的页面跳转都是由SpringSecurity来完成，但是现在前后端分离之后，整个流程发生了变化，现在前端仅仅是调用登录接口进行一次校验即可，而后端只需要返回本次校验的结果，由前端来判断是否校验成功并跳转页面：</p><p><img src="https://s2.loli.net/2023/07/22/yZpHd4wcikVxhta.png" alt="image-20230722164431249"></p><p>因此，现在我们只需要让登录模块响应一个JSON数据告诉前端登录成功与否即可，当然，前端在发起请求的时候依然需要携带Cookie信息，否则后端不认识是谁。</p><p>现在我们就来尝试实现一下这种模式，首先我们配置一下SpringSecurity的相关接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> http<br>                .authorizeHttpRequests(conf -&gt; &#123;<br>                    conf.anyRequest().authenticated();<br>                &#125;)<br>                .formLogin(conf -&gt; &#123;<br>                  <span class="hljs-comment">//一般分离之后，为了统一规范接口，使用 /api/模块/功能 的形式命名接口</span><br>                    conf.loginProcessingUrl(<span class="hljs-string">&quot;/api/auth/login&quot;</span>);<br>                    conf.permitAll();<br>                &#125;)<br>                .csrf(AbstractHttpConfigurer::disable)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样成功定义了登录接口相关内容，但是怎么才能让SpringSecurity在登录成功之后返回一个JSON数据给前端而不是默认的重定向呢？这时我们可以手动设置<code>SuccessHandler</code>和 <code>FailureHandler</code> 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>  <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-keyword">return</span> http<br>              ...<br>              .formLogin(conf -&gt; &#123;<br>                  conf.loginProcessingUrl(<span class="hljs-string">&quot;/api/auth/login&quot;</span>);<br>                <span class="hljs-comment">//使用自定义的成功失败处理器</span><br>                  conf.failureHandler(<span class="hljs-built_in">this</span>::onAuthenticationFailure);<br>                  conf.successHandler(<span class="hljs-built_in">this</span>::onAuthenticationSuccess);<br>                  conf.permitAll();<br>              &#125;)<br>              ...<br>  &#125;<br><br><span class="hljs-comment">//自定义成功失败处理器</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                               HttpServletResponse response,</span><br><span class="hljs-params">                               AuthenticationException exception)</span> &#123;<br><br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, </span><br><span class="hljs-params">                               HttpServletResponse response, </span><br><span class="hljs-params">                               Authentication authentication)</span> &#123;<br>      <br>  &#125;<br></code></pre></td></tr></table></figure><p>现在我们需要返回一个标准的JSON格式数据作为响应，这里我们根据Rest API标准来进行编写：</p><blockquote><p>REST API是遵循REST（Representational State Transfer, 表述性状态转移）原则的Web服务接口，下面简单介绍一下REST接口规范以及对应的响应数据该如何编写:</p></blockquote><h3 id="1-REST接口规范"><a href="#1-REST接口规范" class="headerlink" title="1. REST接口规范"></a>1. REST接口规范</h3><blockquote><ul><li><strong>使用HTTP方法</strong>：GET（检索资源）、POST（创建资源）、PUT（更新资源）、DELETE（删除资源）。</li><li><strong>无状态</strong>: REST接口要求实现无状态从而使其独立于之前的请求。</li><li><strong>使用正确的HTTP状态码</strong>：在HTTP响应中反馈操作的结果（例如，200表示成功，404表示资源不存在等）。</li><li><strong>URI 应该清晰易懂</strong>：URI应能清晰地指示出所引用资源的类型和编号，并能易于理解和使用。</li></ul></blockquote><h3 id="2-响应数据格式"><a href="#2-响应数据格式" class="headerlink" title="2. 响应数据格式"></a>2. 响应数据格式</h3><p>REST应答一般使用的格式为JSON，以下是一个标准的JSON响应数据样例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&gt; <span class="hljs-punctuation">&#123;</span><br>&gt;   <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">200</span><span class="hljs-punctuation">,</span><br>&gt;   <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>&gt;     <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>&gt;     <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Tom&quot;</span><span class="hljs-punctuation">,</span><br>&gt;     <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><br>&gt;   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>&gt;   <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;查询成功&quot;</span><br>&gt; <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>字段的含义分别为：</p><ul><li><strong>code</strong>：HTTP状态码，表示请求的结果。常见的有200（成功）、400（客户端错误）、500（服务器错误）等。</li><li><strong>data</strong>：响应的真实数据。在上例中，是一个包含用户信息的对象。</li><li><strong>message</strong>：请求响应信息，常用于描述请求处理结果。</li></ul><p>上述都是建议的最佳实践，实际应用中可以根据具体的业务需求进行适当的调整。</p></blockquote><p>这里我们创建一个实体类来装载响应数据，可以使用记录类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">RestBean</span>&lt;T&gt; (<span class="hljs-type">int</span> code, T data, String message) &#123;<br><span class="hljs-comment">//写几个工具方法，用于快速创建RestBean对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="hljs-title function_">success</span><span class="hljs-params">(T data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestBean</span>&lt;&gt;(<span class="hljs-number">200</span>, data, <span class="hljs-string">&quot;请求成功&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="hljs-title function_">failure</span><span class="hljs-params">(<span class="hljs-type">int</span> code, String message)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestBean</span>&lt;&gt;(code, <span class="hljs-literal">null</span>, message);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; RestBean&lt;T&gt; <span class="hljs-title function_">failure</span><span class="hljs-params">(<span class="hljs-type">int</span> code)</span>&#123;<br>        <span class="hljs-keyword">return</span> failure(code, <span class="hljs-string">&quot;请求失败&quot;</span>);<br>    &#125;<br><span class="hljs-comment">//将当前对象转换为JSON格式的字符串用于返回</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">asJsonString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> JSONObject.toJSONString(<span class="hljs-built_in">this</span>, JSONWriter.Feature.WriteNulls);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们稍微设置一下对应的Handler即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                               HttpServletResponse response,</span><br><span class="hljs-params">                               AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>      <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>      writer.write(RestBean.failure(<span class="hljs-number">401</span>, exception.getMessage()).asJsonString());<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                               HttpServletResponse response,</span><br><span class="hljs-params">                               Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>      <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>      writer.write(RestBean.success(authentication.getName()).asJsonString());<br>  &#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以使用API测试工具来调试一下了：</p><p><img src="https://s2.loli.net/2023/07/23/EiMUuCjcKpnOmRb.png" alt="image-20230723193442527"></p><p>可以看到响应的结果是标准的JSON格式数据，而不是像之前那样重定向到一个页面，这样前端发起的异步请求就可以进行快速判断了。</p><p>我们来尝试写一个简单的前端逻辑试试看，这里依然引入Axios框架来发起异步请求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInfo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;http://localhost:8081/api/auth/login&#x27;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">username</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>).<span class="hljs-property">value</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">password</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;password&#x27;</span>).<span class="hljs-property">value</span></span><br><span class="language-javascript">        &#125;, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">headers</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">          <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span></span><br><span class="language-javascript">        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span>(data.<span class="hljs-property">code</span> === <span class="hljs-number">200</span>) &#123;  <span class="hljs-comment">//通过状态码进行判断</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/index.html&#x27;</span>  <span class="hljs-comment">//登录成功进入主页</span></span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;登录失败：&#x27;</span>+data.<span class="hljs-property">message</span>)   <span class="hljs-comment">//登录失败返回弹窗</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可能会有小伙伴好奇，这个前端不是每个页面都能随便访问吗，这登录跟不登录有啥区别？实际上我们的前端开发者会在前端做相应的路由以及拦截来控制页面的跳转，我们后端开发者无需担心，我们只需要保证自己返回的数据是准确无误的即可，其他的交给前端小姐姐就好，这里我们只是做个样子。</p><p>当点击按钮时就能发起请求了，但是我们现在遇到了一个新的问题：</p><p><img src="https://s2.loli.net/2023/07/23/KYULQNoFsHbm3zg.png" alt="image-20230723190406008"></p><p>我们在发起登录请求时，前端得到了一个跨域请求错误，这是因为我们前端的站点和后端站点不一致导致的，浏览器为了用户的安全，防止网页中一些恶意脚本跨站请求数据，会对未经许可的跨域请求发起拦截。那么，我们怎么才能让这个请求变成我们许可的呢？对于跨域问题，是属于我们后端需要处理的问题，跟前端无关，我们需要在响应的时候，在响应头中添加一些跨域属性，来告诉浏览器从哪个站点发来的跨域请求是安全的，这样浏览器就不会拦截了。</p><p>那么如何进行配置呢，我们现在使用了SpringSecurity框架，可以直接进行<strong>跨域配置</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> http<br>            ...<br>            .cors(conf -&gt; &#123;<br>                <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">cors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>              <span class="hljs-comment">//添加前端站点地址，这样就可以告诉浏览器信任了</span><br>              cors.addAllowedOrigin(<span class="hljs-string">&quot;http://localhost:8080&quot;</span>);<br>                <span class="hljs-comment">//虽然也可以像这样允许所有 cors.addAllowedOriginPattern(&quot;*&quot;);</span><br>              <span class="hljs-comment">//但是这样并不安全，我们应该只许可给我们信任的站点</span><br>                cors.setAllowCredentials(<span class="hljs-literal">true</span>);  <span class="hljs-comment">//允许跨域请求中携带Cookie</span><br>                cors.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);   <span class="hljs-comment">//其他的也可以配置，为了方便这里就 * 了</span><br>                cors.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>                cors.addExposedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>                <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>();<br>                source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, cors);  <span class="hljs-comment">//直接针对于所有地址生效</span><br>                conf.configurationSource(source);<br>            &#125;)<br>            ...<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当我们再次重启服务器，返回的响应头中都会携带跨域相关的信息，这样浏览器就不会进行拦截了：</p><p><img src="https://s2.loli.net/2023/07/23/QVFEWknMdujomqi.png" alt="image-20230723192217101"></p><p>这样就可以实现前后端分离的登录模式了：</p><p><img src="https://s2.loli.net/2023/07/23/1GpZuQUawM48eVq.png" alt="image-20230723194030641"></p><p>由于记住我功能和退出登录操作跟之前是一样的配置，这里我们就不进行演示了。</p><h3 id="响应JSON化"><a href="#响应JSON化" class="headerlink" title="响应JSON化"></a>响应JSON化</h3><p>前面我们完成了前后端分离的登录模式，我们来看看一般的业务接口该如何去实现，比如这里我们写一个非常简单的的用户名称获取接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>   <span class="hljs-comment">//为了方便，我们一律使用RestController，这样每个请求默认都返回JSON对象</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/user&quot;)</span>   <span class="hljs-comment">//用户相关的接口，路径可以设置为/api/user/xxxx</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/name&quot;)</span><br>    <span class="hljs-keyword">public</span> RestBean&lt;String&gt; <span class="hljs-title function_">username</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>        <span class="hljs-keyword">return</span> RestBean.success(user.getUsername());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样前端就可以在登录之后获取到这个接口的结果了，注意一定要在请求时携带Cookie，否则服务端无法识别身份，会直接被拦截并重定向：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:8081/api/user/name&#x27;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">//携带Cookie访问，不然服务器不认识我们</span></span><br><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>).<span class="hljs-property">innerText</span> = data.<span class="hljs-property">data</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意一定要登录之后再请求，成功的请求结果如下：</p><p><img src="https://s2.loli.net/2023/07/24/L4PcVKpO2nmHG7e.png" alt="image-20230724000237828"></p><p>不过我们发现，我们的一些响应还是不完善，比如用户没有登录，默认还是会302重定向，但是实际上我们只需要告诉前端没有登录就行了，所以说我们修改一下未登录状态下返回的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> http<br>            ...<br>            .exceptionHandling(conf -&gt; &#123;<br>              <span class="hljs-comment">//配置授权相关异常处理器</span><br>                conf.accessDeniedHandler(<span class="hljs-built_in">this</span>::onAccessDeny);<br>              <span class="hljs-comment">//配置验证相关异常的处理器</span><br>                conf.authenticationEntryPoint(<span class="hljs-built_in">this</span>::onAuthenticationFailure);<br>            &#125;)<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>现在有三个方法，但是实际上功能都是一样的，我们可以把它们整合为同一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleProcess</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                     HttpServletResponse response,</span><br><span class="hljs-params">                     Object exceptionOrAuthentication)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>      <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>      <span class="hljs-keyword">if</span>(exceptionOrAuthentication <span class="hljs-keyword">instanceof</span> AccessDeniedException exception) &#123;<br>          writer.write(RestBean.failure(<span class="hljs-number">403</span>, exception.getMessage()).asJsonString());<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exceptionOrAuthentication <span class="hljs-keyword">instanceof</span> Exception exception) &#123;<br>          writer.write(RestBean.failure(<span class="hljs-number">401</span>, exception.getMessage()).asJsonString());<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exceptionOrAuthentication <span class="hljs-keyword">instanceof</span> Authentication authentication)&#123;<br>          writer.write(RestBean.success(authentication.getName()).asJsonString());<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样，用户在没有登录的情况下，请求接口就会返回我们的自定义JSON信息了：</p><p><img src="https://s2.loli.net/2023/07/24/Rf9BSVLvih1lOE2.png" alt="image-20230724002459523"></p><p>对于我们页面中的一些常见的异常，我们也可以<strong>编写异常处理器来将其规范化返回</strong>，比如404页面，我们可以直接配置让其抛出异常：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">throw-exception-if-no-handler-found:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">add-mappings:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>然后编写异常处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionController</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> RestBean&lt;String&gt; <span class="hljs-title function_">error</span><span class="hljs-params">(Exception e)</span>&#123;<br>        <span class="hljs-keyword">if</span>(e <span class="hljs-keyword">instanceof</span> NoHandlerFoundException exception)  <span class="hljs-comment">//这里就大概处理一下404就行</span><br>            <span class="hljs-keyword">return</span> RestBean.failure(<span class="hljs-number">404</span>, e.getMessage());  <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ServletException exception)  <span class="hljs-comment">//其他的Servlet异常就返回400状态码</span><br>            <span class="hljs-keyword">return</span> RestBean.failure(<span class="hljs-number">400</span>, e.getMessage());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> RestBean.failure(<span class="hljs-number">500</span>, e.getMessage());  <span class="hljs-comment">//其他异常直接返回500</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的后端就返回的是非常统一的JSON格式数据了，前端开发人员只需要根据我们返回的数据编写统一的处理即可，基于Session的前后端分离实现起来也是最简单的。</p><hr><h2 id="基于Token的分离（无状态）"><a href="#基于Token的分离（无状态）" class="headerlink" title="基于Token的分离（无状态）"></a>基于Token的分离（无状态）</h2><p>基于Token的前后端分离主打无状态，无状态服务是指在处理每个请求时，服务本身不会维持任何与请求相关的状态信息。每个请求被视为独立的、自包含的操作，服务只关注处理请求本身，而不关心前后请求之间的状态变化。也就是说，用户在发起请求时，服务器不会记录其信息，而是通过用户携带的Token信息来判断是哪一个用户：</p><blockquote><ul><li>有状态：用户请求接口 -&gt;  从Session中读取用户信息  -&gt;   根据当前的用户来处理业务   -&gt;  返回</li><li>无状态：用户携带Token请求接口    -&gt;   从请求中获取用户信息   -&gt;   根据当前的用户来处理业务   -&gt;  返回</li></ul></blockquote><p>无状态服务的优点包括：</p><ol><li><strong>服务端无需存储会话信息</strong>：传统的会话管理方式需要服务端存储用户的会话信息，包括用户的身份认证信息和会话状态。而使用Token，服务端无需存储任何会话信息，所有的认证信息都包含在Token中，使得服务端变得无状态，减轻了服务器的负担，同时也方便了服务的水平扩展。</li><li>减少网络延迟：传统的会话管理方式需要在每次请求中都携带会话标识，即使是无状态的RESTful API也需要携带身份认证信息。而使用Token，身份认证信息已经包含在Token中，只需要在请求的Authorization头部携带Token即可，减少了每次请求的数据量，减少了网络延迟。</li><li>客户端无需存储会话信息：传统的会话管理方式中，客户端需要存储会话标识，以便在每次请求中携带。而使用Token，客户端只需要保存Token即可，方便了客户端的存储和管理。</li><li>跨域支持：Token可以在各个不同的域名之间进行传递和使用，因为Token是通过签名来验证和保护数据完整性的，可以防止未经授权的修改。</li></ol><p>这一部分，我们将深入学习目前比较主流的基于Token的前后端分离方案。</p><h3 id="认识JWT令牌"><a href="#认识JWT令牌" class="headerlink" title="认识JWT令牌"></a>认识JWT令牌</h3><p>在认识Token前后端分离之前，我们需要先学习最常见的JWT令牌，官网：<a href="https://jwt.io/">https://jwt.io</a></p><p>JSON Web Token令牌（JWT）是一个开放标准（<a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a>），它定义了一种紧凑和自成一体的方式，用于在各方之间作为JSON对象安全地传输信息。这些信息可以被验证和信任，因为它是数字签名的。JWT可以使用密钥（使用<strong>HMAC</strong>算法）或使用<strong>RSA</strong>或<strong>ECDSA</strong>进行公钥&#x2F;私钥对进行签名。</p><p>JWT令牌的格式如下：</p><p><img src="https://s2.loli.net/2023/03/07/Xu8lxYhKoJNr6it.png" alt="image-20230307000004710"></p><p>一个JWT令牌由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的钱2部分分别进行Base64编码后用<code>.</code>进行连接形成最终需要传输的字符串。</p><ul><li>标头：包含一些元数据信息，比如JWT签名所使用的加密算法，还有类型，这里统一都是JWT。</li><li>有效载荷：包括用户名称、令牌发布时间、过期时间、JWT ID等，当然我们也可以自定义添加字段，我们的用户信息一般都在这里存放。</li><li>签名：首先需要指定一个密钥，该密钥仅仅保存在服务器中，保证不能让其他用户知道。然后使用Header中指定的算法对Header和Payload进行base64加密之后的结果通过密钥计算哈希值，然后就得出一个签名哈希。这个会用于之后验证内容是否被篡改。</li></ul><p>这里还是补充一下一些概念，因为很多东西都是我们之前没有接触过的：</p><ul><li><p><strong>Base64</strong>：就是包括<strong>小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”&#x2F;“一共64个字符</strong>的字符集（末尾还有1个或多个<code>=</code>用来凑够字节数），任何的符号都可以转换成这个字符集中的字符，这个转换过程就叫做Base64编码，编码之后会生成只包含上述64个字符的字符串。相反，如果需要原本的内容，我们也可以进行Base64解码，回到原有的样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你们可能不知道只用20万赢到578万是什么概念&quot;</span>;<br>  <span class="hljs-comment">//Base64不只是可以对字符串进行编码，任何byte[]数据都可以，编码结果可以是byte[]，也可以是字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">encodeStr</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(str.getBytes());<br>    System.out.println(<span class="hljs-string">&quot;Base64编码后的字符串：&quot;</span>+encodeStr);<br><br>    System.out.println(<span class="hljs-string">&quot;解码后的字符串：&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Base64.getDecoder().decode(encodeStr)));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意Base64不是加密算法，只是一种信息的编码方式而已。</p></li></ul><ul><li><p>加密算法：加密算法分为<strong>对称加密和非对称加密</strong>，其中对称加密（Symmetric Cryptography）比较好理解，就像一把锁配了两把钥匙一样，这两把钥匙你和别人都有一把，然后你们直接传递数据，都会把数据用锁给锁上，就算传递的途中有人把数据窃取了，也没办法解密，因为钥匙只有你和对方有，没有钥匙无法进行解密，但是这样有个问题，既然解密的关键在于钥匙本身，那么如果有人不仅窃取了数据，而且对方那边的治安也不好，于是顺手就偷走了钥匙，那你们之间发的数据不就凉凉了吗。</p><p>因此，<strong>非对称加密</strong>（Asymmetric Cryptography）算法出现了，它并不是直接生成一把钥匙，而是<strong>生成一个公钥和一个私钥</strong>，私钥只能由你保管，而公钥交给对方或是你要发送的任何人都行，现在你需要把数据传给对方，那么就需要使用私钥进行加密，但是，这个数据只能使用对应的公钥进行解密，相反，如果对方需要给你发送数据，那么就需要用<strong>公钥进行加密，而数据只能使用私钥进行解密</strong>，这样的话就算对方的公钥被窃取，那么别人发给你的数据也没办法解密出来，因为需要私钥才能解密，而只有你才有私钥。</p><p>因此，非对称加密的安全性会更高一些，包括HTTPS的隐私信息正是使用非对称加密来保障传输数据的安全（当然HTTPS并不是单纯地使用非对称加密完成的）</p><p>对称加密和非对称加密都有很多的算法，比如<strong>对称加密，就有：DES、IDEA、RC2</strong>，<em>非对称加密有：RSA、DAS、ECC</em></p></li><li><p><strong>不可逆加密算法：</strong> 常见的不可逆加密算法有<code>MD5, HMAC, SHA-1, SHA-224, SHA-256, SHA-384, 和SHA-512, 其中SHA-224、SHA-256、SHA-384</code>，和SHA-512我们可以统称为SHA2加密算法，SHA加密算法的安全性要比MD5更高，而SHA2加密算法比SHA1的要高，其中SHA后面的数字表示的是加密后的字符串长度，SHA1默认会产生一个160位的信息摘要。经过不可逆加密算法得到的加密结果，是无法解密回去的，也就是说加密出来是什么就是什么了。本质上，其就是一种哈希函数，用于对一段信息产生摘要，以<strong>防止被篡改</strong>。</p><p>实际上这种算法就常常被用作信息摘要计算，同样的数据通过同样的算法计算得到的结果肯定也一样，而如果数据被修改，那么计算的结果肯定就不一样了。</p></li></ul><p>因此，JWT令牌实际上是一种<strong>经过加密的JSON数据</strong>，其中包含了<strong>用户名字、用户ID等信息</strong>，我们可以直接解密JWT令牌得到用户的信息，我们可以写一个小测试来看看，导入JWT支持库依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.auth0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>java-jwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要生成一个JWT令牌非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">jwtKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;                 <span class="hljs-comment">//使用一个JWT秘钥进行加密</span><br>        <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(jwtKey);  <span class="hljs-comment">//创建HMAC256加密算法对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jwtToken</span> <span class="hljs-operator">=</span> JWT.create()<br>                .withClaim(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1</span>)   <span class="hljs-comment">//向令牌中塞入自定义的数据</span><br>                .withClaim(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;lbw&quot;</span>)<br>                .withClaim(<span class="hljs-string">&quot;role&quot;</span>, <span class="hljs-string">&quot;nb&quot;</span>)<br>                .withExpiresAt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2024</span>, Calendar.FEBRUARY, <span class="hljs-number">1</span>))  <span class="hljs-comment">//JWT令牌的失效时间</span><br>                .withIssuedAt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())   <span class="hljs-comment">//JWT令牌的签发时间</span><br>                .sign(algorithm);    <span class="hljs-comment">//使用上面的加密算法进行加密，完成签名</span><br>        System.out.println(jwtToken);   <span class="hljs-comment">//得到最终的JWT令牌</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到最后得到的JWT令牌就长这样：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJ<span class="hljs-number">0</span>eXAiOiJKV<span class="hljs-number">1</span>QiLCJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiJ9</span>.eyJyb<span class="hljs-number">2</span>xlIjoibmIiLCJuYW<span class="hljs-number">1</span>lIjoibGJ<span class="hljs-number">3</span>IiwiaWQiOjEsImV<span class="hljs-number">4</span>cCI<span class="hljs-number">6</span><span class="hljs-symbol">NjE2</span><span class="hljs-symbol">NjQ4</span><span class="hljs-symbol">NjA4</span>MDAsImlhdCI<span class="hljs-number">6</span>MTY<span class="hljs-number">5</span>MDEzMTQ<span class="hljs-number">3</span>OH<span class="hljs-number">0.</span>KUuGK<span class="hljs-name">M0</span>Oy<span class="hljs-symbol">nL_DEUnRIETDBlmGjoqbt_5</span>dP<span class="hljs-number">2</span>r<span class="hljs-number">21</span>ZDE<span class="hljs-number">1</span>s<br></code></pre></td></tr></table></figure><p>我们可以使用Base64将其还原为原本的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">jwtToken</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlIjoibmIiLCJuYW1lIjoibGJ3IiwiaWQiOjEsImV4cCI6NjE2NjQ4NjA4MDAsImlhdCI6MTY5MDEzMTQ3OH0.KUuGKM0OynL_DEUnRIETDBlmGjoqbt_5dP2r21ZDE1s&quot;</span>;<br>        String[] split = jwtToken.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; split.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> split[i];<br>            <span class="hljs-type">byte</span>[] decode = Base64.getDecoder().decode(s);<br>            System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(decode));<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析前面两个部分得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;JWT&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;role&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;nb&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;lbw&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">61664860800</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;iat&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1690131478</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到确实是经过Base64加密的JSON格式数据，包括我们的自定义数据也在其中，而我们可以直接使用JWT令牌来作为我们权限校验的核心，我们可以像这样设计我们的系统：</p><p><img src="https://s2.loli.net/2023/07/24/4bThtMwA9XsP5uc.png" alt="image-20230724010807761"></p><p>首先用户还是按照正常流程进行登录，只不过用户在登录成功之后，服务端会返回一个JWT令牌用于后续请求使用，由于JWT令牌具有时效性，所以说当过期之后又需要重新登录。就像我们进入游乐园需要一张门票一样，只有持有游乐园门票才能进入游乐园游玩，如果没有门票就会被拒之门外，而游乐园门票也有时间限制，如果已经过期，我们也是没有办法进入游乐园的。</p><p>所以，我们只需要在后续请求中携带这个Token即可（可以放在Cookie中，也可以放在请求头中）这样服务器就可以直接从Token中解密读取到我们用户的相关信息以及判断用户是否登录过期了。</p><p>既然现在用户信息都在JWT中，那要是用户随便修改里面的内容，岂不是可以以任意身份访问服务器了？这会不会存在安全隐患？对于这个问题，前面我们已经说的很清楚了，JWT实际上最后会有一个加密的签名，这个是根据秘钥+JWT本体内容计算得到的，用户在没有持有秘钥的情况下，是不可能计算得到正确的签名的，所以说服务器会在收到JWT时对签名进行重新计算，比较是否一致，来验证JWT是否被用户恶意修改，如果被修改肯定也是不能通过的。</p><p><img src="https://s2.loli.net/2023/07/24/17dmiHXEG4rLO6W.png" alt="image-20230724011814993"></p><h3 id="SpringSecurity实现JWT校验"><a href="#SpringSecurity实现JWT校验" class="headerlink" title="SpringSecurity实现JWT校验"></a>SpringSecurity实现JWT校验</h3><p>前面我们介绍了JWT的基本原理以及后端的基本校验流程，那么我们现在就来看看如何实现这样的流程。</p><p>SpringSecurity中并没有为我们提供预设的JWT校验模块（只有OAuth2模块才有，但是知识太超前了，我们暂时不讲解）这里我们只能手动进行整合，JWT可以存放在Cookie或是请求头中，不过不管哪种方式，我们都可以通过Request获取到对应的JWT令牌，这里我们使用比较常见的请求头携带JWT的方案，客户端发起的请求中会携带这样的的特殊请求头：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Authorization</span>: Bearer eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJzZWxmIiwic3ViIjoidXNlciIsImV4cCI6MTY5MDIxODE2NCwiaWF0IjoxNjkwMTgyMTY0LCJzY29wZSI6ImFwcCJ9.Z5-WMeulZyx60WeNxrQg2z2GiVquEHrsBl9V4dixbRkAD6rFp-<span class="hljs-number">6</span>gCrcAXWkebs0i-we4xTQ7TZW0ltuhGYZ1GmEaj4F6BP9VN8fLq2aT7GhCJDgjikaTs-w5BbbOD2PN_vTAK_KeVGvYhWU4_l81cvilJWVXAhzMtwgPsz1Dkd04cWTCpI7ZZi-RQaBGYlullXtUrehYcjprla8N-bSpmeb3CBVM3kpAdehzfRpAGWXotN27PIKyAbtiJ0rqdvRmvlSztNY0_1IoO4TprMTUr-wjilGbJ5QTQaYUKRHcK3OJrProz9m8ztClSq0GRvFIB7HuMlYWNYwf7lkKpGvKDg<br></code></pre></td></tr></table></figure><p>这里的Authorization请求头就是携带JWT的专用属性，值的格式为”Bearer Token”，前面的Bearer代表身份验证方式，默认情况下有两种：</p><blockquote><p>Basic 和 Bearer 是两种不同的身份验证方式。</p><p><strong>Basic</strong> 是一种基本的身份验证方式，它将用户名和密码进行base64编码后，放在 Authorization 请求头中，用于向服务器验证用户身份。这种方式不够安全，因为它将密码以明文的形式传输，容易受到中间人攻击。</p><p><strong>Bearer</strong> 是一种更安全的身份验证方式，它基于令牌（Token）来验证用户身份。Bearer 令牌是由身份验证服务器颁发给客户端的，客户端在每个请求中将令牌放在 Authorization 请求头的 Bearer 字段中。服务器会验证令牌的有效性和权限，以确定用户的身份。Bearer 令牌通常使用 JSON Web Token (JWT) 的形式进行传递和验证。</p></blockquote><p>一会我们会自行编写JWT校验拦截器来处理这些信息。</p><p>首先我们先把用于处理JWT令牌的工具类完成一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtils</span> &#123;<br>  <span class="hljs-comment">//Jwt秘钥</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br><br>  <span class="hljs-comment">//根据用户信息创建Jwt令牌</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createJwt</span><span class="hljs-params">(UserDetails user)</span>&#123;<br>        <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(key);<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> calendar.getTime();<br>        calendar.add(Calendar.SECOND, <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">return</span> JWT.create()<br>                .withClaim(<span class="hljs-string">&quot;name&quot;</span>, user.getUsername())  <span class="hljs-comment">//配置JWT自定义信息</span><br>                .withClaim(<span class="hljs-string">&quot;authorities&quot;</span>, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())<br>                .withExpiresAt(calendar.getTime())  <span class="hljs-comment">//设置过期时间</span><br>                .withIssuedAt(now)    <span class="hljs-comment">//设置创建创建时间</span><br>                .sign(algorithm);   <span class="hljs-comment">//最终签名</span><br>    &#125;<br><br>  <span class="hljs-comment">//根据Jwt验证并解析用户信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDetails <span class="hljs-title function_">resolveJwt</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(key);<br>        <span class="hljs-type">JWTVerifier</span> <span class="hljs-variable">jwtVerifier</span> <span class="hljs-operator">=</span> JWT.require(algorithm).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DecodedJWT</span> <span class="hljs-variable">verify</span> <span class="hljs-operator">=</span> jwtVerifier.verify(token);  <span class="hljs-comment">//对JWT令牌进行验证，看看是否被修改</span><br>            Map&lt;String, Claim&gt; claims = verify.getClaims();  <span class="hljs-comment">//获取令牌中内容</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().after(claims.get(<span class="hljs-string">&quot;exp&quot;</span>).asDate())) <span class="hljs-comment">//如果是过期令牌则返回null</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">else</span><br>              <span class="hljs-comment">//重新组装为UserDetails对象，包括用户名、授权信息等</span><br>                <span class="hljs-keyword">return</span> User<br>                        .withUsername(claims.get(<span class="hljs-string">&quot;name&quot;</span>).asString())<br>                        .password(<span class="hljs-string">&quot;&quot;</span>)<br>                        .authorities(claims.get(<span class="hljs-string">&quot;authorities&quot;</span>).asArray(String.class))<br>                        .build();<br>        &#125; <span class="hljs-keyword">catch</span> (JWTVerificationException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要自行实现一个 <code>JwtAuthenticationFilter</code> 加入到 SpringSecurity 默认提供的过滤器链中，用于处理请求头中携带的JWT令牌，并配置登录状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OncePerRequestFilter</span> &#123;  <br><span class="hljs-comment">//继承OncePerRequestFilter表示每次请求过滤一次，用于快速编写JWT校验规则</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>      <span class="hljs-comment">//首先从Header中取出JWT</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">authorization</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>      <span class="hljs-comment">//判断是否包含JWT且格式正确</span><br>        <span class="hljs-keyword">if</span> (authorization != <span class="hljs-literal">null</span> &amp;&amp; authorization.startsWith(<span class="hljs-string">&quot;Bearer &quot;</span>)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> authorization.substring(<span class="hljs-number">7</span>);<br>          <span class="hljs-comment">//开始解析成UserDetails对象，如果得到的是null说明解析失败，JWT有问题</span><br>            <span class="hljs-type">UserDetails</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> JwtUtils.resolveJwt(token);<br>            <span class="hljs-keyword">if</span>(user != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-comment">//验证没有问题，那么就可以开始创建Authentication了，这里我们跟默认情况保持一致</span><br>              <span class="hljs-comment">//使用UsernamePasswordAuthenticationToken作为实体，填写相关用户信息进去</span><br>                <span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">authentication</span> <span class="hljs-operator">=</span><br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="hljs-literal">null</span>, user.getAuthorities());<br>                authentication.setDetails(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));<br>              <span class="hljs-comment">//然后直接把配置好的Authentication塞给SecurityContext表示已经完成验证</span><br>                SecurityContextHolder.getContext().setAuthentication(authentication);<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//最后放行，继续下一个过滤器</span><br>      <span class="hljs-comment">//可能各位小伙伴会好奇，要是没验证成功不是应该拦截吗？这个其实没有关系的</span><br>      <span class="hljs-comment">//因为如果没有验证失败上面是不会给SecurityContext设置Authentication的，后面直接就被拦截掉了</span><br>      <span class="hljs-comment">//而且有可能用户发起的是用户名密码登录请求，这种情况也要放行的，不然怎么登录，所以说直接放行就好</span><br>        filterChain.doFilter(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们来配置一下SecurityConfiguration配置类，其实配置方法跟之前还是差不多，用户依然可以使用表单进行登录，并且登录方式也是一样的，就是有两个新增的部分需要我们注意一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SecurityFilterChain <span class="hljs-title function_">filterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> http<br>          <span class="hljs-comment">//其他跟之前一样，就省略掉了</span><br>                ...  <br>                <span class="hljs-comment">//将Session管理创建策略改成无状态，这样SpringSecurity就不会创建会话了，也不会采用之前那套机制记录用户，因为现在我们可以直接从JWT中获取信息</span><br>                .sessionManagement(conf -&gt; &#123;<br>                    conf.sessionCreationPolicy(SessionCreationPolicy.STATELESS);<br>                &#125;)<br>          <span class="hljs-comment">//添加我们用于处理JWT的过滤器到Security过滤器链中，注意要放在UsernamePasswordAuthenticationFilter之前</span><br>                .addFilterBefore(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class)<br>                .build();<br>    &#125;<br><br>  <span class="hljs-comment">//这个跟之前一样的写法，整合到一起处理，统一返回JSON格式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleProcess</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                               HttpServletResponse response,</span><br><span class="hljs-params">                               Object exceptionOrAuthentication)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>        <span class="hljs-keyword">if</span>(exceptionOrAuthentication <span class="hljs-keyword">instanceof</span> AccessDeniedException exception) &#123;<br>            writer.write(RestBean.failure(<span class="hljs-number">403</span>, exception.getMessage()).asJsonString());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exceptionOrAuthentication <span class="hljs-keyword">instanceof</span> AuthenticationException exception) &#123;<br>            writer.write(RestBean.failure(<span class="hljs-number">401</span>, exception.getMessage()).asJsonString());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exceptionOrAuthentication <span class="hljs-keyword">instanceof</span> Authentication authentication)&#123;<br>          <span class="hljs-comment">//不过这里需要注意，在登录成功的时候需要返回我们生成的JWT令牌，这样客户端下次访问就可以携带这个令牌了，令牌过期之后就需要重新登录才可以</span><br>            writer.write(RestBean.success(JwtUtils.createJwt((User) authentication.getPrincipal())).asJsonString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们创建一个测试使用的Controller来看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在采用JWT之后，我们要怎么使用呢？首先我们还是使用工具来测试一下：</p><p><img src="https://s2.loli.net/2023/07/24/L1O8m6auYc2IFWR.png" alt="image-20230724200235358"></p><p>登录成功之后，可以看到现在返回给我们了一个JWT令牌，接着我们就可以使用这个令牌了。比如现在我们要访问某个接口获取数据，那么就可以携带这个令牌进行访问：</p><p><img src="https://s2.loli.net/2023/07/24/Hn7X5qeDf9htk6P.png" alt="image-20230724200341917"></p><p>注意需要在请求头中添加：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Authorization:</span> Bearer 刚刚获取的Token<br></code></pre></td></tr></table></figure><p>如果以后没有登录或者携带一个错误的JWT访问服务器，都会返回401错误：</p><p><img src="https://s2.loli.net/2023/07/24/ID96yY7lkr5VsPS.png" alt="image-20230724200533964"></p><p>我们现在来模拟一下前端操作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">//其他都是跟之前一样的</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInfo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;http://localhost:8081/api/auth/login&#x27;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">username</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>).<span class="hljs-property">value</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">password</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;password&#x27;</span>).<span class="hljs-property">value</span></span><br><span class="language-javascript">        &#125;, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">headers</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span>(data.<span class="hljs-property">code</span> === <span class="hljs-number">200</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-comment">//将得到的JWT令牌存到sessionStorage用于本次会话</span></span><br><span class="language-javascript">                <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;access_token&quot;</span>, data.<span class="hljs-property">data</span>)</span><br><span class="language-javascript">                <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/index.html&#x27;</span></span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;登录失败：&#x27;</span>+data.<span class="hljs-property">message</span>)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着是首页，获取信息的时候携带上JWT即可，不需要依赖Cookie了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:8081/api/user/name&#x27;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">headers</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&quot;Bearer &quot;</span>+<span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;access_token&quot;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>).<span class="hljs-property">innerText</span> = data.<span class="hljs-property">data</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就实现了基于SpringSecurity的JWT校验，整个流程还是非常清晰的。</p><h3 id="退出登录JWT处理"><a href="#退出登录JWT处理" class="headerlink" title="退出登录JWT处理"></a>退出登录JWT处理</h3><p>虽然我们使用JWT已经很方便了，但是有一个很严重的问题就是，我们没办法像Session那样去踢用户下线，什么意思呢？我们之前可以使用退出登录接口直接退出，用户Session中的验证信息也会被销毁，但是现在是无状态的，用户来管理Token令牌，服务端只认Token是否合法，那这个时候该怎么让用户正确退出登录呢？</p><p>首先我们从最简单的方案开始，我们可以直接让客户端删除自己的JWT令牌，这样不就相当于退出登录了吗，这样甚至不需要请求服务器，直接就退了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">...</span><br><span class="language-javascript">  </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">logout</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//直接删除存在sessionStorage中的JWT令牌</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&quot;access_token&quot;</span>)</span><br><span class="language-javascript">        <span class="hljs-comment">//然后回到登录界面</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/login.html&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样虽然是最简单粗暴的，但是存在一个问题，用户可以自行保存这个Token拿来使用。虽然客户端已经删除掉了，但是这个令牌仍然是可用的，如果用户私自保存过，那么依然可以正常使用这个令牌，这显然是有问题的。</p><p>目前有两种比较好的方案：</p><ul><li>黑名单方案：所有黑名单中的JWT将不可使用。</li><li>白名单方案：不在白名单中的JWT将不可使用。</li></ul><p>这里我们以黑名单机制为例，让用户退出登录之后，无法再次使用之前的JWT进行操作，首先我们需要给JWT额外添加一个用于判断的唯一标识符，这里就用UUID好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createJwt</span><span class="hljs-params">(UserDetails user)</span>&#123;<br>        <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(key);<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> calendar.getTime();<br>        calendar.add(Calendar.SECOND, <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">return</span> JWT.create()<br>          <span class="hljs-comment">//额外添加一个UUID用于记录黑名单，将其作为JWT的ID属性jti</span><br>          .withJWTId(UUID.randomUUID().toString())<br>                .withClaim(<span class="hljs-string">&quot;name&quot;</span>, user.getUsername())<br>                .withClaim(<span class="hljs-string">&quot;authorities&quot;</span>, user.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())<br>                .withExpiresAt(calendar.getTime())<br>                .withIssuedAt(now)<br>                .sign(algorithm);<br>    &#125;<br>  <br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们发出去的所有令牌都会携带一个UUID作为唯一凭据，接着我们可以创建一个专属的表用于存储黑名单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtils</span> &#123;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> HashSet&lt;String&gt; blackList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>  <span class="hljs-comment">//加入黑名单方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">invalidate</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(key);<br>        <span class="hljs-type">JWTVerifier</span> <span class="hljs-variable">jwtVerifier</span> <span class="hljs-operator">=</span> JWT.require(algorithm).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DecodedJWT</span> <span class="hljs-variable">verify</span> <span class="hljs-operator">=</span> jwtVerifier.verify(token);<br>            Map&lt;String, Claim&gt; claims = verify.getClaims();<br>          <span class="hljs-comment">//取出UUID丢进黑名单中</span><br>            <span class="hljs-keyword">return</span> blackList.add(verify.getId());<br>        &#125; <span class="hljs-keyword">catch</span> (JWTVerificationException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>  &#125;<br>  <br>  ...<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDetails <span class="hljs-title function_">resolveJwt</span><span class="hljs-params">(String token)</span>&#123;<br>        <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(key);<br>        <span class="hljs-type">JWTVerifier</span> <span class="hljs-variable">jwtVerifier</span> <span class="hljs-operator">=</span> JWT.require(algorithm).build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DecodedJWT</span> <span class="hljs-variable">verify</span> <span class="hljs-operator">=</span> jwtVerifier.verify(token);<br>            <span class="hljs-comment">//判断是否存在于黑名单中，如果存在，则返回null表示失效</span><br>            <span class="hljs-keyword">if</span>(blackList.contains(verify.getId()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            Map&lt;String, Claim&gt; claims = verify.getClaims();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().after(claims.get(<span class="hljs-string">&quot;exp&quot;</span>).asDate()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> User<br>                    .withUsername(claims.get(<span class="hljs-string">&quot;name&quot;</span>).asString())<br>                    .password(<span class="hljs-string">&quot;&quot;</span>)<br>                    .authorities(claims.get(<span class="hljs-string">&quot;authorities&quot;</span>).asArray(String.class))<br>                    .build();<br>        &#125; <span class="hljs-keyword">catch</span> (JWTVerificationException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来SecurityConfiguration中配置一下退出登录操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                 HttpServletResponse response,</span><br><span class="hljs-params">                                 Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> response.getWriter();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">authorization</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span>(authorization != <span class="hljs-literal">null</span> &amp;&amp; authorization.startsWith(<span class="hljs-string">&quot;Bearer &quot;</span>)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> authorization.substring(<span class="hljs-number">7</span>);<br>          <span class="hljs-comment">//将Token加入黑名单</span><br>            <span class="hljs-keyword">if</span>(JwtUtils.invalidate(token)) &#123;<br>              <span class="hljs-comment">//只有成功加入黑名单才会退出成功</span><br>                writer.write(RestBean.success(<span class="hljs-string">&quot;退出登录成功&quot;</span>).asJsonString());<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        writer.write(RestBean.failure(<span class="hljs-number">400</span>, <span class="hljs-string">&quot;退出登录失败&quot;</span>).asJsonString());<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就成功安排上了黑名单机制，即使用户提前保存，这个Token依然是失效的：</p><p><img src="https://s2.loli.net/2023/07/24/4o76q5yNHkabuip.png" alt="image-20230724214624046"></p><p>虽然这种黑名单机制很方便，但是如果到了后面的微服务阶段，可能多个服务器都需要共享这个黑名单，这个时候我们再将黑名单存储在单个应用中就不太行了，后续我们可以考虑使用Redis服务器来存放黑名单列表，这样就可以实现多个服务器共享，并且根据JWT的过期时间合理设定黑名单中UUID的过期时间，自动清理。</p><h3 id="自动续签JWT令牌"><a href="#自动续签JWT令牌" class="headerlink" title="自动续签JWT令牌"></a>自动续签JWT令牌</h3><p>在有些时候，我们可能希望用户能够一直使用我们的网站，而不是JWT令牌到期之后就需要重新登录，这种情况下前端就可以配置JWT自动续签，在发起请求时如果令牌即将到期，那么就向后端发起续签请求得到一个新的JWT令牌。</p><p>这里我们写一个接口专门用于令牌刷新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/api/auth&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorizeController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/refresh&quot;)</span><br>    <span class="hljs-keyword">public</span> RestBean&lt;String&gt; <span class="hljs-title function_">refreshToken</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> JwtUtils.createJwt(user);<br>        <span class="hljs-keyword">return</span> RestBean.success(jwt);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，前端在发现令牌可用时间不足时，就会先发起一个请求自动完成续期，得到一个新的Token：</p><p><img src="https://s2.loli.net/2023/07/24/cqEgnQOZtFp1w7o.png" alt="image-20230724232152613"></p><p>我们可能还需要配置一下这种方案的请求频率，不然用户疯狂请求刷新Token就不太好了，我们同样可以借助Redis进行限流等操作，防止频繁请求，这里就不详细编写了，各位小伙伴可以自行实现。</p><p>我们最后可以来对比一下两种前后端分离方式的优缺点如何：</p><p><strong>JWT校验方案的优点：</strong></p><ol><li>无状态: JWT是无状态的，服务器不需要在后端维护用户的会话信息，可以在分布式系统中进行水平扩展，减轻服务器的负担。</li><li>基于Token: JWT使用token作为身份认证信息，该token可以存储用户相关的信息和权限。这样可以减少与数据库的频繁交互，提高性能。</li><li>安全性: JWT使用数字签名或加密算法保证token的完整性和安全性。每次请求都会验证token的合法性，防止伪造或篡改。</li><li>跨域支持: JWT可以在不同域之间进行数据传输，适合前后端分离的架构。</li></ol><p><strong>JWT校验方案的缺点：</strong></p><ol><li>无法做到即时失效: JWT中的token通常具有较长的有效期，一旦签发，就无法立即失效。如果需要即时失效，需要在服务端进行额外的处理。</li><li>信息无法撤销: JWT中的token一旦签发，除非到期或者客户端清除，无法撤销。无法中途取消和修改权限。</li><li>Token增大的问题: JWT中包含了用户信息和权限等，token的体积较大，每次请求都需要携带，增加了网络传输的开销。</li><li>动态权限管理问题: JWT无法处理动态权限管理，一旦签发的token权限发生变化，仍然有效，需要其他手段进行处理。</li></ol><p><strong>传统Session校验方案的优点：</strong></p><ol><li>即时失效: Session在服务器端管理，可以通过设置过期时间或手动删除实现即时失效，保护会话的安全性。</li><li>信息即时撤销: 服务器端可以随时撤销或修改Session的信息和权限。</li><li>灵活的权限管理: Session方案可以更灵活地处理动态权限管理，可以根据具体场景进行即时调整。</li></ol><p><strong>传统Session校验方案的缺点：</strong></p><ol><li>状态维护: 传统Session需要在服务器端维护会话状态信息，增加了服务器的负担，不利于系统的横向扩展。</li><li>性能开销: 每次请求都需要在服务器端进行会话状态的校验和读写操作，增加了性能开销。</li><li>跨域问题: Session方案在跨域时存在一些问题，需要进行额外的处理。</li><li>无法分布式共享: 传统Session方案不适用于多个服务器之间共享会话信息的场景，需要额外的管理和同步机制。</li></ol><p>综上所述，JWT校验方案适用于无状态、分布式系统，几乎所有常见的前后端分离的架构都可以采用这种方案。而传统Session校验方案适用于需要即时失效、即时撤销和灵活权限管理的场景，适合传统的服务器端渲染应用，以及客户端支持Cookie功能的前后端分离架构。在选择校验方案时，需要根据具体的业务需求和技术场景进行选择。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://itbaima.net/<br>title: &quot;柏码 - 让每一行代码都闪耀智慧的光芒！&quot;<br>host: itbaima.net<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><p><a href="https://itbaima.net/">柏码 - 让每一行代码都闪耀智慧的光芒！</a></p>]]></content>
    
    
    <summary type="html">it is some basic usage of SpringBoot .</summary>
    
    
    
    <category term="Spring" scheme="https://alleyf.github.io/categories/Spring/"/>
    
    
    <category term="SpringBoot" scheme="https://alleyf.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>司法领域大模型调研二</title>
    <link href="https://alleyf.github.io/2023/10/d36831b1156c.html"/>
    <id>https://alleyf.github.io/2023/10/d36831b1156c.html</id>
    <published>2023-10-24T00:48:27.000Z</published>
    <updated>2023-11-03T00:38:57.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调研任务"><a href="#调研任务" class="headerlink" title="调研任务"></a>调研任务</h1><p><u>司法领域大模型应用研究</u>：对应修改申报书<strong>国内外研究现状部分（面向司法知识图谱的基础数据构建）</strong><br>根据上述目标可以细分以下调研思路：</p><ol><li>继续调研司法大模型国内外研究与应用现状。</li><li>阅读申报书国内外研究现状部分，补充完善已有的并加入代表性的。</li></ol><h1 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h1><p>强调研究领域的重要性：<br>法律知识体系是多种逻辑和知识的结合，知识图谱能够表达这种逻辑关联，并显示被关联的体系内的知识。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.faxin.cn/<br>title: &quot;法信 - 懂法，更懂法律人&quot;<br>host: www.faxin.cn<br></code></pre></td></tr></table></figure><p><a href="https://www.faxin.cn/">法信 - 懂法，更懂法律人</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://powerlaw.ai/about<br>title: &quot;幂律智能&quot;<br>description: &quot;幂律智能（PowerLaw AI）是一家专注于法律领域的初创人工智能公司，旨在利用人工智能技术为法律服务行业赋能。&quot;<br>host: powerlaw.ai<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><p><a href="https://powerlaw.ai/about">幂律智能</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.pkulaw.com/law?isFromV5=1<br>title: &quot;法律法规数据库-法律法规检索系统-北大法宝V6官网&quot;<br>description: &quot;北大法宝法律法规数据库，收录300余万件法律法规文件，来自《立法法》认可的权威文件来源，平均每日更新千余篇。是中国法律法规大全网站，同时是目前国内成熟、专业、先进的法律法规检索系统。&quot;<br>host: www.pkulaw.com<br></code></pre></td></tr></table></figure><p><a href="https://www.pkulaw.com/law?isFromV5=1">北大法宝</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.ailaw.cn/<br>title: &quot;华宇元典Yodex智慧法务管理平台，助力企业法务案件管理、风控管理、合规体系建设。&quot;<br>description: &quot;华宇元典打造了集法律智能与知识自动化服务为一体的智慧法务平台，推动企业提高主动维权能力和纠纷解决质效，打造大合规时代的企业数字化法务部。&quot;<br>host: www.ailaw.cn<br></code></pre></td></tr></table></figure><p><a href="https://www.ailaw.cn/">华宇元典Yodex智慧法务管理平台，助力企业法务案件管理、风控管理、合规体系建设。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://sf.xfyun.cn/services/IFlyLegal<br>title: &quot;法小飞-司法AI平台&quot;<br>description: &quot;法小飞&quot;<br>host: sf.xfyun.cn<br></code></pre></td></tr></table></figure><p><a href="https://sf.xfyun.cn/services/IFlyLegal">法小飞-司法AI平台</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://metaso.cn/#/<br>title: &quot;秘塔科技&quot;<br>description: &quot;秘塔检索是法律人工智能领域的一家新锐科技公司，致力于运用人工智能技术为法律人打造得心应手的生产工具，大幅提升法律行业工作效率，让法律人享受科技的便利。&quot;<br>host: metaso.cn<br></code></pre></td></tr></table></figure><p><a href="https://metaso.cn/#/">秘塔检索</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://hub.baai.ac.cn/view/29492<br>title: &quot;论文浅尝 | 大语言模型与知识图谱：机遇与挑战 - 智源社区&quot;<br>description: &quot;本文介绍了大语言模型（LLMs）在知识表示（KR）和自然语言处理任务中的应用。LLMs的参数化知识已经达到了人类相媲美的性能，这种知识正在逐渐被接受。&quot;<br>host: hub.baai.ac.cn<br>favicon: https://hub.baai.ac.cn/_nuxt/favicon.ico<br>image: https://simg.baai.ac.cn/hub-detail/b8ec3d60935010c7fcb62a739880aa391693101602312.webp<br></code></pre></td></tr></table></figure><p><a href="https://hub.baai.ac.cn/view/29492">论文浅尝 | 大语言模型与知识图谱：机遇与挑战 - 智源社区</a></p><h2 id="国内研究现状"><a href="#国内研究现状" class="headerlink" title="国内研究现状"></a>国内研究现状</h2><ol><li><p><a href="https://aclanthology.org/2023.ccl-2.6/">陈玉博-大模型与知识图谱</a>大模型助力知识图谱构建。在构建知识图谱的过程中，利用大模型可以<strong>提高知识的抽取和注入效率，增强知识图谱的覆盖范围和泛化性能</strong>。知识图谱辅助大模型进行知识校准和提升可解释性。大模型可以借助知识图谱提高知识的准确性，同时利用知识图谱来解释大模型的知识和推理过程，增强模型的可解释性。大模型和知识图谱协同工作。充分利用数据驱动和知识驱动的优势，提升自然语言处理各任务的能力，促进人工智能技术的发展。</p></li><li><p><strong>海致科技与高性能图计算院士工作站共同开发的 Atlas LLM 知识图谱与大模型融合应用平台</strong>，该平台运用知识图谱这项人工智能基础技术，帮助大模型在企业级和工业界应用中克服“幻觉”，实现基于行业与场景的精准推演。</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=1u4N9e-cd2R8zh2T8p_uhnxwF0kqHqxkDnUxEIe5U_MlZgbShqVtIh30Sd1qUMQJE8iYKW4r8h_aTCIw61UbTr5NjY11JstAqSj5hGXDeF0ZCmKyPUl_CaMLpV2AFSpUgx_-SE9BSQz8q_Y4QgkSiQ==&uniplatform=NZKPT&language=CHS">厦门大学洪文兴-面向司法案件的案情知识图谱自动构建</a>提出融合平移嵌入的多任务联合的语义关系抽取模型 BERT-Multitask 进行关系抽取，基于司法判决书构建了针对<strong>交通事故的案件知识图谱</strong>. 实体识别的 $F_1$ 值可提升 0.36, 关系抽取的 $F_1$ 值提升高达 2.37, 为交通事故领域类案推荐的司法人工智能应用提供语义支撑.</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=1u4N9e-cd2SI9t6HbLPEK7kcDwqqHgCKJrwfcPzGUK-j6VSfnku7qJyxl-EV1MFZ2DFiC3WNV6mr7ciKUXpkqCahjQqg_ttjC9o0hTnPZjiv34qmcSLg7D_yvAQJnAPbF9bJIB4njNOdp0l1-QF9yg==&uniplatform=NZKPT&language=CHS">黄茜茜-基于司法判决书的知识图谱构建与知识服务应用分析</a>基于 2015 年-2020 年的“网络诈骗”领域司法判决书，构建了含有约 3 万个实体和 18 万条关系的<strong>网络诈骗案件知识图谱</strong>, 提出了基于知识图谱的智慧司法知识服务框架.</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=1u4N9e-cd2TGWIrXcsPbVTx6gx8vaIo5wVJNdh5ZUrBZQ19AY0LynUsgmt6hZVKMih76mBU-o3td__E-u1Ow_Cr9aSvfELciQOeqk2bs5HpTA6AiaUzNaExzgN6Hkxy9sleNa93WixqbsXn_QchI_A==&uniplatform=NZKPT&language=CHS">杨阳</a>融合公安、工商、银行等多库情报资源信息，搭建<strong>涉众型经济犯罪知识图谱</strong>，着重描绘案件、罪犯、账户三者之间的社交、资金流向等各类关系，为警方打击此类犯罪提供决策支持。</p></li><li><p><a href="https://kns.cnki.net/KNS8/Detail?sfield=fn&QueryID=1147&CurRec=1&recid=&FileName=NJDZ202106014&DbName=CJFDLAST2021&DbCode=CJFD&yx=&pr=&URLID=">黄治纲-南京大学学报-基于司法案例知识图谱的类案推荐</a>，提出基于知识图谱的案件推荐（Knowledge Graph based Case Recommendation，KGCR）模型, 利用文本分类和信息抽取技术构建面向<strong>刑事案例的知识图谱</strong>. 针对 TransH 算法的负采样问题进行改进，提出 FU⁃TransH 算法模型. 以公开的刑事判决书为数据集进行实验，与相关的具有代表性的算法相比，该算法的推荐准确率更高.</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=1u4N9e-cd2RZFOwVGyY4sd9u-Vg9ScQpZGx_5lP_Ndz7LVnbuWXL_FJwPC6FQA8CVGRe8F3I5VD1feeMpfaVWYlKW-2qD2tnCLZD3h_TLzPm6PmqcuvmpD70xYOJf0APXAhJgUk87FyHioQutDnt8w==&uniplatform=NZKPT&language=CHS">陈彦光等</a>在公开的 30 余万份涉毒类案件中抽取实体建成了关于<strong>涉毒案件的知识图谱</strong>；</p></li><li><p><a href="https://github.com/liuhuanyong/CrimeKgAssitant">刘焕勇</a>构建起了一个 20 万问答集, 856 个<strong>罪名的知识库</strong>，实现了<strong>罪名预测、法务咨询问题分类及自动问答</strong>功能。</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=1u4N9e-cd2T9rJjEyaZxDeN7zu2mhLE5B4hlMoEh7iqEbn-piZcl_tsHbwAcwEer378vjbaw6rMbVrJh5s3goJVensp9y_gEMvqq1hLdQKjWNhgGm8UkS1keT_008OqIxYqjRSoqzPZomGctzWAizg==&uniplatform=NZKPT&language=CHS">马灿</a>提出“智慧司法 ”的知识图谱构建，并实现了关于案件的查询系统；</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=1u4N9e-cd2SDTg0l-K5NZuazcysYOLDxn8G4kMbh_AQU-Z81745nOZ7t6mNBoaqaTN4t0MGJifJHucQ99B6FwRvAsTn9VIi4wPJjNemJwc1h3X2uElV-Xq2Ya5c9H126uer4Muf4rZehIp4-rKNVQA==&uniplatform=NZKPT&language=CHS">乔钢柱等</a>实现了基于知识图谱的盗窃案件推理；</p></li><li><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=1u4N9e-cd2Q5SSdTCtxwZZemlwdyjQx_eVYh5DWmEKB7K7xSaWgsFkSBPGWGoUqjQ1mqSW8TFoLf7qfA5vb_uv0rUSv_UmbU6IHLqY0DkibF7k_3hTe1fbRjRepeXxwudjvSvYx5mrnQtTIzajPCwQ==&uniplatform=NZKPT&language=CHS">叶菁菁</a>提出结合文本相似性和协同过滤技术的法条推荐，协同过滤缩小了备选法条的范围，解决了法条数目过多导致模型训练困难的问题；</p></li><li><p><strong>CAIL 2023</strong>一共设置了七个任务，分别为：<strong>司法考试、对话式类案检索、类案检索、事实认定、论辩理解、信息抽取、司法大模型</strong>，同时将提供海量司法文书数据作为数据集。</p></li></ol><hr><hr><h2 id="国外研究现状"><a href="#国外研究现状" class="headerlink" title="国外研究现状"></a>国外研究现状</h2><ol><li><a href="https://scholarworks.iupui.edu/server/api/core/bitstreams/7f155f9c-7976-4fb8-aa34-7641b801aa1e/content">Pandey R</a> 针对凶杀案调查年表展开研究，从中提取证人、嫌疑人、侦探、证据四大类型的实体，构建凶杀案件知识图谱，可辅助调查人员对是否能侦破案件做出合理判断。</li><li>Winkelsetal 发明了一种基于荷兰案例法的法律推荐系统</li><li>Kimetal 建立了一个结合法律信息检索和文本蕴含的法律问答系统</li><li><a href="https://www.sciencedirect.com/science/article/abs/pii/S0306457318306885">Srinivasa K</a> 等基于在线报刊网站上的案件报导<strong>构建案件知识图谱</strong>，除了包含常见的时间、地点、人物等实体节点外，还纳入了图片类型实体，丰富案件信息的表现形式。</li><li><a href="https://link.springer.com/chapter/10.1007/978-981-15-1304-6_33">Wu H</a> 利用物联网技术融合案件电子数据和纸质报告、光盘等非电子数据，再依托自然语言处理、图像识别等人工智能技术构建含有文本、音频、视频等<strong>多模态数据的案件知识图谱</strong>。</li><li><a href="https://arxiv.org/pdf/2103.13084.pdf">Chalkidis等</a>于 2019 年发布的欧洲人权法院案件的段落级合理化注释数据集为法律领域生成段落级合理化注释以增加对系统决策的信任和促进司法决策支持工具的使用的重要性</li><li><a href="https://arxiv.org/abs/2110.00806">Joel Niklaus</a> 多语言的法律判决预测基准数据集，包含来自瑞士联邦最高法院的 85,000 个案例，但案例长度增加时性能下降、不同法律领域或不同地区的案例结果差异。</li></ol><h2 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题"></a>现存问题</h2><ol><li>类案推荐: 存在的<font color="#c00000">推荐准确性差、传统知识图谱向量化表示精度不高</font>等问题。</li><li>数据低质：部分文书存在错别字、标点符号错误等问题，可能会影响文本的准确性和可用性。</li><li>样本不均衡：不同类别的样本数量存在较大的不平衡，可能导致模型在训练和评估时对少数类别的判断能力较弱。</li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>司法知识图谱在智慧司法建设中具有举足轻重的地位。它不仅能够提升司法智能化水平，确保司法公正性，还能加强决策支持能力，推动智慧司法的创新。但是由于司法领域数据的特殊性，司法知识图谱在基础数据方面存在着一些问题： 1）已公开的原始司法数据多来源于真实司法程序，公开前需对数据进行脱敏，公开后的数据需进行大量过滤、清洗和数据均衡工作，才能用于 NLP 模型或知识图谱的数据来源。2） 司法数据大多是非结构化纯文本，计算机无法直接理解，因此，需要对纯文本做高质量的信息抽取可以为下游知识图谱、法律文书处理、类案检索、判决预测等相关司法服务提供有价值的数据支持。3）现有司法数据集之间相互独立、覆盖面窄，不同网络间的数据共享交换体系建立尚不健全，而司法工作中需频繁交互多类数据，“数据孤岛”等现象较为突出。<br>为促进智慧司法的学术研究与应用发展，自 2013 年起，国内逐步搭建了中国审判流程信息公开网、中国裁判文书网、中国执行信息网等信息公开平台，归纳整合司法领域数据，实现了审判管理等数据公开化，为司法知识图谱提供了数据基础。中国法律智能技术评测CAIL(Challenge of AI in Law)自2018年起设置了多项司法评估任务包括司法考试、类案检索、信息抽取、司法大模型等，为研究者提供海量司法文书数据作为数据集，以推动自然语言处理、智能信息检索等人工智能技术在法律领域的应用。目前已有学者基于公开司法数据集，如法律法规数据集、司法案例数据集、法考试题数据集、判决预测数据集、司法问答数据集等，在法条检索、类案推荐、法律咨询、信息抽取、审判辅助、信息管理等领域做出了相关研究；<a href="https://aclanthology.org/2023.ccl-2.6/">陈玉博等</a>提出在构建知识图谱的过程中，利用大模型进行信息抽取可以提高知识的抽取和注入效率，增强知识图谱的覆盖范围和泛化性能。<a href="https://github.com/liuhuanyong/CrimeKgAssitant">刘焕勇</a>构建起了一个 20 万问答集, 856 个罪名的知识库，实现了罪名预测、法务咨询问题分类及自动问答功能。还有部分学者就司法领域的“数据孤岛”问题，研究数据协同交换技术。但数据集的标注、覆盖范围、数据集间的融合协同方面，还面临着巨大挑战。<br>国外在构建高质量的司法数据集方面也进行了相关研究。<a href="https://www.sciencedirect.com/science/article/abs/pii/S0306457318306885">Srinivasa K</a> 等基于在线报刊网站上的案件报导构建案件知识图谱，除了包含常见的时间、地点、人物等实体节点外，还纳入了图片类型实体，丰富案件信息的表现形式。<a href="https://link.springer.com/chapter/10.1007/978-981-15-1304-6_33">Wu H</a> 利用物联网技术融合案件电子数据和纸质报告、光盘等非电子数据，再依托自然语言处理、图像识别等人工智能技术构建含有文本、音频、视频等多模态数据的案件知识图谱。<a href="https://arxiv.org/pdf/2103.13084.pdf">Chalkidis等</a>于 2019 年发布的欧洲人权法院案件的段落级合理化注释数据集为法律领域生成段落级合理化注释以增加对系统决策的信任和促进司法决策支持工具的使用。<a href="https://arxiv.org/pdf/2110.00806.pdf">Joel Niklaus</a> 构建了多语言的法律判决预测基准数据集，包含来自瑞士联邦最高法院的 85,000 个案例，但案例长度增加时性能下降、不同法律领域或不同地区的案例结果存在一定差异。<br>因此，本项目将通过远程监督手段，构建大规模法律法规和司法案件数据集，借助大模型提升复杂法条和司法案件事件抽取任务的表现，同时也对解决高质量司法相关数据稀疏问题具有重要意义。</p><hr><p> 近年来，面向司法领域的知识图谱构建已成为人工智能研究的热点之一。国内外研究者在这一领域取得了丰硕的成果，主要体现在以下几个方面：</p><ol><li>知识图谱自动构建：厦门大学洪文兴通过提出融合平移嵌入的多任务联合的语义关系抽取模型 BERT-Multitask，实现了关系抽取和实体识别的 $F_1$ 值提升，为交通事故领域类案推荐的司法人工智能应用提供了语义支撑。</li><li>知识服务应用：黄茜茜基于司法判决书的知识图谱构建与知识服务应用分析，构建了含有约 3 万个实体和 18 万条关系的网络诈骗案件知识图谱，提出了基于知识图谱的智慧司法知识服务框架。</li><li>多库情报资源融合：杨阳通过融合公安、工商、银行等多库情报资源信息，搭建了涉众型经济犯罪知识图谱，着重描绘案件、罪犯、账户三者之间的社交、资金流向等各类关系，为警方打击此类犯罪提供决策支持。</li><li>基于知识图谱的案件推荐：黄治纲提出基于知识图谱的案件推荐（Knowledge Graph based Case Recommendation，KGCR）模型，利用文本分类和信息抽取技术构建面向刑事案例的知识图谱。相较于相关算法，该算法的推荐准确率更高。</li><li>涉毒案件知识图谱：陈彦光等在公开的 30 余万份涉毒类案件中抽取实体建成了关于涉毒案件的知识图谱。</li><li>罪名的知识库：刘焕勇构建起了一个 20 万问答集、856 个罪名的知识库，实现了罪名预测、法务咨询问题分类及自动问答功能。</li><li>盗窃案件推理：乔钢柱等实现了基于知识图谱的盗窃案件推理。</li><li>法条推荐：叶菁菁提出结合文本相似性和协同过滤技术的法条推荐，协同过滤缩小了备选法条的范围，解决了法条数目过多导致模型训练困难的问题。</li><li>司法大模型：CAIL 2023 设置了七个任务，分别为司法考试、对话式类案检索、类案检索、事实认定、论辩理解、信息抽取、司法大模型，同时将提供海量司法文书数据作为数据集。<br>国外研究现状方面，研究者也在开展类似的工作。例如，Pandey R 针对凶杀案调查年表展开研究，从中提取证人、嫌疑人、侦探、证据四大类型的实体，构建凶杀案件知识图谱。此外，Winkelsetal 发明了一种基于荷兰案例法的法律推荐系统，Kimetal 建立了一个结合法律信息检索和文本蕴含的法律问答系统。<br>尽管在司法知识图谱构建方面取得了一定的成果，但仍存在一些问题需要解决，如类案推荐准确性差、传统知识图谱向量化表示精度不高、数据稀疏、数据质量、样本不均衡等。未来研究将继续在这些方面进行深入探讨，以期为司法领域的发展做出更大的贡献。</li></ol><hr><h1 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h1><h2 id="模型评测"><a href="#模型评测" class="headerlink" title="模型评测"></a>模型评测</h2><h3 id="CoLLaM-法律大模型评估框架"><a href="#CoLLaM-法律大模型评估框架" class="headerlink" title="CoLLaM - 法律大模型评估框架"></a><a href="https://github.com/CSHaitao/CoLLaM#collam---%E6%B3%95%E5%BE%8B%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E6%A1%86%E6%9E%B6">CoLLaM - 法律大模型评估框架</a></h3><p>为了促进智能技术赋能司法，实现更高水平的数字正义，在最高人民法院和中国中文信息学会的指导下，从 2018 年起，CAIL 已连续举办了五届中国法律智能技术评测，先后吸引了来自海内外高校、企业和组织的近 5000 支队伍参赛，成为中国法律智能技术评测的重要平台。CAIL 2018 设置了罪名预测、法条推荐、刑期预测三个任务，并提供了包含 268 万刑事法律文书的数据集；CAIL 2019 设置了阅读理解、要素识别、相似案例匹配三个任务；CAIL 2020 设置了阅读理解、司法摘要、司法考试、论辩挖掘四个任务；CAIL 2021 设置了阅读理解、类案检索、司法考试、司法摘要、论辩理解、案情标签预测、信息抽取七个任务；CAIL 2022 设置了司法考试、事件检测、文书校对、类案检索、涉法舆情摘要、论辩理解、信息抽取、可解释类案匹配八个任务。随着智能技术与法律需求交叉融合的不断深入，CAIL 的任务设置更加符合司法需求，任务难度也逐年升级。<br><strong>CAIL 2023</strong>一共设置了七个任务，分别为：<strong>司法考试、对话式类案检索、类案检索、事实认定、论辩理解、信息抽取、司法大模型</strong>，同时将提供海量司法文书数据作为数据集。CAIL 2023 赛程为 8 月初至 12 月持续 5 个月时间，预计将于 2024 年 1 月在北京举办颁奖典礼暨法律智能技术研讨会。诚邀学术界和工业界的研究者和开发者积极参与和支持评测！</p><blockquote><p>CAIL 评测介绍网站：<a href="http://cail.cipsc.org.cn/">CAIL (China AI and Law Challenge</a></p></blockquote><p>CoLLaM 将大语言模型在法律领域的应用划分为六个能力层次，分别是：记忆（Memorization）、理解（Understanding）、逻辑推理（Logic Inference）、辨别（Discrimination）、生成（Generation）和伦理（Ethic）。<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310241307252.png?token=AWSLQP2K6F7XFHXHR3FXNZDFG5IVS" alt="image.png"></p><ul><li>任务定义<br>基于法律认识能力评估框架，我们构造了一系列涉及不同能力层次的司法能力评估任务。<br><img src="https://github.com/CSHaitao/CoLLaM/raw/main/figure/task.png"></li></ul><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调研任务&quot;&gt;&lt;a href=&quot;#调研任务&quot; class=&quot;headerlink&quot; title=&quot;调研任务&quot;&gt;&lt;/a&gt;调研任务&lt;/h1&gt;&lt;p&gt;&lt;u&gt;司法领域大模型应用研究&lt;/u&gt;：对应修改申报书&lt;strong&gt;国内外研究现状部分（面向司法知识图谱的基础数据构建）&lt;/</summary>
      
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="NLP，KG" scheme="https://alleyf.github.io/tags/NLP%EF%BC%8CKG/"/>
    
  </entry>
  
  <entry>
    <title>国际会议记录</title>
    <link href="https://alleyf.github.io/2023/10/46c739775d39.html"/>
    <id>https://alleyf.github.io/2023/10/46c739775d39.html</id>
    <published>2023-10-21T00:52:02.555Z</published>
    <updated>2023-10-22T01:59:46.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023年数字法治与智慧司法国际研讨会议程"><a href="#2023年数字法治与智慧司法国际研讨会议程" class="headerlink" title="2023年数字法治与智慧司法国际研讨会议程"></a>2023年数字法治与智慧司法国际研讨会议程</h1><h2 id="会议简介"><a href="#会议简介" class="headerlink" title="会议简介"></a>会议简介</h2><p>华中科技大学和湖北高级人民法院联合举办</p><h2 id="演讲记录"><a href="#演讲记录" class="headerlink" title="演讲记录"></a>演讲记录</h2><h3 id="发挥大模型优势，推动智慧司法跃升"><a href="#发挥大模型优势，推动智慧司法跃升" class="headerlink" title="发挥大模型优势，推动智慧司法跃升"></a>发挥大模型优势，推动智慧司法跃升</h3><p>梁新（中国司法大数据研究院院长）（线上）<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211001753.png" alt="image.png"></p><ol><li>国内外大模型在司法领域应用</li></ol><blockquote><p>Lexis+ Al：法律研究和文件起草的生成式 Al   英国律商联讯<br>Robin Al:  结合内部律师的指导来起草和编辑法律合同英国 Robin Al 公司<br>ChatLaw：为大众提供普惠法律服务北京大学<br>万象大模型：知识检索、法官阅卷、庭审辅助等华宇信息<br>法律服务大模型：法律知识、审判辅助、文书生成等中国法研</p></blockquote><ol start="2"><li>生态应用实践<br>法规、制度合规审查场景<br>面向法务人员，辅助地方或企业制度的合规性审查，防止与上位法或关联法规冲突</li></ol><h3 id="知识产权相关的人工智能制度和案例中美欧比较及促进人工智能产业良性发展的对策思考"><a href="#知识产权相关的人工智能制度和案例中美欧比较及促进人工智能产业良性发展的对策思考" class="headerlink" title="知识产权相关的人工智能制度和案例中美欧比较及促进人工智能产业良性发展的对策思考"></a>知识产权相关的人工智能制度和案例中美欧比较及促进人工智能产业良性发展的对策思考</h3><p>余翔（华中科技大学中欧知识产权研究院院长、湖北师范大学副校长、欧洲科学院院士、教授）（线下）<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211113561.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211116571.png" alt="image.png"></p><h3 id="以司法数据科学化助力司法工作现代化"><a href="#以司法数据科学化助力司法工作现代化" class="headerlink" title="以司法数据科学化助力司法工作现代化"></a>以司法数据科学化助力司法工作现代化</h3><p>孙佑海（天津大学法学院院长、中国绿色发展研究院执行院长、教授）（线上）</p><ol><li>深刻认识数据资源为司法工作带来的新机遇<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211121471.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211122730.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211126416.png" alt="44f4409dd925fdea6e45847047860d6.jpg"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211557538.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211603381.png" alt="image.png"></li></ol><h3 id="华宇万象法律大模型的构建与应用实践"><a href="#华宇万象法律大模型的构建与应用实践" class="headerlink" title="华宇万象法律大模型的构建与应用实践"></a>华宇万象法律大模型的构建与应用实践</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211626338.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211626425.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211628608.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211628110.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211628280.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211629206.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211630746.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211630068.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211630040.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310211631968.png" alt="image.png"></p><h3 id="人工智能算法司法应用的发展隐忧及完善路径"><a href="#人工智能算法司法应用的发展隐忧及完善路径" class="headerlink" title="人工智能算法司法应用的发展隐忧及完善路径"></a>人工智能算法司法应用的发展隐忧及完善路径</h3><ol><li>人工智能算法司法的实践图景</li></ol><ul><li><p>算法裁判领域</p></li><li><p>算法推理领域<br>人工智能算法推理基于法律规则和案例，通过数据挖掘、机器学<br>习、自然语言处理等技术，依据特定的推理规则，对案件事实、证<br>据和法律条款进行分析和推理，从而预测案件的结果或提出合理的裁<br>判建议。<br>即通过对数据库中过往案例的事实经验进行分析来处理当下的案件。<br>例如，JUDITH 律师推理系统可以模拟法律形式推理的演绎推理，并将<br>推理过程转化为计算机语言，使机器法律推理从理论变为现实。</p></li><li><p>算法量刑领域<br>算法量刑的运作机理是在大数据、云计算、区块链等技术的支持下形成<br>知识图谱，通过对法律文书的事实要素进行提取，实现类案识别和<br>模型建构，借助深度学习等方法形成量刑算法，在此基础上实现量刑<br>预测和偏离度测算。</p></li></ul><ol start="2"><li>人工智能算法司法应用的发展隐忧</li></ol><ul><li>算法裁判易影响司法自主</li><li>算法推理易影响实质正义</li><li>算法量刑易影响自由裁量权</li></ul><h3 id="法律大模型的挑战和机遇"><a href="#法律大模型的挑战和机遇" class="headerlink" title="法律大模型的挑战和机遇"></a>法律大模型的挑战和机遇</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212036409.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212037457.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212249410.png?token=AWSLQPZXBIK2XXJMJHUYP3DFGPSUO" alt="66db6a1944c12877b17ab79536570a93.jpg"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212040935.png?token=AWSLQP4MTXWPPLXJNFIRZ53FGPDOQ" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212041619.png?token=AWSLQP55Q5A42HXTHBDZFR3FGPDS6" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212044116.png?token=AWSLQP3E6F4A7QCNOLHBDMTFGPD7A" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212046798.png?token=AWSLQPY6AD6T4TLVQDDJJU3FGPEFK" alt="image.png"></p><h3 id="健康大数据治理的分析框架"><a href="#健康大数据治理的分析框架" class="headerlink" title="健康大数据治理的分析框架"></a>健康大数据治理的分析框架</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212103037.png?token=AWSLQP5YH5V7NDMBX54W763FGPGHK" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212112631.png?token=AWSLQP5LLB6TINVTZ7ZMNI3FGPHH6" alt="image.png"></p><h3 id="个人医疗健康数据的跨境共享"><a href="#个人医疗健康数据的跨境共享" class="headerlink" title="个人医疗健康数据的跨境共享"></a>个人医疗健康数据的跨境共享</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212116881.png?token=AWSLQPZYGUEXCCYNL7AZLYDFGPHVC" alt="image.png"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310212129914.png?token=AWSLQPYQLHYXYKKJFFP3YJDFGPJGU" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2023年数字法治与智慧司法国际研讨会议程&quot;&gt;&lt;a href=&quot;#2023年数字法治与智慧司法国际研讨会议程&quot; class=&quot;headerlink&quot; title=&quot;2023年数字法治与智慧司法国际研讨会议程&quot;&gt;&lt;/a&gt;2023年数字法治与智慧司法国际研讨会议程&lt;/</summary>
      
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>司法领域大模型调研一</title>
    <link href="https://alleyf.github.io/2023/10/c114fe139aab.html"/>
    <id>https://alleyf.github.io/2023/10/c114fe139aab.html</id>
    <published>2023-10-18T01:55:23.000Z</published>
    <updated>2023-10-24T01:09:16.950Z</updated>
    
    <content type="html"><![CDATA[<p>调研来源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://github.com/HqWu-HITCS/Awesome-Chinese-LLM#4-llm%E8%AE%AD%E7%BB%83%E5%BE%AE%E8%B0%83%E6%A1%86%E6%9E%B6<br>title: &quot;GitHub - HqWu-HITCS/Awesome-Chinese-LLM: 整理开源的中文大语言模型，以规模较小、可私有化部署、训练成本较低的模型为主，包括底座模型，垂直领域微调及应用，数据集与教程等。&quot;<br>description: &quot;整理开源的中文大语言模型，以规模较小、可私有化部署、训练成本较低的模型为主，包括底座模型，垂直领域微调及应用，数据集与教程等。 - GitHub - HqWu-HITCS/Awesome-Chinese-LLM: 整理开源的中文大语言模型，以规模较小、可私有化部署、训练成本较低的模型为主，包括底座模型，垂直领域微调及应用，数据集与教程等。&quot;<br>host: github.com<br>favicon: https://github.githubassets.com/favicons/favicon.svg<br>image: https://opengraph.githubassets.com/132594c1c3b2385a7b04bb0778a027b442296804625747ac9ba2e8dec643aa52/HqWu-HITCS/Awesome-Chinese-LLM<br></code></pre></td></tr></table></figure><h1 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h1><h2 id="1-ChatLaw系列模型"><a href="#1-ChatLaw系列模型" class="headerlink" title="1.ChatLaw系列模型"></a><a href="https://github.com/PKU-YuanGroup/ChatLaw#chatlaw%E7%B3%BB%E5%88%97%E6%A8%A1%E5%9E%8B">1.ChatLaw系列模型</a></h2><blockquote><p>来源：<a href="https://arxiv.org/pdf/2306.16092.pdf">arXiv: ChatLaw</a><br>由北大开源的一系列法律领域的大模型，并针对<strong>LLM 和知识库</strong>的结合问题给出了法律场景下合理的解决方案。</p></blockquote><ul><li><a href="https://huggingface.co/JessyTsu1/ChatLaw-13B">ChatLaw-13B</a>，此版本为学术 demo 版，基于姜子牙 <a href="https://huggingface.co/IDEA-CCNL/Ziya-LLaMA-13B-v1">Ziya-LLaMA-13B-v1</a> 训练而来，<strong>中文各项表现很好</strong>，但是<strong>逻辑复杂的法律问答效果不佳</strong>，需要用更大参数的模型来解决。</li><li><a href="https://huggingface.co/JessyTsu1/ChatLaw-33B">ChatLaw-33B</a>，此版本为学术 demo 版，基于 <a href="https://github.com/lyogavin/Anima">Anima-33B</a> 训练而来，<strong>逻辑推理能力大幅提升</strong>，但是因为 Anima 的<strong>中文语料过少</strong>，导致问答<strong>时常会出现英文数据</strong>。</li><li><a href="https://huggingface.co/chestnutlzj/ChatLaw-Text2Vec">ChatLaw-Text2Vec</a>，使用 93 w 条判决案例做成的数据集基于 BERT 训练了一个<strong>相似度匹配模型</strong>，可将用户<strong>提问信息和对应的法条相匹配</strong>。</li></ul><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>数据主要由<strong>论坛、新闻、法条、司法解释、法律咨询、法考题、判决文书</strong>组成，随后经过清洗、数据增强等来构造对话数据。</p><h3 id="参考价值"><a href="#参考价值" class="headerlink" title="参考价值"></a>参考价值</h3><ol><li>提出了一种将 <strong>LLM 与矢量知识数据库相结合</strong>的新方法，并且将<strong>矢量数据库检索与关键词检索</strong>相结合，有效降低了单纯依赖矢量数据库检索的不准确性，克服模型<strong>幻觉问题</strong>。</li><li>传统使用<strong>司法选择题</strong>来衡量司法大模型<strong>性能</strong>，但准确率普遍较低参考意义不大，借鉴电子竞技中的<strong>匹配机制和聊天机器人竞技场</strong>（Chatbot Arena）的设计，建立了模型竞逐 <strong>Elo</strong> 积分的评估机制，以更有效地评估模型处理法律多选题的能力。<br> <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310182125959.png" alt="image.png"></li></ol><hr><h2 id="2-智海-录问"><a href="#2-智海-录问" class="headerlink" title="2.智海-录问"></a><a href="https://github.com/zhihaiLLM/wisdomInterrogatory#%E6%99%BA%E6%B5%B7-%E5%BD%95%E9%97%AE">2.智海-录问</a></h2><blockquote><p>智海-录问 (wisdomInterrogatory)是由浙江大学、阿里巴巴达摩院以及华院计算三家单位共同设计研发的法律大模型。核心思想：以“普法共享和司法效能提升”为目标，从推动法律智能化体系入司法实践、数字化案例建设、虚拟法律咨询服务赋能等方面提供支持，形成数字化和智能化的司法基座能力。</p></blockquote><h3 id="数据集-1"><a href="#数据集-1" class="headerlink" title="数据集"></a>数据集</h3><ul><li>模型基座是 <a href="https://github.com/baichuan-inc/baichuan-7B">Baichuan-7B</a>，在此基础上，进行了二次预训练目的是给通用的大模型注入法律领域的知识。预训练的数据包括<strong>法律文书、司法案例以及法律问答数据</strong>。再进行指令微调训练。</li><li>微调训练数据类别包括<strong>法考题、司法咨询、法律情景问答、触犯法律与罪名预测、刑期预测、法院意见、案件摘要提取</strong>等。</li></ul><h3 id="参考价值-1"><a href="#参考价值-1" class="headerlink" title="参考价值"></a>参考价值</h3><p>构建<strong>司法知识库</strong>从中进行<strong>知识检索并融合</strong>，然后与用户输入共同输入到大模型中达到<strong>知识增强</strong>的目的，从而更好地完成各项任务。<br>    <img src="https://github.com/zhihaiLLM/wisdomInterrogatory/raw/main/pics/%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%84%E5%BB%BA.png" alt="知识库|450"><br>    共收集了 6 种类型的知识库，包括<strong>法条类、案例类、模板类、书籍类、法律考试类、法律日常问答类</strong>。<br>    <img src="https://github.com/zhihaiLLM/wisdomInterrogatory/raw/main/pics/%E7%9F%A5%E8%AF%86%E5%A2%9E%E5%BC%BA_2.png" alt="智海录问原理图|700"><br>    知识融合作为知识增强中的核心部分，将检索到的不同来源的知识融合后输入给法律大模型，让问题本身<strong>附带更多的司法信息</strong>，从而优化提高模型回答的效果。比如询问一个案例如何判罚时，意图识别阶段识别出应在法条库和类案库做检索，我们把和知识库名和其下检索到的知识拼接，再和问题拼接，共同输入到模型生成答案：<br>    - 可参考的知识：<strong>法条：知识 1，知识 2 类案：知识 1，知识 2 问题：XXX，请问这个案例应该如何判罚？</strong></p><hr><h2 id="3-LexiLaw-中文法律大模型"><a href="#3-LexiLaw-中文法律大模型" class="headerlink" title="3. LexiLaw - 中文法律大模型"></a><a href="https://github.com/CSHaitao/LexiLaw#lexilaw---%E4%B8%AD%E6%96%87%E6%B3%95%E5%BE%8B%E5%A4%A7%E6%A8%A1%E5%9E%8B">3. LexiLaw - 中文法律大模型</a></h2><p>LexiLaw 是一个<strong>经过微调的中文法律大模型</strong>，它基于 <strong>ChatGLM-6 B</strong> 架构，通过在法律领域的数据集上进行微调，使其在提供<strong>法律咨询和支持</strong>方面具备更高的性能和专业性。</p><h3 id="数据集-2"><a href="#数据集-2" class="headerlink" title="数据集"></a>数据集</h3><p><strong>通用司法领域相关数据集+知识库</strong></p><ol><li>通用领域数据：通用领域文本数据集 <strong><a href="https://github.com/LianjiaTech/BELLE">BELLE</a></strong> 1.5 M，其中包括不同指令类型、不同领域的文本。</li><li>专业法律数据：常见法律问题和相应的答案。这些问答数据涵盖了多个法律领域，如合同法、劳动法、知识产权等。**<a href="https://github.com/LawRefBook/Laws">法律法规</a>** 包含刑法、民法、宪法、司法解释等法律法规。**<a href="https://jecqa.thunlp.org/">法律参考书籍</a>** JEC-QA 数据集提供的法律参考书籍<ul><li><strong><a href="https://github.com/LiuHC0428/LAW-GPT">LawGPT_zh</a></strong> : 52 k 单轮问答数据和 92 k 带有法律依据的情景问答</li><li><strong><a href="https://github.com/AndrewZhe/lawyer-llama">Lawyer LLaMA</a></strong> : 法考数据和法律指令微调数据</li><li><strong><a href="https://www.66law.cn/">华律网问答数据</a></strong> : 20 k 高质量华律网问答数据</li><li><strong><a href="https://github.com/murufeng/ChineseNlpCorpus/blob/master/datasets/lawzhidao/intro.ipynb">法律知道</a></strong> : 百度知道收集的 36 k 条法律问答数据</li></ul></li><li>法律文书：<br> 使用了包括<strong>判决书、法院裁定书和法律文件</strong>等在内的法律文书。这些文书涵盖了各种法律领域和案件类型，从法律裁判文书网收集 50 k 法律文书，使用正则匹配提取文书的事实部分和裁判分析过程部分。</li></ol><h3 id="参考价值-2"><a href="#参考价值-2" class="headerlink" title="参考价值"></a>参考价值</h3><ol><li>数据集构建可以使用<strong>通用司法数据集</strong>（开源法律数据集、法律文书、司法案例）+<strong>知识库</strong>（法律法规、法律书籍）。</li><li><strong>类案检索设计</strong>的结构感知预训练语言模型 <a href="https://github.com/CSHaitao/SAILER">SAILER</a>。<br> 1. 优点：<br>     (1) SAILER 充分利用<strong>法律案例文档中包含的结构信息</strong>，更加关注关键<strong>法律要素</strong>，类似于法律专家浏览法律案例文档的方式。<br>     (2) SAILER 采用<strong>非对称编码器-解码器架构</strong>，整合了多个不同的预训练目标。这样，跨任务的丰富语义信息就会被编码成<strong>密集向量</strong>。<br>     (3) 即使没有任何法律注释数据，SAILER 也具有强大的判别能力。它能<strong>准确区分不同指控</strong>的法律案件。<ol start="2"><li>展望：<br> “In the future, we would like to explore incorporating more expert knowledge such as legal knowledge graphs and law articles into pre-trained language models for better legal case retrieval.”<em>未来，我们希望探索将更多的专家知识（如<strong>法律知识图谱和法律文章</strong>）纳入预训练语言模型，以便更好地进行法律案件检索</em>。</li></ol></li></ol><hr><h2 id="4-DISC-LawLLM"><a href="#4-DISC-LawLLM" class="headerlink" title="4.DISC-LawLLM"></a><a href="https://github.com/FudanDISC/DISC-LawLLM">4.DISC-LawLLM</a></h2><p>DISC-LawLLM 是一个旨在为用户提供专业、智能、全面的<strong>法律服务</strong>的法律领域大模型，由<a href="http://fudan-disc.com/">复旦大学数据智能与社会计算实验室 (Fudan-DISC)</a> 开发并开源。<br>您可以通过访问这个<a href="https://law.fudan-disc.com/">链接</a>来在线体验我们的 DISC-LawLLM。<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310191047973.png" alt="image.png"></p><h3 id="数据集-3"><a href="#数据集-3" class="headerlink" title="数据集"></a>数据集</h3><p>不同场景下的法律智能应用通常需要<strong>结合法律文本理解和生成</strong>的多种基本能力。为此，我们构建了一个高质量的监督微调数据集 DISC-Law-SFT，包括法律信息提取、判决预测、文档摘要和法律问题解答，确保覆盖不同司法应用场景。DISC-Law-SFT 包括两个子集，即 <strong>DISC-Law-SFT-Pair</strong> 和 D<strong>ISC-Law-SFT-Triplet（<a href="https://huggingface.co/datasets/ShengbinYue/DISC-Law-SFT">下载地址</a>）</strong>。前者旨在为 LLM 引入<strong>法律推理能力</strong>，后者则有助于<strong>提高模型利用外部知识的能力</strong></p><table><thead><tr><th>数据集</th><th>对应任务&#x2F;来源</th><th>样本量</th><th>对应情境</th><th></th><th></th></tr></thead><tbody><tr><td>DISC-Law-SFT-Pair</td><td>司法要素提取</td><td>32 K</td><td>法律专业人员助手</td><td></td><td></td></tr><tr><td></td><td>司法事件检测</td><td>27 K</td><td></td><td></td><td></td></tr><tr><td></td><td>案件分类</td><td>20 K</td><td></td><td></td><td></td></tr><tr><td></td><td>判决预测</td><td>11 K</td><td></td><td></td><td></td></tr><tr><td></td><td>类案匹配</td><td>8 K</td><td></td><td></td><td></td></tr><tr><td></td><td>司法摘要</td><td>9 K</td><td></td><td></td><td></td></tr><tr><td></td><td>舆情摘要</td><td>6 K</td><td></td><td></td><td></td></tr><tr><td></td><td>法律问答</td><td>93 K</td><td>法律咨询服务</td><td></td><td></td></tr><tr><td></td><td>司法阅读理解</td><td>38 K</td><td>法律考试助手</td><td></td><td></td></tr><tr><td></td><td>法律考试</td><td>12 K</td><td></td><td></td><td></td></tr><tr><td>DISC-Law-SFT-Triplet</td><td>判决预测</td><td>16 K</td><td>法律专业人员助手</td><td></td><td></td></tr><tr><td></td><td>法律问答</td><td>23 K</td><td>法律咨询服务</td><td></td><td></td></tr><tr><td>General</td><td>Alpaca-GPT 4</td><td>48 K</td><td>通用场景</td><td></td><td></td></tr><tr><td></td><td>Firefly</td><td>60 K</td><td></td><td></td><td></td></tr><tr><td>总计</td><td>403 K</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="参考价值-3"><a href="#参考价值-3" class="headerlink" title="参考价值"></a>参考价值</h3><ol><li>采用法律逻辑提示策略构建中国司法领域的监督微调数据集，并微调具有法律推理能力的 LLM。我们为 LLM 增加了<strong>检索模块（开源检索框架 <a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a>）</strong>，以增强模型获取和利用外部法律知识的能力。<br> <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310191117205.png"></li><li>提出了一个全面的法律基准–<strong>DISC-Law-Eval</strong>，通过<strong>司法评价数据集</strong>（<em>一系列中国法律标准化考试和知识竞赛的单选和多选</em>题）以及<strong>问答题形式</strong>（<em>法律咨询、在线论坛、与司法相关的出版物和法律文件中手工构建了一个高质量的测试集</em>），从客观和主观两个维度对智能法律系统进行评估.<br> <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310191120327.png" alt="image.png"></li></ol><hr><h1 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h1><h2 id="1-性能评估"><a href="#1-性能评估" class="headerlink" title="1. 性能评估"></a>1. 性能评估</h2><h3 id="1-1-逻辑推理能力"><a href="#1-1-逻辑推理能力" class="headerlink" title="1.1 逻辑推理能力"></a>1.1 逻辑推理能力</h3><p>与医疗、教育、金融等垂直领域不同的是，法律场景的<strong>真实问答</strong>通常涉及很<strong>复杂的逻辑推理</strong>，这要求模型自身有<strong>很强的逻辑能力</strong>。</p><h4 id="1-1-1-解决思路"><a href="#1-1-1-解决思路" class="headerlink" title="1.1.1 解决思路"></a>1.1.1 解决思路</h4><p>可以结合 AutoGPT 将输入的<strong>复杂逻辑问题</strong>进行分解为<strong>多个逻辑简单明确的子问题</strong>，分别对各个子问题进行分析处理。<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202310181042436.jpg" alt="Autogpt回答.jpg"></p><blockquote><p>[!NOTE] <strong>AutoGPT</strong><br>自主运行的 GPT，其运行过程无需或少需人工干预，能够根据 GPT 自主决策结果并结合外部资源执行相应操作，通过循环评估策略实时评估目标达成程度，来决定任务是否完成。<br><img src="https://pic1.zhimg.com/80/v2-c9833275b2304aacaa46423af3faee10_1440w.webp" alt="autogpt原理图"><br>主要特点</p><ol><li>🌐分配要自动处理的任务&#x2F;目标，直到完成</li><li>💾将多个 GPT-4 链接在一起以协作完成任务</li><li>🔗互联网访问和读&#x2F;写文件的能力</li><li>🗃️上下文联动记忆性</li></ol></blockquote><hr><h2 id="2-模型幻觉"><a href="#2-模型幻觉" class="headerlink" title="2. 模型幻觉"></a>2. 模型幻觉</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://zhuanlan.zhihu.com/p/651507945<br>title: &quot;七问大模型幻觉｜LLM Hallucination&quot;<br>description: &quot;在语言模型的背景下，幻觉指的是 一本正经的胡说八道：看似流畅自然的表述，实则不符合事实或者是错误的。幻觉现象的存在严重影响LLM应用的可靠性，本文将探讨大型语言模型(LLMs)的幻觉问题，以及解决幻觉现象的一…&quot;<br>host: zhuanlan.zhihu.com<br>image: https://picx.zhimg.com/v2-8fcec54b8e6a07a5c1eaae4575388082_720w.jpg?source=172ae18b<br></code></pre></td></tr></table></figure><p>在语言模型的背景下，幻觉指的是<strong>一本正经的胡说八道</strong>：看似流畅自然的表述，实则不符合事实或者是错误的，实际上就是模型本身<strong>没有自知之明</strong>的觉悟，幻觉现象的存在严重影响 LLM 应用的<strong>可靠性</strong>。</p><h3 id="2-1-解决思路（如何让模型知之为知之，不知为不知）"><a href="#2-1-解决思路（如何让模型知之为知之，不知为不知）" class="headerlink" title="2.1 解决思路（如何让模型知之为知之，不知为不知）"></a>2.1 解决思路（如何让模型知之为知之，不知为不知）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.zhihu.com/question/613263212/answer/3202893895<br>title: &quot;如何解决LLM大语言模型的幻觉问题？ - 知乎&quot;<br>description: &quot;幻觉（Hallucination）一直大模型比较头疼的问题，为了探索大模型有没有可能知道自己「知道哪些知识」，…&quot;<br>host: www.zhihu.com<br></code></pre></td></tr></table></figure><ul><li>幻觉检测：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://arxiv.org/abs/2303.08896<br>title: &quot;SelfCheckGPT: Zero-Resource Black-Box Hallucination Detection for Generative Large Language Models&quot;<br>description: &quot;Generative Large Language Models (LLMs) such as GPT-3 are capable of generating highly fluent responses to a wide variety of user prompts. However, LLMs are known to hallucinate facts and make non-factual statements which can undermine trust in their output. Existing fact-checking approaches either require access to the output probability distribution (which may not be available for systems such as ChatGPT) or external databases that are interfaced via separate, often complex, modules. In this work, we propose \&quot;SelfCheckGPT\&quot;, a simple sampling-based approach that can be used to fact-check the responses of black-box models in a zero-resource fashion, i.e. without an external database. SelfCheckGPT leverages the simple idea that if an LLM has knowledge of a given concept, sampled responses are likely to be similar and contain consistent facts. However, for hallucinated facts, stochastically sampled responses are likely to diverge and contradict one another. We investigate this approach by using GPT-3 to generate passages about individuals from the WikiBio dataset, and manually annotate the factuality of the generated passages. We demonstrate that SelfCheckGPT can: i) detect non-factual and factual sentences; and ii) rank passages in terms of factuality. We compare our approach to several baselines and show that our approach has considerably higher AUC-PR scores in sentence-level hallucination detection and higher correlation scores in passage-level factuality assessment compared to grey-box methods.&quot;<br>host: arxiv.org<br>favicon: https://static.arxiv.org/static/browse/0.3.4/images/icons/favicon-32x32.png<br>image: https://static.arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png<br></code></pre></td></tr></table></figure></li><li>幻觉检测，评估，消除：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://arxiv.org/abs/2305.15852<br>title: &quot;Self-contradictory Hallucinations of Large Language Models: Evaluation, Detection and Mitigation&quot;<br>description: &quot;Large language models (large LMs) are susceptible to producing text that contains hallucinated content. An important instance of this problem is self-contradiction, where the LM generates two contradictory sentences within the same context. In this work, we present a comprehensive investigation into self-contradiction for various instruction-tuned LMs, covering evaluation, detection, and mitigation. Our analysis reveals the prevalence of self-contradictions when LMs generate text for open-domain topics, e.g., in 17.7% of all sentences produced by ChatGPT. Self-contradiction also complements retrieval-based methods, as a large portion of them (e.g., 35.8% for ChatGPT) cannot be verified using Wikipedia. We then propose a novel prompting-based framework designed to effectively detect and mitigate self-contradictions. Our detector achieves high accuracy, e.g., around 80% F1 score when prompting ChatGPT. The mitigation algorithm iteratively refines the generated text to remove contradictory information while preserving text fluency and informativeness. Importantly, our entire framework is applicable to black-box LMs and does not require external grounded knowledge. Our approach is practically effective and has been released as a push-button tool to benefit the public, available at https://chatprotect.ai/.&quot;<br>host: arxiv.org<br>favicon: https://static.arxiv.org/static/browse/0.3.4/images/icons/favicon-32x32.png<br>image: https://static.arxiv.org/static/browse/0.3.4/images/arxiv-logo-fb.png<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="3-隐私安全"><a href="#3-隐私安全" class="headerlink" title="3. 隐私安全"></a>3. 隐私安全</h2><p>如何在保证数据隐私性的前提下，利用私有数据训练大语言模型，从而满足在垂直领域中的应用需求。<br><u>eg：三星通过 ChatGPT 泄露了自己的秘密</u></p><p>（1）<strong>差分隐私</strong>（Differential Privacy）<br>    差分隐私是一种数据隐私保护技术，通过向数据<strong>引入噪声</strong>来隐藏个体数据，以防止从模型的输出中反推个人信息。差分隐私可用于在保护数据的同时进行大规模数据分析。<br>（2）<strong>联邦学习</strong><br>    联邦学习（Federated learning，FL）是一种机器学习环境，在这种环境下，多个客户端（如移动设备或整个组织）在<strong>中央服务器</strong>（如服务提供商）的协调下<strong>协同训练一个模型</strong>，同时<strong>保持训练数据的分散性</strong>。FL 体现了<strong>集中数据收集和最小化</strong>的原则，可以减轻传统的集中式机器学习和数据科学方法带来的许多隐私、安全性风险和成本。因此，FL 是一种有效的<strong>高性能计算范式</strong>，也被看作是满足数据隐私性要求的<strong>分布式训练方法</strong>，可以用来解决司法领域大模型的隐私安全问题。<br>    1. <em>分散的数据存储</em>：<br>        联邦学习允许<strong>法院、执法机构和其他司法实体将敏感数据保留在本地，而不需要将数据集中存储在一个地方</strong>。这减少了中心化数据存储的风险，降低了数据泄露的潜在威胁。<br>    2. <em>隐私保护的模型训练</em>：<br>        联邦学习<strong>允许在本地设备上进行模型训练，同时避免直接访问或暴露个人数据。每个本地设备只共享模型参数的更新</strong>，而不是原始数据，这有助于保护数据隐私。<br>    3. <em>安全的模型聚合</em>：<br>        在联邦学习中，<strong>中央服务器负责聚合和整合来自本地设备的模型参数更新</strong>。这一过程经过安全的加密和验证，以确保模型更新的完整性和隐私性。<br>    4. <em>差分隐私</em>：<br>        差分隐私技术可以与联邦学习结合，以进一步增强数据隐私保护。通过<strong>向模型参数的更新引入噪声，可以在保持模型性能的同时，提供更高级别的个人数据保护</strong>。</p><hr><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><ol><li>目前司法大模型的研究现状综合来看普遍采用<span style="background:#d3f8b6"><font color="#ff0000">微调模型+知识库</font></span>来实现大模型的司法领域垂直应用<br> （1）<strong>微调模型</strong><br> 采用<em><strong>LLM通用预训练模型+司法数据集</strong></em>（法律法规，法律书籍，司法试题，论坛咨询和司法文书、案例等）<br> （2）<strong>知识库</strong><br> 采用法条、案例、文书、题库、问答等建立司法知识库，借助开源检索框架（ <a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a>）对用户输入进行知识检索获得更多关联信息作为<strong>辅助指导</strong>输入到推理模实现知识增强的效果，从而克服一些模型性能和幻觉问题。</li></ol><blockquote><p>[!NOTE] 思考<br>个人认为在知识库的基础上可以利用<strong>信息抽取技术</strong>将其构建为<strong>知识图谱</strong>，去除冗余信息保留关键实体和关系，再结合<strong>图嵌入机制</strong>将知识图谱实体和关系映射到<strong>低维向量空间</strong>中，从而更好地理解和利用知识图谱的信息，便于实现<strong>图谱融合</strong>，也可结合<strong>矢量和关键词检索</strong>进行知识增强，进而完成下游任务（如<strong>法律咨询、法条检索和类案检索</strong>等）。</p></blockquote><ol start="2"><li>司法大模型<strong>性能评估</strong>方面可以参考上述中的<em>Elo积分评估机制</em>和<em>DISC的客观选择题及主观问答题形式</em>进行模型效果评估。</li><li>隐私安全方面，<strong>联邦学习</strong>可以是一个考虑的方向，目前已经有部分学者在做相关研究（如<strong>FedLLM：在专有数据上建立你自己的大型语言模型</strong>），但是联邦学习用于大模型的适用性还有待考证。</li></ol><hr><h1 id="会议记录"><a href="#会议记录" class="headerlink" title="会议记录"></a>会议记录</h1><ol><li>深度挖掘科学问题的研究，具体有哪些科学研究需要解决？</li><li>数据集构建的目的，如何为后续知识图谱的构建提供便利</li><li>如何构建一个高质量与时俱进的专业领域大模型数据集</li><li>知识图谱中实体对齐和实体链接是两个核心问题</li><li>大模型生成的虚拟数据不能用于自己训练，但是可以用于其他的任务</li><li>大模型的知识检索性能可以用于评估知识图谱</li><li>知识图谱提供指导参考辅助大模型，大模型也可以反哺知识图谱的构建融合</li></ol>]]></content>
    
    
    <summary type="html">some overview about law LLM。</summary>
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="NLP" scheme="https://alleyf.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>残差神经网络</title>
    <link href="https://alleyf.github.io/2023/10/153052cac26f.html"/>
    <id>https://alleyf.github.io/2023/10/153052cac26f.html</id>
    <published>2023-10-18T01:54:31.000Z</published>
    <updated>2023-11-18T14:19:08.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一个残差学习框架，用于训练深度神经网络。通过引入残差块，可以让网络更深，同时避免了梯度消失和梯度弥散的问题。在多个视觉识别任务中，残差网络都取得了比传统网络更好的结果。</p><hr><h2 id="背景介绍（相关研究）"><a href="#背景介绍（相关研究）" class="headerlink" title="背景介绍（相关研究）"></a>背景介绍（相关研究）</h2><p>在近些年中，深度网络逐渐往更深的方向发展，但是更深的网络训练更加困难，因为梯度消失和梯度弥散的问题会导致网络难以收敛。之前的研究提出了一些方法，如使用更好的初始化方法、使用更好的激活函数等，但是这些方法并不能完全解决问题。本文提出了一种新的方法，即残差学习框架，通过引入残差块来解决梯度消失和梯度弥散的问题。<br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308211604278.png" alt="image.png|500"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308211613960.png" alt="image.png|500"></p><hr><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Identity-Mapping-by-Shortcuts"><a href="#Identity-Mapping-by-Shortcuts" class="headerlink" title="Identity Mapping by Shortcuts"></a>Identity Mapping by Shortcuts</h3><p>$$y&#x3D;F(x, \left{ W_{i}\right})+x$$</p><hr><p>$$y&#x3D;F(x, \left{ W_{i}\right})+W_{s}x$$</p><blockquote><p>若残差块输入输出维度一致，则直接短接即可；<br>   若唯独不一致，则对输入进行降维增维处理将输入输出维度统一。</p></blockquote><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308211621589.png" alt="image.png|450"></p><blockquote><p>实现为等维直接短接，虚线为异维进行 A (0 填充) &#x2F;B（投影快捷映射）</p></blockquote><hr><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="ImageNet"><a href="#ImageNet" class="headerlink" title="ImageNet"></a>ImageNet</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308211631231.png" alt="image.png"></p><h3 id="CIFAR-10"><a href="#CIFAR-10" class="headerlink" title="CIFAR-10"></a>CIFAR-10</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308211631353.png" alt="image.png|450"><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308211632281.png" alt="image.png"><br>上图左边指的是 Plain Net, 然而 deeper 的时候，会出现明显的 <strong>degradation</strong>。当深度达到 100+的时候，plain Net 的错误率达到了 60%以上。<br>上图中间这是 ResNet，可以看到当 deeper 的时候，错误率也在降低，并没有出现所谓的 degradation。<br>然而右边则显示 <strong>1202 layers</strong> 的 ResNet 的错误率比 <strong>101 layers</strong> 的<strong>错误率高</strong>，作者认为这<strong>不是 degradation 导致</strong>，而是由于这么<strong>大的参数量在 cifar 10 这个小数据集上过拟合</strong>导致。</p><hr><h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><h3 id="1-残差块"><a href="#1-残差块" class="headerlink" title="1. 残差块"></a>1. 残差块</h3><p>作者发现，当加深模型深度时，模型的测试效果没有变好，反而变差。不符合所想的结果，因为浅层的网络应该是深层网络的一个子集，深层网络不应该比浅层网络表现的不好。然而实验的结果表明，当在浅层网络后加恒等映射层，深层网络的效果反而没有浅层网络好。为什么会出现这种原因呢？作者猜想，可能是因为深层网络难以训练。那么为什么会难以训练呢？可能是因为深层网络的最后面的层难以学习到恒等映射，因为浅层网络已经有很好的表现效果了，最后面的层如果找不到更好的表示效果就需要学习恒等映射，而让网络去学习恒等映射是很困难的。</p><blockquote><p>为了解决网络学习恒等映射困难的问题，作者就想，既然学习恒等映射困难，我们就让网络学习 $f(x)&#x3D;0$ 这个映射。也就引出了参差学习块。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200221174711860.png" alt="20200221174711860.png|400"><br>正常网络的输入是 x ，输出是 f (x)，如果我们要学习恒等映射，也就是让网络的部分学会 f (x)&#x3D;x，即图中 f (x) 的部分学会一个 f (x) &#x3D; x 的映射关系，但是我们说直接让网络去学习恒等映射很困难，怎么办？</p><blockquote><p>假设网络的输出是 h (x)，那么不加 shortcut connection 的网络的输出就是 h (x)&#x3D;f (x)&#x3D;x，为了让网络更好拟合恒等映射，我们让 h (x)&#x3D;f (x)+x，那么我们看网络要学习的映射 f (x)，就变为了 f (x)&#x3D;h (x)−x，这时我们发现，如果直接让 f (x)&#x3D;0，那么 h (x)&#x3D;x，也就是说我们让网络输出的结果和恒等映射相同，而网络只学习了 f (x)&#x3D;0 这个映射，这个映射要比 f (x)&#x3D;x 恒等映射更好学习，即模型会更好训练，而不受深层的影响，因为深层中多余的层我们可以都学恒等映射，最起码结果不会比浅层的结果差。然而实验结果表明，加上 shortcut connection 的深层网络比不加 shortcut connection 的浅层网络效果还好，这也就说明了深层网络所能提取的信息更高，抽象能力更强。</p></blockquote><h3 id="2-恒等快捷映射和投影快捷映射"><a href="#2-恒等快捷映射和投影快捷映射" class="headerlink" title="2. 恒等快捷映射和投影快捷映射"></a>2. 恒等快捷映射和投影快捷映射</h3><p>当 shortcut 的输入通道数和输出通道数相同时，我们可以使用恒等映射即 $f (x)&#x3D;x$，也就是将 shortcut 的输出直接加上输入即可（恒等快捷映射）。<br>但是，当 shortcut connection 的输入不等于输出的时候怎么办？（两种方法）</p><blockquote><p>① 将输入数据扩充维度，多余的维度的数据用 0 填充。<br>② 使用 1 x 1 的卷积扩充维度（投影快捷映射）</p><p>我们实际上有三种方式组合：<br>① 零填充快捷连接用来增加维度，所有的快捷连接是没有参数的。<br>② 投影快捷连接用来增加维度，其它的快捷连接是恒等的。<br>③ 所有的快捷连接都是投影。<br>以上三种情况都比没有加 shortcut connection 的好，效果 ③ &gt; ② &gt; ①，但是 ③ 的计算量太大，提升的效果也不大，所以我们一般不用，我们一般用的最多的是 ②。</p></blockquote><p>投影快捷映射：</p><ul><li>当输入和输出的维度不匹配时，使用一个额外的卷积层来进行维度匹配。</li><li>可以用于解决深度残差网络中的维度不匹配问题，从而提高网络的性能。</li><li>在 ResNet 中，投影快捷映射是指使用一个 1 x 1 的卷积层来进行维度匹配。</li></ul><h3 id="3-Deeper-Bottleneck-Architectures"><a href="#3-Deeper-Bottleneck-Architectures" class="headerlink" title="3. Deeper Bottleneck Architectures"></a>3. Deeper Bottleneck Architectures</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308211610964.png" alt="image.png"></p><blockquote><p>先用 1 x 1 降维，3 x 3 进行卷积，再用 1 x 1 进行升维。<br>   事实上，deeper 左边这种结构也能获得很好的效果。那么为什么要用右边这种结构呢？ 主要是源自于<strong>practical</strong>，因为<strong>左边</strong>这种结构在<strong>训练时间上要比右边结构长的多</strong>。</p></blockquote><p align="justify">当换成上图右边这种 Bottleneck 结构的时候，可以发现 152 层的 ResNet 竟然比 VGG 16/19 都要少的复杂度</p>]]></content>
    
    
    <summary type="html">some overview about NLP papers。</summary>
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="CV" scheme="https://alleyf.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心学习</title>
    <link href="https://alleyf.github.io/2023/10/4977175f9574.html"/>
    <id>https://alleyf.github.io/2023/10/4977175f9574.html</id>
    <published>2023-10-16T04:00:17.000Z</published>
    <updated>2023-11-14T12:57:33.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h2 id="数据库定义语言（DDL）"><a href="#数据库定义语言（DDL）" class="headerlink" title="数据库定义语言（DDL）"></a>数据库定义语言（DDL）</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>我们可以通过 <code>create database</code> 来创建一个数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> create database 数据库名<br></code></pre></td></tr></table></figure><p>为了能够支持中文，我们在创建时可以设定编码格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;<br></code></pre></td></tr></table></figure><p>如果我们创建错误了，我们可以将此数据库删除，通过使用 <code>drop database</code> 来删除一个数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> drop database 数据库名<br></code></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>数据库创建完成后，我们一般通过 <code>create table</code> 语句来创建一张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> create table 表名(列名 数据类型[列级约束条件],  <br>              列名 数据类型[列级约束条件],  <br>              ...  <br>              [,表级约束条件])<br></code></pre></td></tr></table></figure><h3 id="SQL-数据类型"><a href="#SQL-数据类型" class="headerlink" title="SQL 数据类型"></a>SQL 数据类型</h3><p><strong>（1）字符串存储：</strong></p><ul><li>char (n)可以存储任意字符串，但是是固定长度为 n，如果插入的长度小于定义长度时，则用空格填充。</li><li>varchar (n)也可以存储任意数量字符串，长度不固定，但不能超过 n，不会用空格填充。<br><strong>（2）存储数字：</strong></li><li>smallint 用于存储小的整数，范围在 (-32768，32767)</li><li>int 用于存储一般的整数，范围在 (-2147483648，2147483647)</li><li>bigint 用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</li><li>float 用于存储单精度小数</li><li>double 用于存储双精度的小数<br><strong>（3）存储时间：</strong></li><li>date 存储日期</li><li>time 存储时间</li><li>year 存储年份</li><li>datetime 用于混合存储日期+时间</li></ul><h3 id="列级约束条件"><a href="#列级约束条件" class="headerlink" title="列级约束条件"></a>列级约束条件</h3><p>列级约束有六种：主键 Primary key、外键 foreign key 、唯一 unique、检查 check （MySQL 不支持）、默认 default 、非空&#x2F;空值 not null&#x2F; null</p><h3 id="表级约束条件"><a href="#表级约束条件" class="headerlink" title="表级约束条件"></a>表级约束条件</h3><p>表级约束有四种：主键、外键、唯一、检查<br>现在我们通过 SQL 语句来创建我们之前提到的三张表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> [CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]<br></code></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>如果我们想修改表结构，我们可以通过 <code>alter table</code> 来进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> ALTER TABLE 表名[ADD 新列名 数据类型[列级约束条件]]  <br>                              [DROP COLUMN 列名[restrict|cascade]]  <br>                              [ALTER COLUMN 列名 新数据类型]<br></code></pre></td></tr></table></figure><p>我们可以通过 ADD 来添加一个新的列，通过 DROP 来删除一个列，不过我们可以添加 restrict 或 cascade，默认是 restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而 cascade 会强制连带引用此列的约束、视图一起删除。还可以通过 ALTER 来修改此列的属性。</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>我们可以通过 <code>drop table</code> 来删除一个表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> DROP TABLE 表名[restrict|cascade]<br></code></pre></td></tr></table></figure><p>其中 restrict 和 cascade 上面的效果一致。</p><hr><h2 id="数据库操纵语言（DML）"><a href="#数据库操纵语言（DML）" class="headerlink" title="数据库操纵语言（DML）"></a>数据库操纵语言（DML）</h2><p>前面我们已经学习了如何使用 SQL 语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>通过使用 <code>insert into</code> 语句来向数据库中插入一条数据（一条记录）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> INSERT INTO 表名 VALUES(值1, 值2, 值3)<br></code></pre></td></tr></table></figure><p>如果插入的<strong>数据与列一一对应</strong>，那么可以<strong>省略列名</strong>，但是如果希望向指定列上插入数据，就需要给出列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2)<br></code></pre></td></tr></table></figure><p>我们也可以一次性向数据库中插入多条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2)<br></code></pre></td></tr></table></figure><p>我们来试试看向我们刚刚创建的表中添加三条数据。</p><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>我们可以通过 <code>update</code> 语句来更新表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> UPDATE 表名 SET 列名=值,... WHERE 条件<br></code></pre></td></tr></table></figure><p>注意，SQL 语句中的等于判断是 <code>=</code><br>**警告：如果忘记添加 <code>WHERE</code> 字句来限定条件，将使得整个表中此列的所有数据都被修改！</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>我们可以通过使用 <code>delete</code> 来删除表中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> DELETE FROM 表名<br></code></pre></td></tr></table></figure><p>通过这种方式，将删除表中全部数据，我们也可以使用 <code>where</code> 来添加条件，只删除指定的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> DELETE FROM 表名 WHERE 条件<br></code></pre></td></tr></table></figure><hr><h2 id="数据库查询语言（DQL）"><a href="#数据库查询语言（DQL）" class="headerlink" title="数据库查询语言（DQL）"></a>数据库查询语言（DQL）</h2><p>数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。</p><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用 <code>select</code> 语句来进行单表查询：<br> – 指定查询某一列数据  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT 列名[,列名] FROM 表名  <br></code></pre></td></tr></table></figure><p> – 会以别名显示此列  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT 列名 别名 FROM 表名  <br></code></pre></td></tr></table></figure><p> – 查询所有的列数据  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名  <br></code></pre></td></tr></table></figure><p> – 只查询不重复的值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT DISTINCT 列名 FROM 表名<br></code></pre></td></tr></table></figure><p>我们也可以添加 <code>where</code> 字句来限定查询目标：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名 WHERE 条件<br></code></pre></td></tr></table></figure><h3 id="常用查询条件"><a href="#常用查询条件" class="headerlink" title="常用查询条件"></a>常用查询条件</h3><ul><li><p>一般的比较运算符，包括&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D;等。</p></li><li><p>是否在集合中：in、not in</p></li><li><p>字符模糊匹配：like，not like</p></li><li><p>多重条件连接查询：and、or、not</p></li></ul><p>我们来尝试使用一下上面这几种条件。</p><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>我们可以通过 <code>order by</code> 来将查询结果进行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC<br></code></pre></td></tr></table></figure><p>使用 ASC 表示升序排序，使用 DESC 表示降序排序，默认为升序。<br>我们也可以可以同时添加多个排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC<br></code></pre></td></tr></table></figure><p>这样会先按照列名 1 进行排序，每组列名 1 相同的数据再按照列名 2 排序。</p><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>聚集函数一般用作统计，包括：</p><ul><li><p><code>count([distinct]*)</code> 统计所有的行数（distinct 表示去重再统计，下同）</p></li><li><p><code>count([distinct]列名)</code> 统计某列的值总和</p></li><li><p><code>sum([distinct]列名)</code> 求一列的和（注意必须是数字类型的）</p></li><li><p><code>avg([distinct]列名)</code> 求一列的平均值（注意必须是数字类型）</p></li><li><p><code>max([distinct]列名)</code> 求一列的最大值</p></li><li><p><code>min([distinct]列名)</code> 求一列的最小值</p></li></ul><p>一般聚集函数是这样使用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT count(distinct 列名) FROM 表名 WHERE 条件 <br></code></pre></td></tr></table></figure><h3 id="分组和分页查询"><a href="#分组和分页查询" class="headerlink" title="分组和分页查询"></a>分组和分页查询</h3><p>通过使用 <code>group by</code> 来对查询结果进行分组，它需要结合聚合函数一起使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名<br></code></pre></td></tr></table></figure><p>我们还可以添加 <code>having</code> 来限制分组条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件<br></code></pre></td></tr></table></figure><p>我们可以通过 <code>limit</code> 来限制查询的数量，只取前 n 个结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名 LIMIT 数量<br></code></pre></td></tr></table></figure><p>我们也可以进行分页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名 LIMIT 起始位置,数量<br></code></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表1, 表2<br></code></pre></td></tr></table></figure><p>直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表1, 表2 WHERE 条件<br></code></pre></td></tr></table></figure><p>这样，只会从笛卡尔积的结果中得到满足条件的数据。<br>**注意：如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。</p><h3 id="自身连接查询"><a href="#自身连接查询" class="headerlink" title="自身连接查询"></a>自身连接查询</h3><p>自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名 别名1, 表名 别名2<br></code></pre></td></tr></table></figure><p>其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。</p><h3 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h3><p>外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：</p><ul><li><p>通过使用 <code>inner join</code> 进行内连接，只会返回<strong>两个表满足条件的交集部分</strong>：</p></li><li><p>通过使用 <code>left join</code> 进行左连接，不仅会返回两个表满足条件的<strong>交集部分</strong>，也会返回<strong>左边表中的全部数据</strong>，而在右表中缺失的数据会使用 <code>null</code> 来代替（右连接 <code>right join</code> 同理，只是反过来而已，这里就不再介绍了）：</p></li></ul><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>我们可以将查询的结果作为另一个查询的条件，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件)<br></code></pre></td></tr></table></figure><p>我们来再次尝试编写一下在最开始我们查找某教师所有学生的 SQL 语句。</p><hr><h2 id="数据库控制语言（DCL）"><a href="#数据库控制语言（DCL）" class="headerlink" title="数据库控制语言（DCL）"></a>数据库控制语言（DCL）</h2><p>庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>我们可以通过 <code>create user</code> 来创建用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> CREATE USER 用户名 identified by 密码;<br></code></pre></td></tr></table></figure><p>也可以不带密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> CREATE USER 用户名;<br></code></pre></td></tr></table></figure><p>我们可以通过@来限制用户登录的登录 IP 地址，<code>%</code> 表示匹配所有的 IP 地址，默认使用的就是任意 IP 地址。</p><h3 id="登陆用户"><a href="#登陆用户" class="headerlink" title="登陆用户"></a>登陆用户</h3><p>首先需要添加一个环境变量，然后我们通过 cmd 去登陆 mysql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> mysql -u 用户名 -p<br></code></pre></td></tr></table></figure><p>输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> show databases;<br></code></pre></td></tr></table></figure><p>我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！</p><h3 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h3><p>我们可以通过使用 <code>grant</code> 来为一个数据库用户进行授权：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option]<br></code></pre></td></tr></table></figure><p>其中 all 代表授予所有权限，当数据库和表为 <code>*</code>，代表为所有的数据库和表都授权。如果在最后添加了 <code>with grant option</code>，那么被授权的用户还能将已获得的授权继续授权给其他用户。<br>我们可以使用 <code>revoke</code> 来收回一个权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户<br></code></pre></td></tr></table></figure><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。<br>我们可以通过 <code>create view</code> 来创建视图;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION];<br></code></pre></td></tr></table></figure><p>WITH CHECK OPTION 是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用 <code>select</code> 语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。</p><ol><li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li><li>若视图的字段来自字段表达式或常数，则不允许对此视图执行 INSERT 和 UPDATE 操作，但允许执行 DELETE 操作。</li><li>若视图的字段来自集函数，则此视图不允许更新。</li><li>若视图定义中含有 GROUP BY 子句，则此视图不允许更新。</li><li>若视图定义中含有 DISTINCT 短语，则此视图不允许更新。</li><li>若视图定义中有嵌套查询，并且内层查询的 FROM 子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图 GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG (Grade) FROM SC); 　　导出视图 GOOD_SC 的基本表是 SC，内层查询中涉及的表也是 SC，所以视图 GOOD_SC 是不允许更新的。</li><li>一个不允许更新的视图上定义的视图也不允许更新<br>通过 <code>drop</code> 来删除一个视图：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> drop view apptest<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像 Hash 表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：<br> – 创建索引  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> CREATE INDEX 索引名称 ON 表名 (列名)  <br></code></pre></td></tr></table></figure><p> – 查看表中的索引  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> show INDEX FROM student<br></code></pre></td></tr></table></figure><p>我们也可以通过下面的命令删除一个索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> drop index 索引名称 on 表名<br></code></pre></td></tr></table></figure><p>虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在<strong>数据更新时产生额外建立索引的开销</strong>，同时也会<strong>占用磁盘资源</strong>。</p><hr><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h2 id="触发器就像其名字一样，在某种条件下会自动触发，在-select-update-delete-时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。触发器所依附的表称为基本表，当触发器表上发生-select-update-delete-等操作时，会自动生成两个临时的表（new-表和-old-表，只能由触发器使用）比如在-insert-操作时，新的内容会被插入到-new-表中；在-delete-操作时，旧的内容会被移到-old-表中，我们仍可在-old-表中拿到被删除的数据；在-update-操作时，旧的内容会被移到-old-表中，新的内容会出现在-new-表中。FOR-EACH-ROW-表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！通过下面的命令来查看触发器：如果不需要，我们就可以删除此触发器："><a href="#触发器就像其名字一样，在某种条件下会自动触发，在-select-update-delete-时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。触发器所依附的表称为基本表，当触发器表上发生-select-update-delete-等操作时，会自动生成两个临时的表（new-表和-old-表，只能由触发器使用）比如在-insert-操作时，新的内容会被插入到-new-表中；在-delete-操作时，旧的内容会被移到-old-表中，我们仍可在-old-表中拿到被删除的数据；在-update-操作时，旧的内容会被移到-old-表中，新的内容会出现在-new-表中。FOR-EACH-ROW-表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！通过下面的命令来查看触发器：如果不需要，我们就可以删除此触发器：" class="headerlink" title="触发器就像其名字一样，在某种条件下会自动触发，在 select &#x2F; update &#x2F; delete 时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。触发器所依附的表称为基本表，当触发器表上发生 select &#x2F; update &#x2F; delete 等操作时，会自动生成两个临时的表（new 表和 old 表，只能由触发器使用）比如在 insert 操作时，新的内容会被插入到 new 表中；在 delete 操作时，旧的内容会被移到 old 表中，我们仍可在 old 表中拿到被删除的数据；在 update 操作时，旧的内容会被移到 old 表中，新的内容会出现在 new 表中。FOR EACH ROW 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！通过下面的命令来查看触发器：如果不需要，我们就可以删除此触发器："></a>触发器就像其名字一样，在某种条件下会自动触发，在 <code>select</code> &#x2F; <code>update</code> &#x2F; <code>delete</code> 时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。<br>触发器所依附的表称为基本表，当触发器表上发生 <code>select</code> &#x2F; <code>update</code> &#x2F; <code>delete</code> 等操作时，会自动生成两个临时的表（new 表和 old 表，只能由触发器使用）<br>比如在 <code>insert</code> 操作时，新的内容会被插入到 new 表中；在 <code>delete</code> 操作时，旧的内容会被移到 old 表中，我们仍可在 old 表中拿到被删除的数据；在 <code>update</code> 操作时，旧的内容会被移到 old 表中，新的内容会出现在 new 表中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno<br></code></pre></td></tr></table></figure><br>FOR EACH ROW 表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！<br>通过下面的命令来查看触发器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SHOW TRIGGERS<br></code></pre></td></tr></table></figure><br>如果不需要，我们就可以删除此触发器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> DROP TRIGGER 触发器名称<br></code></pre></td></tr></table></figure></h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的 SQL 语句来完成，这些数据库操作语句就可以构成一个事务！只有 <strong>Innodb</strong> 引擎支持事务，我们可以这样来查看支持的引擎：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql"> SHOW ENGINES;<br></code></pre></td></tr></table></figure><p>MySQL 默认采用的是 Innodb 引擎，我们也可以去修改为其他的引擎。<br>事务具有以下特性 ACID：</p><ul><li>**原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>**一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li>**隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>**持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>我们通过以下例子来探究以下事务：<br> begin;   #开始事务<br> …<br> rollback;  #回滚事务<br> savepoint 回滚点;  #添加回滚点<br> rollback to 回滚点; #回滚到指定回滚点<br> …<br> commit; #提交事务<br> – 一旦提交，就无法再进行回滚了！</li></ul><hr><h2 id="选学内容"><a href="#选学内容" class="headerlink" title="选学内容"></a>选学内容</h2><p><strong>函数</strong>和<strong>存储过程</strong>并没有包含在我们的教程当中，但是这并不代表它们就不重要，通过学习它们能够让你的数据库管理能力更上一层楼，它们能够捆绑一组 SQL 语句运行，并且可以反复使用，大大提高工作效率。</p><h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><p>通过（<code>@Data，@Getter，@Setter，@AllArgsConstructor等</code>）注解简化传统繁琐的 <code>get/set</code> 和<strong>构造</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span> <br><span class="hljs-meta">@AllArgsConstructor</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123; <br><span class="hljs-keyword">private</span> Integer sid; <br><span class="hljs-keyword">private</span> String name; <br><span class="hljs-keyword">private</span> String sex; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Lombok 之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！</p></blockquote><h2 id="配置-Lombok"><a href="#配置-Lombok" class="headerlink" title="配置 Lombok"></a>配置 Lombok</h2><ul><li>首先我们需要<strong>导入 Lombok 的 jar 依赖</strong>，和 jdbc 依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：<a href="https://projectlombok.org/download">Lombok</a></li><li>然后我们要安装一下 Lombok 插件，由于 IDEA<strong>默认都安装了 Lombok 的插件</strong>，因此直接导入依赖后就可以使用了。</li><li>重启 IDEA</li></ul><p>Lombok 是一种插件化注解 API，是通过添加注解来实现的，然后在<strong>javac</strong>进行编译的时候，进行处理。<br>Java 的编译过程可以分成三个阶段：<br><img src="https://image.itbaima.net/markdown/2023/03/06/fUEondmywKNucOW.png"></p><ol><li>所有源文件会被解析成语法树。</li><li>调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。</li><li>最后，语法树会被分析并转化成类文件。</li></ol><p>实际上在上述的第二阶段，会执行 <a href="https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/core/AnnotationProcessor.java">lombok.core.AnnotationProcessor</a>，它所做的工作就是我们上面所说的，修改语法树。</p><h2 id="使用-Lombok"><a href="#使用-Lombok" class="headerlink" title="使用 Lombok"></a>使用 Lombok</h2><ol><li><code>@Getter</code> 和 <code>@Setter</code> 来为当前类的所有字段生成 <code>get/set方法</code>，他们可以添加到类或是字段上，注意<strong>静态字段不会生成，final 字段无法生成 set 方法</strong>。<ul><li>我们还可以使用 <code>@Accessors</code> 来控制生成 Getter 和 Setter 的<strong>样式</strong>。</li></ul></li><li><code>@ToString</code> 来为当前类生成预设的<strong>toString 方法</strong>。</li><li><code>@EqualsAndHashCode</code> 来快速生成<strong>比较和哈希值方法</strong>。</li><li><code>@AllArgsConstructor</code> 和 <code>@NoArgsConstructor</code> 来快速生成<strong>全参构造和无参构造</strong>。</li><li><code>@RequiredArgsConstructor</code> 来快速生成参数只包含 <code>final</code> 或被标记为 <code>@NonNull</code> 的成员字段。</li><li><code>@Data</code> 能代表 <code>@Setter</code>、<code>@Getter</code>、<code>@RequiredArgsConstructor</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code> 全部注解。<ul><li>一旦使用 <code>@Data</code> 就<strong>不建议此类有继承关系</strong>，因为 <code>equal</code> 方法可能不符合预期结果（尤其是仅比较子类属性）。</li></ul></li><li><code>@Value</code> 与 <code>@Data</code> 类似，但是并<strong>不会生成 setter</strong>并且<strong>成员属性都是 final 的</strong>。</li><li><code>@SneakyThrows</code> 来自动生成<strong>try-catch</strong>代码块。</li><li><code>@Cleanup</code> 作用与局部变量，在最后自动调用其 <code>close()</code> 方法（可以自由更换）</li><li><code>@Builder</code> 来快速生成建造者模式。<ul><li>通过使用 <code>@Builder.Default</code> 来指定默认值。</li><li>通过使用 <code>@Builder.ObtainVia</code> 来指定默认值的获取方式。</li></ul></li></ol><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs (Plain Ordinary Java Object, 普通的 Java 对象)映射成数据库中的记录。</p><h2 id="XML-语言概述"><a href="#XML-语言概述" class="headerlink" title="XML 语言概述"></a>XML 语言概述</h2><p>XML 语言发明最初是用于数据的存储和传输:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">outer</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿伟<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">desc</span>&gt;</span>怎么又在玩电动啊<span class="hljs-tag">&lt;/<span class="hljs-name">desc</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">inner</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">sex</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">sex</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">inner</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">outer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML 主要用于通过编排来展示数据，而 XML 主要是存放数据，它更像是一个配置文件！<br>一个 XML 文件存在以下的格式规范：</p><ul><li>必须存在一个<strong>根节点</strong>，将所有的子标签全部包含。</li><li>可以但不必须包含一个<strong>头部声明</strong>（主要是可以设定编码格式）</li><li>所有的<strong>标签必须成对出现</strong>，可以嵌套但不能交叉嵌套</li><li>区分大小写。</li><li>标签中<strong>可以存在属性</strong>，比如上面的 <code>type=&quot;1&quot;</code> 就是 <code>inner</code> 标签的一个属性，属性的值由单引号或双引号包括。</li></ul><p>XML 文件也可以使用注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-comment">&lt;!-- 注释内容 --&gt;</span><br></code></pre></td></tr></table></figure><p>XML 的转义字符:<br><img src="https://image.itbaima.net/markdown/2023/03/06/j5WEDVxYJ8KSkHt.jpg"><br>可以使用 <code>CD</code> 来快速创建不解析区域：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>&lt;![CDATA[我看你&lt;&gt;&lt;&gt;&lt;&gt;是一点都不懂哦&gt;&gt;&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JDK 为我们内置了一个叫做 <code>org.w3c</code> 的 XML 解析库来进行 XML 文件内容解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 创建DocumentBuilderFactory对象  </span><br> <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();  <br> <span class="hljs-comment">// 创建DocumentBuilder对象  </span><br> <span class="hljs-keyword">try</span> &#123;  <br>     <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> factory.newDocumentBuilder();  <br>     <span class="hljs-type">Document</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> builder.parse(<span class="hljs-string">&quot;file:mappers/test.xml&quot;</span>);  <br>     <span class="hljs-comment">// 每一个标签都作为一个节点  </span><br>     <span class="hljs-type">NodeList</span> <span class="hljs-variable">nodeList</span> <span class="hljs-operator">=</span> d.getElementsByTagName(<span class="hljs-string">&quot;test&quot;</span>);  <span class="hljs-comment">// 可能有很多个名字为test的标签  </span><br>     <span class="hljs-type">Node</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> nodeList.item(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取首个  </span><br> ​  <br>     <span class="hljs-type">NodeList</span> <span class="hljs-variable">childNodes</span> <span class="hljs-operator">=</span> rootNode.getChildNodes(); <span class="hljs-comment">// 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点  </span><br>     <span class="hljs-comment">//节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容  </span><br> ​  <br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; childNodes.getLength(); i++) &#123;  <br>         <span class="hljs-type">Node</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> childNodes.item(i);  <br>         <span class="hljs-keyword">if</span>(child.getNodeType() == Node.ELEMENT_NODE)  <span class="hljs-comment">//过滤换行符之类的内容，因为它们都被认为是一个文本节点  </span><br>         System.out.println(child.getNodeName() + <span class="hljs-string">&quot;：&quot;</span> +child.getFirstChild().getNodeValue());  <br>         <span class="hljs-comment">// 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点）  </span><br>     &#125;  <br> &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>     e.printStackTrace();  <br> &#125;<br></code></pre></td></tr></table></figure><p>当然，学习和使用 XML 只是为了更好地去认识 Mybatis 的工作原理，以及如何使用 XML 来作为 Mybatis 的配置文件，这是在开始之前必须要掌握的内容（需要知道 Mybatis 就是通过这种方式来读取配置文件的）<br>不仅仅是 Mybatis，包括后面的 Spring 等众多框架都会用到 XML 来作为框架的配置文件！</p><h2 id="初次使用-Mybatis"><a href="#初次使用-Mybatis" class="headerlink" title="初次使用 Mybatis"></a>初次使用 Mybatis</h2><p>那么我们首先来感受一下 Mybatis 给我们带来的便捷，就从搭建环境开始，中文文档网站：<a href="https://mybatis.org/mybatis-3/zh/configuration.html">https://mybatis.org/mybatis-3/zh/configuration.html</a><br>我们需要导入 Mybatis 的依赖，Jar 包需要在 github 上下载，同样地放入到项目的根目录下，右键作为依赖即可！（依赖变多之后，我们可以将其放到一个单独的文件夹，不然会很繁杂）<br>依赖导入完成后，我们就可以编写 Mybatis 的配置文件了（现在不是在 Java 代码中配置了，而是通过一个 XML 文件去配置，这样就使得硬编码的部分大大减少，项目后期打包成 Jar 运行不方便修复，但是通过配置文件，我们随时都可以去修改，就变得很方便了，同时代码量也大幅度减少，配置文件填写完成后，我们只需要关心项目的业务逻辑而不是如何去读取配置文件）我们按照官方文档给定的提示，在项目根目录下新建名为 <code>mybatis-config.xml</code> 的文件，并填写以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>  <br> <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span>  </span><br><span class="hljs-meta">   <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span><br><span class="hljs-meta">   <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>       <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>  <br>       <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span>  <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最上方还引入了一个叫做 DTD（文档类型定义）的东西，它提前帮助我们规定了一些标签，我们就需要使用 Mybatis 提前帮助我们规定好的标签来进行配置（因为只有这样 Mybatis 才能正确识别我们配置的内容）<br>通过进行配置，我们就告诉了 Mybatis 我们链接数据库的一些信息，包括 URL、用户名、密码等，这样 Mybatis 就知道该链接哪个数据库、使用哪个账号进行登陆了（也可以不使用配置文件）<br>配置文件完成后，我们需要在 Java 程序启动时，让 Mybatis 对配置文件进行读取并得到一个 <code>SqlSessionFactory</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;  <br>     <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>))&#123;  <br>             <span class="hljs-comment">//暂时还没有业务  </span><br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>直接运行即可，虽然没有干什么事情，但是不会出现错误，如果之前的配置文件编写错误，直接运行会产生报错！那么现在我们来看看，<code>SqlSessionFactory</code> 对象是什么东西：<br><img src="https://s2.loli.net/2023/03/06/67AJEFCsKoin3Hd.jpg" alt="img"><br>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过 <code>SqlSessionFactory</code> 来创建多个新的会话，<code>SqlSession</code> 对象，每个会话就相当于我不同的地方登陆一个账号去访问数据库，你也可以认为这就是之前 JDBC 中的 <code>Statement</code> 对象，会话之间相互隔离，没有任何关联。<br>而通过 <code>SqlSession</code> 就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。<br>我们来尝试一下直接读取实体类，读取实体类肯定需要一个映射规则，比如类中的哪个字段对应数据库中的哪个字段，在查询语句返回结果后，Mybatis 就会自动将对应的结果填入到对象的对应字段上。首先编写实体类，，直接使用 Lombok 是不是就很方便了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">import</span> lombok.Data;  <br> ​  <br> <span class="hljs-meta">@Data</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>     <span class="hljs-type">int</span> sid;   <span class="hljs-comment">//名称最好和数据库字段名称保持一致，不然可能会映射失败导致查询结果丢失  </span><br>     String name;  <br>     String sex;  <br> &#125;<br></code></pre></td></tr></table></figure><p>在根目录下重新创建一个 mapper 文件夹，新建名为 <code>TestMapper.xml</code> 的文件作为我们的映射器，并填写以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>  <br> <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span>  </span><br><span class="hljs-meta">         <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span><br><span class="hljs-meta">         <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;TestMapper&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span>&gt;</span>  <br>         select * from student  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 namespace 就是命名空间，每个 Mapper 都是唯一的，因此需要用一个命名空间来区分，它还可以用来绑定一个接口。我们在里面写入了一个 select 标签，表示添加一个 select 操作，同时 id 作为操作的名称，resultType 指定为我们刚刚定义的实体类，表示将数据库结果映射为 <code>Student</code> 类，然后就在标签中写入我们的查询语句即可。<br>编写好后，我们在配置文件中添加这个 Mapper 映射器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:mappers/TestMapper.xml&quot;</span>/&gt;</span>  <br>     <span class="hljs-comment">&lt;!--    这里用的是url，也可以使用其他类型，我们会在后面讲解    --&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后在程序中使用我们定义好的 Mapper 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;  <br>     <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>))&#123;  <br>         List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string">&quot;selectStudent&quot;</span>);  <br>         student.forEach(System.out::println);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>我们会发现，Mybatis 非常智能，我们只需要告诉一个映射关系，就能够直接将查询结果转化为一个实体类！</p><h2 id="配置-Mybatis"><a href="#配置-Mybatis" class="headerlink" title="配置 Mybatis"></a>配置 Mybatis</h2><p>在了解了 Mybatis 为我们带来的便捷之后，现在我们就可以正式地去学习使用 Mybatis 了！<br>由于 <code>SqlSessionFactory</code> 一般只需要创建一次，因此我们可以创建一个工具类来集中创建 <code>SqlSession</code>，这样会更加方便一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtil</span> &#123;  <br> ​  <br>     <span class="hljs-comment">//在类加载时就进行创建  </span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;  <br>     <span class="hljs-keyword">static</span> &#123;  <br>         <span class="hljs-keyword">try</span> &#123;  <br>             sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>));  <br>         &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;  <br>             e.printStackTrace();  <br>         &#125;  <br>     &#125;  <br> ​  <br>     <span class="hljs-comment">/**  </span><br><span class="hljs-comment">      * 获取一个新的会话  </span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作）  </span><br><span class="hljs-comment">      * <span class="hljs-doctag">@return</span> SqlSession对象  </span><br><span class="hljs-comment">      */</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> autoCommit)</span>&#123;  <br>         <span class="hljs-keyword">return</span> sqlSessionFactory.openSession(autoCommit);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>现在我们只需要在 main 方法中这样写即可查询结果了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession(<span class="hljs-literal">true</span>))&#123;  <br>         List&lt;Student&gt; student = sqlSession.selectList(<span class="hljs-string">&quot;selectStudent&quot;</span>);  <br>         student.forEach(System.out::println);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>之前我们演示了，如何创建一个映射器来将结果快速转换为实体类，但是这样可能还是不够方便，我们每次都需要去找映射器对应操作的名称，而且还要知道对应的返回类型，再通过 <code>SqlSession</code> 来执行对应的方法，能不能再方便一点呢？<br>现在，我们可以通过 <code>namespace</code> 来绑定到一个接口上，利用接口的特性，我们可以直接指明方法的行为，而实际实现则是由 Mybatis 来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestMapper</span> &#123;  <br>     List&lt;Student&gt; <span class="hljs-title function_">selectStudent</span><span class="hljs-params">()</span>;  <br> &#125;<br></code></pre></td></tr></table></figure><p>将 Mapper 文件的命名空间修改为我们的接口，建议同时将其放到同名包中，作为内部资源：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span>&gt;</span>  <br>         select * from student  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>作为内部资源后，我们需要修改一下配置文件中的 mapper 定义，不使用 url 而是 resource 表示是 Jar 内部的文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/test/mapper/TestMapper.xml&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们就可以直接通过 <code>SqlSession</code> 获取对应的实现类，通过接口中定义的行为来直接获取结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession(<span class="hljs-literal">true</span>))&#123;  <br>         <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(TestMapper.class);  <br>         List&lt;Student&gt; student = testMapper.selectStudent();  <br>         student.forEach(System.out::println);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>那么肯定有人好奇，TestMapper 明明是一个我们自己定义接口啊，Mybatis 也不可能提前帮我们写了实现类啊，那这接口怎么就出现了一个实现类呢？我们可以通过调用 <code>getClass()</code> 方法来看看实现类是个什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(TestMapper.class);  <br> System.out.println(testMapper.getClass());<br></code></pre></td></tr></table></figure><p>我们发现，实现类名称很奇怪，名称为 <code>com.sun.proxy.$Proxy4</code>，它是通过<strong>动态代理</strong>生成的，相当于动态生成了一个实现类，而不是预先定义好的，有关 Mybatis 这一部分的原理，我们放在最后一节进行讲解。<br>接下来，我们再来看配置文件，之前我们并没有对配置文件进行一个详细的介绍：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>  <br>             <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>  <br>             <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>  <br>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  <br>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;</span>  <br>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span>  <br>                 <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>  <br>             <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/test/mapper/TestMapper.xml&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>首先就从 <code>environments</code> 标签说起，一般情况下，我们在开发中，都需要指定一个数据库的配置信息，包含连接 URL、用户、密码等信息，而 <code>environment</code> 就是用于进行这些配置的！实际情况下可能会不止有一个数据库连接信息，比如开发过程中我们一般会使用本地的数据库，而如果需要将项目上传到服务器或是防止其他人的电脑上运行时，我们可能就需要配置另一个数据库的信息，因此，我们可以提前定义好所有的数据库信息，该什么时候用什么即可！<br>在 <code>environments</code> 标签上有一个 default 属性，来指定默认的环境，当然如果我们希望使用其他环境，可以修改这个默认环境，也可以在创建工厂时选择环境：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span> ()  <br>         .build (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (<span class="hljs-string">&quot;mybatis-config. xml&quot;</span>), <span class="hljs-string">&quot;环境 ID&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们还可以给类型起一个别名，以简化 Mapper 的编写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- 需要在environments的上方 --&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.test.entity.Student&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Student&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在 Mapper 就可以直接使用别名了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>         select * from student  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果这样还是很麻烦，我们也可以直接让 Mybatis 去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名）</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.test.entity&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以为指定实体类添加一个注解，来指定别名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span>  <br> <span class="hljs-meta">@Alias</span> (<span class="hljs-string">&quot;lbwnb&quot;</span>)  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sid;  <br>     <span class="hljs-keyword">private</span> String name;  <br>     <span class="hljs-keyword">private</span> String sex;  <br> &#125;<br></code></pre></td></tr></table></figure><p>当然，Mybatis 也包含许多的基础配置，通过使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>在前面我们演示了如何快速进行查询，我们只需要编写一个对应的映射器既可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>         select * from student  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，如果你不喜欢使用实体类，那么这些属性还可以被映射到一个 Map 上：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Map&quot;</span>&gt;</span>  <br>     select * from student  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestMapper</span> &#123;  <br>     List&lt;Map&gt; <span class="hljs-title function_">selectStudent</span> <span class="hljs-params">()</span>;  <br> &#125;<br></code></pre></td></tr></table></figure><p>Map 中就会以键值对的形式来存放这些结果了。<br>通过设定一个 <code>resultType</code> 属性，让 Mybatis 知道查询结果需要映射为哪个实体类，要求字段名称保持一致。那么如果我们不希望按照这样的规则来映射呢？我们可以自定义 <code>resultMap</code> 来设定映射规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过指定映射规则，我们现在名称和性别一栏就发生了交换，因为我们将其映射字段进行了交换。<br>如果一个类中存在多个构造方法，那么很有可能会出现这样的错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> ### Exception in thread <span class="hljs-string">&quot;main&quot;</span> org. apache. ibatis. exceptions. PersistenceException:   <br> ### Error querying database.  Cause: org. apache. ibatis. executor. ExecutorException: No constructor found in com. test. entity. Student matching [java. lang. Integer, java. lang. String, java. lang. String]  <br> ### The error may exist in com/test/mapper/TestMapper. xml  <br> ### The error may involve com. test. mapper. TestMapper. getStudentBySid  <br> ### The error occurred <span class="hljs-keyword">while</span> handling results  <br> ### SQL: select * from student <span class="hljs-type">where</span> <span class="hljs-variable">sid</span> <span class="hljs-operator">=</span> ?  <br> ### Cause: org. apache. ibatis. executor. ExecutorException: No constructor found in com. test. entity. Student matching [java. lang. Integer, java. lang. String, java. lang. String]  <br>     at org.apache.ibatis.exceptions.ExceptionFactory.wrapException (ExceptionFactory. java:<span class="hljs-number">30</span>)  <br>     ...<br></code></pre></td></tr></table></figure><p>这时就需要使用 <code>constructor</code> 标签来指定构造方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Integer&quot;</span>/&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;String&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，<strong>指定构造方法后，若此字段被填入了构造方法作为参数，将不会通过反射给字段单独赋值，而构造方法中没有传入的字段，依然会被反射赋值</strong><br>如果数据库中存在一个带下划线的字段，我们可以通过设置让其映射为以驼峰命名的字段，比如 <code>my_test</code> 映射为 <code>myTest</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果不设置，默认为不开启，也就是默认需要名称保持一致。<br>我们接着来看看条件查询，既然是条件查询，那么肯定需要我们传入查询条件，比如现在我们想通过 sid 字段来通过学号查找信息：<br> <code>Student getStudentBySid (int sid);</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>     select * from student where sid = #&#123;sid&#125;  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们通过使用 <code>#&#123;xxx&#125;</code> 或是 <code>$&#123;xxx&#125;</code> 来填入我们给定的属性，实际上 Mybatis 本质也是通过 <code>PreparedStatement</code> 首先进行一次预编译，有效地防止 SQL 注入问题，但是如果使用 <code>$&#123;xxx&#125;</code> 就不再是通过预编译，而是直接传值，因此我们一般都使用 <code>#&#123;xxx&#125;</code> 来进行操作。<br>使用 <code>parameterType</code> 属性来指定参数类型（非必须，可以不用，推荐不用）<br>接着我们来看插入、更新和删除操作，其实与查询操作差不多，不过需要使用对应的标签，比如插入操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>     insert into student (name, sex) values (#&#123;name&#125;, #&#123;sex&#125;)  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <code>int addStudent (Student student);</code><br>我们这里使用的是一个实体类，我们可以直接使用实体类里面对应属性替换到 SQL 语句中，只需要填写属性名称即可，和条件查询是一样的。</p><h2 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h2><p>一个老师可以教授多个学生，那么能否一次性将老师的学生全部映射给此老师的对象呢，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;  <br>     <span class="hljs-type">int</span> tid;  <br>     String name;  <br>     List&lt;Student&gt; studentList;  <br> &#125;<br></code></pre></td></tr></table></figure><p>映射为 Teacher 对象时，同时将其教授的所有学生一并映射为 List 列表，显然这是一种一对多的查询，那么这时就需要进行复杂查询了。而我们之前编写的都非常简单，直接就能完成映射，因此我们现在需要使用 <code>resultMap</code> 来自定义映射规则：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacherByTid&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;asTeacher&quot;</span>&gt;</span>  <br>         select *, teacher. name as tname from student inner join teach on student. sid = teach. sid  <br>                               inner join teacher on teach. tid = teacher. tid where teach. tid = #&#123;tid&#125;  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;asTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;studentList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们的查询结果是一个多表联查的结果，而联查的数据就是我们需要映射的数据（比如这里是一个老师有 N 个学生，联查的结果也是这一个老师对应 N 个学生的 N 条记录），其中 <code>id</code> 标签用于在多条记录中辨别是否为同一个对象的数据，比如上面的查询语句得到的结果中，<code>tid</code> 这一行始终为 <code>1</code>，因此所有的记录都应该是 <code>tid=1</code> 的教师的数据，而不应该变为多个教师的数据，如果不加 id 进行约束，那么会被识别成多个教师的数据！<br>通过使用 <code>collection</code> 来表示将得到的所有结果合并为一个集合，比如上面的数据中每个学生都有单独的一条记录，因此 tid 相同的全部学生的记录就可以最后合并为一个 List，得到最终的映射结果，当然，为了区分，最好也设置一个 id，只不过这个例子中可以当做普通的 <code>result</code> 使用。<br>了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在 Student 新增了一个 Teacher 对象，那么现在又该如何去处理呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span>  <br> <span class="hljs-meta">@Accessors</span> (chain = <span class="hljs-literal">true</span>)  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sid;  <br>     <span class="hljs-keyword">private</span> String name;  <br>     <span class="hljs-keyword">private</span> String sex;  <br>     <span class="hljs-keyword">private</span> Teacher teacher;  <br> &#125;  <br> ​  <br> <span class="hljs-meta">@Data</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;  <br>     <span class="hljs-type">int</span> tid;  <br>     String name;  <br> &#125;<br></code></pre></td></tr></table></figure><p>现在我们希望的是，每次查询到一个 Student 对象时都带上它的老师，同样的，我们也可以使用 <code>resultMap</code> 来实现（先修改一下老师的类定义，不然会很麻烦）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span>  <br>         <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;test2&quot;</span>&gt;</span>  <br>     select *, teacher. name as tname from student left join teach on student. sid = teach. sid  <br>                                                  left join teacher on teach. tid = teacher. tid  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过使用 <code>association</code> 进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。</p><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>我们可以在获取 <code>SqlSession</code> 关闭自动提交来开启事务模式，和 JDBC 其实都差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">false</span>))&#123;  <br>         <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br> ​  <br>         testMapper.addStudent (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> (). setSex (<span class="hljs-string">&quot;男&quot;</span>). setName (<span class="hljs-string">&quot;小王&quot;</span>));  <br> ​  <br>         testMapper.selectStudent (). forEach (System. out::println);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>我们发现，在关闭自动提交后，我们的内容是没有进入到数据库的，现在我们来试一下在最后提交事务：<br> <code>sqlSession.commit ();</code><br>在事务提交后，我们的内容才会被写入到数据库中。现在我们来试试看回滚操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">false</span>))&#123;  <br>     <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br> ​  <br>     testMapper.addStudent (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> (). setSex (<span class="hljs-string">&quot;男&quot;</span>). setName (<span class="hljs-string">&quot;小王&quot;</span>));  <br> ​  <br>     testMapper.selectStudent (). forEach (System. out::println);  <br>     sqlSession.rollback ();  <br>     sqlSession.commit ();  <br> &#125;<br></code></pre></td></tr></table></figure><p>回滚操作也印证成功。</p><h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。<br>其实缓存机制我们在之前学习 IO 流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。<br>因此 Mybatis 内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。<br><img src="https://s2.loli.net/2023/03/06/612LxT98tskrnCz.png" alt="image-20230306163638882"><br>Mybatis 存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>         <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br>         Student student <span class="hljs-number">1</span> = testMapper.getStudentBySid (<span class="hljs-number">1</span>);  <br>         Student student <span class="hljs-number">2</span> = testMapper.getStudentBySid (<span class="hljs-number">1</span>);  <br>         System.out.println (student <span class="hljs-number">1</span> == student <span class="hljs-number">2</span>);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>我们发现，两次得到的是同一个 Student 对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span>  <br> <span class="hljs-meta">@Accessors</span> (chain = <span class="hljs-literal">true</span>)  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br> ​  <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span> <span class="hljs-params">()</span>&#123;  <br>         System.out.println (<span class="hljs-string">&quot;我被构造了&quot;</span>);  <br>     &#125;  <br> ​  <br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sid;  <br>     <span class="hljs-keyword">private</span> String name;  <br>     <span class="hljs-keyword">private</span> String sex;  <br> &#125;<br></code></pre></td></tr></table></figure><p>我们通过前面的学习得知 Mybatis 在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。<br>结果显而易见，<strong>只创建了一次</strong>，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为<strong>第一次的结果已经被缓存了</strong>。<br>那么如果我修改了数据库中的内容，缓存还会生效吗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>         <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br>         Student student <span class="hljs-number">1</span> = testMapper.getStudentBySid (<span class="hljs-number">1</span>);  <br>         testMapper.addStudent (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> (). setName (<span class="hljs-string">&quot;小李&quot;</span>). setSex (<span class="hljs-string">&quot;男&quot;</span>));  <br>         Student student <span class="hljs-number">2</span> = testMapper.getStudentBySid (<span class="hljs-number">1</span>);  <br>         System.out.println (student <span class="hljs-number">1</span> == student <span class="hljs-number">2</span>);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。<br>也就是说，<strong>一级缓存，在进行 DML 操作后，会使得缓存失效</strong>，也就是说 Mybatis 知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，<strong>一级缓存只针对于单个会话，多个会话之间不相通</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>         <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br> ​  <br>         Student student <span class="hljs-number">2</span>;  <br>         <span class="hljs-keyword">try</span> (SqlSession sqlSession <span class="hljs-number">2</span> = MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>             TestMapper testMapper <span class="hljs-number">2</span> = sqlSession <span class="hljs-number">2.</span>getMapper (TestMapper. class);  <br>             student <span class="hljs-number">2</span> = testMapper <span class="hljs-number">2.</span>getStudentBySid (<span class="hljs-number">1</span>);  <br>         &#125;  <br> ​  <br>         Student student <span class="hljs-number">1</span> = testMapper.getStudentBySid (<span class="hljs-number">1</span>);  <br>         System.out.println (student <span class="hljs-number">1</span> == student <span class="hljs-number">2</span>);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>**注意：一个会话 DML 操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！<br>一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器 XML 文件中添加：<br> <code>&lt;cache/&gt;</code><br>可见二级缓存是 Mapper 级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">cache</span>  </span><br><span class="hljs-tag">   <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span>  </span><br><span class="hljs-tag">   <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span>  </span><br><span class="hljs-tag">   <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span>  </span><br><span class="hljs-tag">   <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>我们来编写一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>     Student student;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>         <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br>         student = testMapper.getStudentBySid (<span class="hljs-number">1</span>);  <br>     &#125;  <br> ​  <br>     <span class="hljs-keyword">try</span> (SqlSession sqlSession <span class="hljs-number">2</span> = MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>         TestMapper testMapper <span class="hljs-number">2</span> = sqlSession <span class="hljs-number">2.</span>getMapper (TestMapper. class);  <br>         Student student <span class="hljs-number">2</span> = testMapper <span class="hljs-number">2.</span>getStudentBySid (<span class="hljs-number">1</span>);  <br>         System.out.println (student <span class="hljs-number">2</span> == student);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。<br>那么如果我不希望某个方法开启缓存呢？我们可以添加 useCache 属性来关闭缓存：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>  <br>     select * from student where sid = #&#123;sid&#125;  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们也可以使用 <code>flushCache=&quot;false&quot;</code> 在每次执行后都清空缓存，通过这这个我们还可以控制 DML 操作完成之后不清空缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>  <br>     select * from student where sid = #&#123;sid&#125;  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加了二级缓存之后，<strong>会先从二级缓存中查找数据</strong>，当二级缓存中没有时，<strong>才会从一级缓存中获取</strong>，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>         <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br> ​  <br>         Student student <span class="hljs-number">2</span>;  <br>         <span class="hljs-keyword">try</span> (SqlSession sqlSession <span class="hljs-number">2</span> = MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>             TestMapper testMapper <span class="hljs-number">2</span> = sqlSession <span class="hljs-number">2.</span>getMapper (TestMapper. class);  <br>             student <span class="hljs-number">2</span> = testMapper <span class="hljs-number">2.</span>getStudentBySid (<span class="hljs-number">1</span>);  <br>         &#125;  <br> ​  <br>         Student student <span class="hljs-number">1</span> = testMapper.getStudentBySid (<span class="hljs-number">1</span>);  <br>         System.out.println (student <span class="hljs-number">1</span> == student <span class="hljs-number">2</span>);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。<br>读取顺序：<strong>二级缓存 &#x3D;&gt; 一级缓存 &#x3D;&gt; 数据库</strong><br><img src="https://s2.loli.net/2023/03/06/f2slhXr68k3WpIM.png" alt="image-20230306163717033"><br>虽然缓存机制给我们提供了很大的性能提升，但是缓存存在一个问题，我们之前在 <code>计算机组成原理</code> 中可能学习过缓存一致性问题，也就是说当多个 CPU 在操作自己的缓存时，可能会出现各自的缓存内容不同步的问题，而 Mybatis 也会这样，我们来看看这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  <br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtil.getSession (<span class="hljs-literal">true</span>))&#123;  <br>        <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;  <br>            Thread.sleep (<span class="hljs-number">3000</span>);  <br>            System.out.println (testMapper.getStudentBySid (<span class="hljs-number">1</span>));  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在循环地每三秒读取一次，而在这个过程中，我们使用 IDEA 手动修改数据库中的数据，将 1 号同学的学号改成 100，那么理想情况下，下一次读取将无法获取到小明，因为小明的学号已经发生变化了。<br>但是结果却是依然能够读取，并且 sid 并没有发生改变，这也证明了 Mybatis 的缓存在生效，因为我们是从外部进行修改，Mybatis 不知道我们修改了数据，所以依然在使用缓存中的数据，但是这样很明显是不正确的，因此，<strong>如果存在多台服务器或者是多个程序都在使用 Mybatis 操作同一个数据库，并且都开启了缓存，需要解决这个问题，要么就得关闭 Mybatis 的缓存来保证一致性</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentBySid&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>  <br>     select * from student where sid = #&#123;sid&#125;  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要么就需要实现缓存共用，也就是让所有的 Mybatis 都使用同一个缓存进行数据存取，在后面，我们会继续学习 Redis、Ehcache、Memcache 等缓存框架，通过使用这些工具，就能够很好地解决缓存一致性问题。</p><h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><p>在之前的开发中，我们已经体验到 Mybatis 为我们带来的便捷了，我们只需要编写对应的映射器，并将其绑定到一个接口上，即可直接通过该接口执行我们的 SQL 语句，极大的简化了我们之前 JDBC 那样的代码编写模式。那么，能否实现无需 xml 映射器配置，而是直接使用注解在接口上进行配置呢？答案是可以的，也是现在推荐的一种方式（也不是说 XML 就不要去用了，由于 Java 注解的表达能力和灵活性十分有限，可能相对于 XML 配置某些功能实现起来会不太好办，但是在大部分场景下，直接使用注解开发已经绰绰有余了）<br>首先我们来看一下，使用 XML 进行映射器编写时，我们需要现在 XML 中定义映射规则和 SQL 语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addStudent&quot;</span>&gt;</span>  <br>     insert into student (name, sex) values (#&#123;name&#125;, #&#123;sex&#125;)  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <code>int addStudent (Student student);</code><br>而现在，我们可以直接使用注解来实现，每个操作都有一个对应的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Insert</span> (<span class="hljs-string">&quot;insert into student (name, sex) values (#&#123;name&#125;, #&#123;sex&#125;)&quot;</span>)  <br> <span class="hljs-type">int</span> <span class="hljs-title function_">addStudent</span> <span class="hljs-params">(Student student)</span>;<br></code></pre></td></tr></table></figure><p>当然，我们还需要修改一下配置文件中的映射器注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.mapper.MyMapper&quot;</span>/&gt;</span>  <br>     <span class="hljs-comment">&lt;!--  也可以直接注册整个包下的 &lt;package name=&quot;com.test.mapper&quot;/&gt;  --&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过直接指定 Class，来让 Mybatis 知道我们这里有一个通过注解实现的映射器。<br>我们接着来看一下，如何使用注解进行自定义映射规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Results</span> (&#123;  <br>         <span class="hljs-meta">@Result</span> (id = <span class="hljs-literal">true</span>, column = <span class="hljs-string">&quot;sid&quot;</span>, property = <span class="hljs-string">&quot;sid&quot;</span>),  <br>         <span class="hljs-meta">@Result</span> (column = <span class="hljs-string">&quot;sex&quot;</span>, property = <span class="hljs-string">&quot;name&quot;</span>),  <br>         <span class="hljs-meta">@Result</span> (column = <span class="hljs-string">&quot;name&quot;</span>, property = <span class="hljs-string">&quot;sex&quot;</span>)  <br> &#125;)  <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student&quot;</span>)  <br> List&lt;Student&gt; <span class="hljs-title function_">getAllStudent</span> <span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>直接通过 <code>@Results</code> 注解，就可以直接进行配置了，此注解的 value 是一个 <code>@Result</code> 注解数组，每个 <code>@Result</code> 注解都是一个单独的字段配置，其实就是我们之前在 XML 映射器中写的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;sex&quot;</span>/&gt;</span>      <br>     <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们就可以通过注解来自定义映射规则了。那么如何使用注解来完成复杂查询呢？我们还是使用一个老师多个学生的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Results</span> (&#123;  <br>         <span class="hljs-meta">@Result</span> (id = <span class="hljs-literal">true</span>, column = <span class="hljs-string">&quot;tid&quot;</span>, property = <span class="hljs-string">&quot;tid&quot;</span>),  <br>         <span class="hljs-meta">@Result</span> (column = <span class="hljs-string">&quot;name&quot;</span>, property = <span class="hljs-string">&quot;name&quot;</span>),  <br>         <span class="hljs-meta">@Result</span> (column = <span class="hljs-string">&quot;tid&quot;</span>, property = <span class="hljs-string">&quot;studentList&quot;</span>, many =  <br>             <span class="hljs-meta">@Many</span> (select = <span class="hljs-string">&quot;getStudentByTid&quot;</span>)  <br>         )  <br> &#125;)  <br> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from teacher where tid = #&#123;tid&#125;&quot;</span>)  <br> Teacher <span class="hljs-title function_">getTeacherBySid</span> <span class="hljs-params">(<span class="hljs-type">int</span> tid)</span>;  <br> ​  <br> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student inner join teach on student. sid = teach. sid where tid = #&#123;tid&#125;&quot;</span>)  <br> List&lt;Student&gt; <span class="hljs-title function_">getStudentByTid</span> <span class="hljs-params">(<span class="hljs-type">int</span> tid)</span>;<br></code></pre></td></tr></table></figure><p>我们发现，多出了一个子查询，而这个子查询是单独查询该老师所属学生的信息，而子查询结果作为 <code>@Result</code> 注解的一个 many 结果，代表子查询的所有结果都归入此集合中（也就是之前的 collection 标签）<br> <resultMap id="asTeacher" type="Teacher"><br>     <id column="tid" property="tid"/><br>     <result column="tname" property="name"/><br>     <collection property="studentList" ofType="Student"><br>         <id property="sid" column="sid"/><br>         <result column="name" property="name"/><br>         <result column="sex" property="sex"/><br>     </collection><br> </resultMap><br>同理，<code>@Result</code> 也提供了 <code>@One</code> 子注解来实现一对一的关系表示，类似于之前的 <code>assocation</code> 标签：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Results</span> (&#123;  <br>         <span class="hljs-meta">@Result</span> (id = <span class="hljs-literal">true</span>, column = <span class="hljs-string">&quot;sid&quot;</span>, property = <span class="hljs-string">&quot;sid&quot;</span>),  <br>         <span class="hljs-meta">@Result</span> (column = <span class="hljs-string">&quot;sex&quot;</span>, property = <span class="hljs-string">&quot;name&quot;</span>),  <br>         <span class="hljs-meta">@Result</span> (column = <span class="hljs-string">&quot;name&quot;</span>, property = <span class="hljs-string">&quot;sex&quot;</span>),  <br>         <span class="hljs-meta">@Result</span> (column = <span class="hljs-string">&quot;sid&quot;</span>, property = <span class="hljs-string">&quot;teacher&quot;</span>, one =  <br>             <span class="hljs-meta">@One</span> (select = <span class="hljs-string">&quot;getTeacherBySid&quot;</span>)  <br>         )  <br> &#125;)  <br> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student&quot;</span>)  <br> List&lt;Student&gt; <span class="hljs-title function_">getAllStudent</span> <span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>如果现在我希望直接使用注解编写 SQL 语句但是我希望映射规则依然使用 XML 来实现，这时该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@ResultMap</span> (<span class="hljs-string">&quot;test&quot;</span>)  <br> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student&quot;</span>)  <br> List&lt;Student&gt; <span class="hljs-title function_">getAllStudent</span> <span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>提供了 <code>@ResultMap</code> 注解，直接指定 ID 即可，这样我们就可以使用 XML 中编写的映射规则了，这里就不再演示了。<br>那么如果出现之前的两个构造方法的情况，且没有任何一个构造方法匹配的话，该怎么处理呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Data</span>  <br> <span class="hljs-meta">@Accessors</span> (chain = <span class="hljs-literal">true</span>)  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br> ​  <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span> <span class="hljs-params">(<span class="hljs-type">int</span> sid)</span>&#123;  <br>         System.out.println (<span class="hljs-string">&quot;我是一号构造方法&quot;</span>+sid);  <br>     &#125;  <br> ​  <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span> <span class="hljs-params">(<span class="hljs-type">int</span> sid, String name)</span>&#123;  <br>         System.out.println (<span class="hljs-string">&quot;我是二号构造方法&quot;</span>+sid+name);  <br>     &#125;  <br> ​  <br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sid;  <br>     <span class="hljs-keyword">private</span> String name;  <br>     <span class="hljs-keyword">private</span> String sex;  <br> &#125;<br></code></pre></td></tr></table></figure><p>我们可以通过 <code>@ConstructorArgs</code> 注解来指定构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@ConstructorArgs</span> (&#123;  <br>         <span class="hljs-meta">@Arg</span> (column = <span class="hljs-string">&quot;sid&quot;</span>, javaType = <span class="hljs-type">int</span>. class),  <br>         <span class="hljs-meta">@Arg</span> (column = <span class="hljs-string">&quot;name&quot;</span>, javaType = String. class)  <br> &#125;)  <br> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;</span>)  <br> Student <span class="hljs-title function_">getStudentBySidAndSex</span> <span class="hljs-params">(<span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;sid&quot;</span>)</span> <span class="hljs-type">int</span> sid, <span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;sex&quot;</span>) String sex);<br></code></pre></td></tr></table></figure><p>得到的结果和使用 <code>constructor</code> 标签效果一致，这里就不多做讲解了。<br>我们发现，当参数列表中出现两个以上的参数时，会出现错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;</span>)  <br> Student <span class="hljs-title function_">getStudentBySidAndSex</span> <span class="hljs-params">(<span class="hljs-type">int</span> sid, String sex)</span>;<br> Exception in thread <span class="hljs-string">&quot;main&quot;</span> org. apache. ibatis. exceptions. PersistenceException:   <br> ### Error querying database.  Cause: org. apache. ibatis. binding. BindingException: Parameter <span class="hljs-string">&#x27;sid&#x27;</span> not found. Available parameters are [arg <span class="hljs-number">1</span>, arg <span class="hljs-number">0</span>, param <span class="hljs-number">1</span>, param <span class="hljs-number">2</span>]  <br> ### Cause: org. apache. ibatis. binding. BindingException: Parameter <span class="hljs-string">&#x27;sid&#x27;</span> not found. Available parameters are [arg <span class="hljs-number">1</span>, arg <span class="hljs-number">0</span>, param <span class="hljs-number">1</span>, param <span class="hljs-number">2</span>]  <br>     at org.apache.ibatis.exceptions.ExceptionFactory.wrapException (ExceptionFactory. java:<span class="hljs-number">30</span>)  <br>     at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList (DefaultSqlSession. java:<span class="hljs-number">153</span>)  <br>     at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList (DefaultSqlSession. java:<span class="hljs-number">145</span>)  <br>     at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList (DefaultSqlSession. java:<span class="hljs-number">140</span>)  <br>     at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne (DefaultSqlSession. java:<span class="hljs-number">76</span>)  <br>     at org.apache.ibatis.binding.MapperMethod.execute (MapperMethod. java:<span class="hljs-number">87</span>)  <br>     at org. apache. ibatis. binding. MapperProxy$PlainMethodInvoker.invoke (MapperProxy. java:<span class="hljs-number">145</span>)  <br>     at org.apache.ibatis.binding.MapperProxy.invoke (MapperProxy. java:<span class="hljs-number">86</span>)  <br>     at com. sun. proxy.$Proxy <span class="hljs-number">6.</span>getStudentBySidAndSex (Unknown Source)  <br>     at com.test.Main.main (Main. java:<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>原因是 Mybatis 不明确到底哪个参数是什么，因此我们可以添加 <code>@Param</code> 来指定参数名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student where sid = #&#123;sid&#125; and sex = #&#123;sex&#125;&quot;</span>)  <br> Student <span class="hljs-title function_">getStudentBySidAndSex</span> <span class="hljs-params">(<span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;sid&quot;</span>)</span> <span class="hljs-type">int</span> sid, <span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;sex&quot;</span>) String sex);<br></code></pre></td></tr></table></figure><p>**探究：要是我两个参数一个是基本类型一个是对象类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> System.out.println (testMapper.addStudent (<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> (). setName (<span class="hljs-string">&quot;小陆&quot;</span>). setSex (<span class="hljs-string">&quot;男&quot;</span>)));<br> <span class="hljs-meta">@Insert</span> (<span class="hljs-string">&quot;insert into student (sid, name, sex) values (#&#123;sid&#125;, #&#123;name&#125;, #&#123;sex&#125;)&quot;</span>)  <br> <span class="hljs-type">int</span> <span class="hljs-title function_">addStudent</span> <span class="hljs-params">(<span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;sid&quot;</span>)</span> <span class="hljs-type">int</span> sid, <span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;student&quot;</span>)  Student student);<br></code></pre></td></tr></table></figure><p>那么这个时候，就出现问题了，Mybatis 就不能明确这些属性是从哪里来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"> ### SQL: insert into <span class="hljs-title function_">student</span> <span class="hljs-params">(sid, name, sex)</span> values (?, ?, ?)  <br> ### Cause: org. apache. ibatis. binding. BindingException: Parameter <span class="hljs-string">&#x27;name&#x27;</span> not found. Available parameters are [student, param <span class="hljs-number">1</span>, sid, param <span class="hljs-number">2</span>]  <br>     at org.apache.ibatis.exceptions.ExceptionFactory.wrapException (ExceptionFactory. java:<span class="hljs-number">30</span>)  <br>     at org.apache.ibatis.session.defaults.DefaultSqlSession.update (DefaultSqlSession. java:<span class="hljs-number">196</span>)  <br>     at org.apache.ibatis.session.defaults.DefaultSqlSession.insert (DefaultSqlSession. java:<span class="hljs-number">181</span>)  <br>     at org.apache.ibatis.binding.MapperMethod.execute (MapperMethod. java:<span class="hljs-number">62</span>)  <br>     at org. apache. ibatis. binding. MapperProxy$PlainMethodInvoker.invoke (MapperProxy. java:<span class="hljs-number">145</span>)  <br>     at org.apache.ibatis.binding.MapperProxy.invoke (MapperProxy. java:<span class="hljs-number">86</span>)  <br>     at com. sun. proxy.$Proxy <span class="hljs-number">6.</span>addStudent (Unknown Source)  <br>     at com.test.Main.main (Main. java:<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>那么我们就通过参数名称. 属性的方式去让 Mybatis 知道我们要用的是哪个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Insert</span> (<span class="hljs-string">&quot;insert into student (sid, name, sex) values (#&#123;sid&#125;, #&#123;student. name&#125;, #&#123;student. sex&#125;)&quot;</span>)  <br> <span class="hljs-type">int</span> <span class="hljs-title function_">addStudent</span> <span class="hljs-params">(<span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;sid&quot;</span>)</span> <span class="hljs-type">int</span> sid, <span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;student&quot;</span>)  Student student);<br></code></pre></td></tr></table></figure><p>那么如何通过注解控制缓存机制呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@CacheNamespace</span> (readWrite = <span class="hljs-literal">false</span>)  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMapper</span> &#123;  <br> ​  <br>     <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student&quot;</span>)  <br>     <span class="hljs-meta">@Options</span> (useCache = <span class="hljs-literal">false</span>)  <br>     List&lt;Student&gt; <span class="hljs-title function_">getAllStudent</span> <span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>使用 <code>@CacheNamespace</code> 注解直接定义在接口上即可，然后我们可以通过使用 <code>@Options</code> 来控制单个操作的缓存启用。</p><h2 id="探究-Mybatis-的动态代理机制"><a href="#探究-Mybatis-的动态代理机制" class="headerlink" title="探究 Mybatis 的动态代理机制"></a>探究 Mybatis 的动态代理机制</h2><p>在探究动态代理机制之前，我们要先聊聊什么是代理：其实顾名思义，就好比我开了个大棚，里面栽种的西瓜，那么西瓜成熟了是不是得去卖掉赚钱，而我们的西瓜非常多，一个人肯定卖不过来，肯定就要去多找几个开水果摊的帮我们卖，这就是一种代理。实际上是由水果摊老板在帮我们卖瓜，我们只告诉老板卖多少钱，而至于怎么卖的是由水果摊老板决定的。<br><img src="https://s2.loli.net/2023/03/06/f2slhXr68k3WpIM.png" alt="img"><br>那么现在我们来尝试实现一下这样的类结构，首先定义一个接口用于规范行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shopper</span> &#123;  <br> ​       <span class="hljs-comment">//卖瓜行为  </span><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">saleWatermelon</span> <span class="hljs-params">(String customer)</span>;  <br> &#125;<br></code></pre></td></tr></table></figure><p>然后需要实现一下卖瓜行为，也就是我们要告诉老板卖多少钱，这里就直接写成成功出售：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shopper</span>&#123;  <br> ​  <br>     <span class="hljs-comment">//卖瓜行为的实现  </span><br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saleWatermelon</span> <span class="hljs-params">(String customer)</span> &#123;  <br>         System.out.println (<span class="hljs-string">&quot;成功出售西瓜给 ===&gt; &quot;</span>+customer);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>最后老板代理后肯定要用自己的方式去出售这些西瓜，成交之后再按照我们告诉老板的价格进行出售：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shopper</span>&#123;  <br> ​  <br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Shopper impl;  <br> ​  <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShopperProxy</span> <span class="hljs-params">(Shopper impl)</span>&#123;  <br>         <span class="hljs-built_in">this</span>. impl = impl;  <br>     &#125;  <br> ​  <br>     <span class="hljs-comment">//代理卖瓜行为  </span><br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saleWatermelon</span> <span class="hljs-params">(String customer)</span> &#123;  <br>         <span class="hljs-comment">//首先进行代理商讨价还价行为  </span><br>         System.out.println (customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);  <br>         System.out.println (<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);  <br>         System.out.println (customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);  <br>         System.out.println (<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);  <br>         System.out.println (customer + <span class="hljs-string">&quot;：给我挑一个。&quot;</span>);  <br> ​  <br>         impl.saleWatermelon (customer);   <span class="hljs-comment">//讨价还价成功，进行我们告诉代理商的卖瓜行为  </span><br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>现在我们来试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>         <span class="hljs-type">Shopper</span> <span class="hljs-variable">shopper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShopperProxy</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ShopperImpl</span> ());  <br>         shopper.saleWatermelon (<span class="hljs-string">&quot;小强&quot;</span>);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>这样的操作称为<strong>静态代理</strong>，也就是说我们需要<strong>提前知道接口的定义并进行实现</strong>才可以完成代理，而 Mybatis 这样的是无法预知代理接口的，我们就需要用到动态代理。<br>JDK 提供的反射框架就为我们很好地解决了动态代理的问题，在这里相当于对 JavaSE 阶段反射的内容进行一个补充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;  <br> ​  <br>     Object target;  <br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShopperProxy</span> <span class="hljs-params">(Object target)</span>&#123;  <br>         <span class="hljs-built_in">this</span>. target = target;  <br>     &#125;  <br> ​  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span> <span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>         <span class="hljs-type">String</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> (String) args[<span class="hljs-number">0</span>];  <br>         System.out.println (customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);  <br>         System.out.println (<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);  <br>         System.out.println (customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);  <br>         System.out.println (<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);  <br>         System.out.println (customer + <span class="hljs-string">&quot;：行，给我挑一个。&quot;</span>);  <br>         <span class="hljs-keyword">return</span> method.invoke (target, args);  <br>     &#125;  <br> &#125;<br></code></pre></td></tr></table></figure><p>通过实现 <code>InvocationHandler</code> 来成为一个动态代理，我们发现它提供了一个 invoke 方法，用于调用被代理对象的方法并完成我们的代理工作。现在就可以通过 <code>Proxy. newProxyInstance</code> 来生成一个动态代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-type">Shopper</span> <span class="hljs-variable">impl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShopperImpl</span> ();  <br>     <span class="hljs-type">Shopper</span> <span class="hljs-variable">shopper</span> <span class="hljs-operator">=</span> (Shopper) Proxy.newProxyInstance (impl.getClass (). getClassLoader (),  <br>             impl.getClass (). getInterfaces (), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShopperProxy</span> (impl));  <br>     shopper.saleWatermelon (<span class="hljs-string">&quot;小强&quot;</span>);  <br>     System.out.println (shopper.getClass ());  <br> &#125;<br></code></pre></td></tr></table></figure><p>通过打印类型我们发现，就是我们之前看到的那种奇怪的类：<code>class com. sun. proxy.$Proxy 0</code>，因此 Mybatis 其实也是这样的来实现的（肯定有人问了：Mybatis 是直接代理接口啊，你这个不还是要把接口实现了吗？）那我们来改改，现在我们不代理任何类了，直接做接口实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopperProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;  <br> ​  <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span> <span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>         <span class="hljs-type">String</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> (String) args[<span class="hljs-number">0</span>];  <br>         System.out.println (customer + <span class="hljs-string">&quot;：哥们，这瓜多少钱一斤啊？&quot;</span>);  <br>         System.out.println (<span class="hljs-string">&quot;老板：两块钱一斤。&quot;</span>);  <br>         System.out.println (customer + <span class="hljs-string">&quot;：你这瓜皮子是金子做的，还是瓜粒子是金子做的？&quot;</span>);  <br>         System.out.println (<span class="hljs-string">&quot;老板：你瞅瞅现在哪有瓜啊，这都是大棚的瓜，你嫌贵我还嫌贵呢。&quot;</span>);  <br>         System.out.println (customer + <span class="hljs-string">&quot;：行，给我挑一个。&quot;</span>);  <br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>     &#125;  <br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>     <span class="hljs-type">Shopper</span> <span class="hljs-variable">shopper</span> <span class="hljs-operator">=</span> (Shopper) Proxy.newProxyInstance (Shopper.class.getClassLoader (),  <br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123; Shopper. class &#125;,   <span class="hljs-comment">//因为本身就是接口，所以直接用就行  </span><br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShopperProxy</span> ());  <br>     shopper.saleWatermelon (<span class="hljs-string">&quot;小强&quot;</span>);  <br>     System.out.println (shopper.getClass ());  <br> &#125;<br></code></pre></td></tr></table></figure><p>可以去看看 Mybatis 的源码。<br>Mybatis 的学习差不多就到这里为止了，不过，同样类型的框架还有很多，Mybatis 属于半自动框架，SQL 语句依然需要我们自己编写，虽然存在一定的麻烦，但是会更加灵活，而后面我们还会学习 JPA，它是全自动的框架，你几乎见不到 SQL 的影子！</p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven 利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。<br>通过 Maven，可以帮助我们做：</p><ul><li>项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。</li><li>依赖管理，项目使用到哪些依赖，可以快速完成导入。</li></ul><p>我们之前并没有讲解如何将我们的项目打包为 Jar 文件运行，同时，我们导入依赖的时候，每次都要去下载对应的 Jar 包，这样其实是很麻烦的，并且还有可能一个 Jar 包依赖于另一个 Jar 包，就像之前使用 JUnit 一样，因此我们需要一个更加方便的包管理机制。<br>Maven 也需要安装环境，但是 IDEA 已经自带了 Maven 环境，因此我们不需要再去进行额外的环境安装（无 IDEA 也能使用 Maven，但是配置过程很麻烦，并且我们现在使用的都是 IDEA 的集成开发环境，所以这里就不讲解 Maven 命令行操作了）我们直接创建一个新的 Maven 项目即可。</p><h2 id="Maven-项目结构"><a href="#Maven-项目结构" class="headerlink" title="Maven 项目结构"></a>Maven 项目结构</h2><p>我们可以来看一下，一个 Maven 项目和我们普通的项目有什么区别：<br><img src="https://s2.loli.net/2023/03/06/tYh7BGvZHu6ncdf.jpg" alt="img"><br>那么首先，我们需要了解一下 POM 文件，它相当于是我们整个 Maven 项目的配置文件，它也是使用 XML 编写的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot; http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot; http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot; http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以看到，Maven 的配置文件是以 <code>project</code> 为根节点，而 <code>modelVersion</code> 定义了当前模型的版本，一般是 4.0.0，我们不用去修改。<br><code>groupId</code>、<code>artifactId</code>、<code>version</code> 这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的 Maven 坐标，因此我们通过 Maven 导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载 Jar 文件，而是 Maven 自动帮助我们下载依赖并导入。</p><ul><li><code>groupId</code> 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是 <code>org. example</code>，一个组下面可以有很多个项目。</li><li><code>artifactId</code> 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。</li><li><code>version</code> 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像 LOL 一样，每次赛季更新都会有一个大版本更新，我们的 Maven 项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的 SNAPSHOT 代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号）</li></ul><p><code>properties</code> 中一般都是一些变量和选项的配置，我们这里指定了 JDK 的源代码和编译版本为 1.8，无需进行修改。</p><h2 id="Maven-依赖导入"><a href="#Maven-依赖导入" class="headerlink" title="Maven 依赖导入"></a>Maven 依赖导入</h2><p>现在我们尝试使用 Maven 来帮助我们快速导入依赖，我们需要导入之前的 JDBC 驱动依赖、JUnit 依赖、Mybatis 依赖、Lombok 依赖，那么如何使用 Maven 来管理依赖呢？<br>我们可以创建一个 <code>dependencies</code> 节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    //里面填写的就是所有的依赖<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：[mavenrepository]( <a href="https://mvnrepository.com/">https://mvnrepository.com/</a> <a href="https://mvnrepository.com/">Fetching Data#5mce</a>) 进行查询（可能打不开，建议用流量，或是直接百度某个项目的 Maven 依赖），我们直接搜索 lombok 即可，打开后可以看到已经给我们写出了依赖的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们直接将其添加到 <code>dependencies</code> 节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> (<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>);<br>        System.out.println (student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>项目运行成功，表示成功导入了依赖。那么，Maven 是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看 Maven 项目的依赖管理流程：<br><img src="https://s2.loli.net/2023/03/06/XYNMU5WCrZv9cwy.jpg" alt="img"><br>通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven 可以直接从中央仓库中下载大部分的依赖（Maven 第一次导入依赖是需要联网的），远程仓库中下载之后，会暂时存储在本地仓库，我们会发现我们本地存在一个 <code>. m 2</code> 文件夹，这就是 Maven 本地仓库文件夹，默认建立在 C 盘，如果你 C 盘空间不足，会出现问题！<br>在下次导入依赖时，如果 Maven 发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。<br>可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下 IDEA 自带的 Maven 插件远程仓库地址，我们打开 IDEA 的安装目录，找到 <code>安装根目录/plugins/maven/lib/maven 3/conf</code> 文件夹，找到 <code>settings. xml</code> 文件，打开编辑：<br>找到 mirros 标签，添加以下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven. aliyun. com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了）</p><h2 id="Maven-依赖作用域"><a href="#Maven-依赖作用域" class="headerlink" title="Maven 依赖作用域"></a>Maven 依赖作用域</h2><p>除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性：</p><ul><li><strong>type</strong>：依赖的类型，对于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值为 jar</li><li><strong>scope</strong>：<strong>依赖的范围</strong>（作用域，着重讲解）</li><li><strong>optional</strong>：标记依赖是否可选</li><li><strong>exclusions</strong>：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如 Lombok）</li></ul><p>我们着重来讲解一下 <code>scope</code> 属性，它决定了依赖的作用域范围：</p><ul><li><strong>compile</strong> ：为<strong>默认的依赖有效范围</strong>。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。</li><li><strong>provided</strong> ：在<strong>编译、测试时有效</strong>，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的 Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此 Lombok 不需要在项目运行时也存在。</li><li><strong>runtime</strong> ：在<strong>运行、测试时有效</strong>，但是在编译代码时无效。比如我们如果需要自己写一个 JDBC 实现，那么肯定要用到 JDK 为我们指定的接口，但是实际上在运行时是不用自带 JDK 的依赖，因此只保留我们自己写的内容即可。</li><li><strong>test</strong> ：只<strong>在测试时有效</strong>，例如：JUnit，我们一般只会在测试阶段使用 JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入 JUnit 的依赖：</li></ul><p>同样的，我们可以在网站上搜索 Junit 的依赖，我们这里导入最新的 JUnit 5 作为依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. junit. jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们所有的测试用例全部编写到 Maven 项目给我们划分的 test 目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        System.out.println (<span class="hljs-string">&quot;测试&quot;</span>);<br>      <span class="hljs-comment">//Assert 在 JUnit 5 时名称发生了变化 Assertions</span><br>        Assertions.assertArrayEquals (<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，一般仅用作测试的依赖如 JUnit 只保留在测试中即可，那么现在我们再来添加 JDBC 和 Mybatis 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现，Maven 还给我们提供了一个 <code>resource</code> 文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的 Jar 中，比如我们在这里编写一个 Mybatis 的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br>&lt;! DOCTYPE configuration<br>        PUBLIC &quot;-//mybatis. org//DTD Config 3.0//EN&quot;<br>        &quot; http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;JDK_LOGGING&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 需要在environments的上方 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.test.entity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.mapper.TestMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们创建一下测试用例，顺便带大家了解一下 Junit 5 的一些比较方便的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br>    <span class="hljs-comment">//因为配置文件位于内部，我们需要使用 Resources 类的 getResourceAsStream 来获取内部的资源文件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory factory;<br>    <span class="hljs-comment">//在 JUnit 5 中@Before 被废弃，它被细分了：</span><br>    <span class="hljs-meta">@BeforeAll</span> <span class="hljs-comment">// 一次性开启所有测试案例只会执行一次 (方法必须是 static)</span><br>    <span class="hljs-comment">// @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">()</span>&#123;<br>        factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span> ()<br>                .build (Resources.getResourceAsStream (<span class="hljs-string">&quot;mybatis. xml&quot;</span>));<br>    &#125;<br>    <span class="hljs-meta">@DisplayName</span> (<span class="hljs-string">&quot;Mybatis 数据库测试&quot;</span>)  <span class="hljs-comment">//自定义测试名称</span><br>    <span class="hljs-meta">@RepeatedTest</span> (<span class="hljs-number">3</span>)  <span class="hljs-comment">//自动执行多次测试</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> factory.openSession (<span class="hljs-literal">true</span>))&#123;<br>            <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper (TestMapper. class);<br>            System.out.println (testMapper.getStudentBySid (<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个 Jar 怎么办呢？我们可以使用第四种作用域：</p><ul><li><strong>system</strong>：作用域和 provided 是一样的，但是它不是从远程仓库获取，而是直接导入本地 Jar 包：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax. jntm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>C://学习资料/4 K 高清无码/test. jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比如上面的例子，如果 scope 为 system，那么我们需要添加一个 systemPath 来指定 jar 文件的位置，这里就不再演示了。</p><h2 id="Maven-可选依赖"><a href="#Maven-可选依赖" class="headerlink" title="Maven 可选依赖"></a>Maven 可选依赖</h2><p>当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加 <code>optional</code> 标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br></code></pre></td></tr></table></figure><p>比如 Mybatis 的 POM 文件中，就存在大量的可选依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. slf 4 j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf 4 j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. slf 4 j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf 4 j-log 4 j 12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log 4 j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log 4 j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> ...<br></code></pre></td></tr></table></figure><p>由于 Mybatis 要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为 Mybatis 的日志打印器，因此这些日志框架仅 Mybatis 内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入 Mybatis 之后想用什么日志框架再自己加就可以了。</p><h2 id="Maven-排除依赖"><a href="#Maven-排除依赖" class="headerlink" title="Maven 排除依赖"></a>Maven 排除依赖</h2><p>我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目又不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. junit. jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. junit. jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们这里演示了排除 JUnit 的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。</p><h2 id="Maven-继承关系"><a href="#Maven-继承关系" class="headerlink" title="Maven 继承关系"></a>Maven 继承关系</h2><p>一个 Maven 项目可以继承自另一个 Maven 项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。<br>我们右键左侧栏，新建一个模块，来创建一个子项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot; http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot; http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot; http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>MavenTest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ChildModel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以看到，IDEA 默认给我们添加了一个 parent 节点，表示此 Maven 项目是父 Maven 项目的子项目，子项目直接继承父项目的 <code>groupId</code>，子项目会直接继承父项目的所有依赖，除非依赖添加了 optional 标签，我们来编写一个测试用例尝试一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok. extern. java. Log;<br><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        log.info (<span class="hljs-string">&quot;我是日志信息&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，子项目也成功继承了 Lombok 依赖。<br>我们还可以让父 Maven 项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将 <code>dependencies</code> 全部放入 <code>dependencyManagement</code> 节点，这样父项目就完全作为依赖统一管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. junit. jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，父项目如果还存在 dependencies 节点的话，里面的内依赖依然是直接继承：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. junit. jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      ...<br></code></pre></td></tr></table></figure><h2 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h2><p>我们可以看到在 IDEA 右上角 Maven 板块中，每个 Maven 项目都有一个生命周期，实际上这些是 Maven 的一些插件，每个插件都有各自的功能，比如：</p><ul><li><code>clean</code> 命令，执行后会清理整个 <code>target</code> 文件夹，在之后编写 Springboot 项目时可以解决一些缓存没更新的问题。</li><li><code>validate</code> 命令可以验证项目的可用性。</li><li><code>compile</code> 命令可以将项目编译为. class 文件。</li><li><code>install</code> 命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用</li><li><code>verify</code> 命令可以按顺序执行每个默认生命周期阶段（<code>validate</code>，<code>compile</code>，<code>package</code> 等）</li></ul><h2 id="Maven-测试项目"><a href="#Maven-测试项目" class="headerlink" title="Maven 测试项目"></a>Maven 测试项目</h2><p>通过使用 <code>test</code> 命令，可以一键测试所有位于 test 目录下的测试案例，请注意有以下要求：</p><ul><li>测试类的名称必须是以 <code>Test</code> 结尾，比如 <code>MainTest</code></li><li>测试方法上必须标注 <code>@Test</code> 注解，实测 <code>@RepeatedTest</code> 无效</li></ul><p>这是由于 JUnit 5 比较新，我们需要重新配置插件升级到高版本，才能完美的兼容 Junit 5：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. apache. maven. plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- JUnit 5 requires Surefire version 2.22.0 or higher --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在 <code>@RepeatedTest</code>、<code>@BeforeAll</code> 也能使用了。</p><h2 id="Maven-打包项目"><a href="#Maven-打包项目" class="headerlink" title="Maven 打包项目"></a>Maven 打包项目</h2><p>我们的项目在编写完成之后，要么作为 Jar 依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行 <code>package</code> 命令就可以直接对项目的代码进行打包，生成 jar 文件。<br>当然，以上方式仅适用于作为 Jar 依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到 Jar 中，同时还需要将依赖也一并打包到 Jar 中，因为我们使用了别人为我们提供的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com. test. Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>make-assembly<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>single<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在打包之前也会执行一次 test 命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择 <code>执行 Maven 目标</code> 来手动执行 Maven 命令，输入 <code>mvn package -Dmaven. test. skip=true </code> 来以跳过测试的方式进行打包。<br>最后得到我们的 Jar 文件，在同级目录下输入 <code>java -jar xxxx. jar</code> 来运行我们打包好的 Jar 可执行程序（xxx 代表文件名称）</p><ul><li><code>deploy</code> 命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。</li><li><code>site</code> 命令用于生成当前项目的发布站点，暂时不需要了解。</li></ul><p>我们之前还讲解了多模块项目，那么多模块下父项目存在一个 <code>packing</code> 打包类型标签，所有的父级项目的 packing 都为 pom，packing 默认是 jar 类型，如果不作配置，maven 会将该项目打成 jar 包。作为父级项目，还有一个重要的属性，那就是 modules，通过 modules 标签将项目的所有子项目引用进来，在 build 父级项目时，会根据子模块的相互依赖关系整理一个 build 顺序，然后依次 build。</p><hr><h2 id="使用-Maven-创建-Web-项目"><a href="#使用-Maven-创建-Web-项目" class="headerlink" title="使用 Maven 创建 Web 项目"></a>使用 Maven 创建 Web 项目</h2><p>虽然我们已经可以在 Tomcat 上部署我们的前端页面了，但是依然只是一个静态页面（每次访问都是同样的样子），那么如何向服务器请求一个动态的页面呢（比如显示我们访问当前页面的时间）这时就需要我们编写一个 Web 应用程序来实现了，我们需要在用户向服务器发起页面请求时，进行一些处理，再将结果发送给用户的浏览器。<br>**注意：这里需要使用终极版 IDEA，如果你的还是社区版，就很难受了。<br>我们打开 IDEA，新建一个项目，选择 Java Enterprise（社区版没有此选项！）项目名称随便，项目模板选择 Web 应用程序，然后我们需要配置 Web 应用程序服务器，将我们的 Tomcat 服务器集成到 IDEA 中。配置很简单，首先点击新建，然后设置 Tomcat 主目录即可，配置完成后，点击下一步即可，依赖项使用默认即可，然后点击完成，之后 IDEA 会自动帮助我们创建 Maven 项目。<br>创建完成后，直接点击右上角即可运行此项目了，但是我们发现，有一个 Servlet 页面不生效。<br>需要注意的是，Tomcat 10 以上的版本比较新，Servlet API 包名发生了一些变化，因此我们需要修改一下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta. servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta. servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意包名全部从 javax 改为 jakarta，我们需要手动修改一下。<br>感兴趣的可以了解一下为什么名称被修改了：</p><blockquote><p>Eclipse 基金会在 2019 年对 Java EE 标准的每个规范进行了重命名，阐明了每个规范在 Jakarta EE 平台未来的角色。</p><p>新的名称 Jakarta EE 是 Java EE 的第二次重命名。2006 年 5 月，“J 2 EE”一词被弃用，并选择了 Java EE 这个名称。在 YouTube 还只是一家独立的公司的时候，数字 2 就就从名字中消失了，而且当时冥王星仍然被认为是一颗行星。同样，作为 Java SE 5（2004）的一部分，数字 2 也从 J 2 SE 中删除了，那时谷歌还没有上市。</p><p><strong>因为不能再使用 javax 名称空间，Jakarta EE 提供了非常明显的分界线。</strong></p><ul><li>Jakarta 9（2019 及以后）使用 jakarta 命名空间。</li><li>Java EE 5（2005）到 Java EE 8（2017）使用 javax 命名空间。</li><li>Java EE 4 使用 javax 命名空间。</li></ul></blockquote><p>我们可以将项目直接打包为 war 包（默认），打包好之后，放入 webapp 文件夹，就可以直接运行我们通过 Java 编写的 Web 应用程序了，访问路径为文件的名称。</p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>前面我们已经完成了基本的环境搭建，那么现在我们就可以开始来了解我们的第一个重要类——Servlet。<br>它是 Java EE 的一个标准，大部分的 Web 服务器都支持此标准，包括 Tomcat，就像之前的 JDBC 一样，由官方定义了一系列接口，而具体实现由我们来编写，最后交给 Web 服务器（如 Tomcat）来运行我们编写的 Servlet。<br>那么，它能做什么呢？我们可以通过实现 Servlet 来进行动态网页响应，使用 Servlet，不再是直接由 Tomcat 服务器发送我们编写好的静态网页内容（HTML 文件），而是由我们通过 Java 代码进行动态拼接的结果，它能够很好地实现动态网页的返回。<br>当然，Servlet 并不是专用于 HTTP 协议通信，也可以用于其他的通信，但是一般都是用于 HTTP。</p><h3 id="创建-Servlet"><a href="#创建-Servlet" class="headerlink" title="创建 Servlet"></a>创建 Servlet</h3><p>那么如何创建一个 Servlet 呢，非常简单，我们只需要实现 <code>Servlet</code> 类即可，并添加注解 <code>@WebServlet</code> 来进行注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>... 实现接口方法<br>&#125;<br></code></pre></td></tr></table></figure><p>现在就可以去访问一下我们的页面： <a href="http://localhost:8080/test/test">http://localhost:8080/test/test</a><br>我们发现，直接访问此页面是没有任何内容的，这是因为我们还没有为该请求方法编写实现，这里先不做讲解，后面我们会对浏览器的请求处理做详细的介绍。<br>除了直接编写一个类，我们也可以在 <code>web. xml</code> 中进行注册，现将类上 <code>@WebServlet</code> 的注解去掉：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com. example. webtest. TestServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/test<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样的方式也能注册 Servlet，但是显然直接使用<strong>注解更加方便</strong>，因此之后我们一律使用注解进行开发。只有比较新的版本才支持此注解，老的版本是不支持的哦。<br>实际上，Tomcat 服务器会为我们提供一些默认的 Servlet，也就是说在服务器启动后，即使我们什么都不编写，<strong>Tomcat 也自带了几个默认的 Servlet</strong>，他们编写在 conf 目录下的 <code>web.xml</code> 中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- The mapping for the default servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*. jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*. jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现，默认的 Servlet 实际上可以帮助我们去访问一些<em>静态资源</em>，这也是为什么我们启动 Tomcat 服务器之后，能够直接访问 webapp 目录下的静态页面。<br>我们可以将之前编写的页面放入到 webapp 目录下，来测试一下是否能直接访问。</p><h3 id="探究-Servlet-的生命周期"><a href="#探究-Servlet-的生命周期" class="headerlink" title="探究 Servlet 的生命周期"></a>探究 Servlet 的生命周期</h3><p>我们已经了解了如何注册一个 Servlet，那么我们接着来看看，一个 Servlet 是如何运行的。<br>首先我们需要了解，Servlet 中的方法各自是在什么时候被调用的，我们先编写一个打印语句来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestServlet</span> <span class="hljs-params">()</span>&#123;<br>        System.out.println (<span class="hljs-string">&quot;我是构造方法！&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        System.out.println (<span class="hljs-string">&quot;我是 init&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span> <span class="hljs-params">()</span> &#123;<br>        System.out.println (<span class="hljs-string">&quot;我是 getServletConfig&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span> <span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println (<span class="hljs-string">&quot;我是 service&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span> <span class="hljs-params">()</span> &#123;<br>        System.out.println (<span class="hljs-string">&quot;我是 getServletInfo&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span> <span class="hljs-params">()</span> &#123;<br>        System.out.println (<span class="hljs-string">&quot;我是 destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先启动一次服务器，然后访问我们定义的页面，然后再关闭服务器，得到如下的顺序：</p><blockquote><p>我是构造方法！<br>我是 init<br>我是 service<br>我是 service（出现两次是因为浏览器请求了 2 次，是因为有一次是请求 favicon. ico，浏览器通病）<br>我是 destroy</p></blockquote><p>我们可以多次尝试去访问此页面，但是<strong>init 和构造方法只会执行一次</strong>，而每次访问都会执行的是 <code>service</code> 方法，因此，一个 Servlet 的生命周期为：</p><ul><li>首先执行构造方法完成 Servlet 初始化</li><li>Servlet 初始化后调用 <strong>init ()</strong> 方法。</li><li>Servlet 调用 <strong>service ()</strong> 方法来处理客户端的请求。</li><li>Servlet 销毁前调用 <strong>destroy ()</strong> 方法。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><p>现在我们发现，实际上在 Web 应用程序运行时，每当浏览器向服务器发起一个请求时，都会创建一个线程执行一次 <code>service</code> 方法，来让我们处理用户的请求，并将结果响应给用户。<br>我们发现 <code>service</code> 方法中，还有两个参数，<code>ServletRequest</code> 和 <code>ServletResponse</code>，实际上，用户发起的 HTTP 请求，就被 Tomcat 服务器封装为了一个 <code>ServletRequest</code> 对象，我们得到是其实是 Tomcat 服务器帮助我们创建的一个实现类，HTTP 请求报文中的所有内容，都可以从 <code>ServletRequest</code> 对象中获取，同理，<code>ServletResponse</code> 就是我们需要返回给浏览器的 HTTP 响应报文实体类封装。<br>那么我们来看看 <code>ServletRequest</code> 中有哪些内容，我们可以获取请求的一些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span> <span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//首先将其转换为 HttpServletRequest（继承自 ServletRequest，一般是此接口实现）</span><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        System.out.println (request.getProtocol ());  <span class="hljs-comment">//获取协议版本</span><br>        System.out.println (request.getRemoteAddr ());  <span class="hljs-comment">//获取访问者的 IP 地址</span><br>    System.out.println (request.getMethod ());   <span class="hljs-comment">//获取请求方法</span><br>        <span class="hljs-comment">//获取头部信息</span><br>        Enumeration&lt;String&gt; enumeration = request.getHeaderNames ();<br>        <span class="hljs-keyword">while</span> (enumeration.hasMoreElements ())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> enumeration.nextElement ();<br>            System.out.println (name + <span class="hljs-string">&quot;: &quot;</span> + request.getHeader (name));<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，整个 HTTP<strong>请求报文中的所有内容</strong>，都可以通过 <code>HttpServletRequest</code> 对象来获取，当然，它的作用肯定不仅仅是获取头部信息，我们还可以使用它来完成更多操作，后面会一一讲解。<br>那么我们再来看看 <code>ServletResponse</code>，这个是服务端的响应内容，我们可以在这里填写我们想要发送给浏览器显示的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转换为 HttpServletResponse（同上）</span><br><span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br><span class="hljs-comment">//设定内容类型以及编码格式（普通 HTML 文本使用 text/html，之后会讲解文件传输）</span><br>response.setHeader (<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br><span class="hljs-comment">//获取 Writer 直接写入内容</span><br>response. getWriter (). write (<span class="hljs-string">&quot;我是响应内容！&quot;</span>);<br><span class="hljs-comment">//所有内容写入完成之后，再发送给浏览器</span><br></code></pre></td></tr></table></figure><p>现在我们在浏览器中打开此页面，就能够收到服务器发来的响应内容了。其中，响应头部分，是由 Tomcat 帮助我们生成的一个默认响应头。<br><img src="https://s2.loli.net/2023/03/06/OpTzXU5b8VjkSiB.jpg" alt="点击查看源网页"><br>因此，实际上整个流程就已经很清晰明了了。</p><h3 id="解读和使用-HttpServlet"><a href="#解读和使用-HttpServlet" class="headerlink" title="解读和使用 HttpServlet"></a>解读和使用 HttpServlet</h3><p>前面我们已经学习了如何创建、注册和使用 Servlet，那么我们继续来深入学习 Servlet 接口的一些实现类。<br>首先 <code>Servlet</code> 有一个直接实现抽象类 <code>GenericServlet</code>，那么我们来看看此类做了什么事情。<br>我们发现，这个类完善了配置文件读取和 Servlet 信息相关的的操作，但是依然没有去实现 service 方法，因此此类仅仅是用于完善一个 Servlet 的基本操作，那么我们接着来看 <code>HttpServlet</code>，它是遵循 HTTP 协议的一种 Servlet，继承自 <code>GenericServlet</code>，它根据 HTTP 协议的规则，完善了 service 方法。<br>在阅读了 HttpServlet 源码之后，我们发现，其实我们只需要继承 HttpServlet 来编写我们的 Servlet 就可以了，并且它已经帮助我们提前实现了一些操作，这样就会给我们省去很多的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp. setContentType (<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>        resp. getWriter (). write (<span class="hljs-string">&quot;&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们只需要重写对应的请求方式，就可以快速完成 Servlet 的编写。</p><h3 id="WebServlet-注解详解"><a href="#WebServlet-注解详解" class="headerlink" title="@WebServlet 注解详解"></a>@WebServlet 注解详解</h3><p>我们接着来看 WebServlet 注解，我们前面已经得知，可以直接使用此注解来快速注册一个 Servlet，那么我们来想细看看此注解还有什么其他的玩法。<br>首先<strong>name 属性就是 Servlet 名称</strong>，而<strong>urlPatterns 和 value 实际上是同样功能，就是代表当前 Servlet 的访问路径</strong>，它不仅仅可以是一个固定值，还可以进行<strong>通配符匹配</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/test/*&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面的路径表示，所有匹配 <code>/test/随便什么</code> 的路径名称，都可以访问此 Servlet，我们可以在浏览器中尝试一下。<br>也可以进行某个扩展名称的匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;*. js&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样的话，获取任何以 js 结尾的文件，都会由我们自己定义的 Servlet 处理。<br>那么如果我们的路径为 <code>/</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/&quot;</span>)<br></code></pre></td></tr></table></figure><p>此路径和 Tomcat 默认为我们提供的 Servlet 冲突，会直接替换掉默认的，而使用我们的，此路径的意思为，如果没有找到匹配当前访问路径的 Servlet，那么久会使用此 Servlet 进行处理。<br>我们还可以为一个 Servlet 配置多个访问路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (&#123;<span class="hljs-string">&quot;/test 1&quot;</span>, <span class="hljs-string">&quot;/test 2&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>我们接着来看<strong>loadOnStartup 属性</strong>，此属性决定了<strong>是否在 Tomcat 启动时就加载此 Servlet</strong>，默认情况下，Servlet 只有在被访问时才会加载，它的<strong>默认值为-1，表示不在启动时加载</strong>，我们可以将其修改为大于等于 0 的数，来开启启动时加载。并且<strong>数字的大小决定了此 Servlet 的启动优先级</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet</span> (value = <span class="hljs-string">&quot;/test&quot;</span>, loadOnStartup = <span class="hljs-number">1</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <span class="hljs-built_in">super</span>. init ();<br>        log. info (<span class="hljs-string">&quot;我被初始化了！&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp. setContentType (<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>        resp. getWriter (). write (<span class="hljs-string">&quot;&lt;h1&gt;恭喜你解锁了全新玩法&lt;/h1&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他内容都是 Servlet 的一些基本配置，这里就不详细讲解了。</p><h3 id="使用-POST-请求完成登陆"><a href="#使用-POST-请求完成登陆" class="headerlink" title="使用 POST 请求完成登陆"></a>使用 POST 请求完成登陆</h3><p>我们需要修改一下我们的 Servlet，现在我们要让其能够接收一个 POST 请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Log</span><br><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/login&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        req. getParameterMap (). forEach ((k, v) -&gt; &#123;<br>            System. out. println (k + <span class="hljs-string">&quot;: &quot;</span> + Arrays. toString (v));<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ParameterMap</code> 存储了我们发送的 POST 请求所携带的表单数据，我们可以直接将其遍历查看，浏览器发送了什么数据。<br>现在我们再来修改一下前端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录到系统<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;login&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;用户名&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;密码&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过修改 form 标签的属性，现在我们点击登录按钮，会自动向后台发送一个 POST 请求，请求地址为当前地址+&#x2F;login（注意不同路径的写法），也就是我们上面编写的 Servlet 路径。<br>运行服务器，测试后发现，在点击按钮后，确实向服务器发起了一个 POST 请求，并且携带了表单中文本框的数据。<br>现在，我们根据已有的基础，将其与数据库打通，我们进行一个真正的用户登录操作，首先修改一下 Servlet 的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//首先设置一下响应类型</span><br>    resp. setContentType (<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>    <span class="hljs-comment">//获取 POST 请求携带的表单数据</span><br>    Map&lt;String, String[]&gt; map = req. getParameterMap ();<br>    <span class="hljs-comment">//判断表单是否完整</span><br>    <span class="hljs-keyword">if</span> (map. containsKey (<span class="hljs-string">&quot;username&quot;</span>) &amp;&amp; map. containsKey (<span class="hljs-string">&quot;password&quot;</span>)) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req. getParameter (<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> req. getParameter (<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-comment">//权限校验（待完善）</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        resp. getWriter (). write (<span class="hljs-string">&quot;错误，您的表单数据不完整！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们再去编写<strong>Mybatis 的依赖和配置文件</strong>，创建一个表，用于存放我们用户的账号和密码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br>&lt;! DOCTYPE configuration<br>        PUBLIC &quot;-//mybatis. org//DTD Config 3.0//EN&quot;<br>        &quot; http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.example.mapper.UserMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置完成后，在我们的<strong>Servlet 的 init 方法中编写 Mybatis 初始化代码</strong>，因为它只需要初始化一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">SqlSessionFactory factory;<br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    factory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span> (). build (Resources. getResourceAsReader (<span class="hljs-string">&quot;mybatis-config. xml&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们创建一个实体类以及 Mapper 来进行用户信息查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from users where username = #&#123;username&#125; and password = #&#123;password&#125;&quot;</span>)<br>    User <span class="hljs-title function_">getUser</span> <span class="hljs-params">(<span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;username&quot;</span>)</span> String username, <span class="hljs-meta">@Param</span> (<span class="hljs-string">&quot;password&quot;</span>) String password);<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，现在完事具备，只欠东风了，我们来完善一下登陆验证逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//登陆校验（待完善）</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> factory. openSession (<span class="hljs-literal">true</span>))&#123;<br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession. getMapper (UserMapper. class);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper. getUser (username, password);<br>    <span class="hljs-comment">//判断用户是否登陆成功，若查询到信息则表示存在此用户</span><br>    <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>)&#123;<br>        resp. getWriter (). write (<span class="hljs-string">&quot;登陆成功！&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        resp. getWriter (). write (<span class="hljs-string">&quot;登陆失败，请验证您的用户名或密码！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="上传和下载文件"><a href="#上传和下载文件" class="headerlink" title="上传和下载文件"></a>上传和下载文件</h3><p>首先我们来看看比较简单的下载文件，首先将我们的 icon. png 放入到 resource 文件夹中，接着我们编写一个 Servlet 用于处理文件下载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/file&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>      resp. setContentType (<span class="hljs-string">&quot;image/png&quot;</span>);  <br>      <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> resp. getOutputStream ();<br>      <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources. getResourceAsStream (<span class="hljs-string">&quot;icon. png&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更加快速地编写 IO 代码，我们可以引入一个工具库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用此类库可以快速完成 IO 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">resp. setContentType (<span class="hljs-string">&quot;image/png&quot;</span>);<br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> resp. getOutputStream ();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources. getResourceAsStream (<span class="hljs-string">&quot;icon. png&quot;</span>);<br><span class="hljs-comment">//直接使用 copy 方法完成转换</span><br>IOUtils. copy (inputStream, outputStream);<br></code></pre></td></tr></table></figure><p>现在我们在前端页面添加一个链接，用于下载此文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;icon.png&quot;</span>&gt;</span>点我下载高清资源<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下载文件搞定，那么如何上传一个文件呢？<br>首先我们编写前端部分：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test-file&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意必须添加 <code>enctype=&quot;multipart/form-data&quot;</code>，来表示此表单用于文件传输。<br>现在我们来修改一下 Servlet 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MultipartConfig</span><br><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/file&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span> (<span class="hljs-string">&quot;/Users/nagocoler/Documents/IdeaProjects/WebTest/test. png&quot;</span>))&#123;<br>            <span class="hljs-type">Part</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> req. getPart (<span class="hljs-string">&quot;test-file&quot;</span>);<br>            IOUtils. copy (part. getInputStream (), stream);<br>            resp. setContentType (<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>            resp. getWriter (). write (<span class="hljs-string">&quot;文件上传成功！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，必须添加 <code>@MultipartConfig</code> 注解来表示此 Servlet 用于处理文件上传请求。<br>现在我们再运行服务器，并将我们刚才下载的文件又上传给服务端。</p><h3 id="使用-XHR-请求数据"><a href="#使用-XHR-请求数据" class="headerlink" title="使用 XHR 请求数据"></a>使用 XHR 请求数据</h3><blockquote><p>XHR 请求封装后就是<strong>Ajax，axios</strong>之类的 js 请求。</p></blockquote><p>现在我们希望，网页中的部分内容，可以动态显示，比如网页上有一个时间，旁边有一个按钮，点击按钮就可以刷新当前时间。<br>这个时候就需要我们在网页展示时向后端发起请求了，并根据后端响应的结果，动态地更新页面中的内容，要实现此功能，就需要用到 JavaScript 来帮助我们，首先在 js 中编写我们的<strong>XHR 请求</strong>，并在请求中完成动态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTime</span> () &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span> ();<br>    xhr. onreadystatechange = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (xhr. readyState === <span class="hljs-number">4</span> &amp;&amp; xhr. status === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-variable language_">document</span>. getElementById (<span class="hljs-string">&quot;time&quot;</span>). innerText = xhr. responseText<br>        &#125;<br>    &#125;;<br>    xhr. open (<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-literal">true</span>);<br>    xhr. send ();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着修改一下前端页面，添加一个时间显示区域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;updateTime()&quot;</span>&gt;</span>更新数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    updateTime ()<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后创建一个 Servlet 用于处理时间更新请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (<span class="hljs-string">&quot;/time&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">dateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span> (<span class="hljs-string">&quot;yyyy 年 MM 月 dd 日 HH:mm: ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> dateFormat. format (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> ());<br>        resp. setContentType (<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>        resp. getWriter (). write (date);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重定向与请求转发"><a href="#重定向与请求转发" class="headerlink" title="重定向与请求转发"></a>重定向与请求转发</h3><p>当我们希望用户登录完成之后，直接跳转到网站的首页，那么这个时候，我们就可以使用重定向来完成。当浏览器收到一个重定向的响应时，会按照重定向响应给出的地址，再次向此地址发出请求。<br>实现重定向很简单，只需要调用一个方法即可，我们修改一下登陆成功后执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">resp. sendRedirect (<span class="hljs-string">&quot;time&quot;</span>);<br></code></pre></td></tr></table></figure><p>调用后，响应的状态码会被设置为 302，并且响应头中添加了一个 Location 属性，此属性表示，需要重定向到哪一个网址。<br>请求转发其实是一种服务器内部的跳转机制，我们知道，重定向会使得浏览器去重新请求一个页面，而请求转发则是服务器内部进行跳转，它的目的是，直接将本次请求转发给其他 Servlet 进行处理，并由其他 Servlet 来返回结果，因此它是在进行内部的转发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">req. getRequestDispatcher (<span class="hljs-string">&quot;/time&quot;</span>). forward (req, resp);<br></code></pre></td></tr></table></figure><p>现在，在登陆成功的时候，我们将请求转发给处理时间的 Servlet，注意这里的路径规则和之前的不同，我们需要填写 Servlet 上指明的路径，并且请求转发只能转发到此应用程序内部的 Servlet，不能转发给其他站点或是其他 Web 应用程序。<br>现在再次进行登陆操作，我们发现，返回结果为一个 405 页面，证明了，我们的请求现在是被另一个 Servlet 进行处理，并且请求的信息全部被转交给另一个 Servlet，由于此 Servlet 不支持 POST 请求，因此返回 405 状态码。<br>那么也就是说，该请求包括请求参数也一起被传递了，那么我们可以尝试获取以下 POST 请求的参数。<br>现在我们给此 Servlet 添加 POST 请求处理，直接转交给 Get 请求处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-built_in">this</span>. doGet (req, resp);<br>&#125;<br></code></pre></td></tr></table></figure><p>再次访问，成功得到结果，但是我们发现，浏览器只发起了一次请求，并没有再次请求新的 URL，也就是说，这一次请求直接返回了请求转发后的处理结果。<br><strong>请求转发的好处在于一次请求并且可以携带数据</strong>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">req. setAttribute (<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是请求转发前的数据&quot;</span>);<br>req. getRequestDispatcher (<span class="hljs-string">&quot;/time&quot;</span>). forward (req, resp);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System. out. println (req. getAttribute (<span class="hljs-string">&quot;test&quot;</span>));<br></code></pre></td></tr></table></figure><p>通过 <code>setAttribute</code> 方法来给当前请求添加一个附加数据，在请求转发后，我们可以直接获取到该数据。<br>重定向属于 2 次请求，因此无法使用这种方式来传递数据，那么，如何在重定向之间传递数据呢？我们可以使用即将要介绍的 <code>ServletContext</code> 对象。<br>最后总结，两者的区别为：</p><ul><li><strong>请求转发</strong>是<strong>一次请求</strong>，<strong>重定向</strong>是<strong>两次请求，第二次请求一定是 Get</strong></li><li><strong>请求转发</strong>可以<strong>共享请求参数</strong> ，<strong>重定向</strong>之后，就<strong>获取不了共享参数</strong>了</li><li><strong>请求转发</strong>只能<strong>转发给内部的 Servlet</strong>，重定向可以<strong>重定向到其他站点</strong></li></ul><h3 id="了解-ServletContext-对象"><a href="#了解-ServletContext-对象" class="headerlink" title="了解 ServletContext 对象"></a>了解 ServletContext 对象</h3><p><strong>ServletContext 全局唯一</strong>，它是属于整个 Web 应用程序的，我们可以通过 <code>getServletContext ()</code> 来获取到此对象。<br>此对象也能设置附加值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> getServletContext ();<br>context. setAttribute (<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;我是重定向之前的数据&quot;</span>);<br>resp. sendRedirect (<span class="hljs-string">&quot;time&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System. out. println (getServletContext (). getAttribute (<span class="hljs-string">&quot;test&quot;</span>));<br></code></pre></td></tr></table></figure><p>因为无论在哪里，无论什么时间，获取到的<strong>ServletContext 始终是同一个对象</strong>，因此我们可以随时随地获取我们添加的属性。<br>它不仅仅可以用来进行<strong>数据传递</strong>，还可以做一些其他的事情，比如<strong>请求转发</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> getServletContext ()<br>context. getRequestDispatcher (<span class="hljs-string">&quot;/time&quot;</span>). forward (req, resp);<br></code></pre></td></tr></table></figure><p>它还可以获取根目录下的资源文件（注意是 webapp 根目录下的，不是 resource 中的资源）</p><h3 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h3><p>初始化参数类似于初始化配置需要的一些值，比如我们的数据库连接相关信息，就可以通过初始化参数来给予 Servlet，或是一些其他的配置项，也可以使用初始化参数来实现。<br>我们可以给一个 Servlet 添加一些初始化参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span> (value = <span class="hljs-string">&quot;/login&quot;</span>, initParams = &#123;<br>        <span class="hljs-meta">@WebInitParam</span> (name = <span class="hljs-string">&quot;test&quot;</span>, value = <span class="hljs-string">&quot;我是一个默认的初始化参数&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>它也是以键值对形式保存的，我们可以直接通过 Servlet 的 <code>getInitParameter</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System. out. println (getInitParameter (<span class="hljs-string">&quot;test&quot;</span>));<br></code></pre></td></tr></table></figure><p>但是，这里的初始化参数仅仅是针对于此 Servlet，我们也可以定义全局初始化参数，只需要在 web. xml 编写即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>lbwnb<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>我是全局初始化参数<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>我们需要使用<em><strong>ServletContext 来读取全局初始化参数</strong>，但是</em><em>不能读取注解中的 initParams 中的局部参数</em>**：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> getServletContext ();<br>System. out. println (context. getInitParameter (<span class="hljs-string">&quot;lbwnb&quot;</span>));<br></code></pre></td></tr></table></figure><hr><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie 可以在浏览器中保存一些信息，并且在下次请求时，请求头中会携带这些信息。<br>我们可以编写一个测试用例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span> (<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>);<br>resp. addCookie (cookie);<br>resp. sendRedirect (<span class="hljs-string">&quot;time&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Cookie cookie : req. getCookies ()) &#123;<br>    System. out. println (cookie. getName () + <span class="hljs-string">&quot;: &quot;</span> + cookie. getValue ());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以观察一下，在 <code>HttpServletResponse</code> 中添加 Cookie 之后，浏览器的响应头中会包含一个 <code>Set-Cookie</code> 属性，同时，在重定向之后，我们的请求头中，会携带此 Cookie 作为一个属性，同时，我们可以直接通过 <code>HttpServletRequest</code> 来快速获取有哪些 Cookie 信息。<br><img src="https://s2.loli.net/2023/03/06/3JcLpr9GYMnbBHw.jpg" alt="点击查看源网页"><br>一个 Cookie 包含哪些信息：</p><ul><li>name   -   Cookie 的名称，Cookie 一旦创建，名称便不可更改</li><li>value  -   Cookie 的值，如果值为 Unicode 字符，需要为字符编码。如果为二进制数据，则需要使用 BASE 64 编码</li><li>maxAge  -  Cookie 失效的时间，单位秒。如果为正数，则该 Cookie 在 maxAge 秒后失效。如果为负数，该 Cookie 为临时 Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该 Cookie。如果为 0，表示删除该 Cookie。默认为-1。</li><li>secure  -  该 Cookie 是否仅被使用安全协议传输。安全协议。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。</li><li>path  -  Cookie 的使用路径。如果设置为“&#x2F;sessionWeb&#x2F;”，则只有 contextPath 为“&#x2F;sessionWeb”的程序可以访问该 Cookie。如果设置为“&#x2F;”，则本域名下 contextPath 都可以访问该 Cookie。注意最后一个字符必须为“&#x2F;”。</li><li>domain  -  可以访问该 Cookie 的域名。如果设置为“. google. com”，则所有以“google. com”结尾的域名都可以访问该 Cookie。注意第一个字符必须为“.”。</li><li>comment  -  该 Cookie 的用处说明，浏览器显示 Cookie 信息的时候显示该说明。</li><li>version  -  Cookie 使用的版本号。0 表示遵循 Netscape 的 Cookie 规范，1 表示遵循 W 3 C 的 RFC 2109 规范</li></ul><p>我们发现，最关键的其实是 <code>name</code>、<code>value</code>、<code>maxAge</code>、<code>domain</code> 属性。<br>那么我们来尝试修改一下 maxAge 来看看失效时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cookie. setMaxAge (<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>设定为 20 秒，我们可以直接看到，响应头为我们设定了 20 秒的过期时间。20 秒内访问都会携带此 Cookie，而超过 20 秒，Cookie 消失。<br>既然了解了 Cookie 的作用，我们就可以通过使用 Cookie 来实现记住我功能，我们可以将<strong>用户名和密码全部保存在 Cookie 中</strong>，如果访问我们的首页时携带了这些 Cookie，那么我们就可以直接为用户进行登陆，如果登陆成功则直接跳转到首页，如果登陆失败，则清理浏览器中的 Cookie。<br><strong>（1）Cookie 存储用户信息案例</strong><br>那么首先，我们先在前端页面的表单中添加一个勾选框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;记住我&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;remember-me&quot;</span>&gt;</span><br>        记住我<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着，我们在登陆成功时进行判断，如果用户勾选了记住我，那么就讲 Cookie 存储到本地：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (map. containsKey (<span class="hljs-string">&quot;remember-me&quot;</span>))&#123;   <span class="hljs-comment">//若勾选了勾选框，那么会此表单信息</span><br>    <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie_username</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span> (<span class="hljs-string">&quot;username&quot;</span>, username);<br>    cookie_username. setMaxAge (<span class="hljs-number">30</span>);<br>    <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie_password</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span> (<span class="hljs-string">&quot;password&quot;</span>, password);<br>    cookie_password. setMaxAge (<span class="hljs-number">30</span>);<br>    resp. addCookie (cookie_username);<br>    resp. addCookie (cookie_password);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们修改一下默认的请求地址，现在一律通过 <code> http://localhost:8080/yyds/login</code> 进行登陆，那么我们需要添加 GET 请求的相关处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    Cookie[] cookies = req. getCookies ();<br>    <span class="hljs-keyword">if</span> (cookies != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>            <span class="hljs-keyword">if</span> (cookie. getName (). equals (<span class="hljs-string">&quot;username&quot;</span>)) username = cookie. getValue ();<br>            <span class="hljs-keyword">if</span> (cookie. getName (). equals (<span class="hljs-string">&quot;password&quot;</span>)) password = cookie. getValue ();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (username != <span class="hljs-literal">null</span> &amp;&amp; password != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//登陆校验</span><br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> factory. openSession (<span class="hljs-literal">true</span>))&#123;<br>                <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession. getMapper (UserMapper. class);<br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper. getUser (username, password);<br>                <span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>)&#123;<br>                    resp. sendRedirect (<span class="hljs-string">&quot;time&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//直接返回</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    req. getRequestDispatcher (<span class="hljs-string">&quot;/&quot;</span>). forward (req, resp);   <span class="hljs-comment">//正常情况还是转发给默认的 Servlet 帮我们返回静态页面</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，30 秒内都不需要登陆，访问登陆页面后，会直接跳转到 time 页面。<br>现在已经离我们理想的页面越来越接近了，但是仍然有一个问题，就是我们的首页，无论是否登陆，所有人都可以访问，那么，如何才可以实现只有登陆之后才能访问呢？这就需要用到 Session 了。</p><hr><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>由于 HTTP 是无连接的，那么如何能够辨别当前的请求是来自哪个用户发起的呢？Session 就是用来处理这种问题的，<strong>每个用户的会话</strong>都会<strong>有一个自己的 Session 对象</strong>，来自<strong>同一个浏览器的所有请求</strong>，就属于<strong>同一个会话</strong>。<br>但是 HTTP 协议是无连接的呀，那 Session 是如何做到辨别是否来自同一个浏览器呢？Session 实际上是基于 Cookie 实现的，前面我们了解了 Cookie，我们知道，服务端可以将 Cookie 保存到浏览器，当浏览器下次访问时，就会附带这些 Cookie 信息。<br>Session 也利用了这一点，它会给浏览器设定一个叫做 <code>JSESSIONID</code> 的 Cookie，值是一个随机的排列组合，而此 Cookie 就对应了你属于哪一个对话，只要我们的浏览器携带此 Cookie 访问服务器，服务器就会通过 Cookie 的值进行辨别，得到对应的 Session 对象，因此，这样就可以追踪到底是哪一个浏览器在访问服务器。<br><img src="https://s2.loli.net/2023/03/06/wCYHNg39tFcK76M.gif" alt="点击查看源网页"><br>那么现在，我们在用户登录成功之后，将<strong>用户对象添加到 Session</strong>中，只要是此用户发起的请求，我们都可以从 <code>HttpSession</code> 中读取到存储在会话中的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req. getSession ();<br>session. setAttribute (<span class="hljs-string">&quot;user&quot;</span>, user);<br></code></pre></td></tr></table></figure><p>同时，如果用户没有登录就去访问首页，那么我们将发送一个重定向请求，告诉用户，需要先进行登录才可以访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req. getSession ();<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session. getAttribute (<span class="hljs-string">&quot;user&quot;</span>);<br><span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>    resp. sendRedirect (<span class="hljs-string">&quot;login&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在访问的过程中，注意观察 Cookie 变化。<br>Session 并不是永远都存在的，它有着自己的过期时间，默认时间为 30 分钟，若超过此时间，Session 将丢失，我们可以在配置文件中修改过期时间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们也可以在代码中使用 <code>invalidate</code> 方法来使 Session 立即失效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">session. invalidate ();<br></code></pre></td></tr></table></figure><p>现在，<strong>通过 Session，我们就可以更好地控制用户对于资源的访问</strong>，只有完成登陆的用户才有资格访问首页。</p><blockquote><p>[!NOTE] <strong>Session 和 Cookie 区别与联系</strong>？<br>Session 和 Cookie 是在 Web 开发中用于跟踪用户状态和保持用户信息的两种常见机制。</p><ol><li>Cookie（HTTP Cookie）是<strong>服务器发送到用户浏览器并存储在用户本地计算机上的小型文本文件</strong>。它包含了一些关于用户的信息，例如用户的身份认证、偏好设置等。浏览器在每次请求时都会将 Cookie 发送给服务器，以便服务器可以根据 Cookie 中的信息进行相应的处理。Cookie 可以设置过期时间，可以在<strong>浏览器关闭后仍然保留，并且可以在不同的页面之间共享</strong>。 </li><li>Session 是<strong>服务器端的机制</strong>，用于在<strong>服务器上存储和跟踪用户的状态信息</strong>。当用户访问网站时，服务器会为该用户创建一个唯一的会话标识（Session ID），并将该标识存储在服务器上。然后，服务器将 Session ID 发送给浏览器，通常通过 Cookie，以便在用户的后续请求中进行识别。服务器可以使用 Session 来存储用户的信息和状态，以便在用户与服务器之间的交互中进行跟踪和管理。与 Cookie 不同，Session 数据存储在服务器上，用户无法直接修改。Session ID 是在<strong>用户登录或注销时</strong>发生改变的。<br> 总结起来，<strong>Cookie</strong> 存储在用户<strong>本地</strong>计算机上，用于存储用户信息和状态，由<strong>浏览器管理</strong>；而 <em>Session</em> 存储在<em>服务器</em>上，用于存储用户信息和状态，由<em>服务器管理</em>。<u>Cookie 在浏览器关闭后仍然存在，可以在不同页面间共享；而 Session 在用户关闭浏览器后通常会自动销毁。</u></li></ol></blockquote><blockquote><p>[!NOTE]<br><strong>Session ID 的改变通常在以下情况下发生</strong>：</p><ol><li><p>用户登录或注销：当用户登录或注销时，会话状态发生改变，旧的会话将被销毁，新的会话将被创建，因此会生成一个新的 Session ID。</p></li><li><p>Session 过期：会话可以设置过期时间，如果会话超过了过期时间没有活动，会话将被销毁，并在下一次请求时生成一个新的 Session ID。</p></li><li><p>会话管理策略更改：在某些情况下，会话管理策略可能会更改，例如更改会话超时时间、更改会话存储方式等，这可能会导致生成新的 Session ID。</p></li><li><p>会话迁移：在某些情况下，会话可能需要从一个服务器迁移到另一个服务器，这可能会导致生成新的 Session ID。</p></li></ol></blockquote><blockquote><p>需要注意的是，Session ID 的改变并不一定意味着会话数据的丢失，会话数据可以通过新的 Session ID 进行关联和恢复。但在某些情况下，可能需要特别注意处理会话数据的转移和迁移。</p></blockquote><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>有了 Session 之后，我们就可以很好地控制用户的登陆验证了，只有授权的用户，才可以访问一些页面，但是我们需要一个一个去进行配置，还是太过复杂，能否一次性地过滤掉没有登录验证的用户呢？<br><strong>过滤器相当于在所有访问前加了一堵墙</strong>，来自浏览器的所有访问请求都会首先经过过滤器，只有过滤器允许通过的请求，才可以顺利地到达对应的 <code>Servlet</code>，而过滤器不允许的通过的请求，我们可以自由地进行控制是否进行<strong>重定向或是请求转发</strong>。并且过滤器可以添加很多个，就相当于添加了很多堵墙，我们的请求只有穿过层层阻碍，才能与 Servlet 相拥，像极了爱情。<br><img src="https://s2.loli.net/2023/03/06/md9X75EToshnH8I.jpg" alt="点击查看源网页"><br>添加一个过滤器非常简单，只需要实现 Filter 接口，并添加 <code>@WebFilter</code> 注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter</span> (<span class="hljs-string">&quot;/*&quot;</span>)   <span class="hljs-comment">//路径的匹配规则和 Servlet 一致，这里表示匹配所有请求</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span> <span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就成功地添加了一个过滤器，那么添加一句打印语句看看，是否所有的请求都会经过此过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>System. out. println (request. getRequestURL ());<br></code></pre></td></tr></table></figure><p>我们发现，现在我们发起的所有请求，一律需要经过此过滤器，并且所有的请求都没有任何的响应内容。<br>那么如何让请求可以顺利地到达对应的 Servlet，也就是说怎么让这个请求顺利通过呢？我们只需要在最后添加一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">filterChain. doFilter (servletRequest, servletResponse);<br></code></pre></td></tr></table></figure><p>那么这行代码是什么意思呢？<br>由于我们整个应用程序可能存在多个过滤器，那么这行代码的意思实际上是<strong>将此请求继续传递给下一个过滤器</strong>，当没有下一个过滤器时，才会到达对应的 Servlet 进行处理，我们可以再来创建一个过滤器看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter</span> (<span class="hljs-string">&quot;/*&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-number">2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span> <span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        System. out. println (<span class="hljs-string">&quot;我是 2 号过滤器&quot;</span>);<br>        filterChain. doFilter (servletRequest, servletResponse);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于过滤器的过滤顺序是按照类名的自然排序进行的，因此我们将第一个过滤器命名进行调整。<br>我们发现，在经过第一个过滤器之后，会继续前往第二个过滤器，只有两个过滤器全部经过之后，才会到达我们的 Servlet 中。<br><img src="https://s2.loli.net/2023/03/06/LaDmPMWEtAB1HVF.jpg" alt="点击查看源网页"><br>实际上，当 <code>doFilter</code> 方法调用时，就会<strong>一直向下直到 Servlet</strong>，在 Servlet 处理完成之后，又<strong>依次返回</strong>到最前面的 Filter，类似于递归的结构，我们添加几个输出语句来判断一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span> <span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    System. out. println (<span class="hljs-string">&quot;我是 2 号过滤器&quot;</span>);<br>    filterChain. doFilter (servletRequest, servletResponse);<br>    System. out. println (<span class="hljs-string">&quot;我是 2 号过滤器，处理后&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span> <span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    System. out. println (<span class="hljs-string">&quot;我是 1 号过滤器&quot;</span>);<br>    filterChain. doFilter (servletRequest, servletResponse);<br>    System. out. println (<span class="hljs-string">&quot;我是 1 号过滤器，处理后&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后验证我们的结论。<br>同 Servlet 一样，Filter 也有对应的 HttpFilter 专用类，它针对 HTTP 请求进行了专门处理，因此我们可以直接使用 HttpFilter 来编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericFilter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7478463438252262094</span> L;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpFilter</span> <span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span> <span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-keyword">if</span> (req <span class="hljs-keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="hljs-keyword">instanceof</span> HttpServletResponse) &#123;<br>            <span class="hljs-built_in">this</span>. doFilter ((HttpServletRequest) req, (HttpServletResponse) res, chain);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span> (<span class="hljs-string">&quot;non-HTTP request or response&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        chain. doFilter (req, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在，我们就可以给我们的应用程序添加一个过滤器，用户在未登录情况下，只允许<strong>静态资源和登陆页面</strong>请求通过，登陆之后畅行无阻：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter</span> (<span class="hljs-string">&quot;/*&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpFilter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span> <span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> req. getRequestURL (). toString ();<br>        <span class="hljs-comment">//判断是否为静态资源</span><br>        <span class="hljs-keyword">if</span> (! url. endsWith (<span class="hljs-string">&quot;. js&quot;</span>) &amp;&amp; !url. endsWith (<span class="hljs-string">&quot;. css&quot;</span>) &amp;&amp; !url. endsWith (<span class="hljs-string">&quot;. png&quot;</span>))&#123;<br>            <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req. getSession ();<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session. getAttribute (<span class="hljs-string">&quot;user&quot;</span>);<br>            <span class="hljs-comment">//判断是否未登陆</span><br>            <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> &amp;&amp; !url. endsWith (<span class="hljs-string">&quot;login&quot;</span>))&#123;<br>                res. sendRedirect (<span class="hljs-string">&quot;login&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//交给过滤链处理</span><br>        chain. doFilter (req, res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h1><p>如果我们希望，在应用程序加载的时候，或是 Session 创建的时候，亦或是在 Request 对象创建的时候进行一些操作，那么这个时候，我们就可以使用监听器来实现。<br><img src="https://s2.loli.net/2023/03/06/xl4hzgOaSCdXHcu.png" alt="img"><br>默认为我们提供了很多类型的监听器，我们这里就演示一下监听 Session 的创建即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpSessionListener</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sessionCreated</span> <span class="hljs-params">(HttpSessionEvent se)</span> &#123;<br>        System. out. println (<span class="hljs-string">&quot;有一个 Session 被创建了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有关监听器相关内容，了解即可。</p><hr><h1 id="了解-JSP-页面与加载规则"><a href="#了解-JSP-页面与加载规则" class="headerlink" title="了解 JSP 页面与加载规则"></a>了解 JSP 页面与加载规则</h1><p>前面我们已经完成了整个 Web 应用程序生命周期中所有内容的学习，我们已经完全了解，如何编写一个 Web 应用程序，并放在 Tomcat 上部署运行，以及如何控制浏览器发来的请求，通过 Session+Filter 实现用户登陆验证，通过 Cookie 实现自动登陆等操作。到目前为止，我们已经具备编写一个完整 Web 网站的能力。<br>在之前的教程中，我们的前端静态页面并没有与后端相结合，我们前端页面所需的数据全部需要单独向后端发起请求获取，并动态进行内容填充，这是一种典型的前后端分离写法，前端只负责要数据和显示数据，后端只负责处理数据和提供数据，这也是现在更流行的一种写法，让前端开发者和后端开发者各尽其责，更加专一，这才是我们所希望的开发模式。<br>JSP 并不是我们需要重点学习的内容，因为它已经过时了，使用 JSP 会导致前后端严重耦合，因此这里只做了解即可。<br>JSP 其实就是一种模板引擎，那么何谓模板引擎呢？顾名思义，它就是一个模板，而模板需要我们填入数据，才可以变成一个页面，也就是说，我们可以直接在前端页面中直接填写数据，填写后生成一个最终的 HTML 页面返回给前端。<br>首先我们来创建一个新的项目，项目创建成功后，删除 Java 目录下的内容，只留下默认创建的 jsp 文件，我们发现，在 webapp 目录中，存在一个 <code>index. jsp</code> 文件，现在我们直接运行项目，会直接访问这个 JSP 页面。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;JSP - Hello World&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;&lt;%= <span class="hljs-string">&quot;Hello World!&quot;</span> %&gt;<br>&lt;/h1&gt;<br>&lt;br/&gt;<br>&lt;a href=<span class="hljs-string">&quot;hello-servlet&quot;</span>&gt;Hello Servlet&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>但是我们并没有编写对应的 Servlet 来解析啊，那么为什么这个 JSP 页面会被加载呢？<br>实际上，我们一开始提到的两个 Tomcat 默认的 Servlet 中，一个是用于请求静态资源，还有一个就是用于处理 jsp 的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- The mappings for the JSP servlet --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>jsp<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*. jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*. jspx<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么，JSP 和普通 HTML 页面有什么区别呢，我们发现它的语法和普通 HTML 页面几乎一致，我们可以直接在 JSP 中编写 Java 代码，并在页面加载的时候执行，我们随便找个地方插入：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br>    System. out. println (<span class="hljs-string">&quot;JSP 页面被加载&quot;</span>);<br>%&gt;<br></code></pre></td></tr></table></figure><p>我们发现，请求一次页面，页面就会加载一次，并执行我们填写的 Java 代码。也就是说，我们可以直接在此页面中执行 Java 代码来填充我们的数据，这样我们的页面就变成了一个动态页面，使用 <code>&lt;%=  %&gt;</code> 来填写一个值：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;h1&gt;&lt;%= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() %&gt;&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>现在访问我们的网站，每次都会创建一个新的 Date 对象，因此每次访问获取的时间都不一样，我们的网站已经算是一个动态的网站的了。<br>虽然这样在一定程度上上为我们提供了便利，但是这样的写法相当于整个页面既要编写前端代码，也要编写后端代码，随着项目的扩大，整个页面会显得难以阅读，并且现在都是前后端开发人员职责非常明确的，如果要编写 JSP 页面，那就必须要招一个既会前端也会后端的程序员，这样显然会导致不必要的开销。<br>那么我们来研究一下，为什么 JSP 页面能够在加载的时候执行 Java 代码呢？<br>首先我们将此项目打包，并在 Tomcat 服务端中运行，生成了一个文件夹并且可以正常访问。<br>我们现在看到 <code>work</code> 目录，我们发现这个里面多了一个 <code>index_jsp. java</code> 和 <code>index_jsp. class</code>，那么这些东西是干嘛的呢，我们来反编译一下就啥都知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">index_jsp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">org</span>. apache. jasper. runtime. HttpJspBase  <span class="hljs-comment">//继承自 HttpServlet</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">org</span>. apache. jasper. runtime. JspSourceDependent,<br>                 org. apache. jasper. runtime. JspSourceImports &#123;<br> ...<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_jspService</span> <span class="hljs-params">(<span class="hljs-keyword">final</span> jakarta. servlet. http. HttpServletRequest request, <span class="hljs-keyword">final</span> jakarta. servlet. http. HttpServletResponse response)</span><br>      <span class="hljs-keyword">throws</span> java. io. IOException, jakarta. servlet. ServletException &#123;<br>    <span class="hljs-keyword">if</span> (! jakarta. servlet. DispatcherType. ERROR. equals (request. getDispatcherType ())) &#123;<br>      <span class="hljs-keyword">final</span> java. lang. <span class="hljs-type">String</span> <span class="hljs-variable">_jspx_method</span> <span class="hljs-operator">=</span> request. getMethod ();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OPTIONS&quot;</span>. equals (_jspx_method)) &#123;<br>        response. setHeader (<span class="hljs-string">&quot;Allow&quot;</span>,<span class="hljs-string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;GET&quot;</span>. equals (_jspx_method) &amp;&amp; !<span class="hljs-string">&quot;POST&quot;</span>. equals (_jspx_method) &amp;&amp; !<span class="hljs-string">&quot;HEAD&quot;</span>. equals (_jspx_method)) &#123;<br>        response. setHeader (<span class="hljs-string">&quot;Allow&quot;</span>,<span class="hljs-string">&quot;GET, HEAD, POST, OPTIONS&quot;</span>);<br>        response. sendError (HttpServletResponse. SC_METHOD_NOT_ALLOWED, <span class="hljs-string">&quot;JSP 只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> jakarta. servlet. jsp. PageContext pageContext;<br>    jakarta. servlet. http. <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">final</span> jakarta. servlet. ServletContext application;<br>    <span class="hljs-keyword">final</span> jakarta. servlet. ServletConfig config;<br>    jakarta. servlet. jsp. <span class="hljs-type">JspWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">final</span> java. lang. <span class="hljs-type">Object</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>    jakarta. servlet. jsp. <span class="hljs-type">JspWriter</span> <span class="hljs-variable">_jspx_out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    jakarta. servlet. jsp. <span class="hljs-type">PageContext</span> <span class="hljs-variable">_jspx_page_context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      response. setContentType (<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br>      pageContext = _jspxFactory. getPageContext (<span class="hljs-built_in">this</span>, request, response,<br>             <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-literal">true</span>);<br>      _jspx_page_context = pageContext;<br>      application = pageContext. getServletContext ();<br>      config = pageContext. getServletConfig ();<br>      session = pageContext. getSession ();<br>      out = pageContext. getOut ();<br>      _jspx_out = out;<br>      out. write (<span class="hljs-string">&quot;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;html&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;head&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;    &lt;title&gt;JSP - Hello World&lt;/title&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;/head&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;body&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span>);<br>      out. print ( <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> () );<br>      out. write (<span class="hljs-string">&quot;&lt;/h1&gt;\n&quot;</span>);<br>    System. out. println (<span class="hljs-string">&quot;JSP 页面被加载&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;br/&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;a href=\&quot;hello-servlet\&quot;&gt;Hello Servlet&lt;/a&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;/body&gt;\n&quot;</span>);<br>      out. write (<span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (java. lang. Throwable t) &#123;<br>      <span class="hljs-keyword">if</span> (! (t <span class="hljs-keyword">instanceof</span> jakarta. servlet. jsp. SkipPageException))&#123;<br>        out = _jspx_out;<br>        <span class="hljs-keyword">if</span> (out != <span class="hljs-literal">null</span> &amp;&amp; out. getBufferSize () != <span class="hljs-number">0</span>)<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (response. isCommitted ()) &#123;<br>              out. flush ();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              out. clearBuffer ();<br>            &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (java. io. IOException e) &#123;&#125;<br>        <span class="hljs-keyword">if</span> (_jspx_page_context != <span class="hljs-literal">null</span>) _jspx_page_context. handlePageException (t);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span> (t);<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      _jspxFactory. releasePageContext (_jspx_page_context);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，它是继承自 <code>HttpJspBase</code> 类，我们可以反编译一下 jasper. jar（它在 tomcat 的 lib 目录中）来看看:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org. apache. jasper. runtime;<br><span class="hljs-keyword">import</span> jakarta. servlet. ServletConfig;<br><span class="hljs-keyword">import</span> jakarta. servlet. ServletException;<br><span class="hljs-keyword">import</span> jakarta. servlet. http. HttpServlet;<br><span class="hljs-keyword">import</span> jakarta. servlet. http. HttpServletRequest;<br><span class="hljs-keyword">import</span> jakarta. servlet. http. HttpServletResponse;<br><span class="hljs-keyword">import</span> jakarta. servlet. jsp. HttpJspPage;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> org. apache. jasper. compiler. Localizer;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpJspBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpJspPage</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> L;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">HttpJspBase</span> <span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <span class="hljs-built_in">super</span>. init (config);<br>        <span class="hljs-built_in">this</span>. jspInit ();<br>        <span class="hljs-built_in">this</span>._jspInit ();<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Localizer. getMessage (<span class="hljs-string">&quot;jsp. engine. info&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;3.0&quot;</span>&#125;);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>. jspDestroy ();<br>        <span class="hljs-built_in">this</span>._jspDestroy ();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>._jspService (request, response);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jspInit</span> <span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_jspInit</span> <span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jspDestroy</span> <span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_jspDestroy</span> <span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_jspService</span> <span class="hljs-params">(HttpServletRequest <span class="hljs-keyword">var</span> <span class="hljs-number">1</span>, HttpServletResponse <span class="hljs-keyword">var</span> <span class="hljs-number">2</span>)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Tomcat 在加载 JSP 页面时，会将其动态转换为一个 java 类并编译为 class 进行加载，而生成的 Java 类，正是一个 Servlet 的子类，而页面的内容全部被编译为输出字符串，这便是 JSP 的加载原理，因此，JSP 本质上依然是一个 Servlet！<br><img src="https://s2.loli.net/2023/03/06/UGJBqvOTDeX5SuM.png" alt="image-20230306164106712"></p><hr><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring 就是这样的一个框架（<a href="https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/core.html#spring-core">文档</a>，它就是为了简化开发而生，它是轻量级的<strong>IoC</strong>和<strong>AOP</strong>的容器框架，主要是针对<strong>Bean</strong>的生命周期进行管理的轻量级容器，并且它的生态已经发展得极为庞大。</p><h2 id="IOC-容器基础"><a href="#IOC-容器基础" class="headerlink" title="IOC 容器基础"></a>IOC 容器基础</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://zhuanlan.zhihu.com/p/637355010<br>title: &quot;深入理解spring-IOC&lt;容器的设计&gt;&quot;<br>description: &quot;spring在Java中的地位不言而喻，学习Java逃不开spring的学习。有人戏称Java程序员是spring程序员，因为，spring太强大了。它帮助Java程序员实现了很多基础功能，降低了程序员开发应用的难度。而也是有了spring的存…&quot;<br>host: zhuanlan.zhihu.com<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/637355010">深入理解spring-IOC&lt;容器的设计&gt; - 知乎</a><br>在 Spring 框架中，IOC（Inversion of Control）是一种设计原则和实现机制，<strong>它将对象的创建、依赖关系的管理和生命周期的控制从应用程序代码中解耦出来，交给容器来完成。</strong>  </p><blockquote><p>简单来说，IOC 就是由容器来控制对象的创建和管理，而不是由应用程序代码直接控制。通过 IOC，应用程序只需要定义好对象的依赖关系和配置信息，容器会根据这些信息来创建对象，并自动注入对象之间的依赖关系</p></blockquote><p><strong>高耦合度</strong>带来的缺点是很明显的，也是现代软件开发中很致命的问题。如果要改善这种情况，我们只能将各个模块进行解耦，让各个模块之间的依赖性不再那么地强。也就是说，Service 的实现类，不再由我们决定，而是让程序自己决定，所有的实现类对象，全部交给程序来管理，所有对象之间的关系，也由程序来动态决定，这样就引入了 IoC 理论。<br><strong>IOC</strong>是 Inversion of Control 的缩写，翻译为：“<strong>控制反转</strong>”，把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。<br><img src="https://image.itbaima.net/markdown/2022/10/08/XsYQRk93CHewISB.png"></p><blockquote><p>我们可以将对象交给 IoC 容器进行管理，比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    a.test(IoC.getBean(Service.class));   <span class="hljs-comment">//瞎编的一个容器类，但是是那个意思</span><br>    <span class="hljs-comment">//比如现在在IoC容器中管理的Service的实现是B，那么我们从里面拿到的Service实现就是B</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Service&gt; list;   <span class="hljs-comment">//一律使用Service，具体实现由IoC容器提供</span><br>    <span class="hljs-keyword">public</span> Service <span class="hljs-title function_">test</span><span class="hljs-params">(Service b)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Service</span>&#123; &#125;   <span class="hljs-comment">//使用Service做一个顶层抽象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Service</span>&#123;&#125;  <span class="hljs-comment">//B依然是具体实现类，并交给IoC容器管理</span><br></code></pre></td></tr></table></figure><p>当具体实现类发生修改时，我们同样只需要将<strong>新的实现类交给 IoC 容器管理</strong>，这样我们无需修改之前的任何代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Service</span>&#123; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Service</span>&#123;&#125;   <span class="hljs-comment">//现在实现类变成了D，但是之前的代码并不会报错</span><br></code></pre></td></tr></table></figure><p>这样，即使我们的底层实现类发生了修改，也不会导致与其相关联的类出现错误，而进行大面积修改，通过<strong>定义抽象+容器管理</strong>的形式，我们就可以将<strong>原有的强关联解除</strong>。<br><strong>高内聚，低耦合</strong>，是现代软件的开发的设计目标，而 Spring 框架就给我们提供了这样的一个 IoC 容器进行对象的的管理，一个由 Spring IoC 容器实例化、组装和管理的对象，我们称其为 Bean。</p><h2 id="第一个-Spring-项目"><a href="#第一个-Spring-项目" class="headerlink" title="第一个 Spring 项目"></a>第一个 Spring 项目</h2><p>首先一定要明确，使用 Spring 首要目的是为了<strong>使得软件项目进行解耦</strong>，而不是为了去简化代码！通过它，就可以更好的对我们的 Bean 进行管理，这一部分我们来体验一下 Spring 的基本使用。<br>Spring 并不是一个独立的框架，它实际上包含了很多的模块：<br><img src="https://s2.loli.net/2022/11/21/KT2XhuCNVmcSvi5.png" alt="image-20221121233807593"><br>而我们首先要去学习的就是<strong>Core Container</strong>，也就是核心容器模块，只有了解了 Spring 的核心技术，我们才能真正认识这个框架为我们带来的便捷之处。<br>Spring 是一个非入侵式的框架，就像一个工具库一样，它可以很简单地加入到我们已有的项目中，因此，我们只需要直接导入其依赖就可以使用了，Spring 核心框架的 Maven 依赖坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：与旧版教程不同的是，<strong>Spring 6</strong>要求你使用的 Java 版本为 <code>17</code> 及以上，包括后面我们在学习 SpringMvc 时，要求 Tomcat 版本必须为 10 以上。这个依赖中包含了如下依赖：</p></blockquote><p><img src="https://s2.loli.net/2022/11/22/HszTflPavUdQKGJ.png" alt="image-20221122133820198"><br>这里出现的都是 Spring 核心相关的内容，如 Beans、Core、Context、SpEL 以及非常关键的 AOP 框架，在本章中，我们都会进行讲解。</p><blockquote><p>如果在使用 Spring 框架的过程中出现如下警告：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">12</span> 月 <span class="hljs-number">17</span>, <span class="hljs-number">2022</span> <span class="hljs-number">3</span>:<span class="hljs-number">26</span>:<span class="hljs-number">26</span> 下午 org. springframework. core. LocalVariableTableParameterNameDiscoverer inspectClass<br>警告: <span class="hljs-keyword">Using</span> deprecated <span class="hljs-string">&#x27;-debug&#x27;</span> fallback <span class="hljs-keyword">for</span> parameter <span class="hljs-type">name</span> resolution. Compile the affected code <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;-parameters&#x27;</span> <span class="hljs-keyword">instead</span> <span class="hljs-keyword">or</span> avoid its introspection: XXXX<br></code></pre></td></tr></table></figure><p>这是因为 LocalVariableTableParameterNameDiscoverer 在 Spring 6.0.1 版本已经被标记为过时，并且即将移除，请在 Maven 配置文件中为编译插件添加 <code>-parameters</code> 编译参数：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.10.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">compilerArgs</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">arg</span>&gt;</span>-parameters<span class="hljs-tag">&lt;/<span class="hljs-name">arg</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">compilerArgs</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>没有此问题请无视这部分。</p></blockquote><p>这里我们就来尝试编写一个最简的 Spring 项目，我们在前面已经讲过了，Spring 会给我们提供 IoC 容器用于管理 Bean，但是我们得先为这个容器编写一个配置文件，我们可以通过配置文件告诉容器需要管理哪些 Bean 以及 Bean 的属性、依赖关系等等。<br>首先我们需要在 resource 中创建一个 Spring 配置文件（在 resource 中创建的文件，会在编译时被一起放到类路径下），命名为 test. xml，直接右键点击即可创建：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时 IDEA 会提示我们没有为此文件配置应用程序上下文，这里我们只需要指定成当前项目就行了，当然配置这个只是为了代码提示和依赖关系快速查看，如果不进行配置也不会影响什么，程序依然可以正常运行：<br><img src="https://s2.loli.net/2022/11/21/bBtrSWlVz9oD2JF.png" alt="image-20221121234427739"><br>这里我们直接按照默认配置点确定就行了：<br><img src="https://s2.loli.net/2022/11/21/xoatfu4nX6iRr3v.png" alt="image-20221121234447213"><br>Spring 为我们提供了一个 IoC 容器，用于去存放我们需要使用的对象，我们可以将对象交给 IoC 容器进行管理，当我们需要使用对象时，就可以向 IoC 容器去索要，并由它来决定给我们哪一个对象。而我们如果需要使用 Spring 为我们提供的 IoC 容器，那么就需要创建一个应用程序上下文，它代表的就是 IoC 容器，它会负责实例化、配置和组装 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//ApplicationContext是应用程序上下文的顶层接口，它有很多种实现，这里我们先介绍第一种</span><br>  <span class="hljs-comment">//因为这里使用的是XML配置文件，所以说我们就使用 ClassPathXmlApplicationContext 这个实现类</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;test.xml&quot;</span>);  <span class="hljs-comment">//这里写上刚刚的名字</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在我们要让 IoC 容器帮助我们管理一个 Student 对象（Bean），当我们需要这个对象时再申请，那么就需要这样，首先先将 Student 类定义出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.bean;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然现在要让别人帮忙管理对象，那么就不能再由我们自己去 new 这个对象了，而是编写对应的配置，我们打开刚刚创建的 <code>test.xml</code> 文件进行编辑，添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean name=<span class="hljs-string">&quot;student&quot;</span> class=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>这里我们就在配置文件中编写好了对应 Bean 的信息，之后容器就会根据这里的配置进行处理了。<br>现在，这个对象不需要我们再去创建了，而是由 IoC 容器自动进行创建并提供，我们可以直接从上下文中获取到它为我们创建的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;test.xml&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) context.getBean(<span class="hljs-string">&quot;student&quot;</span>);   <span class="hljs-comment">//使用getBean方法来获取对应的对象（Bean）</span><br>    student.hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这里得到的 Student 对象是由 Spring 通过<strong>反射机制</strong>帮助我们创建的，初学者会非常疑惑，为什么要这样来创建对象，而不是直接 new 一个对象？为什么要交给 IoC 容器管理呢？<br><img src="https://s2.loli.net/2022/11/22/sjLiFokU1f3CvH5.png" alt="image-20221122153946251"></p><h2 id="Bean-注册与配置"><a href="#Bean-注册与配置" class="headerlink" title="Bean 注册与配置"></a>Bean 注册与配置</h2><p>前面我们通过一个简单例子体验了一下如何使用 Spring 来管理我们的对象，并向 IoC 容器索要被管理的对象。这节课我们就来详细了解一下如何向 Spring 注册 Bean 以及 Bean 的相关配置。<br>实际上我们的配置文件可以有很多个，并且这些配置文件是可以相互导入的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;test.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是为了简单起见，我们还是从单配置文件开始讲起，首先我们需要知道如何配置 Bean 并注册。<br>要配置一个 Bean，只需要添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>但是这样写的话，Spring 无法得知我们要配置的 Bean 到底是哪一个类，所以说我们还得指定对应的类才可以：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/22/SRV3znQJH4A7vDl.png" alt="image-20221122164149924"><br>可以看到类的旁边出现了 Bean 的图标，表示我们的 Bean 已经注册成功了，这样，我们就可以根据类型向容器索要 Bean 实例对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;test.xml&quot;</span>);<br>  <span class="hljs-comment">//getBean有多种形式，其中第一种就是根据类型获取对应的Bean</span><br>  <span class="hljs-comment">//容器中只要注册了对应类的Bean或是对应类型子类的Bean，都可以获取到</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context.getBean(Student.class);<br>    student.hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>不过在有些时候，Bean 的获取可能会出现歧义，我们可以来分别注册两个子类的 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Student</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">art</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我爱画画&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SportStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sport</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我爱运动&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtStudent&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.SportStudent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>但是此时我们在获取 Bean 时却是<strong>索要的它们的父类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context.getBean(Student.class);<br>student.hello();<br></code></pre></td></tr></table></figure><p>运行时得到如下报错：<br><img src="https://s2.loli.net/2022/11/22/vliWJ4SZdx5E6yX.png" alt="image-20221122164100561"><br>这里出现了一个<strong>Bean 定义不唯一异常</strong>，很明显，因为我们需要的类型是 Student，但是此时有两个 Bean 定义都满足这个类型，它们都是 Student 的子类，此时 IoC 容器不知道给我们返回哪一个 Bean，所以就只能抛出异常了。<br>因此，如果我们需要一个 Bean 并且使用类型进行获取，那么必须要指明类型并且不能出现歧义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArtStudent</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context.getBean(ArtStudent.class);<br>student.art();<br></code></pre></td></tr></table></figure><p>那要是两个 Bean 的类型都是一样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean class=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;<br>&lt;bean class=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>这种情况下，就无法使用 Class 来进行区分了，除了为 Bean 指定对应类型之外，我们也可以为 Bean<strong>指定一个名称</strong>用于区分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;art&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtStudent&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sport&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.SportStudent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>name 属性就是为这个 Bean 设定一个独一无二的名称（<strong>id 属性也可以，跟 name 功能相同</strong>，但是会检查命名是否规范，否则会显示黄标），不同的 Bean 名字不能相同，否则报错：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这样，这两个 Bean 我们就可以区分出来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) context.getBean(<span class="hljs-string">&quot;a&quot;</span>);<br>student.hello();<br></code></pre></td></tr></table></figure><p>虽然目前这两 Bean 定义都是一模一样的，也没什么区别，但是这确实是两个不同的 Bean，只是类型一样而已，之后我们还可以为这两个 Bean 分别设置不同的其他属性。<br>我们可以给 Bean 起名字，也可以<strong>起别名</strong>，就行我们除了有一个名字之外，可能在家里还有自己的小名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这样，我们使用别名也是可以拿到对应的 Bean 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) context.getBean(<span class="hljs-string">&quot;test&quot;</span>);<br>student.hello();<br></code></pre></td></tr></table></figure><p>那么现在又有新的问题了，IoC 容器创建的 Bean 是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次 Bean 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> context.getBean(Student.class);<br><span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> context.getBean(Student.class);<br>System.out.println(student1 == student2);   <span class="hljs-comment">//默认为单例模式，对象始终为同一个</span><br></code></pre></td></tr></table></figure><p>我们发现，最后得到的结果为 true，那么说明每次从 IoC 容器获取到的对象，始终都是同一个，默认情况下，<em><strong>通过 IoC 容器进行管理的 Bean 都是单例模式（默认为饿汉式单例模式，IOC 容器创建时就新建了 Bean 实例）的，这个对象只会被创建一次</strong></em>。<br>如果我们希望每次拿到的对象都是一个新的，我们也可以将其作用域进行修改：<br><img src="https://s2.loli.net/2022/11/22/hDGo7m9uBlgVn5A.png" alt="image-20221122175719997"><br>这里一共有两种作用域，第一种是 <code>singleton</code>，默认情况下就是这一种，当然还有 <code>prototype</code>，表示为<strong>原型模式</strong>（为了方便叫多例模式也行）这种模式每次得到的对象都是一个新的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> context.getBean(Student.class);  <span class="hljs-comment">//原型模式下，对象不再始终是同一个了</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> context.getBean(Student.class);<br>System.out.println(student1 == student2);<br></code></pre></td></tr></table></figure><blockquote><p>实际上，当 Bean 的作用域为单例模式时，那么它会在一开始（容器加载配置时）就被创建，我们之后拿到的都是这个对象。而处于原型模式下，只有在获取时才会被创建，也就是说，单例模式下，Bean 会被 IoC 容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于在要用的时候直接 new 了一个对象，并不会被保存。</p></blockquote><p>当然，如果我们希望单例模式下的 Bean 不用再一开始就加载，而是一样等到需要时再加载（加载后依然会被容器存储，之后一直使用这个对象了，不会再创建新的）我们也可以<strong>开启懒加载</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>开启<em>懒加载</em>后，只有在真正第一次使用时才会创建对象。</p></blockquote><p>因为单例模式下 Bean 是由 IoC 容器加载，但是加载顺序我们并不清楚，如果我们需要维护 Bean 的加载顺序（比如某个 Bean 必须要在另一个 Bean 之前创建）那么我们可以使用 <code>depends-on</code> 来设定前置加载 Bean，这样被依赖的 Bean 一定会在之前加载，比如 Teacher 应该在 Student 之前加载：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Teacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">depends-on</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这样就可以保证 Bean 的加载顺序了。</p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>依赖注入 (Dependency Injection, DI)是一种设计模式，也是 Spring 框架的核心概念之一。现在我们已经了解了如何注册和使用一个 Bean，但是这样还远远不够，还记得我们一开始说的，消除类之间的强关联吗？比如现在有一个教师接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的实现有两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtTeacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Teacher</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是美术老师，我教你画画！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgramTeacher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Teacher</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是编程老师，我教你学Golang！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的学生一开始有一个老师教他，比如美术老师：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArtTeacher</span>();   <br>  <span class="hljs-comment">//在以前，如果我们需要制定哪个老师教我们，直接new创建对应的对象就可以了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        teacher.teach();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们发现，如果美术老师不教了，现在来了一个其他的老师教学生，那么就需要去修改 Student 类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProgramTeacher</span>();<br>  ...<br></code></pre></td></tr></table></figure><p>可以想象一下，如果现在冒出来各种各样的类都需要这样去用 Teacher，那么一旦 Teacher 的实现发生变化，会导致我们挨个对之前用到 Teacher 的类进行修改，这就很难受了。<br>而有了依赖注入之后，Student 中的 Teacher 成员变量，可以由 IoC 容器来选择一个合适的 Teacher 对象进行赋值，也就是说，IoC 容器在创建对象时，需要将我们预先给定的属性注入到对象中，非常简单，我们可以使用 <code>property</code> 标签来实现，我们将 bean 标签展开：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ProgramTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同时我们还需要修改一下 Student 类，依赖注入要求对应的属性必须有一个 set 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>  <span class="hljs-comment">//要使用依赖注入，我们必须提供一个set方法（无论成员变量的访问权限是什么）命名规则依然是驼峰命名法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTeacher</span><span class="hljs-params">(Teacher teacher)</span> &#123;<br>        <span class="hljs-built_in">this</span>.teacher = teacher;<br>    &#125;<br>    ...<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/22/wu2EYC8HToJbsva.png" alt="image-20221122191025279"><br>使用 <code>property</code> 来指定需要<strong>注入的值或是一个 Bean</strong>，这里我们选择 ProgramTeacher，那么在使用时，Student 类中的得到的就是这个 Bean 的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context.getBean(Student.class);<br>student.study();<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/22/n3zYWvIoE8CrRDT.png" alt="image-20221122191109690"><br>可以看到，现在我们的 Java 代码中，没有出现任何的具体实现类信息（ArtTeacher、ProgramTeacher 都没出现）取而代之的是那一堆 xml 配置，这样，就算我们切换老师的实现为另一个类，也不用去调整代码，只需要变动一下 Bean 的类型就可以：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  只需要修改这里的class即可，现在改为ArtTeacher  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样，这个 Bean 的 class 就变成了新的类型，并且我们不需要再去调整其他位置的代码，再次启动程序：<br><img src="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" alt="image-20221122191427776"><br>通过依赖注入，是不是开始逐渐感受到 Spring 为我们带来的便利了？当然，依赖注入并不一定要注入其他的 Bean，也可以是一个简单的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean name=<span class="hljs-string">&quot;student&quot;</span> class=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;卢本伟&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>直接使用 <code>value</code> 可以直接传入一个具体值。<br>实际上，在很多情况下，类中的某些参数是在构造方法中就已经完成的初始化，而不是创建之后，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Teacher teacher;   <span class="hljs-comment">//构造方法中完成，所以说是一个final变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(Teacher teacher)</span>&#123;   <span class="hljs-comment">//Teacher属性是在构造方法中完成的初始化</span><br>        <span class="hljs-built_in">this</span>.teacher = teacher;<br>    &#125;<br>  ...<br></code></pre></td></tr></table></figure><p>我们前面说了，Bean 实际上是由 IoC 容器进行创建的，但是现在我们修改了默认的无参构造，可以看到配置文件里面报错了：<br><img src="https://s2.loli.net/2022/11/22/5HN8GKQywWaYvrF.png" alt="image-20221122174328107"><br>很明显，是因为我们修改了构造方法，IoC 容器默认只会调用无参构造，所以，我们需要指明一个可以用的构造方法，我们展开 bean 标签，添加一个 <code>constructor-arg</code> 标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的 <code>constructor-arg</code> 就是构造方法的一个参数，这个参数可以写很多个，会自动匹配符合里面参数数量的构造方法，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。<br><img src="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" alt="image-20221122191427776"><br>通过这种方式，我们也能实现依赖注入，只不过现在我们将依赖注入的时机提前到了对象构造时。<br>那要是出现这种情况呢？现在我们的 Student 类中是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一号构造方法&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是二号构造方法&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = String.valueOf(age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们希望使用的是二号构造方法，那么怎么才能指定呢？有 2 种方式，我们可以<strong>给标签添加类型</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>也可以指定为对应的参数名称：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>反正只要能够保证我们指定的参数匹配到目标构造方法即可。<br>现在我们的类中出现了一个比较特殊的类型，它是一个<strong>集合类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; list;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setList</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这种集合类型，有着特殊的支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  对于集合类型，我们可以直接使用标签编辑集合的默认值  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不仅仅是 List，Map、Set 这类常用集合类包括数组在内，都是支持这样编写的，比如 Map 类型，我们也可以使用 <code>entry</code> 来注入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;语文&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100.0&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;数学&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80.0&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;英语&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;92.5&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于集合中的数据类型不为基本数据类型（<strong>引用类型</strong>）的参考下面的写法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;artTeacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.ArtTeacher&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;programTeacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.ProgramTeacher&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.Student&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        方式一：通过set方法进行依赖注入--&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;--&gt;</span>    <br>    <span class="hljs-comment">&lt;!--        方式二：通过构造方法进行依赖注入--&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.List&quot;</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;artTeacher&quot;</span>/&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;programTeacher&quot;</span>/&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小赵&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>至此，我们就已经完成了两种依赖注入的学习：</p><blockquote><p>[!NOTE] 依赖注入方式</p><ul><li>Setter 依赖注入：通过成员属性对应的 set 方法完成注入。</li><li>构造方法依赖注入：通过构造方法完成注入。</li></ul></blockquote><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>在之前，如果我们需要使用依赖注入的话，我们需要对 <code>property</code> 参数进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是有些时候为了方便，我们也可以开启自动装配。自动装配就是让 IoC 容器自己去寻找需要填入的值，我们只需要将 set 方法提供好就可以了，这里需要添加 autowire 属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><code>autowire</code> 属性有两个值普通，一个是 byName，还有一个是 byType，顾名思义，一个是根据类型去寻找合适的 Bean 自动装配，还有一个是根据名字去找，这样我们就不需要显式指定 <code>property</code> 了。<br><img src="https://s2.loli.net/2022/11/22/QIBRwScq6fu4XDm.png" alt="image-20221122221936559"><br>此时 set 方法旁边会出现一个自动装配图标，效果和上面是一样的。<br>对于使用构造方法完成的依赖注入，也支持自动装配，我们只需要将 autowire 修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;constructor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这样，我们只需要提供一个对应参数的构造方法就可以了（这种情况默认也是 byType 寻找的）：<br><img src="https://s2.loli.net/2022/11/22/rgl7fXJ2ZKAU8Rd.png" alt="image-20221122230320004"><br>这样同样可以完成自动注入：<br><img src="https://s2.loli.net/2022/11/22/evKArqDYcIQPCXT.png" alt="image-20221122191427776"><br>自动化的东西虽然省事，但是太过机械，有些时候，自动装配可能会遇到一些问题，比如出现了下面的情况：<br><img src="https://s2.loli.net/2022/11/22/SQTchJBq4G8NWyC.png" alt="image-20221122223048820"><br>此时，由于 <code>autowire</code> 的规则为 byType，存在两个候选 Bean，但是我们其实希望 ProgramTeacher 这个 Bean 在任何情况下都不参与到自动装配中，此时我们就可以将它的自动装配候选关闭：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ProgramTeacher&quot;</span> <span class="hljs-attr">autowire-candidate</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>autowire-candidate</code> 设定 false 时，这个 Bean 将不再作为自动装配的候选 Bean，此时自动装配候选就只剩下一个唯一的 Bean 了，报错消失，程序可以正常运行。<br>除了这种方式，我们也可以设定<strong>primary 属性</strong>，表示这个 Bean 作为主要的 Bean，当出现歧义时，也会优先选择：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtTeacher&quot;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ProgramTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 总结</p><ol><li>通过为 bean 设置 <code>autowire</code> 属性（候选值包括 <code>byType，byName，constructor</code>）实现自动装配（<em>为 bean 类的属性自动赋值初始化</em>）。</li><li>当存在多个可被自动装配的 bean 导致 autowire 出现歧义时可通过以下两种方式之一处理：<ul><li>为目标 bean<strong>设置 primary 属性为 true</strong>，提高优先级。</li><li>对非目标 bean 设置<strong>autowire-candidate 为 false</strong>，取消自动装配候选。</li></ul></li></ol></blockquote><h2 id="生命周期与继承"><a href="#生命周期与继承" class="headerlink" title="生命周期与继承"></a>生命周期与继承</h2><p>除了修改构造方法，我们也可以为 Bean 指定初始化方法和销毁方法，以便在对象创建和被销毁时执行一些其他的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是对象初始化时要做的事情！&quot;</span>);    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是对象销毁时要做的事情！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过 <code>init-method</code> 和 <code>destroy-method</code> 来指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroy&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>那么什么时候是初始化，什么时候又是销毁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当容器创建时，默认情况下Bean都是单例的，那么都会在一开始就加载好，对象构造完成后，会执行init-method</span><br><span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;test.xml&quot;</span>);<br><span class="hljs-comment">//我们可以调用close方法关闭容器，此时容器内存放的Bean也会被一起销毁，会执行destroy-method</span><br>context.close();<br></code></pre></td></tr></table></figure><p>所以说，最后的结果为：<br><img src="https://s2.loli.net/2022/11/23/GWIyPDOaK4TAM1N.png" alt="image-20221123132604262"></p><blockquote><p>注意，如果 Bean 不是单例模式，而是采用的原型模式，那么就只会在获取时才创建，并调用 init-method，而对应的销毁方法不会被调用（因此，对于原型模式下的 Bean，Spring 无法顾及其完整生命周期，而在单例模式下，Spring 能够从 Bean 对象的创建一直管理到对象的销毁）官方文档原文如下：<br>In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean. The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold. To get the Spring container to release resources held by prototype-scoped beans, try using a custom <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-bpp">bean post-processor</a>, which holds a reference to beans that need to be cleaned up.</p></blockquote><p>Bean 之间也是具备<strong>继承关系</strong>的，只不过这里的继承并不是类的继承，而是<strong>属性的继承</strong>，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SportStudent</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，我们先将 ArtStudent 注册一个 Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;artStudent&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtStudent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们会注入一个 name 的初始值，此时我们创建了一个 SportStudent 的 Bean，我们希望这个 Bean 的属性跟刚刚创建的 Bean 属性是一样的，那么我们可以写一个一模一样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.SportStudent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是如果属性太多的话，是不是写起来有点麻烦？这种情况，我们就可以配置 Bean 之间的继承关系了，我们可以让 SportStudent 这个 Bean 直接继承 ArtStudent 这个 Bean 配置的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.SportStudent&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;artStudent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这样，在 ArtStudent Bean 中配置的属性，会直接继承给 SportStudent Bean（注意，所有配置的属性，在子 Bean 中必须也要存在，并且可以进行注入，否则会出现错误）当然，如果子类中某些属性比较特殊，也可以在继承的基础上单独配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;artStudent&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtStudent&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.SportStudent&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;artStudent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们只是希望某一个 Bean 仅作为一个<strong>配置模版供其他 Bean 继承使用，那么我们可以将其配置为 abstract</strong>，这样，容器就不会创建这个 Bean 的对象了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;artStudent&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ArtStudent&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小明&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.SportStudent&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;artStudent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意，一旦声明为<strong>抽象 Bean</strong>，那么就<strong>无法通过容器获取到其实例化对象</strong>。<br><img src="https://s2.loli.net/2022/11/23/SyDkvOldB7ETW4z.png" alt="image-20221123140409416"><br>不过 Bean 的继承使用频率不是很高，了解就行。<br>这里最后再提一下，我们前面已经学习了各种各样的 Bean 配置属性，如果我们希望<strong>整个上下文中所有的 Bean 都采用某种配置</strong>，我们可以在<strong>最外层的 beans 标签中进行默认配置</strong>：<br><img src="https://s2.loli.net/2022/11/23/KzSUJXa4jBfO9rd.png" alt="image-20221123141221259"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        配置模板bean仅用于子bean继承属性--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;template&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.Student&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;小张&quot;</span>/&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;art&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.ArtTeacher&quot;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;template&quot;</span>/&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;program&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.ProgramTeacher&quot;</span> <span class="hljs-attr">autowire-candidate</span>=<span class="hljs-string">&quot;false&quot;</span>  </span><br><span class="hljs-tag">          <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;template&quot;</span>/&gt;</span>  <br>    <span class="hljs-comment">&lt;!--    &lt;bean name=&quot;student&quot; class=&quot;org.example.entity.Student&quot; autowire=&quot;constructor&quot; init-method=&quot;init&quot;--&gt;</span>  <br>    <span class="hljs-comment">&lt;!--          destroy-method=&quot;destroy&quot;&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;        方式一：通过set方法进行依赖注入&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;        &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;/&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;        方式二：通过构造方法进行依赖注入&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;        &lt;constructor-arg name=&quot;teacher&quot; type=&quot;java.util.List&quot;&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;            &lt;list&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;                &lt;ref bean=&quot;artTeacher&quot;/&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;                &lt;ref bean=&quot;programTeacher&quot;/&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;            &lt;/list&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;        &lt;/constructor-arg&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;        &lt;constructor-arg name=&quot;name&quot; value=&quot;小赵&quot; type=&quot;java.lang.String&quot;/&gt;&amp;ndash;&amp;gt;--&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;/bean&gt;--&gt;</span>  <br>    <span class="hljs-comment">&lt;!--    只需要修改IOC容器中管理的类，即可动态改变具体实现类--&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;bean name=&quot;aservice&quot; class=&quot;org.example.service.Aservice&quot;/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;bean name=&quot;bservice&quot; class=&quot;org.example.service.Bservice&quot; lazy-init=&quot;true&quot; depends-on=&quot;artStudent&quot;/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;bean name=&quot;artStudent&quot; class=&quot;org.example.entity.ArtStudent&quot; depends-on=&quot;student&quot;/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;bean name=&quot;sportStudent&quot; class=&quot;org.example.entity.SportStudent&quot; depends-on=&quot;student&quot;/&gt;--&gt;</span>    <span class="hljs-comment">&lt;!--    &lt;alias name=&quot;student&quot; alias=&quot;freer&quot;/&gt;--&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样，即使 Bean 没有配置某项属性，但是只要在最外层编写了默认配置，那么同样会生效，除非 Bean 自己进行配置覆盖掉默认配置。</p><blockquote><p>[!NOTE] 总结</p><ol><li>通过为 bean 设置 <code>init-method</code> 和 <code>destroy-method</code> 属性指定 <strong>bean 实例的初始化和销毁所调用的方法</strong>。</li><li>bean 可以继承，通过配置 <code>parent</code> 属性继承父 bean，一般用于<strong>继承父 bean 的属性</strong>。</li><li>可以为 <code>beans</code> 设置<strong>默认全局配置</strong>包括 <code>default-autowire，default-init/destroy-method，default-lazy-init</code> 等。</li></ol></blockquote><h2 id="工厂模式和工厂-Bean"><a href="#工厂模式和工厂-Bean" class="headerlink" title="工厂模式和工厂 Bean"></a>工厂模式和工厂 Bean</h2><p>前面我们介绍了 IoC 容器的 Bean 创建机制，默认情况下，容器会调用 Bean 对应类型的构造方法进行对象创建，但是在某些时候，我们可能不希望外界使用类的构造方法完成对象创建，比如在工厂方法设计模式中（详情请观看《Java 设计模式》篇视频教程）我们更希望 Spring 不要直接利用反射机制通过构造方法创建 Bean 对象，而是利用反射机制先找到对应的工厂类，然后利用工厂类去生成需要的 Bean 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    Student () &#123;<br>        System.out.println (<span class="hljs-string">&quot;我被构造了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">getStudent</span> <span class="hljs-params">()</span>&#123;<br>      System.out.println (<span class="hljs-string">&quot;欢迎光临电子厂&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时 Student 有一个工厂，我们正常情况下需要使用工厂才可以得到 Student 对象，现在我们希望 Spring 也这样做，不要直接去反射搞构造方法创建，我们可以通过 factory-method 进行指定：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.StudentFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getStudent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意，这里的 Bean 类型需要填写为 Student 类的工厂类，并且添加 factory-method 指定对应的工厂方法，但是最后注册的是工厂方法的返回类型，所以说依然是 Student 的 Bean：<br><img src="https://s2.loli.net/2022/11/23/5Id43xPneJiWfZs.png" alt="image-20221123143302785"><br>此时我们再去进行获取，拿到的也是通过工厂方法得到的对象：<br><img src="https://s2.loli.net/2022/11/23/l8HzN7Rwthqrim5.png" alt="image-20221123143347376"><br>这里有一个误区，千万不要认为是我们注册了 StudentFactory 这个 Bean，class 填写为这个类这个只是为了告诉 Spring 我们的工厂方法在哪个位置，真正注册的是工厂方法提供的东西。<br>可以发现，当我们采用工厂模式后，我们就无法再通过配置文件对 Bean 进行依赖注入等操作了，而是只能在工厂方法中完成，这似乎与 Spring 的设计理念背道而驰？<br>当然，可能某些工厂类需要构造出对象之后才能使用，我们也可以将某个工厂类直接注册为工厂 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">getStudent</span> <span class="hljs-params">()</span>&#123;<br>        System.out.println (<span class="hljs-string">&quot;欢迎光临电子厂&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在需要 StudentFactory 对象才可以获取到 Student，此时我们就只能先将其注册为 Bean 了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;studentFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.StudentFactory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>像这样将工厂类注册为 Bean，我们称其为工厂 Bean，然后再使用 <code>factory-bean</code> 来指定 Bean 的工厂 Bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;studentFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getStudent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意，使用 factory-bean 之后，不再要求指定 class，我们可以直接使用了：<br><img src="https://s2.loli.net/2022/11/23/ih1Af7xBdX3ebaG.png" alt="image-20221123164134470"><br>此时可以看到，工厂方法上同样有了图标，这种方式，由于工厂类被注册为 Bean，此时我们就可以在配置文件中为工厂 Bean 配置依赖注入等内容了。<br>这里还有一个很细节的操作，如果我们想获取工厂 Bean 为我们提供的 Bean，可以直接输入工厂 Bean 的名称，这样不会得到工厂 Bean 的实例，而是工厂 Bean 生产的 Bean 的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> (Student) context.getBean (<span class="hljs-string">&quot;studentFactory&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然，如果我们需要获取工厂类的实例，可以在名称前面添加 <code>&amp;</code> 符号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StudentFactory</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> (StudentFactory) context.getBean (<span class="hljs-string">&quot;&amp;studentFactory&quot;</span>);<br></code></pre></td></tr></table></figure><p>又是一个小细节。</p><blockquote><p>[!NOTE] 总结<br>工厂 bean 可以<strong>间接创建 bean</strong>从而<strong>代替构造方法或者 setter</strong>直接创建 bean，从而实现 bean 实例化过程中其他的逻辑功能，借助工厂 bean 实例化需要的 bean 有以下两种方式：</p><ol><li>写工厂类并添加 <strong>get 产品 bean 的静态方法</strong>，在 <code>xml</code> 配置文件中<strong>注册工厂 bean 并设置 factory-method 方法</strong>指定实例化产品 <strong>bean 的静态方法</strong>。</li><li>写工厂类并添加 <strong>get 产品 bean 的对象方法</strong>，然后实现 <code>FactoryBean&lt;产品类&gt;</code> 接口并<strong>重写 getObject（return get 产品 bean）和 getObjectType（return 产品 bean. class）</strong> 方法，接着<strong>注册工厂 bean</strong> 即可（不用配置 <code>factory-method</code>）</li></ol></blockquote><h2 id="使用注解开发-1"><a href="#使用注解开发-1" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><p>使用配置文件进行配置，貌似有点太累了吧？可以想象一下，如果我们的项目非常庞大，整个配置文件将会充满 Bean 配置，并且会继续庞大下去，能否有一种更加高效的方法能够省去配置呢？还记得我们在 JavaWeb 阶段用到的非常方便东西吗？没错，就是注解。<br>既然现在要使用注解来进行开发，那么我们就删掉之前的 xml 配置文件吧，我们来看看使用注解能有多方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> ();<br></code></pre></td></tr></table></figure><p>现在我们使用 AnnotationConfigApplicationContext 作为上下文实现，它是注解配置的。<br>既然现在采用注解，我们就需要使用类来编写配置文件，在之前，我们如果要编写一个配置的话，需要：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot; http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot; http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot; http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们只需要创建一个配置类就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两者是等价的，同样的，在一开始会提示我们没有配置上下文：<br><img src="https://s2.loli.net/2022/11/23/YNl5nVkfJriogdD.png" alt="image-20221123175555433"><br>这里按照要求配置一下就可以，同上，这个只是会影响 IDEA 的代码提示，不会影响程序运行。<br>我们可以为 AnnotationConfigApplicationContext 指定一个默认的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br><span class="hljs-comment">//这个构造方法可以接收多个配置类（更准确的说是多个组件）</span><br></code></pre></td></tr></table></figure><p>那么现在我们该如何配置 Bean 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span> (<span class="hljs-string">&quot;student&quot;</span>)<br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">student</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写相对于配置文件中的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot; http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot; http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot; http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过 <code>@Import</code> 还可以引入其他配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import</span> (LBWConfiguration. class)  <span class="hljs-comment">//在讲解到 Spring 原理时，我们还会遇到它，目前只做了解即可。</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br></code></pre></td></tr></table></figure><p>只不过现在变成了由 Java 代码为我们提供 Bean 配置，这样会更加的灵活，也更加便于控制 Bean 对象的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context.getBean (Student. class);<br>System.out.println (student);<br></code></pre></td></tr></table></figure><p>使用方法是相同的，这跟使用 XML 配置是一样的。<br>那么肯定就有小伙伴好奇了，我们之前使用的那么多特性在哪里配置呢？首先，初始化方法和摧毁方法、自动装配可以直接在@Bean 注解中进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> (name = <span class="hljs-string">&quot;&quot;</span>, initMethod = <span class="hljs-string">&quot;&quot;</span>, destroyMethod = <span class="hljs-string">&quot;&quot;</span>, autowireCandidate = <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">student</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><p>其次，我们可以使用一些其他的注解来配置其他属性，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Lazy</span> (<span class="hljs-literal">true</span>)     <span class="hljs-comment">//对应 lazy-init 属性</span><br><span class="hljs-meta">@Scope</span> (<span class="hljs-string">&quot;prototype&quot;</span>)    <span class="hljs-comment">//对应 scope 属性</span><br><span class="hljs-meta">@DependsOn</span> (<span class="hljs-string">&quot;teacher&quot;</span>)    <span class="hljs-comment">//对应 depends-on 属性</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">student</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于那些我们需要通过构造方法或是 Setter 完成依赖注入的 Bean，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.ProgramTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.test.bean.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>像这种需要引入其他 Bean 进行的注入，我们可以直接将其作为形式参数放到方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">teacher</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span> ();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">student</span> <span class="hljs-params">(Teacher teacher)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> (teacher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们可以看到，旁边已经出现图标了：<br><img src="https://s2.loli.net/2022/11/23/wy5JtiVp8zK1bmG.png" alt="image-20221123213527325"><br>运行程序之后，我们发现，这样确实可以直接得到对应的 Bean 并使用。<br>只不过，除了这种基于构造器或是 Setter 的依赖注入之外，我们也可以直接到 Bean 对应的类中使用自动装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-meta">@Autowired</span>   <span class="hljs-comment">//使用此注解来进行自动装配，由 IoC 容器自动为其赋值</span><br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们甚至连构造方法和 Setter 都不需要去编写了，就能直接完成自动装配，是不是感觉比那堆配置方便多了？<br>当然，@Autowired 并不是只能用于字段，对于构造方法或是 Setter，它同样可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTeacher</span> <span class="hljs-params">(Teacher teacher)</span> &#123;<br>        <span class="hljs-built_in">this</span>. teacher = teacher;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>@Autowired 默认采用 byType 的方式</em>进行自动装配，也就是说会使用类型进行配，那么要是出现了多个相同类型的 Bean，如果我们想要指定使用其中的某一个该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span> (<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">teacherA</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span> ();<br>&#125;<br><span class="hljs-meta">@Bean</span> (<span class="hljs-string">&quot;b&quot;</span>)<br><span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">teacherB</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，我们可以配合 <code>@Qualifier 进行名称匹配</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier</span> (<span class="hljs-string">&quot;a&quot;</span>)   <span class="hljs-comment">//匹配名称为 a 的 Teacher 类型的 Bean</span><br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要提一下，在我们旧版本的 SSM 教程中讲解了 <code>@Resource</code> 这个注解，但是现在它没有了。<br>随着 Java 版本的更新迭代，某些 javax 包下的包，会被逐渐弃用并移除。在 JDK 11 版本以后，javax. annotation 这个包被移除并且更名为 <code>jakarta. annotation</code>（我们在 JavaWeb 篇已经介绍过为什么要改名字了）其中有一个非常重要的注解，叫做@Resource，它的作用与@Autowired 时相同的，也可以实现自动装配，但是在 IDEA 中并不推荐使用@Autowired 注解对成员字段进行自动装配，而是推荐使用@Resource，如果需要使用这个注解，还需要额外导入包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta. annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta. annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用方法一样，直接替换掉就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过，他们两有些机制上的不同：</p><blockquote><ul><li>@Resource 默认<strong>ByName</strong>如果找不到则<strong>ByType</strong>，可以添加到 <strong>set 方法、字段</strong>上。</li><li>@Autowired 默认是<strong>byType</strong>，只会根据类型寻找，可以添加在<strong>构造方法、set 方法、字段、方法参数</strong>上。<br>因为@Resource 的匹配机制更加合理高效，因此官方并不推荐使用@Autowired 字段注入，当然，实际上 Spring 官方更推荐我们使用基于构造方法或是 Setter 的@Autowired 注入，比如 Setter 注入的一个好处是，Setter 方法使该类的对象能够在以后重新配置或重新注入。其实，最后使用哪个注解，还是看你自己，要是有强迫症不能忍受黄标但是又实在想用字段注入，那就用@Resource 注解。<br>除了这个注解之外，还有 <code>@PostConstruct 和@PreDestroy</code>，它们效果和 <code>init-method 和 destroy-method</code> 是一样的：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">()</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;我是初始化方法&quot;</span>);<br>&#125;<br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span> <span class="hljs-params">()</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;我是销毁方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要将其添加到对应的方法上即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>context. close ();<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/23/wXRuAjVF2ykCOJ4.png" alt="image-20221123225232979"><br>可以看到效果是完全一样的，这些注解都是 jakarta. annotation 提供的<br>前面我们介绍了使用@Bean 来注册 Bean，但是实际上我们发现，如果只是简单将一个类作为 Bean 的话，这样写还是不太方便，因为都是固定模式，就是单纯的 new 一个对象出来，能不能像之前一样，让容器自己反射获取构造方法去生成这个对象呢？<br>肯定是可以的，我们可以在需要注册为 Bean 的类上添加 <code>@Component</code> 注解来将一个类进行注册（现在最常用的方式），不过要实现这样的方式，我们需要添加一个自动扫描来告诉 Spring，它需要在哪些包中查找我们提供的 <code>@Component</code> 声明的 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> (<span class="hljs-string">&quot;lbwnb&quot;</span>)   <span class="hljs-comment">//同样可以自己起名字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>要注册这个类的 Bean，只需要添加 <code>@Component</code> 即可，然后配置一下包扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;com. test. bean&quot;</span>)   <span class="hljs-comment">//包扫描，这样 Spring 就会去扫描对应包下所有的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 在扫描对应包下所有的类时，会自动将那些添加了@Component 的类注册为 Bean，是不是感觉很方便？只不过这种方式只适用于我们自己编写类的情况，如果是第三方包提供的类，只能使用前者完成注册，并且这种方式并不是那么的灵活。<br>不过，无论是通过@Bean 还是@Component 形式注册的 Bean，<strong>Spring 都会为其添加一个默认的 name 属性</strong>，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的默认名称生产规则依然是类名并按照首字母小写的驼峰命名法来的，所以说对应的就是 student：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) context. getBean (<span class="hljs-string">&quot;student&quot;</span>);   <span class="hljs-comment">//这样同样可以获取到</span><br>System. out. println (student);<br></code></pre></td></tr></table></figure><p>同样的，如果是通过@Bean 注册的，默认名称是对应的方法名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">artStudent</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) context. getBean (<span class="hljs-string">&quot;artStudent&quot;</span>);<br>System. out. println (student);<br></code></pre></td></tr></table></figure><p>相比传统的 XML 配置方式，注解形式的配置确实能够减少我们很多工作量。并且，对于这种使用 <code>@Component</code> 注册的 Bean，如果其构造方法不是默认无参构造，那么默认会对其每一个参数都进行自动注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    Teacher teacher;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span> <span class="hljs-params">(Teacher teacher)</span>&#123;   <span class="hljs-comment">//如果有 Teacher 类型的 Bean，那么这里的参数会被自动注入</span><br>        <span class="hljs-built_in">this</span>. teacher = teacher;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，对于我们之前使用的工厂模式，Spring 也提供了接口，我们可以直接实现接口表示这个 Bean 是一个工厂 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Student&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">getObject</span> <span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//生产的 Bean 对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType () &#123;   <span class="hljs-comment">//生产的 Bean 类型</span><br>        <span class="hljs-keyword">return</span> Student. class;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span> <span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//生产的 Bean 是否采用单例模式</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上跟我们之前在配置文件中编写是一样的，这里就不多说了。<br>请注意，使用注解虽然可以省事很多，代码也能变得更简洁，但是这并不代表 XML 配置文件就是没有意义的，它们有着各自的优点，在不同的场景下合理使用，能够起到事半功倍的效果，官方原文：</p><blockquote><p>Are annotations better than XML for configuring Spring?</p><p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.</p><p>No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java">JavaConfig</a> option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the <a href="https://spring.io/tools">Spring Tools for Eclipse</a>.<br>至此，关于 Spring 的 IoC 基础部分，我们就全部介绍完了。在最后，有一个问题，现在有两个类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> Student student;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个类互相需要注入对方的实例对象，这个时候 Spring 会怎么进行处理呢？如果 Bean 变成原型模式，Spring 又会怎么处理呢？<br>这个问题我们会在实现原理探究部分进行详细介绍。</p><blockquote><p>[!NOTE] 总结<br>通过使用<strong>注解</strong>来注册配置 bean 可以免去 xml 的繁琐配置，步骤如下:</p><ul><li>首先需要写一个配置类并标注 <code>@Configuration</code> 注解和需要扫描的用 <code>@Component</code> 注解注册的 <strong>bean</strong></li><li>既可以用 <code>@Component</code> 为类注册 bean，也可以手动在 Config 中用 <code>@Bean</code> 注册，bean 的属性可以通过 <code>@Autowire/Resource</code> 注解进行依赖自动装配，默认注册的 bean 的名称为<em>首字母小写的类名</em></li><li>多个配置文件可以通过 <code>@Import</code> 还可以引入<strong>其他配置类</strong>，也可以注册 [[#工厂模式和工厂 Bean]]，具体如下配置：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Config</span><br><span class="hljs-keyword">package</span> org. example. config;  <br>  <br><span class="hljs-keyword">import</span> org. example. entity. ArtTeacher;  <br><span class="hljs-keyword">import</span> org. example. entity. ProgramTeacher;  <br><span class="hljs-keyword">import</span> org. example. entity. Student;  <br><span class="hljs-keyword">import</span> org. example. entity. Teacher;  <br><span class="hljs-keyword">import</span> org. springframework. context. annotation.*;  <br><span class="hljs-meta">@Import</span> (LBWConfiguration. class)<br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-meta">@ComponentScans</span> (&#123;  <br>        <span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;org. example. entity&quot;</span>)  <br>&#125;)  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;  <br><span class="hljs-comment">//    手动注册为 bean  </span><br><span class="hljs-comment">//    @Bean (&quot;art&quot;)  </span><br><span class="hljs-comment">//    public Teacher artteacher () &#123;  </span><br><span class="hljs-comment">//        return new ArtTeacher (&quot;王老师&quot;);  </span><br><span class="hljs-comment">//    &#125;  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//    @Bean (&quot;program&quot;)  </span><br><span class="hljs-comment">//    public Teacher proteacher () &#123;  </span><br><span class="hljs-comment">//        return new ProgramTeacher (&quot;赵老师&quot;);  </span><br><span class="hljs-comment">//    &#125;  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//    @Bean (&quot;student&quot;)  </span><br><span class="hljs-comment">////    @DependsOn (&quot;teacher&quot;)  </span><br><span class="hljs-comment">//    public Student student () &#123;  </span><br><span class="hljs-comment">//        return new Student ();  </span><br><span class="hljs-comment">//    &#125;  </span><br>&#125;<br><span class="hljs-comment">//Student</span><br><span class="hljs-keyword">package</span> org. example. entity;  <br>  <br><span class="hljs-keyword">import</span> jakarta. annotation. PostConstruct;  <br><span class="hljs-keyword">import</span> jakarta. annotation. PreDestroy;  <br><span class="hljs-keyword">import</span> jakarta. annotation. Resource;  <br><span class="hljs-keyword">import</span> lombok. AllArgsConstructor;  <br><span class="hljs-keyword">import</span> lombok. Data;  <br><span class="hljs-keyword">import</span> lombok. NoArgsConstructor;  <br><span class="hljs-keyword">import</span> org. springframework. beans. factory. annotation. Autowired;  <br><span class="hljs-keyword">import</span> org. springframework. beans. factory. annotation. Qualifier;  <br><span class="hljs-keyword">import</span> org. springframework. context. annotation. Scope;  <br><span class="hljs-keyword">import</span> org. springframework. stereotype. Component;  <br>  <br><span class="hljs-keyword">import</span> java. util. List;  <br>  <br><span class="hljs-meta">@Data</span>  <br><span class="hljs-meta">@AllArgsConstructor</span>  <br><span class="hljs-meta">@NoArgsConstructor</span>  <br><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//自动注册为 bean，value 参数为 bean 名</span><br><span class="hljs-meta">@Scope</span> (<span class="hljs-string">&quot;prototype&quot;</span>)  <span class="hljs-comment">//作用为设置为原型模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>    <span class="hljs-meta">@Qualifier</span> (<span class="hljs-string">&quot;artTeacher&quot;</span>)  <span class="hljs-comment">//多个候选依赖 bean 时为避免歧义指定一个</span><br>    <span class="hljs-meta">@Resource</span>  <span class="hljs-comment">//依赖自动装配，name 参数为依赖的 bean 名</span><br>    Teacher teacher;  <br>    String name;  <br>  <br><span class="hljs-comment">//    Student (Teacher teacher) &#123;  </span><br><span class="hljs-comment">//        this. teacher = teacher;  </span><br><span class="hljs-comment">//    &#125;  </span><br>  <br>    <span class="hljs-comment">//    public Student (Teacher teacher) &#123;//        this. teacher = teacher;  </span><br><span class="hljs-comment">//    &#125;  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//    public Student (String name) &#123;  </span><br><span class="hljs-comment">//        this. name = name;  </span><br><span class="hljs-comment">//    &#125;  </span><br>    <span class="hljs-meta">@PostConstruct</span>  <span class="hljs-comment">//构造后初始化方法，类似于 xml 中的 init-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">()</span> &#123;  <br>        System. out. println (Student. class. getName () + <span class="hljs-string">&quot; 初始化完成&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@PreDestroy</span>  <span class="hljs-comment">//销毁前销毁方法，类似于 xml 中的 destroy-method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span> <span class="hljs-params">()</span> &#123;  <br>        System. out. println (<span class="hljs-built_in">this</span>. getClass (). getName () + <span class="hljs-string">&quot; 销毁完成&quot;</span>);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span> <span class="hljs-params">()</span> &#123;  <br>        teacher. teach ();  <br>    &#125;  <br><span class="hljs-comment">//    public void setTeacher (Teacher teacher) &#123;  </span><br><span class="hljs-comment">//        this. teacher = teacher;  </span><br><span class="hljs-comment">//    &#125;  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">//    public void setName (String name) &#123;  </span><br><span class="hljs-comment">//        this. name = name;  </span><br><span class="hljs-comment">//    &#125;  </span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><hr><h2 id="Spring-高级特性（选学）"><a href="#Spring-高级特性（选学）" class="headerlink" title="Spring 高级特性（选学）"></a>Spring 高级特性（选学）</h2><p>注意：本部分为选学内容，如果 Spring 基础部分学的不是很明白，不建议看这一部分，在理解清楚之后再来看也可以，但也不是说以后就不用学了，这些东西在某些项目中可能会用到，你迟早还是要回来补的。<br>前面我们介绍了 Spring 的基础部分，我们接着来介绍 Spring 的一些其他高级特性。</p><h3 id="Bean-Aware"><a href="#Bean-Aware" class="headerlink" title="Bean Aware"></a>Bean Aware</h3><p>在 Spring 中提供了一些以 Aware 结尾的接口，实现了 Aware 接口的 bean 在被初始化之后，可以获取相应资源。Aware 的中文意思为感知。<strong>简单来说，他就是一个标识，实现此接口的类会获得某些感知能力，Spring 容器会在 Bean 被加载时，根据类实现的感知接口，会调用类中实现的对应感知方法</strong>。<br>比如 BeanNameAware 之类的以 Aware 结尾的接口，这个接口获取的资源就是 BeanName：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span> &#123;   <span class="hljs-comment">//我们只需要实现这个接口就可以了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span> <span class="hljs-params">(String name)</span> &#123;   <span class="hljs-comment">//Bean 在加载的时候，容器就会自动调用此方法，将 Bean 的名称给到我们</span><br>        System. out. println (<span class="hljs-string">&quot;我在加载阶段获得了 Bean 名字：&quot;</span>+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>又比如 BeanClassLoaderAware，那么它能够使得我们可以在 Bean 加载阶段就获取到当前 Bean 的类加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanClassLoaderAware</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanClassLoader</span> <span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>        System. out. println (classLoader);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] Aware 总结<br>Aware 特性就是当 bean 加载的过程中通过实现特定的接口对一些信息自动获取或执行特定的操作，eg：<code>BeanNameAware，BeanFactoryAware，ApplicationContextAware，ResourceAware等</code></p></blockquote><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>为了执行某些任务，我们可能需要一些非常规的操作，比如我们希望使用多线程来处理我们的结果或是执行一些定时任务，到达指定时间再去执行。这时我们首先想到的就是创建一个新的线程来处理，或是使用 TimerTask 来完成定时任务，但是我们有了 Spring 框架之后，就不用这样了，因为 Spring 框架为我们提供了更加便捷的方式进行任务调度。<br>首先我们来看异步任务执行，需要使用 Spring 异步任务支持，我们需要在配置类上添加 <code>@EnableAsync</code> 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;com. test. bean&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们只需要在需要异步执行的方法上，添加 <code>@Async</code> 注解即可将此方法标记为异步，当此方法被调用时，会异步执行，也就是新开一个线程执行，而不是在当前线程执行。我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">syncTest</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System. out. println (Thread. currentThread (). getName ()+<span class="hljs-string">&quot;我是同步执行的方法，开始...&quot;</span>);<br>        Thread. sleep (<span class="hljs-number">3000</span>);<br>        System. out. println (<span class="hljs-string">&quot;我是同步执行的方法，结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTest</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System. out. println (Thread. currentThread (). getName ()+<span class="hljs-string">&quot;我是异步执行的方法，开始...&quot;</span>);<br>        Thread. sleep (<span class="hljs-number">3000</span>);<br>        System. out. println (<span class="hljs-string">&quot;我是异步执行的方法，结束！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们在主方法中分别调用一下试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>    student. asyncTest ();   <span class="hljs-comment">//异步执行</span><br>    student. syncTest ();    <span class="hljs-comment">//同步执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们的任务执行结果为：<br><img src="https://s2.loli.net/2022/11/25/7VKh3dreROJUTcN.png" alt="image-20221125153110860"><br>很明显，异步执行的任务并不是在当前线程启动的，而是在其他线程启动的，所以说并不会在当前线程阻塞，可以看到马上就开始执行下一行代码，调用同步执行的任务了。<br>因此，当我们要将 Bean 的某个方法设计为异步执行时，就可以直接添加这个注解。但是需要注意，添加此注解要求方法的返回值只能是 <em><strong>void 或是 Future</strong></em> 类型才可以（Future 类型我们在 JUC 篇视频教程中有详细介绍）<br>还有，在使用时，可能还会出现这样的信息：<br><img src="https://s2.loli.net/2022/11/25/7RfCIvYAZhMDPJe.png" alt="image-20221125153426124"><br>虽然出现了这样的信息，但是我们的程序依然可以正常运行，这是因为 Spring 默认会从容器中选择一个 <code>Executor</code> 类型（这同样是在 JUC 篇视频教程中介绍的类型）的实例，并使用它来创建线程执行任务，这是 Spring 推荐的方式，当然，如果没有找到，那么会使用自带的 SimpleAsyncTaskExecutor 处理异步方法调用。<br>肯定会有小伙伴疑惑，什么情况？！这个方法很明显我们并没有去编写异步执行的逻辑，那么为什么会异步执行呢？这里很明显是同步调用的方法啊。的确，如果这个 Bean 只是一个简简单单的 Student 类型的对象，确实做不到。但是它真的只是一个简简单单的 Student 类型对象吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>System. out. println (student. getClass ());   <span class="hljs-comment">//这里我们通过 getClass 来获取一下类型，你会发现惊喜</span><br></code></pre></td></tr></table></figure><p>我们来看看结果：<br><img src="https://s2.loli.net/2022/11/25/qUlV5hj96YEupQM.png" alt="image-20221125154133618"><br>？？？这是什么东西？这实际上 Spring 帮助我们动态生成的一个代理类，我们原本的类代码已经被修改了，当然，这只是冰山一角，更多的内容，我们还会再 AOP 面向切片部分中继续为大家进行介绍，能做到这样的操作，这其实都是 AOP 的功劳。<br>看完了异步任务，我们接着来看定时任务，定时任务其实就是指定在哪个时候再去执行，在 JavaSE 阶段我们使用过 TimerTask 来执行定时任务。Spring 中的定时任务是全局性质的，当我们的 Spring 程序启动后，那么定时任务也就跟着启动了，我们可以在配置类上添加 <code>@EnableScheduling</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;com.test.bean&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们可以直接在配置类里面编写定时任务，把我们要做的任务写成方法，并添加 <code>@Scheduled</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled</span> (fixedRate = <span class="hljs-number">2000</span>)   <span class="hljs-comment">//单位依然是毫秒，这里是每两秒钟打印一次</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span> <span class="hljs-params">()</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;我是定时任务！&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> ());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/25/aGv7f3eBXPsFdYr.png" alt="image-20221125155352390"><br>我们注意到 <code>@Scheduled</code> 中有很多参数，我们需要指定’cron’, ‘fixedDelay (String)’, or ‘fixedRate (String)’的其中一个，否则无法创建定时任务，他们的区别如下：</p><blockquote><ul><li>fixedDelay：在上一次定时任务执行完之后，间隔多久继续执行。</li><li>fixedRate：无论上一次定时任务有没有执行完成，两次任务之间的时间间隔。</li><li>cron：如果嫌上面两个不够灵活，你还可以使用 cron 表达式来指定任务计划。<br>这里简单讲解一下 cron 表达式： <a href="https://blog.csdn.net/sunnyzyq/article/details/98597252">https://blog.csdn.net/sunnyzyq/article/details/98597252</a></li></ul></blockquote><blockquote><p>[!NOTE] Spring 异步和定时总结</p><ul><li>任务调度中异步和定时任务的用法：<ol><li>在应用配置文件中添加 <code>@EnableScheduling（定时任务），@EnableAsync （异步任务支持,作用于bean实现异步任务）</code> 注解</li><li>在方法前添加 <code>@Async</code> 注解实现异步方法，添加 <code>@Scheduled</code> 注解实现定时任务（还要为该注解设置定时属性，包括 <em>cron</em>，<em>fixedDelay</em>，<em>fixedRate</em>等）</li></ol></li></ul></blockquote><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听实际上就是等待某个事件的触发，当事件触发时，对应事件的监听器就会被通知，如果你学习过 Java Swing 篇视频教程，应该会深有体会，监听器可是很关键的，只不过在 Spring 中用的不是很频繁罢了。但是这里还是要简单介绍一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span> <span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>        System. out. println (event. getApplicationContext ());   <span class="hljs-comment">//可以直接通过事件获取到事件相关的东西</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要编写监听器，我们只需要让 Bean 继承 ApplicationListener 就可以了，并且将类型指定为对应的 Event 事件，这样，当发生某个事件时就会通知我们，比如 ContextRefreshedEvent，这个事件会在 Spring 容器初始化完成会触发一次：<br><img src="https://s2.loli.net/2022/11/25/MZN3eohGmV17vUJ.png" alt="image-20221125155804255"><br>是不是感觉挺智能的？Spring 内部有各种各样的事件，当然我们也可以自己编写事件，然后在某个时刻发布这个事件到所有的监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> &#123;   <span class="hljs-comment">//自定义事件需要继承 ApplicationEvent</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestEvent</span> <span class="hljs-params">(Object source)</span> &#123;<br>        <span class="hljs-built_in">super</span> (source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;TestEvent&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span> <span class="hljs-params">(TestEvent event)</span> &#123;<br>        System. out. println (<span class="hljs-string">&quot;发生了一次自定义事件，成功监听到！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在我们希望在定时任务中每秒钟发生一次这个事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskComponent</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationEventPublisherAware</span> &#123;  <br>  <span class="hljs-comment">//要发布事件，需要拿到 ApplicationEventPublisher，这里我们通过 Aware 在初始化的时候拿到</span><br>  <span class="hljs-comment">//实际上我们的 ApplicationContext 就是 ApplicationEventPublisher 的实现类，这里拿到的就是</span><br>  <span class="hljs-comment">//我们创建的 ApplicationContext 对象</span><br>    ApplicationEventPublisher publisher;<br>    <span class="hljs-meta">@Scheduled</span> (fixedRate = <span class="hljs-number">1000</span>)   <span class="hljs-comment">//一秒一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span> <span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//直接通过 ApplicationEventPublisher 的 publishEvent 方法发布事件</span><br>      <span class="hljs-comment">//这样，所有这个事件的监听器，都会监听到这个事件发生了</span><br>        publisher. publishEvent (<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestEvent</span> (<span class="hljs-built_in">this</span>));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationEventPublisher</span> <span class="hljs-params">(ApplicationEventPublisher publisher)</span> &#123;<br>        <span class="hljs-built_in">this</span>.publisher = publisher;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，发布事件旁边出现了图标，说明就可以了：<br><img src="https://s2.loli.net/2022/11/25/fDxYEGPWdyMt7XF.png" alt="image-20221125161224037"><br>点击这个图标快速跳转到哪里监听了这个事件，运行结果：<br><img src="https://s2.loli.net/2022/11/25/FKy1jBx3MJvVdDN.png" alt="image-20221125161125557"><br>这样，我们就实现了自定义事件发布和监听。</p><blockquote><p>[!NOTE] 监听器用法总结</p><ul><li>监听器实现对事件的监听并做出反应，具体使用方法：<ol><li>Spring 默认为我们提供了一些<strong>监听事件接口（ContextRefreshedEvent，ContextStartedEvent 等）</strong>，只需要实现需要的接口并完成监听反应逻辑功能即可</li><li>自定义事件并监听：<ul><li>编写自定义事件需要继承 <code>ApplicationEvent</code> 类并实现构造方法</li><li>编写自定义监听器并实现 <code>ApplicationListener&lt;~&gt;</code> 接口（泛型填自定义事件），并重写 <code>onApplicationEvent</code> 响应方法</li><li>在需要应用监听器的类中注入 <code>ApplicationEventPublisher</code> 属性，并在需要被监听的方法中进行事件发布（*publisher. publishEvent (new TestEvent (this))*）</li></ul></li></ol></li></ul></blockquote><hr><h2 id="SpringEL-表达式"><a href="#SpringEL-表达式" class="headerlink" title="SpringEL 表达式"></a>SpringEL 表达式</h2><p>SpEL 是一种强大，简洁的装配 Bean 的方式，它可以通过运行期间执行的表达式将值装配到我们的<strong>属性或构造函数</strong>当中，更可以调用 JDK 中提供的静态常量，获取外部 <code>Properties</code> 文件中的的配置。</p><h3 id="外部属性注入"><a href="#外部属性注入" class="headerlink" title="外部属性注入"></a>外部属性注入</h3><p>有些时候，我们甚至可以将一些外部配置文件中的配置进行读取，并完成注入。<br>我们需要创建以 <code>.properties</code> 结尾的配置文件，这种配置文件格式很简单，类似于 Map，需要一个 Key 和一个 Value，中间使用等号进行连接，这里我们在 resource 目录下创建一个 <code>test.properties</code> 文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">test.name</span>=<span class="hljs-string">只因</span><br></code></pre></td></tr></table></figure><p>这样，Key 就是 <code>test. name</code>，Value 就是 <code>只因</code>，我们可以通过一个注解直接读取到外部配置文件中对应的属性值，首先我们需要引入这个配置文件，我们可以在配置类上添加 <code>@PropertySource</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;com.test.bean&quot;</span>)<br><span class="hljs-meta">@PropertySource</span> (<span class="hljs-string">&quot;classpath:test.properties&quot;</span>)   <span class="hljs-comment">//注意，类路径下的文件名称需要在前面加上 classpath:</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们就可以开始快乐的使用了，我们可以使用 <code>@Value</code> （自动注入基本数据类型）注解结合 <em>${}占位符</em> 将外部配置文件中的值注入到任何我们想要的位置，就像我们之前使用 <code>@Resource</code> 自动注入依赖 bean 一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;$&#123;test.name&#125;&quot;</span>)   <span class="hljs-comment">//这里需要在外层套上 $&#123; &#125;</span><br>    <span class="hljs-keyword">private</span> String name;   <span class="hljs-comment">//String 会被自动赋值为配置文件中对应属性的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span> <span class="hljs-params">()</span>&#123;<br>        System.out.println (<span class="hljs-string">&quot;我的名字是：&quot;</span>+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@Value</code> 中的 <code>$&#123;...&#125;</code> 表示占位符，它会读取外部配置文件的属性值装配到属性中，如果配置正确没问题的话，这里甚至还会直接显示对应配置项的值：<br><img src="https://s2.loli.net/2022/11/25/HDZ4l3tcreoOGh8.png" alt="image-20221125164854022"><br>我们来测试一下吧：<br><img src="https://s2.loli.net/2022/11/25/g5tBKW4Sm9lXnrR.png" alt="image-20221125165145332"><br>如果遇到乱码的情况，请将配置文件的编码格式切换成 UTF-8（可以在 IDEA 设置中进行配置）然后在@PropertySource 注解中添加属性 <code>encoding = &quot;UTF-8&quot;</code> 这样就正常了，当然，其实一般情况下也很少会在配置文件中用到中文。<br>除了在字段上进行注入之外，我们也可以在需要注入的方法中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>  <span class="hljs-comment">//构造方法中的参数除了被自动注入外，我们也可以选择使用@Value 进行注入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span> <span class="hljs-params">(<span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;$&#123;test. name&#125;&quot;</span>)</span> String name)&#123;<br>        <span class="hljs-built_in">this</span>. name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;我的名字是：&quot;</span>+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果我们只是想简单的<strong>注入一个常量值，也可以直接填入固定值</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span> <span class="hljs-params">(<span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;10&quot;</span>)</span> String name)&#123;   <span class="hljs-comment">//只不过，这里都是常量值了，我干嘛不直接写到代码里呢</span><br>    <span class="hljs-built_in">this</span>. name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，@Value 的功能还远不止这些，配合 SpringEL 表达式，能够实现更加强大的功能。</p><h3 id="SpEL-简单使用"><a href="#SpEL-简单使用" class="headerlink" title="SpEL 简单使用"></a>SpEL 简单使用</h3><p>Spring 官方为我们提供了一套非常高级 SpEL 表达式，通过使用表达式，我们可以更加灵活地使用 Spring 框架。<br>首先我们来看看如何创建一个 SpEL 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span> ();<br><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;&#x27;Hello World&#x27;&quot;</span>);  <span class="hljs-comment">//使用 parseExpression 方法来创建一个表达式</span><br>System. out. println (exp. getValue ());   <span class="hljs-comment">//表达式最终的运算结果可以通过 getValue ()获取</span><br></code></pre></td></tr></table></figure><p>这里得到的就是一个很简单的 Hello World 字符串，字符串使用单引号囊括，SpEL 是具有运算能力的。<br>我们可以像写 Java 一样，对这个字符串进行各种操作，比如调用方法之类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;&#x27;Hello World&#x27;. toUpperCase ()&quot;</span>);   <span class="hljs-comment">//调用 String 的 toUpperCase 方法</span><br>System. out. println (exp. getValue ());<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/25/PZmheYn5EVTvURN.png" alt="image-20221125173157008"><br>不仅能调用方法、还可以访问属性、使用构造方法等，是不是感觉挺牛的，居然还能这样玩。<br>对于 <code>Getter</code> 方法，我们可以像访问属性一样去使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//比如 String. getBytes () 方法，就是一个 Getter，那么可以写成 bytes</span><br><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;&#x27;Hello World&#x27;. bytes&quot;</span>);<br>System. out. println (exp. getValue ());<br></code></pre></td></tr></table></figure><p>表达式可以不止一级，我们可以多级调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;&#x27;Hello World&#x27;. bytes. length&quot;</span>);   <span class="hljs-comment">//继续访问数组的 length 属性</span><br>System. out. println (exp. getValue ());<br></code></pre></td></tr></table></figure><p>我们继续来试试看构造方法，其实就是写 Java 代码，只是可以写成这种表达式而已：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;new String (&#x27;hello world&#x27;). toUpperCase ()&quot;</span>);<br>System. out. println (exp. getValue ());<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/25/PZmheYn5EVTvURN.png" alt="image-20221125173157008"><br>它甚至还支持根据特定表达式，从给定对象中获取属性出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span> <span class="hljs-params">(<span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;$&#123;test. name&#125;&quot;</span>)</span> String name)&#123;<br>        <span class="hljs-built_in">this</span>. name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//比如下面要访问 name 属性，那么这个属性得可以访问才行，访问权限不够是不行的</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span> ();<br><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;name&quot;</span>);<br>System. out. println (exp. getValue (student));    <span class="hljs-comment">//直接读取对象的 name 属性</span><br></code></pre></td></tr></table></figure><p>拿到对象属性之后，甚至还可以继续去处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;name. bytes. length&quot;</span>);   <span class="hljs-comment">//拿到 name 之后继续 getBytes 然后 length</span><br></code></pre></td></tr></table></figure><p>除了获取，我们也可以调用表达式的 <code>setValue</code> 方法来设定属性的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;name&quot;</span>);<br>exp. setValue (student, <span class="hljs-string">&quot;刻师傅&quot;</span>);   <span class="hljs-comment">//同样的，这个属性得有访问权限且能 set 才可以，否则会报错</span><br></code></pre></td></tr></table></figure><p>除了属性调用，我们也可以使用运算符进行各种<strong>高级运算</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;66 &gt; 77&quot;</span>);   <span class="hljs-comment">//比较运算</span><br>System. out. println (exp. getValue ());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;99 + 99 * 3&quot;</span>);   <span class="hljs-comment">//算数运算</span><br>System. out. println (exp. getValue ());<br></code></pre></td></tr></table></figure><p>对于那些<strong>需要导入才能使用的类</strong>，我们需要使用一个特殊的语法：<code>T (java.lang.Math).random ()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;T (java.lang.Math).random ()&quot;</span>);   <span class="hljs-comment">//由 T ()囊括，包含完整包名+类名</span><br><span class="hljs-comment">//Expression exp = parser. parseExpression (&quot;T (System). nanoTime ()&quot;);   //默认导入的类可以不加包名</span><br>System.out.println (exp. etValue ());<br></code></pre></td></tr></table></figure><h3 id="集合操作相关语法"><a href="#集合操作相关语法" class="headerlink" title="集合操作相关语法"></a>集合操作相关语法</h3><p>现在我们的类中存在一些集合类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; map = Map. of (<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;你干嘛&quot;</span>);<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; list = List. of (<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用 SpEL 快速取出集合中的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;map[&#x27;test&#x27;]&quot;</span>);  <span class="hljs-comment">//对于 Map 这里映射型，可以直接使用 map[key]来取出 value</span><br>System. out. println (exp. getValue (student));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;list[2]&quot;</span>);   <span class="hljs-comment">//对于 List、数组这类，可以直接使用[index]</span><br>System. out. println (exp. getValue (student));<br></code></pre></td></tr></table></figure><p>我们也可以快速创建集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;&#123;5, 2, 1, 4, 6, 7, 0, 3, 9, 8&#125;&quot;</span>); <span class="hljs-comment">//使用&#123;&#125;来快速创建 List 集合</span><br><span class="hljs-type">List</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (List) exp. getValue ();<br>value. forEach (System. out::println);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot; &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125; &quot;</span>);   <span class="hljs-comment">//它是支持嵌套使用的</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建 Map 也很简单，只需要 key: value 就可以了，怎么有股 JSON 味</span><br><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;&#123;name: &#x27;小明&#x27;, info: &#123;address: &#x27;北京市朝阳区&#x27;, tel: 10086&#125;&#125;&quot;</span>);<br>System. out. println (exp. getValue ());<br></code></pre></td></tr></table></figure><p>你以为就这么简单吗，我们还可以直接根据条件获取集合中的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Clazz&gt; list = List. of (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Clazz</span> (<span class="hljs-string">&quot;高等数学&quot;</span>, <span class="hljs-number">4</span>));<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Clazz</span> (String name, <span class="hljs-type">int</span> score)&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//现在我们希望从 list 中获取那些满足我们条件的元素，并组成一个新的集合，我们可以使用.? 运算符</span><br><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;list.?[name == &#x27;高等数学&#x27;]&quot;</span>);<br>System. out. println (exp. getValue (student));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;list.?[score &gt; 3]&quot;</span>);   <span class="hljs-comment">//选择学分大于 3 分的科目</span><br>System. out. println (exp. getValue (student));<br></code></pre></td></tr></table></figure><p>我们还可以针对某个属性创建对应的投影集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;list.![name]&quot;</span>);   <span class="hljs-comment">//使用.! 创建投影集合，这里创建的时课程名称组成的新集合</span><br>System. out. println (exp. getValue (student));<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/30/yLNHPJnWkoR3Cb2.png" alt="image-20221130153142677"><br>我们接着来介绍<strong>安全导航运算符</strong>，安全导航运算符用于避免 NullPointerException，它来自 Groovy 语言。通常，当您有对对象的引用时，您可能需要在访问对象的方法或属性之前验证它是否为空。为了避免这种情况，安全导航运算符返回 null 而不是抛出异常。以下示例显示了如何使用安全导航运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;name. toUpperCase ()&quot;</span>);   <span class="hljs-comment">//如果 Student 对象中的 name 属性为 null</span><br>System. out. println (exp. getValue (student));<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/30/dojeP5kYcM7KHiv.png" alt="image-20221130150723018"><br>当遇到 null 时很不方便，我们还得写判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (student. name != <span class="hljs-literal">null</span>)<br>    System. out. println (student. name. toUpperCase ());<br></code></pre></td></tr></table></figure><p>Java 8 之后能这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional. ofNullable (student. name). ifPresent (System. out::println);<br></code></pre></td></tr></table></figure><p>但是你如果写过 Kotlin：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println (student. name?. toUpperCase ());<br></code></pre></td></tr></table></figure><p>类似于这种判空问题，我们就可以直接使用安全导航运算符，SpEL 也支持这种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser. parseExpression (<span class="hljs-string">&quot;name?. toUpperCase ()&quot;</span>);<br>System. out. println (exp. getValue (student));<br></code></pre></td></tr></table></figure><p>当遇到空时，只会得到一个 null，而不是直接抛出一个异常：<br><img src="https://s2.loli.net/2022/11/30/tOf3LFsWE4H8BVc.png" alt="image-20221130150654287"><br>我们可以将 SpEL 配合 @Value 注解或是 xml 配置文件中的 value 属性使用，比如 XML 中可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;numberGuess&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.spring.samples.NumberGuess&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;randomNumber&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或是使用注解开发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldValueTestBean</span> &#123;<br>    <span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;#&#123; systemProperties[&#x27;user. region&#x27;] &#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> String defaultLocale;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们有时候在使用配置文件中的值时，就能进行一些简单的处理了。<br>有关更多详细语法教程，请前往： <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions-language-ref">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions-language-ref</a></p><blockquote><p>[!NOTE] 总结</p><ul><li>外部属性注入流程：<ol><li>为 Class 添加 <code>@PropertySource (&quot;classpath:test.properties&quot;)</code> 注解</li><li>为属性添加 <code>@Value(&quot;$&#123;student.name&#125;&quot;)</code> 注解自动注入外部文件中的值</li></ol></li><li>SpEL 表达式使用方法：<br> 1. <code>ExpressionParser parser = new SpelExpressionParser ();</code> 创建 ExpressionParser<br> 2. 书写 <code>Expression exp = parser. parseExpression (&quot;&#39;Hello World&#39;&quot;</code>) exp 表达式<br> 3. <code>exp.getValue()</code> 取值，<code>exp.setValue(Class&lt;?&gt;,value)</code> 修改值，<code>parser.parseExpression(&quot;T(org.example.entity.Student).test()&quot;)</code> 调用方法</li><li>常见 SpEL 表达式集合操作：<ol><li>取元素：<code>parser.parseExpression(&quot;list[2]&quot;)</code></li><li>创建集合：List：<code>parser.parseExpression(&quot;&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;&quot;)</code>，Map：<code>parser.parseExpression(&quot;&#123;name:&#39;xixi&#39;,age:12&#125;&quot;)</code></li><li>条件过滤：*.?* 过滤 <code>parser.parseExpression(&quot;clazzList.?[score&gt;=90 &amp;&amp; name== &#39;国学&#39;]&quot;)</code></li><li>投影复制：*.!* 复制 <code>parser.parseExpression(&quot;clazzList.![name]&quot;)</code></li><li>安全判空：*?.* 安全导航 <code>parser.parseExpression(&quot;name?.toUpperCase()&quot;)</code></li><li>如影随形：*#{}* 表示 SpEL 表达式，注解中使用：<code> @Value (&quot;#&#123; systemProperties[&#39;user. region&#39;] &#125;&quot;)</code>，xml 中使用：<code>&lt;property name=&quot;randomNumber&quot; value=&quot;#&#123; T(java.lang.Math).random() * 100.0 &#125;&quot;/&gt;</code></li></ol></li></ul></blockquote><hr><h2 id="AOP-面向切片"><a href="#AOP-面向切片" class="headerlink" title="AOP 面向切片"></a>AOP 面向切片</h2><p>又是一个听起来很高大上的名词，AOP（Aspect Oriented Programming）思想实际上就是：在运行时，动态地将代码切入到类的指定方法、指定位置上。也就是说，我们可以使用 AOP 来帮助我们在方法执行前或执行之后，做一些额外的操作，实际上，它就是代理！<br>通过 AOP 我们可以在保证原有业务不变的情况下，添加额外的动作，比如我们的某些方法执行完成之后，需要打印日志，那么这个时候，我们就可以使用 AOP 来帮助我们完成，它可以批量地为这些方法添加动作。可以说，它相当于将我们原有的方法，在不改变源代码的基础上进行了增强处理。<br><img src="https://s2.loli.net/2022/11/30/sJbSrgiAxa8Vhcv.png" alt="image-20221130155358974"><br>相当于我们的整个业务流程，被直接斩断，并在断掉的位置添加了一个额外的操作，再连接起来，也就是在一个切点位置插入内容。它的原理实际上就是通过动态代理机制实现的，我们在 JavaWeb 阶段已经给大家讲解过动态代理了。不过 Spring 底层并不是使用的 JDK 提供的动态代理，而是使用的第三方库实现，它能够以父类的形式代理，而不仅仅是接口。</p><h3 id="使用配置实现-AOP"><a href="#使用配置实现-AOP" class="headerlink" title="使用配置实现 AOP"></a>使用配置实现 AOP</h3><p>在开始之前，我们先换回之前的 XML 配置模式，之后也会给大家讲解如何使用注解完成 AOP 操作，注意这里我们还加入了一些新的 AOP 相关的约束进来，建议直接 CV 下面的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot; http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot; http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot; http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring 是支持 AOP 编程的框架之一（实际上它整合了 AspectJ 框架的一部分），要使用 AOP 我们需要先导入一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要实现 AOP 操作，我们需要知道这些内容：</p><ol><li>需要切入的类，类的哪个方法需要被切入</li><li>切入之后需要执行什么动作</li><li>是在方法执行前切入还是在方法执行后切入</li><li>如何告诉 Spring 需要进行切入<br>比如现在我们希望对这个学生对象的 <code>study</code> 方法进行增强，在不修改源代码的情况下，增加一些额外的操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;室友还在打游戏，我狠狠的学 Java，太爽了&quot;</span>); <br>      <span class="hljs-comment">//现在我们希望在这个方法执行完之后，打印一些其他的内容，在不修改原有代码的情况下，该怎么做呢？</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean class=<span class="hljs-string">&quot;org.example.entity.Student&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>那么我们按照上面的流程，依次来看，首先需要解决的问题是，找到需要切入的类，很明显，就是这个 Student 类，我们要切入的是这个 <code>study</code> 方法。<br>第二步，我们切入之后要做什么呢？这里我们直接创建一个新的类，并将要执行的操作写成一个方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentAOP</span> &#123;<br>  <span class="hljs-comment">//这个方法就是我们打算对其进行的增强操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterStudy</span> <span class="hljs-params">()</span> &#123;<br>        System. out. println (<span class="hljs-string">&quot;为什么毕业了他们都继承家产，我还倒给他们打工，我努力的意义在哪里...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>注意这个类也得注册为 Bean 才可以：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentAOP&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.StudentAOP&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>第三步，我们要明确这是在方法执行之前切入还是执行之后切入，很明显，按照上面的要求，我们需要执行之后进行切入。<br>第四步，最关键的来了，我们怎么才能告诉 Spring 我们要进行切入操作呢？这里我们需要在配置文件中进行 AOP 配置：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>接着我们需要添加一个新的切点，首先填写 ID，这个随便起都可以：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>然后就是通过后面的 <code>expression</code> 表达式来选择到我们需要切入的方法，这个表达式支持很多种方式进行选择，Spring AOP 支持以下 AspectJ 切点指示器（PCD）用于表达式：</li></ol><ul><li><code>execution</code>：用于匹配方法执行连接点。这是使用 Spring AOP 时使用的主要点切割指示器。</li><li><code>within</code>：限制匹配到某些类型的连接点（使用 Spring AOP 时在匹配类型中声明的方法的执行）。</li><li><code>this</code>：限制与连接点匹配（使用 Spring AOP 时方法的执行），其中 bean 引用（Spring AOP 代理）是给定类型的实例。</li><li><code>target</code>：限制匹配连接点（使用 Spring AOP 时方法的执行），其中目标对象（正在代理的应用程序对象）是给定类型的实例。</li><li><code>args</code>：限制与连接点匹配（使用 Spring AOP 时方法的执行），其中参数是给定类型的实例。</li><li><code>@target</code>：限制匹配连接点（使用 Spring AOP 时方法的执行），其中执行对象的类具有给定类型的注释。</li><li><code>@args</code>：限制匹配到连接点（使用 Spring AOP 时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。</li><li><code>@within</code>：限制与具有给定注释的类型中的连接点匹配（使用 Spring AOP 时在带有给定注释的类型中声明的方法的执行）。</li><li><code>@annotation</code>：与连接点主体（在 Spring AOP 中运行的方法）具有给定注释的连接点匹配的限制。<br>更多详细内容请查阅： <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators">https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators</a><br>其中，我们主要学习的 <code>execution</code> 填写格式如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">修饰符包名. 类名. 方法名称 (方法参数)<br></code></pre></td></tr></table></figure></li><li>修饰符：public、protected、private、包括返回值类型、static 等等（使用*代表任意修饰符）</li><li>包名：如 com. test（* 代表全部，比如 com.*代表 com 包下的全部包）</li><li>类名：使用*也可以代表包下的所有类</li><li>方法名称：可以使用*代表全部方法</li><li>方法参数：填写对应的参数即可，比如 (String, String)，也可以使用*来代表任意一个参数，使用.. 代表所有参数。<br>也可以使用其他属性来进行匹配，比如 <code>@annotation</code> 可以用于表示标记了哪些注解的方法被切入，这里我们就只是简单的执行，所以说只需要这样写就可以了：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* org.example.entity.Student.study())&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>这样，我们就指明了需要切入的方法，然后就是将我们的增强方法，我们在里面继续添加 <code>aop:aspect</code> 标签，并使用 <code>ref</code> 属性将其指向我们刚刚注册的 AOP 类 Bean：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* org.example.entity.Student.study())&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;studentAOP&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>接着就是添加后续动作了，当然，官方支持的有多种多样的，比如执行前、执行后、抛出异常后、方法返回后等等：<br><img src="https://s2.loli.net/2022/12/16/uopJ9KyqMvQSwi4.png" alt="image-20221216155201849"><br>其中 <code>around 方法</code> 为环绕方法，自定义度会更高，我们会在稍后介绍。这里我们按照上面的要求，直接添加后续动作，注意需要指明生效的切点：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;studentAOP&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--     method就是我们的增强方法，pointcut-ref指向我们刚刚创建的切点     --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;afterStudy&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br></code></pre></td></tr></table></figure>这样，我们就成功配置好了，配置正确会在旁边出现图标：<br><img src="https://s2.loli.net/2022/12/16/hBaSmuovMzp5iIn.png" alt="image-20221216155551779"><br>我们来试试看吧：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> (<span class="hljs-string">&quot;application. xml&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>    bean. study ();<br>&#125;<br></code></pre></td></tr></table></figure>结果如下：<br><img src="https://s2.loli.net/2022/12/16/JlvLe9rgQw2pbXo.png" alt="image-20221216155616952"><br>可以看到在我们原本的方法执行完成之后，它还继续执行了我们的增强方法，这实际上就是动态代理做到的，实现在不修改原有代码的基础上，对方法的调用进行各种增强，在之后的 SpringMVC 学习中，我们甚至可以使用它来快速配置访问日志打印。<br>前面我们说了，AOP 是基于动态代理实现的，所以说我们如果直接获取 Bean 的类型，会发现不是原本的类型了：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>System. out. println (bean. getClass ());<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/12/16/8lsiRj6Q9eTLhSI.png" alt="image-20221216172042146"><br>这里其实是 Spring 通过 CGLib 为我们生成的动态代理类，也就不难理解为什么调用方法会直接得到增强之后的结果了。包括我们前面讲解 Spring 的异步任务调度时，为什么能够直接实现异步，其实就是利用了 AOP 机制实现的方法增强。<br>虽然这些功能已经非常强大了，但是仅仅只能简单的切入还是不能满足一些需求，在某些情况下，我们可以需求方法执行的一些参数，比如方法执行之后返回了什么，或是方法开始之前传入了什么参数等等，现在我们修改一下 Student 中 <code>study</code> 方法的参数：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span> <span class="hljs-params">(String str)</span>&#123;  <span class="hljs-comment">//现在方法有一个 String 类型的参数</span><br>        System. out. println (<span class="hljs-string">&quot;都别学 Java 了，根本找不到工作，快去卷&quot;</span>+str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>我们希望在增强的方法中也能拿到这个参数，然后进行处理：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentAOP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterStudy</span> <span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//这个 str 参数我们该从哪里拿呢？</span><br>        System. out. println (<span class="hljs-string">&quot;学什么&quot;</span>+str+<span class="hljs-string">&quot;，Rust 天下第一！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这个时候，我们可以为我们切入的方法添加一个 JoinPoint 参数，通过此参数就可以快速获取切点位置的一些信息：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterStudy</span> <span class="hljs-params">(JoinPoint point)</span> &#123;   <span class="hljs-comment">//JoinPoint 实例会被自动传入</span><br>    <span class="hljs-comment">//这里我们直接通过 getArgs ()返回的参数数组获取第 1 个参数</span><br>    System. out. println (<span class="hljs-string">&quot;学什么&quot;</span>+point. getArgs ()[<span class="hljs-number">0</span>]+<span class="hljs-string">&quot;，Rust 天下第一！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>接着我们修改一下刚刚的 AOP 配置（因为方法参数有变动）看看结果吧：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* org.example.entity.Student.study(String))&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>现在我们来测试一下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> (<span class="hljs-string">&quot;application. xml&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>    bean. study (<span class="hljs-string">&quot;PHP&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/12/16/NrZA49JvpgEyL2O.png" alt="image-20221216160501469"><br>是不是感觉大部分功能都可以通过 AOP 来完成了？<br>我们接着来看自定义度更高的环绕方法，现在我们希望在方法执行前和执行后都加入各种各样的动作，如果还是一个一个切点写，有点太慢了，能不能直接写一起呢，此时我们就可以使用环绕方法。<br>环绕方法相当于完全代理了此方法，它完全将此方法包含在中间，需要我们手动调用才可以执行此方法，并且我们可以直接获取更多的参数：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span> <span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    System. out. println (<span class="hljs-string">&quot;方法开始之前&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> joinPoint. proceed ();   <span class="hljs-comment">//调用 process 方法来执行被代理的原方法，如果有返回值，可以使用 value 接收</span><br>    System. out. println (<span class="hljs-string">&quot;方法执行完成，结果为：&quot;</span>+value);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>注意，如果代理方法存在返回值，那么环绕方法也需要有一个返回值，通过 <code>proceed</code> 方法来执行代理的方法，也可以修改参数之后调用 <code>proceed (Object[])</code>，使用我们给定的参数再去执行：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span> <span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    System. out. println (<span class="hljs-string">&quot;方法开始之前&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> joinPoint. getArgs ()[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;伞兵一号&quot;</span>;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> joinPoint. proceed (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;arg&#125;);<br>    System. out. println (<span class="hljs-string">&quot;方法执行完成，结果为：&quot;</span>+value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>这里我们还是以 <code>study</code> 方法为例，现在我们希望在调用前修改这个方法传入的参数值，改成我们自己的，然后在调用之后对返回值结果也进行处理：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">study</span> <span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-keyword">if</span> (str. equals (<span class="hljs-string">&quot;Java&quot;</span>))<br>        System. out. println (<span class="hljs-string">&quot;我的梦想是学 Java&quot;</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        System. out. println (<span class="hljs-string">&quot;我就要学 Java，不要修改我的梦想！&quot;</span>);<br>        str = <span class="hljs-string">&quot;Java&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure>现在我们编写一个环绕方法，对其进行全方面处理：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span> <span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    System. out. println (<span class="hljs-string">&quot;我是她的家长，他不能学 Java，必须学 Rust，这是为他好&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> joinPoint. proceed (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;Rust&quot;</span>&#125;);<br>    <span class="hljs-keyword">if</span> (value. equals (<span class="hljs-string">&quot;Java&quot;</span>)) &#123;<br>        System. out. println (<span class="hljs-string">&quot;听话，学 Rust 以后进大厂！&quot;</span>);<br>        value = <span class="hljs-string">&quot;Rust&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>同样的，因为方法变动了，现在我们去修改一下我们的 AOP 配置：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* org.example.entity.Student.study(String))&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;studentAOP&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;around&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/12/16/FPwQjRvsDgTnoWx.png" alt="image-20221216162003675"><br>细心的小伙伴可能会发现，环绕方法的图标是全包的，跟我们之前的图标不太一样。<br>现在我们来试试看吧：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> (<span class="hljs-string">&quot;application. xml&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>    System. out. println (<span class="hljs-string">&quot;已报名：&quot;</span>+bean. study (<span class="hljs-string">&quot;Java&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/12/16/pGl7n8qboe4tuJf.png" alt="image-20221216161855358"><br>这样，我们就实现了环绕方法，通过合理利用 AOP 带来的便捷，可以使得我们的代码更加清爽和优美。这里介绍一下 AOP 领域中的特性术语，防止自己下来看不懂文章：</li><li>通知（Advice）: AOP 框架中的增强处理，通知描述了<strong>切面何时执行以及如何执行增强处理</strong>，也就是我们上面编写的方法实现。</li><li>连接点（join point）: 连接点表示应用执行过程中<strong>能够插入切面的一个点</strong>，这个点可以是方法的调用、异常的抛出，实际上就是我们在方法执行前或是执行后需要做的内容。</li><li>切点（PointCut）: <strong>可以插入增强处理的连接点</strong>，可以是方法执行之前也可以方法执行之后，还可以是抛出异常之类的。</li><li>切面（Aspect）: 切面是<strong>通知和切点的结合</strong>，我们之前在 xml 中定义的就是切面，包括很多信息。</li><li>引入（Introduction）：引入允许我们向现有的类添加<strong>新的方法或者属性</strong>。</li><li>织入（Weaving）: <strong>将增强处理添加到目标对象中</strong>，并<strong>创建一个被增强的对象</strong>，我们之前都是在将我们的增强处理添加到目标对象，也就是织入（这名字挺有文艺范的）</li></ul><blockquote><p>[!NOTE] xml 实现 AOP 总结</p><ul><li>实现切入类和对应属性和方法</li><li>编写 AOP 配置文件，注册相应的 bean，并配置 AOP 切点、切面和切面的操作等</li><li>切入方法可以获取被切入的方法的形参并执行被被切入的方法等</li></ul></blockquote><h3 id="使用接口实现-AOP"><a href="#使用接口实现-AOP" class="headerlink" title="使用接口实现 AOP"></a>使用接口实现 AOP</h3><p>前面我们介绍了如何使用 xml 配置一个 AOP 操作，这节课我们来看看如何使用 <code>Advice</code> 实现 AOP。<br>它与我们之前学习的动态代理更接近一些，比如在方法开始执行之前或是执行之后会去调用我们实现的接口，首先我们需要将一个类实现 Advice 接口，只有实现此接口，才可以被通知，比如我们这里使用 <code>MethodBeforeAdvice</code> 表示是一个在方法执行之前的动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentAOP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System. out. println (<span class="hljs-string">&quot;通过 Advice 实现 AOP&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，方法中包括了很多的参数，其中 <code>args</code> 代表的是方法执行前得到的<strong>实参列表</strong>，还有 <code>target</code> 表示执行此方法的<strong>实例对象</strong>。运行之后，效果和之前是一样的，但是在这里我们就可以快速获取到更多信息。还是以简单的 study 方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;我是学习方法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.Student&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentAOP&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.entity.StudentAOP&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* org.example.entity.Student.study())&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--  这里只需要添加我们刚刚写好的advisor就可以了，注意是Bean的名字  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;studentAOP&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们来测试一下吧：<br><img src="https://s2.loli.net/2022/12/16/ofducpb2mLh9XHi.png" alt="image-20221216164110367"><br>除了此接口以外，还有其他的接口，比如 <code>AfterReturningAdvice</code> 就需要实现一个方法执行之后的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentAOP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span>, AfterReturningAdvice &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System. out. println (<span class="hljs-string">&quot;通过 Advice 实现 AOP&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span> <span class="hljs-params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System. out. println (<span class="hljs-string">&quot;我是方法执行之后的结果，方法返回值为：&quot;</span>+returnValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为使用的是接口，就非常方便，直接写一起，配置文件都不需要改了：<br><img src="https://s2.loli.net/2022/12/16/DUZzqaBSiJKNv8j.png" alt="image-20221216164242506"><br>我们也可以使用 <code>MethodInterceptor</code>（同样也是 Advice 的子接口）进行更加<strong>环绕</strong>那样的自定义的增强，它用起来就真的像代理一样，例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">study</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;我是学习方法！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;lbwnb&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentAOP</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;   <span class="hljs-comment">//实现 MethodInterceptor 接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span> <span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <span class="hljs-comment">//invoke 方法就是代理方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> invocation. proceed ();   <span class="hljs-comment">//跟之前一样，需要手动 proceed ()才能调用原方法</span><br>        <span class="hljs-keyword">return</span> value+<span class="hljs-string">&quot;增强&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看结果吧：<br><img src="https://s2.loli.net/2022/12/16/ARcUW2mJrn7Y6f9.png" alt="image-20221216173211310"></p><blockquote><p>[!NOTE] xml 结合接口实现 AOP 总结</p><ul><li>AOP 通知类实现需要的接口（<code>MethodBeforeAdvice前置通知, AfterReturningAdvice后置通知, MethodInterceptor环绕通知</code>）</li><li>编写 AOP 配置文件，设置 <code>&lt;aop:advisor advice-ref=&quot;studentAOP&quot; pointcut-ref=&quot;study&quot;/&gt;</code></li></ul></blockquote><h3 id="使用注解实现-AOP"><a href="#使用注解实现-AOP" class="headerlink" title="使用注解实现 AOP"></a>使用注解实现 AOP</h3><p>接着我们来看看如何使用注解实现 AOP 操作，现在变回我们之前的注解开发，首先我们需要在主类添加 <code>@EnableAspectJAutoProxy</code> 注解，开启 AOP 注解支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;org. example. entity&quot;</span>)<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是熟悉的玩法，类上直接添加 <code>@Component</code> 快速注册 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;我是学习方法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要在定义 AOP 增强操作的类上添加 <code>@Aspect</code> 注解和 <code>@Component</code> 将其注册为 Bean 即可，就像我们之前在配置文件中也要将其注册为 Bean 那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentAOP</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们可以在里面编写增强方法，并将此方法添加到一个切点中，比如我们希望在 Student 的 study 方法执行之前执行我们的 <code>before</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">()</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;我是之前执行的内容！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么只需要添加@Before 注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span> (<span class="hljs-string">&quot;execution (* org. example. entity. Student. study ())&quot;</span>)  <span class="hljs-comment">//execution 写法跟之前一样</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">()</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;我是之前执行的内容！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，这个方法就会在指定方法执行之前执行了，是不是感觉比 XML 配置方便多了。我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context. getBean (Student. class);<br>    bean. study ();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/16/KpiXcdNt7BglYQh.png" alt="image-20221216165625372"><br>同样的，我们可以为其添加 <code>JoinPoint</code> 参数来获取切入点信息，使用方法跟之前一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span> (<span class="hljs-string">&quot;execution (* org. example. entity. Student. study ())&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">(JoinPoint point)</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;参数列表：&quot;</span>+ Arrays. toString (point. getArgs ()));<br>    System. out. println (<span class="hljs-string">&quot;我是之前执行的内容！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更方便，我们还可以直接将参数放入，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span> <span class="hljs-params">(String str)</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;我是学习方法！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用命名绑定模式，可以快速得到原方法的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before</span> (value = <span class="hljs-string">&quot;execution (* org. example. entity. Student. study (..)) &amp;&amp; args (str)&quot;</span>, argNames = <span class="hljs-string">&quot;str&quot;</span>)<br><span class="hljs-comment">//命名绑定模式就是根据下面的方法参数列表进行匹配</span><br><span class="hljs-comment">//这里 args 指明参数，注意需要跟原方法保持一致，然后在 argNames 中指明</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span> <span class="hljs-params">(String str)</span>&#123;<br>    System. out. println (str);   <span class="hljs-comment">//可以快速得到传入的参数</span><br>    System. out. println (<span class="hljs-string">&quot;我是之前执行的内容！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>除了@Before，还有很多可以直接使用的注解，比如@AfterReturning、@AfterThrowing 等，比如@AfterReturning：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">study</span> <span class="hljs-params">()</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;我是学习方法！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;lbwnb&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AfterReturning</span> (value = <span class="hljs-string">&quot;execution (* org. example. entity. Student. study ())&quot;</span>, argNames = <span class="hljs-string">&quot;returnVal&quot;</span>, returning = <span class="hljs-string">&quot;returnVal&quot;</span>)   <span class="hljs-comment">//使用 returning 指定接收方法返回值的参数 returnVal</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturn</span> <span class="hljs-params">(Object returnVal)</span>&#123;<br>    System. out. println (<span class="hljs-string">&quot;返回值是：&quot;</span>+returnVal);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，环绕也可以直接通过注解声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around</span> (<span class="hljs-string">&quot;execution (* com. test. bean. Student. test (..))&quot;</span>)<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span> <span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    System. out. println (<span class="hljs-string">&quot;方法执行之前！&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> point. proceed ();<br>    System. out. println (<span class="hljs-string">&quot;方法执行之后！&quot;</span>);<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，无论是使用注解或是 XML 配置，我们要做的流程都是一样的，在之后的学习中，我们还会遇到更多需要使用 AOP 的地方。</p><blockquote><p>[!NOTE] 注解实现 AOP 总结<br>注解实现 AOP 代理的步骤：</p><ol><li>首先为<strong>配置主类</strong>添加注解 <code>@EnableAspectJAutoProxy</code> 开启 AOP 代理</li><li>编写<strong>AOP 增强类</strong>并添加 <code>@Aspect</code> 和 <code>@Bean</code> 注解</li><li>实现<strong>代理增强方法</strong>并添加需要的注解（<code>@Before，@After/AfterReturning/AfterThrowing，@Round</code> 等），并未注解配置 <code>value</code> 属性指定代理增强的<em>目标</em>，（<strong>可选</strong>）设置 <code>argsName</code> 属性指定对应<em>形参</em>，eg：<br>  <code>@After(value = &quot;execution(* org.example.entity.Student.study(..)) &amp;&amp;  args(msg)&quot;,argNames = &quot;msg&quot;)</code></li></ol></blockquote><hr><h2 id="数据库框架整合"><a href="#数据库框架整合" class="headerlink" title="数据库框架整合"></a>数据库框架整合</h2><p>学习了 Spring 之后，我们已经了解如何将一个类作为 Bean 交由 IoC 容器管理，这样，我们就可以通过更方便的方式来使用 Mybatis 框架，我们可以直接把 SqlSessionFactory、Mapper 交给 Spring 进行管理，并且可以通过注入的方式快速地使用它们。<br>因此，我们要学习一下如何将 Mybatis 与 Spring 进行整合，那么首先，我们需要在之前知识的基础上继续深化学习。</p><h3 id="了解数据源"><a href="#了解数据源" class="headerlink" title="了解数据源"></a>了解数据源</h3><p>在之前，我们如果需要创建一个 JDBC 的连接，那么必须使用 <code>DriverManager. getConnection ()</code> 来创建连接，连接建立后，我们才可以进行数据库操作。而学习了 Mybatis 之后，我们就不用再去使用 <code>DriverManager</code> 为我们提供连接对象，而是直接使用 Mybatis 为我们提供的 <code>SqlSessionFactory</code> 工具类来获取对应的 <code>SqlSession</code> 通过会话对象去操作数据库。<br>那么，它到底是如何封装 JDBC 的呢？我们可以试着来猜想一下，会不会是 Mybatis 每次都是帮助我们调用 <code>DriverManager</code> 来实现的数据库连接创建？我们可以看看 Mybatis 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSession <span class="hljs-title function_">openSession</span> <span class="hljs-params">(<span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. openSessionFromDataSource (<span class="hljs-built_in">this</span>. configuration. getDefaultExecutorType (), (TransactionIsolationLevel) <span class="hljs-literal">null</span>, autoCommit);<br>&#125;<br></code></pre></td></tr></table></figure><p>在通过 <code>SqlSessionFactory</code> 调用 <code>openSession</code> 方法之后，它调用了内部的一个私有的方法 <code>openSessionFromDataSource</code>，我们接着来看，这个方法里面定义了什么内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SqlSession <span class="hljs-title function_">openSessionFromDataSource</span> <span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level, <span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">tx</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    DefaultSqlSession <span class="hljs-keyword">var</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取当前环境（由配置文件映射的对象实体）</span><br>        <span class="hljs-type">Environment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. configuration. getEnvironment ();<br>      <span class="hljs-comment">//事务工厂（暂时不提，下一板块讲解）</span><br>        <span class="hljs-type">TransactionFactory</span> <span class="hljs-variable">transactionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. getTransactionFactoryFromEnvironment (environment);<br>      <span class="hljs-comment">//配置文件中：&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br>      <span class="hljs-comment">//生成事务（根据我们的配置，会默认生成 JdbcTransaction），这里是关键，我们看到这里用到了 environment. getDataSource ()方法</span><br>        tx = transactionFactory. newTransaction (environment. getDataSource (), level, autoCommit);<br>      <span class="hljs-comment">//执行器，包括全部的数据库操作方法定义，本质上是在使用执行器操作数据库，需要传入事务对象</span><br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. configuration. newExecutor (tx, execType);<br>      <span class="hljs-comment">//封装为 SqlSession 对象</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-number">8</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSession</span> (<span class="hljs-built_in">this</span>. configuration, executor, autoCommit);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception <span class="hljs-keyword">var</span> <span class="hljs-number">12</span>) &#123;<br>        <span class="hljs-built_in">this</span>. closeTransaction (tx);<br>        <span class="hljs-keyword">throw</span> ExceptionFactory. wrapException (<span class="hljs-string">&quot;Error opening session.  Cause: &quot;</span> + <span class="hljs-keyword">var</span> <span class="hljs-number">12</span>, <span class="hljs-keyword">var</span> <span class="hljs-number">12</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ErrorContext. instance (). reset ();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">var</span> <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，我们的数据源配置信息，存放在了 <code>Transaction</code> 对象中，那么现在我们只需要知道执行器到底是如何执行 SQL 语句的，我们就知道到底如何创建 <code>Connection</code> 对象了，这时就需要获取数据库的链接信息了，那么我们来看看，这个 <code>DataSource</code> 到底是个什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataSource</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CommonDataSource</span>, Wrapper &#123;<br>  Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br>  Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">(String username, String password)</span><br>    <span class="hljs-keyword">throws</span> SQLException;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，它是在 <code>javax. sql</code> 定义的一个接口，它包括了两个方法，都是用于获取连接的。因此，现在我们可以断定，并不是通过之前 <code>DriverManager</code> 的方法去获取连接了，而是使用 <code>DataSource</code> 的实现类来获取的，因此，也就正式引入到我们这一节的话题了：</p><blockquote><p>数据库链接的建立和关闭是极其耗费系统资源的操作，通过 DriverManager 获取的数据库连接，一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完后立即关闭连接，频繁的打开、关闭连接会持续消耗网络资源，造成整个系统性能的低下。<br>因此，JDBC 为我们定义了一个数据源的标准，也就是 <code>DataSource</code> 接口，告诉数据源数据库的连接信息，并将所有的连接全部交给数据源进行集中管理，当需要一个 <code>Connection</code> 对象时，可以向数据源申请，数据源会根据内部机制，合理地分配连接对象给我们。<br>一般比较常用的 <code>DataSource</code> 实现，都是采用池化技术，就是在一开始就创建好 N 个连接，这样之后使用就无需再次进行连接，而是直接使用现成的 <code>Connection</code> 对象进行数据库操作。<br><img src="https://s2.loli.net/2022/12/17/rk4mcdvYn6osOLW.png" alt="image-20221217134119558"><br>当然，也可以使用传统的即用即连的方式获取 <code>Connection</code> 对象，Mybatis 为我们提供了几个默认的数据源实现，我们之前一直在使用的是官方的默认配置，也就是池化数据源：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br>&lt;! DOCTYPE configuration<br>        PUBLIC &quot;-//mybatis. org//DTD Config 3.0//EN&quot;<br>        &quot; http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;驱动类（含包名）&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;数据库连接URL&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;用户名&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;密码&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的 <code>type</code> 属性一共三个选项：</p><ul><li>UNPOOLED   不使用连接池的数据源</li><li>POOLED    使用连接池的数据源</li><li>JNDI     使用 JNDI 实现的数据源</li></ul><h3 id="解读-Mybatis-数据源实现（选学）"><a href="#解读-Mybatis-数据源实现（选学）" class="headerlink" title="解读 Mybatis 数据源实现（选学）"></a>解读 Mybatis 数据源实现（选学）</h3><p>前面我们介绍了 DataSource 数据源，那么我们就来看看，Mybatis 到底是怎么实现的。我们先来看看，不使用池化的数据源实现，它叫做 <code>UnpooledDataSource</code>，我们来看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnpooledDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> ClassLoader driverClassLoader;<br>    <span class="hljs-keyword">private</span> Properties driverProperties;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span> ();<br>    <span class="hljs-keyword">private</span> String driver;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> Boolean autoCommit;<br>    <span class="hljs-keyword">private</span> Integer defaultTransactionIsolationLevel;<br>    <span class="hljs-keyword">private</span> Integer defaultNetworkTimeout;<br>  ...<br></code></pre></td></tr></table></figure><p>首先这个类中定义了很多的成员，包括数据库的连接信息、数据库驱动信息、事务相关信息等。我们接着来看，它是如何实现 <code>DataSource</code> 中提供的接口方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. doGetConnection (<span class="hljs-built_in">this</span>. username, <span class="hljs-built_in">this</span>. password);<br>&#125;<br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. doGetConnection (username, password);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，这两个方法都指向了内部的一个 <code>doGetConnection</code> 方法，那么我们接着来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Connection <span class="hljs-title function_">doGetConnection</span> <span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span> ();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. driverProperties != <span class="hljs-literal">null</span>) &#123;<br>        props. putAll (<span class="hljs-built_in">this</span>. driverProperties);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (username != <span class="hljs-literal">null</span>) &#123;<br>        props. setProperty (<span class="hljs-string">&quot;user&quot;</span>, username);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (password != <span class="hljs-literal">null</span>) &#123;<br>        props. setProperty (<span class="hljs-string">&quot;password&quot;</span>, password);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. doGetConnection (props);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将用户名和密码配置封装为一个 Properties 对象，然后执行另一个重载同名的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Connection <span class="hljs-title function_">doGetConnection</span> <span class="hljs-params">(Properties properties)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>  <span class="hljs-comment">//若未初始化驱动，需要先初始化，内部维护了一个 Map 来记录初始化信息，这里不多介绍了</span><br>    <span class="hljs-built_in">this</span>. initializeDriver ();<br>  <span class="hljs-comment">//传统的获取连接的方式，是不是终于找到熟悉的味道了</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager. getConnection (<span class="hljs-built_in">this</span>. url, properties);<br>  <span class="hljs-comment">//对连接进行额外的一些配置</span><br>    <span class="hljs-built_in">this</span>. configureConnection (connection);<br>    <span class="hljs-keyword">return</span> connection;   <span class="hljs-comment">//返回得到的 Connection 对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，就返回 <code>Connection</code> 对象了，而此对象正是通过 <code>DriverManager</code> 来创建的，因此，非池化的数据源实现依然使用的是传统的连接创建方式，那我们接着来看池化的数据源实现，它是 <code>PooledDataSource</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataSource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory. getLog (PooledDataSource. class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">PoolState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PoolState</span> (<span class="hljs-built_in">this</span>);<br>  <span class="hljs-comment">//内部维护了一个非池化的数据源，这是要干嘛？</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UnpooledDataSource dataSource;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">poolMaximumActiveConnections</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">poolMaximumIdleConnections</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">poolMaximumCheckoutTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">poolTimeToWait</span> <span class="hljs-operator">=</span> <span class="hljs-number">20000</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-variable">poolMaximumLocalBadConnectionTolerance</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">poolPingQuery</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NO PING QUERY SET&quot;</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> poolPingEnabled;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> poolPingConnectionsNotUsedFor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> expectedConnectionTypeCode;<br>  <span class="hljs-comment">//并发相关类，我们在 JUC 篇视频教程中介绍过，感兴趣可以前往观看</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span> ();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition condition;<br></code></pre></td></tr></table></figure><p>我们发现，在这里的定义就比非池化的实现复杂得多了，因为它还要考虑并发的问题，并且还要考虑如何合理地存放大量的链接对象，该如何进行合理分配，因此它的玩法非常之高级，但是，再高级的玩法，我们都要拿下。<br>首先注意，它存放了一个 UnpooledDataSource，此对象是在构造时就被创建，其实创建 Connection 还是依靠数据库驱动创建，我们后面慢慢解析，首先我们来看看它是如何实现接口方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. popConnection (<span class="hljs-built_in">this</span>. dataSource. getUsername (), <span class="hljs-built_in">this</span>. dataSource. getPassword ()). getProxyConnection ();<br>&#125;<br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. popConnection (username, password). getProxyConnection ();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，它调用了 <code>popConnection ()</code> 方法来获取连接对象，然后进行了一个代理，通过这方法名字我们可以猜测，有可能整个连接池就是一个类似于栈的集合类型结构实现的。那么我们接着来看看 <code>popConnection</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> PooledConnection <span class="hljs-title function_">popConnection</span> <span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">countedWait</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">//返回的是 PooledConnection 对象，</span><br>    <span class="hljs-type">PooledConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> System. currentTimeMillis ();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">localBadConnectionCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>. state) &#123;   <span class="hljs-comment">//加锁，因为有可能很多个线程都需要获取连接对象</span><br>            PoolState <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span>;<br>          <span class="hljs-comment">//PoolState 存了两个 List，一个是空闲列表，一个是活跃列表</span><br>            <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>. state. idleConnections. isEmpty ()) &#123;   <span class="hljs-comment">//有空闲的连接时，可以直接分配 Connection</span><br>                conn = (PooledConnection) <span class="hljs-built_in">this</span>. state. idleConnections. remove (<span class="hljs-number">0</span>);  <span class="hljs-comment">//ArrayList 中取第一个元素</span><br>                <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                    log. debug (<span class="hljs-string">&quot;Checked out connection &quot;</span> + conn. getRealHashCode () + <span class="hljs-string">&quot; from pool.&quot;</span>);<br>                &#125;<br>            <span class="hljs-comment">//如果已经没有多余的连接可以分配，那么就检查一下活跃连接数是否达到最大的分配上限，如果没有，就 new 一个新的</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. state. activeConnections. size () &lt; <span class="hljs-built_in">this</span>. poolMaximumActiveConnections) &#123;<br>              <span class="hljs-comment">//注意 new 了之后并没有立即往 List 里面塞，只是存了一些基本信息</span><br>              <span class="hljs-comment">//我们发现，这里依靠 UnpooledDataSource 创建了一个 Connection 对象，并将其封装到 PooledConnection 中</span><br>              <span class="hljs-comment">//所以说内部维护的 UnpooledDataSource 对象其实是为了节省代码，因为创建数据库连接其实都是一样的方式</span><br>                conn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledConnection</span> (<span class="hljs-built_in">this</span>. dataSource. getConnection (), <span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                    log. debug (<span class="hljs-string">&quot;Created connection &quot;</span> + conn. getRealHashCode () + <span class="hljs-string">&quot;.&quot;</span>);<br>                &#125;<br>              <span class="hljs-comment">//以上条件都不满足，那么只能从之前的连接中寻找了，看看有没有那种卡住的链接（比如，由于网络问题有可能之前的连接一直被卡住，然而正常情况下早就结束并且可以使用了，所以这里相当于是优化也算是一种捡漏的方式）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">//获取最早创建的连接</span><br>                <span class="hljs-type">PooledConnection</span> <span class="hljs-variable">oldestActiveConnection</span> <span class="hljs-operator">=</span> (PooledConnection) <span class="hljs-built_in">this</span>. state. activeConnections. get (<span class="hljs-number">0</span>);<br>                <span class="hljs-type">long</span> <span class="hljs-variable">longestCheckoutTime</span> <span class="hljs-operator">=</span> oldestActiveConnection. getCheckoutTime ();<br>              <span class="hljs-comment">//判断是否超过最大的使用时间</span><br>                <span class="hljs-keyword">if</span> (longestCheckoutTime &gt; (<span class="hljs-type">long</span>) <span class="hljs-built_in">this</span>. poolMaximumCheckoutTime) &#123;<br>                  <span class="hljs-comment">//超时统计信息（不重要）</span><br>                    ++<span class="hljs-built_in">this</span>. state. claimedOverdueConnectionCount;<br>                    <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span> = <span class="hljs-built_in">this</span>. state;<br>                    <span class="hljs-keyword">var</span> <span class="hljs-number">10000.</span> accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;<br>                    <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span> = <span class="hljs-built_in">this</span>. state;<br>                    <span class="hljs-keyword">var</span> <span class="hljs-number">10000.</span> accumulatedCheckoutTime += longestCheckoutTime;<br>                  <span class="hljs-comment">//从活跃列表中移除此链接信息</span><br>                    <span class="hljs-built_in">this</span>. state. activeConnections. remove (oldestActiveConnection);<br>                  <span class="hljs-comment">//如果开启事务，还需要回滚一下</span><br>                    <span class="hljs-keyword">if</span> (! oldestActiveConnection. getRealConnection (). getAutoCommit ()) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            oldestActiveConnection. getRealConnection (). rollback ();<br>                        &#125; <span class="hljs-keyword">catch</span> (SQLException <span class="hljs-keyword">var</span> <span class="hljs-number">15</span>) &#123;<br>                            log. debug (<span class="hljs-string">&quot;Bad connection. Could not roll back&quot;</span>);<br>                        &#125;<br>                    &#125;<br>                  <span class="hljs-comment">//这里就根据之前的连接对象直接 new 一个新的连接（注意使用的还是之前的 Connection 对象，并没有创建新的对象，只是被重新封装了）</span><br>                    conn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledConnection</span> (oldestActiveConnection. getRealConnection (), <span class="hljs-built_in">this</span>);<br>                    conn. setCreatedTimestamp (oldestActiveConnection. getCreatedTimestamp ());<br>                    conn. setLastUsedTimestamp (oldestActiveConnection. getLastUsedTimestamp ());<br>                  <span class="hljs-comment">//过期</span><br>                    oldestActiveConnection. invalidate ();<br>                    <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                        log. debug (<span class="hljs-string">&quot;Claimed overdue connection &quot;</span> + conn. getRealHashCode () + <span class="hljs-string">&quot;.&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">//没有超时，那就确实是没连接可以用了，只能卡住了（阻塞）</span><br>                  <span class="hljs-comment">//然后顺手记录一下目前有几个线程在等待其他的任务搞完</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (! countedWait) &#123;<br>                            ++<span class="hljs-built_in">this</span>. state. hadToWaitCount;<br>                            countedWait = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                            log. debug (<span class="hljs-string">&quot;Waiting as long as &quot;</span> + <span class="hljs-built_in">this</span>. poolTimeToWait + <span class="hljs-string">&quot; milliseconds for connection.&quot;</span>);<br>                        &#125;<br>                      <span class="hljs-comment">//最后再等等</span><br>                        <span class="hljs-type">long</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> System. currentTimeMillis ();<br>                        <span class="hljs-built_in">this</span>. state. wait ((<span class="hljs-type">long</span>) <span class="hljs-built_in">this</span>. poolTimeToWait);<br>                      <span class="hljs-comment">//要是超过等待时间还是没等到，只能放弃了</span><br>                      <span class="hljs-comment">//注意这样的话 con 就为 null 了</span><br>                        <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span> = <span class="hljs-built_in">this</span>. state;<br>                        <span class="hljs-keyword">var</span> <span class="hljs-number">10000.</span> accumulatedWaitTime += System. currentTimeMillis () - wt;<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException <span class="hljs-keyword">var</span> <span class="hljs-number">16</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>          <span class="hljs-comment">//经过之前的操作，并且已经成功分配到连接对象的情况下</span><br>            <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (conn. isValid ()) &#123;  <span class="hljs-comment">//首先验证是否有效</span><br>                    <span class="hljs-keyword">if</span> (! conn. getRealConnection (). getAutoCommit ()) &#123;  <span class="hljs-comment">//清理之前可能存在的遗留事务操作</span><br>                        conn. getRealConnection (). rollback ();<br>                    &#125;<br>                    conn. setConnectionTypeCode (<span class="hljs-built_in">this</span>. assembleConnectionTypeCode (<span class="hljs-built_in">this</span>. dataSource. getUrl (), username, password));<br>                    conn. setCheckoutTimestamp (System. currentTimeMillis ());<br>                    conn. setLastUsedTimestamp (System. currentTimeMillis ());<br>                  <span class="hljs-comment">//添加到活跃表中</span><br>                    <span class="hljs-built_in">this</span>. state. activeConnections. add (conn);<br>                    <span class="hljs-comment">//统计信息（不重要）</span><br>                    ++<span class="hljs-built_in">this</span>. state. requestCount;<br>                    <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span> = <span class="hljs-built_in">this</span>. state;<br>                    <span class="hljs-keyword">var</span> <span class="hljs-number">10000.</span> accumulatedRequestTime += System. currentTimeMillis () - t;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-comment">//无效的连接，直接抛异常</span><br>                    <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                        log. debug (<span class="hljs-string">&quot;A bad connection (&quot;</span> + conn. getRealHashCode () + <span class="hljs-string">&quot;) was returned from the pool, getting another connection.&quot;</span>);<br>                    &#125;<br>                    ++<span class="hljs-built_in">this</span>. state. badConnectionCount;<br>                    ++localBadConnectionCount;<br>                    conn = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (localBadConnectionCount &gt; <span class="hljs-built_in">this</span>. poolMaximumIdleConnections + <span class="hljs-built_in">this</span>. poolMaximumLocalBadConnectionTolerance) &#123;<br>                        <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                            log. debug (<span class="hljs-string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);<br>                        &#125;<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span> (<span class="hljs-string">&quot;PooledDataSource: Could not get a good connection to the database.&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//最后该干嘛干嘛，要是之前拿到的 con 是 null 的话，直接抛异常</span><br>    <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>            log. debug (<span class="hljs-string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span> (<span class="hljs-string">&quot;PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection.&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> conn;   <span class="hljs-comment">//否则正常返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过上面一顿猛如虎的操作之后，我们可以得到以下信息：</p><blockquote><p>如果最后得到了连接对象（有可能是从空闲列表中得到，有可能是直接创建的新的，还有可能是经过回收策略回收得到的），那么连接 (Connection)对象一定会被放在活跃列表中 (state. activeConnections)<br>那么肯定有一个疑问，现在我们已经知道获取一个链接会直接进入到活跃列表中，那么，如果一个连接被关闭，又会发生什么事情呢，我们来看看此方法返回之后，会调用 <code>getProxyConnection</code> 来获取一个代理对象，实际上就是 <code>PooledConnection</code> 类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CLOSE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;close&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;?&gt;[] IFACES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Connection. class&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hashCode;<br>  <span class="hljs-comment">//会记录是来自哪一个数据源创建的的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PooledDataSource dataSource;<br>  <span class="hljs-comment">//连接对象本体</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Connection realConnection;<br>  <span class="hljs-comment">//代理的链接对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Connection proxyConnection;<br>  ...<br></code></pre></td></tr></table></figure><p>它直接代理了构造方法中传入的 Connection 对象，也是使用 JDK 的动态代理实现的，那么我们来看一下，它是如何进行代理的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span> <span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method. getName ();<br>  <span class="hljs-comment">//如果调用的是 Connection 对象的 close 方法，</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;close&quot;</span>. equals (methodName)) &#123;<br>      <span class="hljs-comment">//这里并不会真的关闭连接（这也是为什么用代理），而是调用之前数据源的 pushConnection 方法，将此连接改为为空闲状态</span><br>        <span class="hljs-built_in">this</span>. dataSource. pushConnection (<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (! Object. class. equals (method. getDeclaringClass ())) &#123;<br>                <span class="hljs-built_in">this</span>. checkConnection ();<br>              <span class="hljs-comment">//任何操作执行之前都会检查连接是否可用</span><br>            &#125;<br>          <span class="hljs-comment">//原方法该干嘛干嘛</span><br>            <span class="hljs-keyword">return</span> method. invoke (<span class="hljs-built_in">this</span>. realConnection, args);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable <span class="hljs-keyword">var</span> <span class="hljs-number">6</span>) &#123;<br>            <span class="hljs-keyword">throw</span> ExceptionUtil. unwrapThrowable (<span class="hljs-keyword">var</span> <span class="hljs-number">6</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这下，池化数据源的大致流程其实就已经很清晰了，那么我们最后再来看看 <code>pushConnection</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushConnection</span> <span class="hljs-params">(PooledConnection conn)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>. state) &#123;   <span class="hljs-comment">//老规矩，先来把锁</span><br>      <span class="hljs-comment">//先从活跃列表移除此连接</span><br>        <span class="hljs-built_in">this</span>. state. activeConnections. remove (conn);<br>      <span class="hljs-comment">//判断此链接是否可用</span><br>        <span class="hljs-keyword">if</span> (conn. isValid ()) &#123;<br>            PoolState <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span>;<br>          <span class="hljs-comment">//看看闲置列表容量是否已满（容量满了就回不去了）</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. state. idleConnections. size () &lt; <span class="hljs-built_in">this</span>. poolMaximumIdleConnections &amp;&amp; conn. getConnectionTypeCode () == <span class="hljs-built_in">this</span>. expectedConnectionTypeCode) &#123;<br>                <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span> = <span class="hljs-built_in">this</span>. state;<br>                <span class="hljs-keyword">var</span> <span class="hljs-number">10000.</span> accumulatedCheckoutTime += conn. getCheckoutTime ();<br>                <span class="hljs-keyword">if</span> (! conn. getRealConnection (). getAutoCommit ()) &#123;<br>                    conn. getRealConnection (). rollback ();<br>                &#125;<br>              <span class="hljs-comment">//把唯一有用的 Connection 对象拿出来，然后重新创建一个 PooledConnection 包装</span><br>                <span class="hljs-type">PooledConnection</span> <span class="hljs-variable">newConn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledConnection</span> (conn. getRealConnection (), <span class="hljs-built_in">this</span>);<br>              <span class="hljs-comment">//放入闲置列表，成功回收</span><br>                <span class="hljs-built_in">this</span>. state. idleConnections. add (newConn);<br>                newConn. setCreatedTimestamp (conn. getCreatedTimestamp ());<br>                newConn. setLastUsedTimestamp (conn. getLastUsedTimestamp ());<br>                conn. invalidate ();<br>                <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                    log. debug (<span class="hljs-string">&quot;Returned connection &quot;</span> + newConn. getRealHashCode () + <span class="hljs-string">&quot; to pool.&quot;</span>);<br>                &#125;<br>                <span class="hljs-built_in">this</span>. state. notifyAll ();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">var</span> <span class="hljs-number">10000</span> = <span class="hljs-built_in">this</span>. state;<br>                <span class="hljs-keyword">var</span> <span class="hljs-number">10000.</span> accumulatedCheckoutTime += conn. getCheckoutTime ();<br>                <span class="hljs-keyword">if</span> (! conn. getRealConnection (). getAutoCommit ()) &#123;<br>                    conn. getRealConnection (). rollback ();<br>                &#125;<br>                conn. getRealConnection (). close ();<br>                <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                    log. debug (<span class="hljs-string">&quot;Closed connection &quot;</span> + conn. getRealHashCode () + <span class="hljs-string">&quot;.&quot;</span>);<br>                &#125;<br>                conn. invalidate ();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (log. isDebugEnabled ()) &#123;<br>                log. debug (<span class="hljs-string">&quot;A bad connection (&quot;</span> + conn. getRealHashCode () + <span class="hljs-string">&quot;) attempted to return to the pool, discarding connection.&quot;</span>);<br>            &#125;<br>            ++<span class="hljs-built_in">this</span>. state. badConnectionCount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就已经完全了解了 Mybatis 的池化数据源的执行流程了。只不过，无论 Connection 管理方式如何变换，无论数据源再高级，我们要知道，它都最终都会使用 <code>DriverManager</code> 来创建连接对象，而最终使用的也是 <code>DriverManager</code> 提供的 <code>Connection</code> 对象。</p><h3 id="整合-Mybatis-框架"><a href="#整合-Mybatis-框架" class="headerlink" title="整合 Mybatis 框架"></a>整合 Mybatis 框架</h3><p>通过了解数据源，我们已经清楚，Mybatis 实际上是在使用自己编写的数据源（数据源实现其实有很多，之后我们再聊其他的）默认使用的是池化数据源，它预先存储了很多的连接对象。<br>那么我们来看一下，如何将 Mybatis 与 Spring 更好的结合呢，比如我们现在希望将 SqlSessionFactory 交给 IoC 容器进行管理，而不是我们自己创建工具类来管理（我们之前一直都在使用工具类管理和创建会话）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这两个依赖不用我说了吧 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 注意，对于Spring 6.0来说，版本需要在3.5以上 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Mybatis针对于Spring专门编写的支持框架 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Spring的JDBC支持框架 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 mybatis-spring 依赖中，为我们提供了 SqlSessionTemplate 类，它其实就是官方封装的一个工具类，我们可以将其注册为 Bean，这样我们随时都可以向 IoC 容器索要对象，而不用自己再去编写一个工具类了，我们可以直接在配置类中创建。对于这种别人编写的类型，如果要注册为 Bean，那么只能在配置类中完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;org. example. entity&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>  <span class="hljs-comment">//注册 SqlSessionTemplate 的 Bean</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionTemplate <span class="hljs-title function_">sqlSessionTemplate</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span> (). build (Resources. getResourceAsReader (<span class="hljs-string">&quot;mybatis-config. xml&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionTemplate</span> (factory);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里随便编写一个测试的 Mapper 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sid;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestMapper</span> &#123;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from student where sid = 1&quot;</span>)<br>    Student <span class="hljs-title function_">getStudent</span> <span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br>&lt;! DOCTYPE configuration<br>        PUBLIC &quot;-//mybatis. org//DTD Config 3.0//EN&quot;<br>        &quot; http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.mapper.TestMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br>    <span class="hljs-type">SqlSessionTemplate</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> context. getBean (SqlSessionTemplate. class);<br>    <span class="hljs-type">TestMapper</span> <span class="hljs-variable">testMapper</span> <span class="hljs-operator">=</span> template. getMapper (TestMapper. class);<br>    System. out. println (testMapper. getStudent ());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/12/17/L83vrESxoXKO7fQ.png" alt="image-20221217142651610"><br>这样，我们就成功将 Mybatis 与 Spring 完成了初步整合，直接从容器中就能获取到 SqlSessionTemplate，结合自动注入，我们的代码量能够进一步的减少。<br>虽然这样已经很方便了，但是还不够方便，我们依然需要手动去获取 Mapper 对象，那么能否直接得到对应的 Mapper 对象呢，我们希望让 Spring 直接帮助我们管理所有的 Mapper，当需要时，可以直接从容器中获取，我们可以直接在配置类上方添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;org.example.entity&quot;</span>)<br><span class="hljs-meta">@MapperScan</span> (<span class="hljs-string">&quot;org.example.mapper&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br></code></pre></td></tr></table></figure><p>这样，Mybatis 就会自动扫描对应包下所有的接口，并直接被注册为对应的 Mapper 作为 Bean 管理，那么我们现在就可以直接通过容器获取了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br>    <span class="hljs-type">TestMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> context. getBean (TestMapper. class);<br>    System. out. println (mapper. getStudent ());<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们后续的 SpringBoot 学习阶段，会有更加方便的方式来注册 Mapper，我们只需要一个 <code>@Mapper</code> 注解即可完成，非常简单。<br>请一定注意，必须存在 <code>SqlSessionTemplate</code> 或是 <code>SqlSessionFactoryBean</code> 的 Bean，否则会无法初始化（毕竟要数据库的链接信息）我们接着来看，如果我们希望直接去除 Mybatis 的配置文件，完全实现全注解配置，那么改怎么去实现呢？我们可以使用 <code>SqlSessionFactoryBean</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;org.example.entity&quot;</span>)<br><span class="hljs-meta">@MapperScan</span> (<span class="hljs-string">&quot;org.example.mapper&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span>   <span class="hljs-comment">//单独创建一个 Bean，方便之后更换</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledDataSource</span> (<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>,<br>                <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/study&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactoryBean <span class="hljs-title function_">sqlSessionFactoryBean</span> <span class="hljs-params">(DataSource dataSource)</span>&#123;  <span class="hljs-comment">//直接参数得到 Bean 对象</span><br>        <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span> ();<br>        bean. setDataSource (dataSource);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们需要创建一个数据源的实现类，因为这是数据库最基本的信息，然后再给到 <code>SqlSessionFactoryBean</code> 实例，这样，我们相当于直接在一开始通过 IoC 容器配置了 <code>SqlSessionFactory</code>，这里只需要传入一个 <code>DataSource</code> 的实现即可，我们采用池化数据源。<br>删除配置文件，重新再来运行，同样可以正常使用 Mapper。从这里开始，通过 IoC 容器，Mybatis 已经不再需要使用配置文件了，在我们之后的学习中，基于 Spring 的开发将不会再出现 Mybatis 的配置文件。</p><blockquote><p>[!NOTE] <strong>spring 结合 mybatis 使用总结</strong></p><ul><li>spring 结合 mybatis 使用步骤：<ol><li>编写实体类（对应于数据库的表），写对应 Mapper 接口注解实现对应的 sql 指令，再编写 mybatis-config. xml 文件配置数据库连接环境并注册 mapper。</li><li>编写应用配置文件 Configuration 添加 mapper 和 entity 扫描注解，注册 SqlSessionTemplate 的 bean 或 SqlSessionFactoryBean。</li><li>服务层直接通过 context. getBean ()获取 mapper，调用 mapper 接口的方法。</li></ol></li></ul></blockquote><h3 id="使用-HikariCP-连接池"><a href="#使用-HikariCP-连接池" class="headerlink" title="使用 HikariCP 连接池"></a>使用 HikariCP 连接池</h3><p>前面我们提到了数据源还有其他实现，比如 C 3 P 0、Druid 等，它们都是非常优秀的数据源实现（可以自行了解），不过我们这里要介绍的，是之后在 SpringBoot 中还会遇到的 HikariCP 连接池。</p><blockquote><p>HikariCP 是由日本程序员开源的一个数据库连接池组件，代码非常轻量，并且速度非常的快。根据官方提供的数据，在酷睿 i 7 开启 32 个线程 32 个连接的情况下，进行随机数据库读写操作，HikariCP 的速度是现在常用的 C 3 P 0 数据库连接池的数百倍。在 SpringBoot 3.0 中，官方也是推荐使用 HikariCP。<br><img src="https://s2.loli.net/2022/12/17/Q6gPI9RVe1X7Noq.png" alt="image-20221217145126777"><br>首先，我们需要导入依赖：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. zaxxer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HikariCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要更换数据源实现，非常简单，我们可以直接声明一个 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span> <span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">HikariDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariDataSource</span> ();<br>    dataSource. setJdbcUrl (<span class="hljs-string">&quot;jdbc:mysql://localhost: 3306/study&quot;</span>);<br>    dataSource. setDriverClassName (<span class="hljs-string">&quot;com. mysql. cj. jdbc. Driver&quot;</span>);<br>    dataSource. setUsername (<span class="hljs-string">&quot;root&quot;</span>);<br>    dataSource. setPassword (<span class="hljs-string">&quot;123456&quot;</span>);<br>    <span class="hljs-keyword">return</span> dataSource;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们发现，同样可以得到输出结果，但是出现了一个报错：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">SLF 4 J:</span> <span class="hljs-literal">No</span> <span class="hljs-string">SLF</span> <span class="hljs-number">4</span> <span class="hljs-string">J</span> <span class="hljs-string">providers</span> <span class="hljs-string">were</span> <span class="hljs-string">found.</span><br><span class="hljs-attr">SLF 4 J:</span> <span class="hljs-string">Defaulting</span> <span class="hljs-string">to</span> <span class="hljs-literal">no</span><span class="hljs-string">-operation</span> <span class="hljs-string">(NOP)</span> <span class="hljs-string">logger</span> <span class="hljs-string">implementation</span><br><span class="hljs-attr">SLF 4 J:</span> <span class="hljs-string">See</span> <span class="hljs-string">http://www.slf4j.org/codes.html#noProviders</span> <span class="hljs-string">for</span> <span class="hljs-string">further</span> <span class="hljs-string">details.</span><br></code></pre></td></tr></table></figure><p>此数据源实际上是采用了 SLF 4 J 日志框架打印日志信息，但是现在没有任何的日志实现（slf 4 j 只是一个 API 标准，它规范了多种日志框架的操作，统一使用 SLF 4 J 定义的方法来操作不同的日志框架，我们会在 SpringBoot 篇进行详细介绍）我们这里就使用 JUL 作为日志实现，我们需要导入另一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-jdk14<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意版本一定要和 <code>slf4j-api</code> 保持一致，我们可以在这里直接查看：<br><img src="https://s2.loli.net/2022/12/17/93OSknRKXwdZsp7.png" alt="image-20221217154216832"><br>这样，HikariCP 数据源的启动日志就可以正常打印出来了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">12 月 17, 2022 3:41:38 下午 com. zaxxer. hikari. HikariDataSource getConnection<br>信息: HikariPool-1 - Starting<span class="hljs-built_in">..</span>.<br>12 月 17, 2022 3:41:38 下午 com. zaxxer. hikari. pool. HikariPool checkFailFast<br>信息: HikariPool-1 - Added<span class="hljs-built_in"> connection </span>com.mysql.cj.jdbc.ConnectionImpl@4f8969b0<br>12 月 17, 2022 3:41:38 下午 com. zaxxer. hikari. HikariDataSource getConnection<br>信息: HikariPool-1 - Start completed.<br>Student (<span class="hljs-attribute">sid</span>=1, <span class="hljs-attribute">name</span>=小明, <span class="hljs-attribute">sex</span>=男)<br></code></pre></td></tr></table></figure><p>在 SpringBoot 阶段，我们还会遇到 <code>HikariPool-1 - Starting...</code> 和 <code>HikariPool-1 - Start completed.</code> 同款日志信息。<br>当然，Lombok 肯定也是支持这个日志框架快速注解的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (MainConfiguration. class);<br>        <span class="hljs-type">TestMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> context. getBean (TestMapper. class);<br>        log. info (mapper. getStudent (). toString ());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] HikariDataSource 用法总结</p><ul><li>使用 HikariPool 数据库连接池步骤：<ol><li>引入 xml 依赖</li><li>应用配置中注册 DataSource 的 bean 并在内部使用 HikariDataSource</li></ol></li></ul></blockquote><h3 id="Mybatis-事务管理"><a href="#Mybatis-事务管理" class="headerlink" title="Mybatis 事务管理"></a>Mybatis 事务管理</h3><p>我们前面已经讲解了如何让 Mybatis 与 Spring 更好地融合在一起，通过将对应的 Bean 类型注册到容器中，就能更加方便的去使用 Mapper，那么现在，我们接着来看 Spring 的事务控制。<br>在开始之前，我们还是回顾一下事务机制。首先事务遵循一个 ACID 原则：</p><ul><li>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li><li>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。类比银行转账，从一个账号扣款，另一个账号增款，必须保证总金额不变。</li><li>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。类比多个人同时编辑同一文档，每个人看到的结果都是独立的，不会受其他人的影响，不过难免会存在冲突。</li><li>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。类比写入硬盘的文件，即使关机重启，文件仍然存在。<br>简单来说，事务就是要么完成，要么就啥都别做！并且不同的事务之间相互隔离，互不干扰。<br>那么我们接着来深入了解一下事务的<strong>隔离机制</strong>（在之前数据库入门阶段并没有提到）我们说了，事务之间是相互隔离互不干扰的，那么如果出现了下面的情况，会怎么样呢：<blockquote><p>当两个事务同时在执行，并且同时在操作同一个数据，这样很容易出现并发相关的问题，比如一个事务先读取了某条数据，而另一个事务此时修改了此数据，当前一个事务紧接着再次读取时，会导致和前一次读取的数据不一致，这就是一种典型的数据虚读现象。<br>因此，为了解决这些问题，事务之间实际上是存在一些隔离级别的：</p></blockquote></li><li><em>ISOLATION_READ_UNCOMMITTED</em>（读未提交）：其他事务会读取当前事务尚未更改的提交（相当于读取的是这个事务暂时缓存的内容，并不是数据库中的内容）</li><li><em>ISOLATION_READ_COMMITTED</em>（读已提交）：其他事务会读取当前事务已经提交的数据（也就是直接读取数据库中已经发生更改的内容）</li><li><em>ISOLATION_REPEATABLE_READ</em>（可重复读）：其他事务会读取当前事务已经提交的数据并且其他事务执行过程中不允许再进行数据修改（注意这里仅仅是不允许修改数据）</li><li><em>ISOLATION_SERIALIZABLE</em>（串行化）：它完全服从 ACID 原则，一个事务必须等待其他事务结束之后才能开始执行，相当于挨个执行，效率很低<br>我们依次来看看，不同的隔离级别会导致什么问题。首先是 <code>读未提交</code> 级别，此级别属于最低级别，相当于各个事务共享一个缓存区域，任何事务的操作都在这里进行。那么它会导致以下问题：<br><img src="https://s2.loli.net/2022/12/17/hQpluLA2bFKo1O8.png" alt="image-20221217155511058"><br>也就是说，事务 A 最后得到的实际上是一个毫无意义的数据（事务 B 已经回滚了）我们称此数据为”脏数据”，这种现象称为<strong>脏读</strong><br>我们接着来看 <code>读已提交</code> 级别，事务只能读取其他事务已经提交的内容，相当于直接从数据中读取数据，这样就可以避免<strong>脏读</strong>问题了，但是它还是存在以下问题：<br><img src="https://s2.loli.net/2022/12/17/K1sJbDNyudOgAcV.png" alt="image-20221217155538073"><br>这正是我们前面例子中提到的问题，虽然它避免了脏读问题，但是如果事件 B 修改并提交了数据，那么实际上事务 A 之前读取到的数据依然不是最新的数据，直接导致两次读取的数据不一致，这种现象称为<strong>虚读</strong>也可以称为<strong>不可重复读</strong><br>因此，下一个隔离级别 <code>可重复读</code> 就能够解决这样的问题（MySQL 的默认隔离级别），它规定在其他事务执行时，不允许修改数据，这样，就可以有效地避免不可重复读的问题，但是这样就一定安全了吗？这里仅仅是禁止了事务执行过程中的 UPDATE 操作，但是它并没有禁止 INSERT 这类操作，因此，如果事务 A 执行过程中事务 B 插入了新的数据，那么 A 这时是毫不知情的，比如：<br><img src="https://s2.loli.net/2022/12/17/uwiHT8AcobeBjL3.png" alt="image-20221217160023674"><br>两个人同时报名一个活动，两个报名的事务同时在进行，但是他们一开始读取到的人数都是 5，而这时，它们都会认为报名成功后人数应该变成 6，而正常情况下应该是 7，因此这个时候就发生了数据的<strong>幻读</strong>现象。<br>因此，要解决这种问题，只能使用最后一种隔离级别 <code>串行化</code> 来实现了，每个事务不能同时进行，直接避免所有并发问题，简单粗暴，但是效率爆减，并不推荐。<br>最后总结三种情况：<blockquote><ul><li>脏读：读取到了被回滚的数据，它毫无意义。</li><li>虚读（不可重复读）：由于其他事务更新数据，两次读取的数据不一致。</li><li>幻读：由于其他事务执行插入删除操作，而又无法感知到表中记录条数发生变化，当下次再读取时会莫名其妙多出或缺失数据，就像产生幻觉一样。<br>（对于虚读和幻读的区分：虚读是某个数据前后读取不一致，幻读是整个表的记录数量前后读取不一致<br><img src="https://s2.loli.net/2022/12/17/nHfV8R1ZUybTSd2.png" alt="image-20221217160052616|500"><br>Mybatis 对于数据库的事务管理，也有着相应的封装。一个事务无非就是创建、提交、回滚、关闭，因此这些操作被 Mybatis 抽象为一个接口：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Transaction</span> &#123;<br>    Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br>    Integer <span class="hljs-title function_">getTimeout</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException;<br>&#125;<br></code></pre></td></tr></table></figure>对于此接口的实现，MyBatis 的事务管理分为两种形式：</li></ul><ol><li>使用<strong>JDBC</strong>的事务管理机制：即利用对应数据库的驱动生成的 <code>Connection</code> 对象完成对事务的提交（commit ()）、回滚（rollback ()）、关闭（close ()）等，对应的实现类为 <code>JdbcTransaction</code></li><li>使用<strong>MANAGED</strong>的事务管理机制：这种机制 MyBatis 自身不会去实现事务管理，而是让程序的容器（比如 Spring）来实现对事务的管理，对应的实现类为 <code>ManagedTransaction</code></li><li>如果需要自定义，那么得实现 <code>org.apache.ibatis.transaction.Transaction</code> 接口，然后在 <code>type</code> 属性中指定其类名。使用自定义的事务管理器可以根据具体需求来实现一些特定的事务管理行为。<br>而我们之前一直使用的其实就是 JDBC 的事务，相当于直接使用 <code>Connection</code> 对象（之前 JavaWeb 阶段已经讲解过了）在进行事务操作，并没有额外的管理机制，对应的配置为：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>那么我们来看看 <code>JdbcTransaction</code> 是不是像我们上面所说的那样管理事务的，直接上源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Transaction</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LogFactory. getLog (JdbcTransaction. class);<br>    <span class="hljs-keyword">protected</span> Connection connection;<br>    <span class="hljs-keyword">protected</span> DataSource dataSource;<br>    <span class="hljs-keyword">protected</span> TransactionIsolationLevel level;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> autoCommit;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdbcTransaction</span> <span class="hljs-params">(DataSource ds, TransactionIsolationLevel desiredLevel, <span class="hljs-type">boolean</span> desiredAutoCommit)</span> &#123;<br>      <span class="hljs-comment">//数据源</span><br>        <span class="hljs-built_in">this</span>.dataSource = ds;<br>      <span class="hljs-comment">//事务隔离级别，上面已经提到过了</span><br>        <span class="hljs-built_in">this</span>.level = desiredLevel;<br>      <span class="hljs-comment">//是否自动提交</span><br>        <span class="hljs-built_in">this</span>.autoCommit = desiredAutoCommit;<br>    &#125;<br>  <span class="hljs-comment">//也可以直接给个 Connection 对象</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdbcTransaction</span> <span class="hljs-params">(Connection connection)</span> &#123;<br>        <span class="hljs-built_in">this</span>.connection = connection;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>      <span class="hljs-comment">//没有就通过数据源新开一个 Connection</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.connection == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.openConnection ();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.connection;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>      <span class="hljs-comment">//连接已经创建并且没开启自动提交才可以使用</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.connection != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">this</span>.connection.getAutoCommit ()) &#123;<br>            <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>                log.debug (<span class="hljs-string">&quot;Committing JDBC Connection [&quot;</span> + <span class="hljs-built_in">this</span>. connection + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br><span class="hljs-comment">//实际上使用的是数据库驱动提供的 Connection 对象进行事务操作</span><br>            <span class="hljs-built_in">this</span>.connection.commit();<br>        &#125;<br>    &#125;<br>  ...<br></code></pre></td></tr></table></figure>相当于 <code>JdbcTransaction</code> 只是为数据库驱动提供的 <code>Connection</code> 对象套了层壳，所有的事务操作实际上是直接调用 <code>Connection</code> 对象。那么我们接着来看 <code>ManagedTransaction</code> 的源码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagedTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Transaction</span> &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>我们发现，大体内容和 <code>JdbcTransaction</code> 差不多，但是它并没有实现任何的事务操作。也就是说，它希望将实现交给其他的管理框架来完成，而 Spring 就为 Mybatis 提供了一个非常好的事务管理实现。</li></ol><h3 id="使用-Spring-事务管理"><a href="#使用-Spring-事务管理" class="headerlink" title="使用 Spring 事务管理"></a>使用 Spring 事务管理</h3><p>现在我们来学习一下 Spring 提供的事务管理（Spring 事务管理分为编程式事务和声明式事务，但是编程式事务过于复杂并且具有高度耦合性，违背了 Spring 框架的设计初衷，因此这里只讲解声明式事务）声明式事务是基于 AOP 实现的。<br>使用声明式事务非常简单，我们只需要在配置类添加 <code>@EnableTransactionManagement</code> 注解即可，这样就可以开启 Spring 的事务支持了。接着，我们只需要把一个事务要做的所有事情封装到 Service 层的一个方法中即可，首先需要在配置文件中注册一个新的 Bean，事务需要执行必须有一个事务管理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span> (<span class="hljs-string">&quot;org.example&quot;</span>)<br><span class="hljs-meta">@MapperScan</span> (<span class="hljs-string">&quot;org.example.mapper&quot;</span>)<br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransactionManager <span class="hljs-title function_">transactionManager</span> <span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span> (dataSource);<br>    &#125;<br>  ...<br></code></pre></td></tr></table></figure><p>接着我们来编写一个简单的 Mapper 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestMapper</span> &#123;<br>    ...<br>    <span class="hljs-meta">@Insert</span> (<span class="hljs-string">&quot;insert into student (name, sex) values (&#x27;测试&#x27;, &#x27;男&#x27;)&quot;</span>)<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertStudent</span> <span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样会向数据库中插入一条新的学生信息，接着，假设我们这里有一个业务需要连续插入两条学生信息，首先编写业务层的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们再来编写业务层的实现，我们可以直接将其注册为 Bean，交给 Spring 来进行管理，这样就可以自动将 Mapper 注入到类中了，并且可以支持事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TestService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    TestMapper mapper;<br>    <span class="hljs-meta">@Transactional</span>   <span class="hljs-comment">//此注解表示事务，之后执行的所有方法都会在同一个事务中执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span> &#123;<br>        mapper. insertStudent ();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;我是测试异常！&quot;</span>);<br>        mapper. insertStudent ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需在方法上添加 <code>@Transactional</code> 注解，即可表示此方法执行的是一个事务操作，在调用此方法时，Spring 会通过 AOP 机制为其进行增强，一旦发现异常，事务会自动回滚。最后我们来调用一下此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        log. info (<span class="hljs-string">&quot;项目正在启动...&quot;</span>);<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (TestConfiguration. class);<br>        <span class="hljs-type">TestService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context.getBean (TestService.class);<br>        service.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果是出现错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">12</span> 月 <span class="hljs-number">17</span>, <span class="hljs-number">2022</span> <span class="hljs-number">4</span>:09:<span class="hljs-number">00</span> 下午 com. zaxxer. hikari. HikariDataSource getConnection<br>信息: HikariPool-<span class="hljs-number">1</span> - Start completed.<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java. lang. RuntimeException: 我是测试异常！<br>at org. example. service. TestServiceImpl. test (TestServiceImpl. java:<span class="hljs-number">17</span>)<br>at java. base/jdk. internal. reflect. NativeMethodAccessorImpl. invoke <span class="hljs-number">0</span> (Native Method)<br>at java. base/jdk. internal. reflect. NativeMethodAccessorImpl. invoke (NativeMethodAccessorImpl. java:<span class="hljs-number">77</span>)<br>at java. base/jdk. internal. reflect. DelegatingMethodAccessorImpl. invoke (DelegatingMethodAccessorImpl. java:<span class="hljs-number">43</span>)<br>at java. base/java. lang. reflect. Method. invoke (Method. java:<span class="hljs-number">568</span>)<br>at org. springframework. aop. support. AopUtils. invokeJoinpointUsingReflection (AopUtils. java:<span class="hljs-number">343</span>)<br>at org. springframework. aop. framework. ReflectiveMethodInvocation. invokeJoinpoint (ReflectiveMethodInvocation. java:<span class="hljs-number">196</span>)<br></code></pre></td></tr></table></figure><p>我们发现，整个栈追踪信息中包含了大量 aop 包下的内容，也就印证了它确实是通过 AOP 实现的，那么我们接着来看一下，数据库中的数据是否没有发生变化（出现异常回滚了）<br><img src="https://s2.loli.net/2022/12/17/TQDbpK2JVP3d9wz.png" alt="image-20221217161027254"><br>结果显而易见，第一次的插入操作确实被回滚了，数据库中没有任何新增的内容。<br>我们接着来研究一下 <code>@Transactional</code> 注解的一些参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target</span> (&#123;ElementType. TYPE, ElementType. METHOD&#125;)<br><span class="hljs-meta">@Retention</span> (RetentionPolicy. RUNTIME)<br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Transactional &#123;<br>    <span class="hljs-meta">@AliasFor</span> (<span class="hljs-string">&quot;transactionManager&quot;</span>)<br>    String <span class="hljs-title function_">value</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-meta">@AliasFor</span> (<span class="hljs-string">&quot;value&quot;</span>)<br>    String <span class="hljs-title function_">transactionManager</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    String[] label () <span class="hljs-keyword">default</span> &#123;&#125;;<br>    Propagation <span class="hljs-title function_">propagation</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Propagation. REQUIRED;<br>    Isolation <span class="hljs-title function_">isolation</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Isolation. DEFAULT;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">timeout</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br>    String <span class="hljs-title function_">timeoutString</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">readOnly</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] rollbackFor () <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] rollbackForClassName () <span class="hljs-keyword">default</span> &#123;&#125;;<br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] noRollbackFor () <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] noRollbackForClassName () <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来讲解几个比较关键的属性：<br>    - <em>transactionManager</em>：指定事务管理器<br>    - <em>propagation</em>：事务传播规则，一个事务可以包括 N 个子事务<br>    - <em>isolation</em>：事务隔离级别，不多说了<br>    - <em>timeout</em>：事务超时时间<br>    - <em>readOnly</em>：是否为只读事务，不同的数据库会根据只读属性进行优化，比如 MySQL 一旦声明事务为只读，那么就不允许增删改操作了。<br>    - <em>rollbackFor</em> 和 <em>noRollbackFor</em>：发生指定异常时回滚或是不回滚，默认发生任何异常都回滚。<br>除了事务的传播规则，其他的内容其实已经给大家讲解过了，那么我们就来看看事务的传播。事务传播一共有七种级别：<br><img src="https://s2.loli.net/2022/12/17/C1RA4mBEoxNDFGl.png" alt="image-20221217161156859"><br>Spring 默认的传播级别是 <code>PROPAGATION_REQUIRED</code>，那么我们来看看，它是如何传播的，现在我们的 <code>Service</code> 类中一共存在两个事务，而一个事务方法包含了另一个事务方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TestService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    TestMapper mapper;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span> &#123;<br>        test <span class="hljs-number">2</span> ();   <span class="hljs-comment">//包含另一个事务</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;我是测试异常！&quot;</span>);  <span class="hljs-comment">//发生异常时，会回滚另一个事务吗？</span><br>    &#125;<br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test <span class="hljs-number">2</span> () &#123;<br>        mapper. insertStudent ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们得到结果，另一个事务也被回滚了，也就是说，相当于另一个事务直接加入到此事务中，也就是表中所描述的那样。如果单独执行 <code>test 2 ()</code> 则会开启一个新的事务，而执行 <code>test ()</code> 则会直接让内部的 <code>test 2 ()</code> 加入到当前事务中。<br>现在我们将 <code>test 2 ()</code> 的传播级别设定为 <code>SUPPORTS</code>，那么这时如果单独调用 <code>test 2 ()</code> 方法，并不会以事务的方式执行，当发生异常时，虽然依然存在 AOP 增强，但是不会进行回滚操作，而现在再调用 <code>test ()</code> 方法，才会以事务的方式执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span> &#123;<br>    test <span class="hljs-number">2</span> ();<br>&#125;<br><span class="hljs-meta">@Transactional</span> (propagation = Propagation. SUPPORTS)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test <span class="hljs-number">2</span> () &#123;<br>    mapper. insertStudent ();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;我是测试异常！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看 <code>MANDATORY</code>，它非常严格，如果当前方法并没有在任何事务中进行，会直接出现异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span> &#123;<br>    test <span class="hljs-number">2</span> ();<br>&#125;<br><span class="hljs-meta">@Transactional</span> (propagation = Propagation. MANDATORY)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test <span class="hljs-number">2</span> () &#123;<br>    mapper. insertStudent ();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;我是测试异常！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>直接运行 <code>test 2 ()</code> 方法，报错如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> org. springframework. transaction. IllegalTransactionStateException: No existing transaction found <span class="hljs-keyword">for</span> transaction marked with propagation <span class="hljs-string">&#x27;mandatory&#x27;</span><br>at org. springframework. transaction. support. AbstractPlatformTransactionManager. getTransaction (AbstractPlatformTransactionManager. java:<span class="hljs-number">362</span>)<br>at org. springframework. transaction. interceptor. TransactionAspectSupport. createTransactionIfNecessary (TransactionAspectSupport. java:<span class="hljs-number">595</span>)<br>at org. springframework. transaction. interceptor. TransactionAspectSupport. invokeWithinTransaction (TransactionAspectSupport. java:<span class="hljs-number">382</span>)<br>at org. springframework. transaction. interceptor. TransactionInterceptor. invoke (TransactionInterceptor. java:<span class="hljs-number">119</span>)<br>at org. springframework. aop. framework. ReflectiveMethodInvocation. proceed (ReflectiveMethodInvocation. java:<span class="hljs-number">186</span>)<br>at org. springframework. aop. framework. JdkDynamicAopProxy. invoke (JdkDynamicAopProxy. java:<span class="hljs-number">215</span>)<br>at com. sun. proxy.$Proxy <span class="hljs-number">29.</span> test <span class="hljs-number">2</span> (Unknown Source)<br>at com. test. Main. main (Main. java:<span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p><code>NESTED</code> 级别表示如果存在外层事务，则此方法单独创建一个子事务，回滚只会影响到此子事务，实际上就是利用创建 Savepoint，然后回滚到此保存点实现的。<code>NEVER</code> 级别表示此方法不应该加入到任何事务中，其余类型适用于同时操作多数据源情况下的分布式事务管理，这里暂时不做介绍。</p><blockquote><p>[!NOTE] Spring 事务管理总结</p><ul><li>配置类添加 <code>@EnableTransactionManagement</code> 注解开启 Spring 事务管理。</li><li>当需要执行一组数据库操作时需要在 service 方法上添加 <code>@Transactional</code> 注解表示为该方法开启事务。</li><li><code>@Transactional</code> 注解包括多个属性（<em>propagation</em>，<em>isolation</em>，<em>timeout</em>，<em>readOnly</em>，<em>rollbackFor</em>等），设置事务的传播级别，隔离级别，超时时间，是否只读和回滚场景等。</li></ul></blockquote><h3 id="集成-JUnit-测试"><a href="#集成-JUnit-测试" class="headerlink" title="集成 JUnit 测试"></a>集成 JUnit 测试</h3><p>既然使用了 Spring，那么怎么集成到 JUnit 中进行测试呢，首先大家能够想到的肯定是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (TestConfiguration. class);<br>        <span class="hljs-type">TestService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> context. getBean (TestService. class);<br>        service. test ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接编写一个测试用例即可，但是这样的话，如果我们有很多个测试用例，那么我们不可能每次测试都去创建 ApplicationContext 吧？我们可以使用 <code>@Before</code> 添加一个测试前动作来提前配置 ApplicationContext，但是这样的话，还是不够简便，能不能有更快速高效的方法呢？<br>Spring 为我们提供了一个 Test 模块，它会自动集成 Junit 进行测试，我们可以导入一下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. junit. jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里导入的是 JUnit 5 和 SpringTest 模块依赖，然后直接在我们的测试类上添加两个注解就可以搞定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExtendWith</span> (SpringExtension.class)<br><span class="hljs-meta">@ContextConfiguration</span> (classes = TestConfiguration.class)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    TestService service;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        service. test ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@ExtendWith</code> 是由 JUnit 提供的注解，等同于旧版本的 <code>@RunWith</code> 注解，然后使用 SpringTest 模块提供的 <code>@ContextConfiguration</code> 注解来表示要加载哪一个配置文件，可以是 XML 文件也可以是类，我们这里就直接使用类进行加载。<br>配置完成后，我们可以直接使用 <code>@Autowired</code> 来进行依赖注入，并且直接在测试方法中使用注入的 Bean，现在就非常方便了。<br>至此，SSM 中的其中一个 S（Spring）和一个 M（Mybatis）就已经学完了，我们还剩下一个 SpringMvc 需要去学习，下一章，我们将重新回到 Web 开发，了解在 Spring 框架的加持下，我们如何更高效地开发 Web 应用程序。</p><hr><h2 id="实现原理探究（选学）"><a href="#实现原理探究（选学）" class="headerlink" title="实现原理探究（选学）"></a>实现原理探究（选学）</h2><p>注意：本版块难度很大，所有内容都作为选学内容。</p><h3 id="Bean-工厂与-Bean-定义"><a href="#Bean-工厂与-Bean-定义" class="headerlink" title="Bean 工厂与 Bean 定义"></a>Bean 工厂与 Bean 定义</h3><p>实际上我们之前的所有操作都离不开一个东西，那就是 IoC 容器，那么它到底是如何实现呢？这一部分我们将详细介绍，首先我们大致了解一下 ApplicationContext 的加载流程：<br><img src="https://s2.loli.net/2022/12/17/Un6qjPci2uvkL5X.png" alt="image-20221217162656678"><br>我们可以看到，整个过程极为复杂，一句话肯定是无法解释的。由于 Spring 的源码非常庞大，因此我们不可能再像了解其他框架那样直接自底向上逐行干源码了（各位可以自己点开看看，代码量非常多）<br><img src="https://s2.loli.net/2022/12/17/QXqvO1sGh6d4ZSz.png" alt="image-20221217162821241"><br>我们只能对几个关键部分进行介绍，在了解这些内容之后，实际上不需要完全阅读所有部分的源码都可以有一个大致的认识。<br>首先，容器既然要管理 Bean，那么肯定需要一个完善的管理机制，实际上，对 Bean 的管理都是依靠 BeanFactory 在进行，顾名思义 BeanFactory 就是对 Bean 进行生产和管理的工厂，我们可以尝试自己创建和使用 BeanFactory 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> ();  <span class="hljs-comment">//这是 BeanFactory 的一个默认实现类</span><br>    System. out. println (<span class="hljs-string">&quot;获取 Bean 对象：&quot;</span>+factory. getBean (<span class="hljs-string">&quot;lbwnb&quot;</span>));  <span class="hljs-comment">//我们可以直接找工厂获取 Bean 对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以直接找 Bean 工厂索要对象，只不过在一开始，工厂并不知道自己需要生产什么，可以生产什么，因此我们直接索要一个工厂不知道的 Bean 对象，会直接得到：<br><img src="https://s2.loli.net/2023/02/14/n54N3iFQX7awHAl.png" alt="image-20230214193208233"><br>我们只有告诉工厂我们要生产什么，怎么生产，工厂才能开工：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> ();  <span class="hljs-comment">//这是 BeanFactory 的一个默认实现类</span><br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder   <span class="hljs-comment">//使用 BeanDefinitionBuilder 快速创建 Bean 定义</span><br>            .rootBeanDefinition (Student. class)   <span class="hljs-comment">//Bean 的类型</span><br>            .setScope (<span class="hljs-string">&quot;prototype&quot;</span>)    <span class="hljs-comment">//设置作用域为原型模式</span><br>            .getBeanDefinition ();     <span class="hljs-comment">//生成此 Bean 定义</span><br>    factory. registerBeanDefinition (<span class="hljs-string">&quot;lbwnb&quot;</span>, definition);   <span class="hljs-comment">//向工厂注册 Bean 此定义，并设定 Bean 的名称</span><br>    System. out. println (factory. getBean (<span class="hljs-string">&quot;lbwnb&quot;</span>));  <span class="hljs-comment">//现在就可以拿到了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，我们的 ApplicationContext 中就维护了一个 AutowireCapableBeanFactory 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRefreshableApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractApplicationContext</span> &#123;<br> <span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> DefaultListableBeanFactory beanFactory;   <span class="hljs-comment">//默认构造后存放在这里的是一个 DefaultListableBeanFactory 对象</span><br>  ...<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ConfigurableListableBeanFactory <span class="hljs-title function_">getBeanFactory</span> <span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//getBeanFactory 就可以直接得到上面的对象了</span><br>     <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. beanFactory;<br>     <span class="hljs-keyword">if</span> (beanFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span> (<span class="hljs-string">&quot;BeanFactory not initialized or already closed - &quot;</span> +<br>              <span class="hljs-string">&quot;call &#x27;refresh&#x27; before accessing beans via the ApplicationContext&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">return</span> beanFactory;<br>  &#125;<br></code></pre></td></tr></table></figure><p>我们可以尝试获取一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> (<span class="hljs-string">&quot;application. xml&quot;</span>);<br><span class="hljs-comment">//我们可以直接获取此对象</span><br>System. out. println (context. getAutowireCapableBeanFactory ());<br></code></pre></td></tr></table></figure><p>正是因为这样，ApplicationContext 才具有了管理和生产 Bean 对象的能力。<br>不过，我们的配置可能是 XML、可能是配置类，那么 Spring 要如何进行解析，将这些变成对应的 BeanDefinition 对象呢？使用 BeanDefinitionReader 就可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> ();<br>    <span class="hljs-comment">//比如我们要读取 XML 配置，我们直接使用 XmlBeanDefinitionReader 就可以快速进行扫描</span><br>    <span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span> (factory);<br>    <span class="hljs-comment">//加载此 XML 文件中所有的 Bean 定义到 Bean 工厂中</span><br>    reader. loadBeanDefinitions (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span> (<span class="hljs-string">&quot;application. xml&quot;</span>));<br>    <span class="hljs-comment">//可以看到能正常生产此 Bean 的实例对象</span><br>    System. out. println (factory. getBean (Student. class));<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，针对于不同类型的配置方式，ApplicationContext 有着多种实现，其中常用的有：</p><ul><li>ClassPathXmlApplicationContext：适用于类路径下的 XML 配置文件。</li><li>FileSystemXmlApplicationContext：适用于非类路径下的 XML 配置文件。</li><li>AnnotationConfigApplicationContext：适用于注解配置形式。<br>比如 ClassPathXmlApplicationContext 在初始化的时候就会创建一个对应的 XmlBeanDefinitionReader 进行扫描：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span> <span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException, IOException &#123;<br>   <span class="hljs-comment">// 为给定的 BeanFactory 创建 XmlBeanDefinitionReader 便于读取 XML 中的 Bean 配置</span><br>   <span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">beanDefinitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span> (beanFactory);<br>   <span class="hljs-comment">// 各种配置，忽略掉</span><br>   beanDefinitionReader. setEnvironment (<span class="hljs-built_in">this</span>. getEnvironment ());<br>   ...<br>   <span class="hljs-comment">// 配置完成后，直接开始加载 XML 文件中的 Bean 定义</span><br>   loadBeanDefinitions (beanDefinitionReader);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span> <span class="hljs-params">(XmlBeanDefinitionReader reader)</span> <span class="hljs-keyword">throws</span> BeansException, IOException &#123;<br>   Resource[] configResources = getConfigResources ();   <span class="hljs-comment">//具体加载过程我就不详细介绍了</span><br>   <span class="hljs-keyword">if</span> (configResources != <span class="hljs-literal">null</span>) &#123;<br>      reader. loadBeanDefinitions (configResources);<br>   &#125;<br>   String[] configLocations = getConfigLocations ();<br>   <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-literal">null</span>) &#123;<br>      reader. loadBeanDefinitions (configLocations);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>现在，我们就已经知道，Bean 实际上是一开始通过 BeanDefinitionReader 进行扫描，然后将所有 Bean 以 BeanDefinition 对象的形式注册到对应的 BeanFactory 中进行集中管理，而我们使用的 ApplicationContext 实际上内部就有一个 BeanFactory 在进行 Bean 管理，这样容器才拥有了最基本的 Bean 管理功能。<br>当然，BeanFactory 还可以具有父子关系，其中最关键的作用就是继承父容器中所有的 Bean 定义，这样的话，如果我们想要创建一个新的 BeanFactory 并且默认具有其他 BeanFactory 中所有的 Bean 定义外加一些其他的，那么就可以采用这种形式，这是很方便的。<br>我们可以来尝试一下，创建两个工厂：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factoryParent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> ();<br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">factoryChild</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> ();<br>        <span class="hljs-comment">//在父工厂中注册 A</span><br>        factoryParent. registerBeanDefinition (<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span> (A.class));<br>      <span class="hljs-comment">//在子工厂中注册 B、C</span><br>        factoryChild. registerBeanDefinition (<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span> (B.class));<br>        factoryChild. registerBeanDefinition (<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span> (C.class));<br>        <span class="hljs-comment">//最后设定子工厂的父工厂</span><br>        factoryChild. setParentBeanFactory (factoryParent);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123; &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123; &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>现在我们来看看是不是我们想的那样：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System. out. println (factoryChild. getBean (A.class));  <span class="hljs-comment">//子工厂不仅能获取到自己的，也可以拿到父工厂的</span><br>System. out. println (factoryChild. getBean (B.class));<br>System. out. println (factoryChild. getBean (C.class));<br>System. out. println (factoryParent. getBean (B.class));   <span class="hljs-comment">//注意父工厂不能拿到子工厂的，就像类的继承一样</span><br></code></pre></td></tr></table></figure>同样的，我们在使用 ApplicationContext 时，也可以设定这样的父子关系，效果相同：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">contextParent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> (<span class="hljs-string">&quot;parent. xml&quot;</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">contextChild</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;child. xml&quot;</span>&#125;, contextParent);  <span class="hljs-comment">//第一个参数只能用数组，奇怪</span><br>&#125;<br></code></pre></td></tr></table></figure>当然，除了这些功能之外，BeanFactory 还提供了很多其他的管理 Bean 定义的方法，比如移除 Bean 定义、拷贝 Bean 定义、销毁单例 Bean 实例对象等功能，这里就不一一列出了，各位小伙伴自己调用一下测试就可以了，很简单。<blockquote><p>[!NOTE] Bean 管理的本质<br>实际上 <code>bean</code> 的创建管理是由 <code>beanFactory</code> 进行的，而工厂的管理必须依据 <code>beanDefinition</code> 定义作为管理手册，只有工厂里注册了对应 bean 的定义才能对其进行管理</p></blockquote></li></ul><h3 id="单例-Bean-的创建与循环依赖"><a href="#单例-Bean-的创建与循环依赖" class="headerlink" title="单例 Bean 的创建与循环依赖"></a>单例 Bean 的创建与循环依赖</h3><p>前面我们讲解了配置的 Bean 是如何被读取并加载到容器中的，接着我们来了解一下 Bean 实例对象是如何被创建并得到的，我们知道，如果要得到一个 Bean 的实例很简单，通过 <code>getBean</code> 方法就可以直接拿到了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> (<span class="hljs-string">&quot;application. xml&quot;</span>);<br>System. out. println (context. getBean (Student. class));   <span class="hljs-comment">//通过此方法就能快速得到</span><br></code></pre></td></tr></table></figure><p>那么，一个 Bean 的实例对象到底是如何创建出来的呢？我们还要继续对我们之前讲解的 BeanFactory 进行深入介绍。<br>我们可以直接找到 BeanFactory 接口的一个抽象实现 <code>AbstractBeanFactory</code> 类，它实现了 <code>getBean ()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span> <span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>  <span class="hljs-comment">//套娃开始了，做好准备</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. doGetBean (name, (Class) <span class="hljs-literal">null</span>, (Object[]) <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们 <code>doGetBean ()</code> 接着来看方法里面干了什么，这个方法比较长，我们分段进行讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span> <span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. transformedBeanName (name);   <span class="hljs-comment">//虽然这里直接传的就是 name，但是万一是别名呢，所以还得要解析一下变成原本的 Bean 名字</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. getSingleton (beanName);   <span class="hljs-comment">//首先直接获取单例 Bean 对象</span><br>    Object beanInstance;<br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">//判断是否成功获取到共享的单例对象</span><br>    ...<br></code></pre></td></tr></table></figure><p>因为所有的 Bean 默认都是单例模式，对象只会存在一个，因此它会先调用父类的 <code>getSingleton ()</code> 方法来直接获取单例对象，如果有的话，就可以直接拿到 Bean 的实例。如果 Bean 不是单例模式，那么会进入 else 代码块。这一部分我们先来看单例模式下的处理，其实逻辑非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span> <span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. logger. isTraceEnabled ()) &#123;<br>          <span class="hljs-comment">//这里会判断 Bean 是否为正在创建状态，为什么会有这种状态呢？我们会在后面进行介绍</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. isSingletonCurrentlyInCreation (beanName)) &#123;<br>                <span class="hljs-built_in">this</span>. logger. trace (<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>. logger. trace (<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//这里 getObjectForBeanInstance 会进行最终处理</span><br>      <span class="hljs-comment">//因为 Bean 有两个特殊的类型，工厂 Bena 和空 Bean，所以说需要单独处理</span><br>      <span class="hljs-comment">//如果是普通 Bean 直接原样返回 beanInstance 接收到最终结果</span><br>        beanInstance = <span class="hljs-built_in">this</span>. getObjectForBeanInstance (sharedInstance, name, beanName, (RootBeanDefinition) <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       ...<br>    &#125;<br>  <span class="hljs-comment">//最后还会进行一次类型判断，如果都没问题，直接返回 beanInstance 作为结果，我们就得到 Bean 的实例对象了</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. adaptBeanInstance (name, beanInstance, requiredType);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上整个单例 Bean 的创建路线还是很清晰的，并没有什么很难理解的地方，在正常情况下，其实就是简单的创建对象实例并返回即可。<br>其中最关键的是它对于循环依赖的处理。我们发现，在上面的代码中，得到单例对象后，会有一个很特殊的判断 <code>isSingletonCurrentlyInCreation</code>，这个是干嘛的？对象不应该直接创建出来吗？为什么会有这种正在创建的状态呢？我们来探究一下。<br>开始之前先给大家提个问题：</p><blockquote><p>现在有两个 Bean，A 和 B 都是以原型模式进行创建，而 A 中需要注入 B，B 中需要注入 A，这时就会出现 A 还未创建完成，就需要 B，而 B 这时也没创建完成，因为 B 需要 A，而 A 等着 B，B 又等着 A，这样就只能无限循环下去了（就像死锁那种感觉）所以就出现了循环依赖的问题（同理，一个对象注入自己，还有三个对象之间，甚至多个对象之间也会出现这种情况）<br>但是，在单例模式下，由于每个 Bean 只会创建一个实例，只要能够处理好对象之间的引用关系，Spring 完全有机会解决单例对象循环依赖的问题。那么单例模式下是如何解决循环依赖问题的呢？<br><img src="https://s2.loli.net/2022/12/17/aRjr1968Lc3BkKH.png" alt="image-20221217170912302"><br>我们回到一开始的 <code>getSingleton ()</code> 方法中，研究一下它到底是如何处理循环依赖的，它是可以自动解决循环依赖问题的：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span> <span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. singletonObjects. get (beanName);<br>  <span class="hljs-comment">//先从第一层列表中拿 Bean 实例，拿到直接返回</span><br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-built_in">this</span>. isSingletonCurrentlyInCreation (beanName)) &#123;<br>      <span class="hljs-comment">//如果第一层拿不到，并且已经认定为处于循环状态，看看第二层有没有</span><br>        singletonObject = <span class="hljs-built_in">this</span>. earlySingletonObjects. get (beanName);<br>      <span class="hljs-comment">//要是还是没有，继续往下</span><br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>. singletonObjects) &#123;<br>              <span class="hljs-comment">//加锁再执行一次上述流程</span><br>                singletonObject = <span class="hljs-built_in">this</span>. singletonObjects. get (beanName);<br>                <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                    singletonObject = <span class="hljs-built_in">this</span>. earlySingletonObjects. get (beanName);<br>                    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br>                      <span class="hljs-comment">//仍然没有获取到实例，只能从 singletonFactory 中获取了</span><br>                        ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory) <span class="hljs-built_in">this</span>. singletonFactories. get (beanName);<br>                        <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>                            singletonObject = singletonFactory. getObject ();<br>                          <span class="hljs-comment">//丢进 earlySingletonObjects 中，下次就可以直接在第二层拿到了</span><br>                            <span class="hljs-built_in">this</span>. earlySingletonObjects. put (beanName, singletonObject);<br>                            <span class="hljs-built_in">this</span>. singletonFactories. remove (beanName);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来很复杂，实际上它使用了三级缓存的方式来处理循环依赖的问题，包括：</p><ul><li>singletonObjects，用于保存实例化、注入、初始化完成的 bean 实例</li><li>earlySingletonObjects，用于保存实例化完成的 bean 实例</li><li>singletonFactories，在初始创建 Bean 对象时都会生成一个对应的单例工厂用于获取早期对象<br>我们先来画一个流程图理清整个过程：<br><img src="https://s2.loli.net/2022/12/18/xFfUuaozLpiVg96.png" alt="image-20221218150012610"><br>我们在了解这个流程之前，一定要先明确，单例 Bean 对象的获取，会有哪些结果，首先就是如果我们获取的 Bean 压根就没在工厂中注册，那得到的结果肯定是 null；其次，如果我们获取的 Bean 已经注册了，那么肯定就可以得到这个单例对象，只是不清楚创建到哪一个阶段了。<br>现在我们根据上面的流程图，来模拟一下 A 和 B 循环依赖的情况：<br><img src="https://s2.loli.net/2023/02/14/ezkOUv8Wjrb2tVF.png" alt="image-20230214222056632"><br>有的小伙伴就会有疑问了，看起来似乎两级缓存也可以解决问题啊，干嘛搞三层而且还搞个对象工厂？这不是多此一举吗？实际上这是为了满足 Bean 的生命周期而做的，通过工厂获取早期对象代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getEarlyBeanReference</span> <span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>  <span class="hljs-comment">//这里很关键，会对一些特别的 BeanPostProcessor 进行处理，比如 AOP 代理相关的，如果这个 Bean 是被 AOP 代理的，我们需要得到的是一个经过 AOP 代理的对象，而不是直接创建出来的对象，这个过程需要 BeanPostProcessor 来完成（AOP 产生代理对象的逻辑是在属性填充之后，因此只能再加一级进行缓冲）</span><br>    <span class="hljs-keyword">if</span> (! mbd. isSynthetic () &amp;&amp; hasInstantiationAwareBeanPostProcessors ()) &#123;<br>        <span class="hljs-keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache (). smartInstantiationAware) &#123;<br>            exposedObject = bp. getEarlyBeanReference (exposedObject, beanName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure>我们会在后面的部分中详细介绍 BeanPostProcessor 以及 AOP 的实现原理，届时各位再回来看就会明白了。</li></ul><h3 id="后置处理器与-AOP"><a href="#后置处理器与-AOP" class="headerlink" title="后置处理器与 AOP"></a>后置处理器与 AOP</h3><p>接着我们来介绍一下 <code>PostProcessor</code>，它其实是 Spring 提供的一种后置处理机制，它可以让我们能够插手 Bean、BeanFactory、BeanDefinition 的创建过程，相当于进行一个最终的处理，而最后得到的结果（比如 Bean 实例、Bean 定义等）就是经过后置处理器返回的结果，它是整个加载过程的最后一步。<br>而 AOP 机制正是通过它来实现的，我们首先来认识一下第一个接口 <code>BeanPostProcessor</code>，它相当于 Bean 初始化的一个后置动作，我们可以直接实现此接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意它后置处理器也要进行注册</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span> <span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System. out. println (beanName);  <span class="hljs-comment">//打印 bean 的名称</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span> <span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">return</span> BeanPostProcessor. <span class="hljs-built_in">super</span>. postProcessBeforeInitialization (bean, beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，此接口中包括两个方法，一个是 <code>postProcessAfterInitialization</code> 用于在 Bean 初始化之后进行处理，还有一个 <code>postProcessBeforeInitialization</code> 用于在 Bean 初始化之前进行处理，注意这里的初始化不是创建对象，而是调用类的初始化方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span> <span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System. out. println (<span class="hljs-string">&quot;我是之后：&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> bean;   <span class="hljs-comment">//这里返回的 Bean 相当于最终的结果了，我们依然能够插手修改，这里返回之后是什么就是什么了</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span> <span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System. out. println (<span class="hljs-string">&quot;我是之前：&quot;</span>+beanName);<br>        <span class="hljs-keyword">return</span> bean;   <span class="hljs-comment">//这里返回的 Bean 会交给下一个阶段，也就是初始化方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TestService</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestServiceImpl</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;我是构造方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;我是初始化方法&quot;</span>);<br>    &#125;<br>    TestMapper mapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMapper</span> <span class="hljs-params">(TestMapper mapper)</span> &#123;<br>        System. out. println (<span class="hljs-string">&quot;我是依赖注入&quot;</span>);<br>        <span class="hljs-built_in">this</span>. mapper = mapper;<br>    &#125;<br>  ...<br></code></pre></td></tr></table></figure><p>而 TestServiceImpl 的加载顺序为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">我是构造方法<br>我是依赖注入<br>我是之前：testServiceImpl<br>我是初始化方法<br>我是之后：testServiceImpl<br></code></pre></td></tr></table></figure><p>现在我们再来总结一下一个 Bean 的加载流程：<br>[Bean 定义]首先扫描 Bean，加载 Bean 定义 -&gt; [依赖注入]根据 Bean 定义通过反射创建 Bean 实例 -&gt; [依赖注入]进行依赖注入（顺便解决循环依赖问题）-&gt; [初始化 Bean]BeanPostProcessor 的初始化之前方法 -&gt; [初始化 Bean]Bean 初始化方法 -&gt; [初始化 Bean]BeanPostProcessor 的初始化之后方法 -&gt; [完成]最终得到的 Bean 加载完成的实例<br>利用这种机制，理解 Aop 的实现过程就非常简单了，AOP 实际上也是通过这种机制实现的，它的实现类是 <code>AnnotationAwareAspectJAutoProxyCreator</code>，而它就是在最后对 Bean 进行了代理，因此最后我们得到的结果实际上就是一个动态代理的对象（有关详细实现过程，这里就不进行列举了，感兴趣的可以继续深入）因此，实际上之前设计的三层缓存，都是由于需要处理 AOP 设计的，因为在 Bean 创建得到最终对象之前，很有可能会被 PostProcessor 给偷梁换柱！<br>那么肯定有人有疑问了，这个类没有被注册啊，那按理说它不应该参与到 Bean 的初始化流程中的，为什么它直接就被加载了呢？<br>还记得 <code>@EnableAspectJAutoProxy</code> 吗？我们来看看它是如何定义就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target</span> (&#123;ElementType. TYPE&#125;)<br><span class="hljs-meta">@Retention</span> (RetentionPolicy. RUNTIME)<br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import</span> (&#123;AspectJAutoProxyRegistrar. class&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAspectJAutoProxy &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyTargetClass</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">exposeProxy</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现它使用了 <code>@Import</code> 来注册 <code>AspectJAutoProxyRegistrar</code>，那么这个类又是什么呢，我们接着来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAutoProxyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br>    AspectJAutoProxyRegistrar () &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span> <span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>      <span class="hljs-comment">//注册 AnnotationAwareAspectJAutoProxyCreator 到容器中</span><br>        AopConfigUtils. registerAspectJAnnotationAutoProxyCreatorIfNecessary (registry);<br>        <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">enableAspectJAutoProxy</span> <span class="hljs-operator">=</span> AnnotationConfigUtils. attributesFor (importingClassMetadata, EnableAspectJAutoProxy. class);<br>        <span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (enableAspectJAutoProxy. getBoolean (<span class="hljs-string">&quot;proxyTargetClass&quot;</span>)) &#123;<br>                AopConfigUtils. forceAutoProxyCreatorToUseClassProxying (registry);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (enableAspectJAutoProxy. getBoolean (<span class="hljs-string">&quot;exposeProxy&quot;</span>)) &#123;<br>                AopConfigUtils. forceAutoProxyCreatorToExposeProxy (registry);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它实现了接口，这个接口也是 Spring 提供的一种 Bean 加载机制，它支持直接向容器中添加 Bean 定义，容器也会加载这个 Bean：</p><ul><li>ImportBeanDefinitionRegistrar 类只能通过其他类@Import 的方式来加载，通常是启动类或配置类。</li><li>使用@Import，如果括号中的类是 ImportBeanDefinitionRegistrar 的实现类，则会调用接口中方法（一般用于注册 Bean）</li><li>实现该接口的类拥有注册 bean 的能力。<br>我们可以看到此接口提供了一个 <code>BeanDefinitionRegistry</code> 正是用于注册 Bean 的定义的。<br>因此，当我们打上了 <code>@EnableAspectJAutoProxy</code> 注解之后，首先会通过 <code>@Import</code> 加载 AspectJAutoProxyRegistrar，然后调用其 <code>registerBeanDefinitions</code> 方法，然后使用工具类注册 AnnotationAwareAspectJAutoProxyCreator 到容器中，这样在每个 Bean 创建之后，如果需要使用 AOP，那么就会通过 AOP 的后置处理器进行处理，最后返回一个代理对象。<br>我们也可以尝试编写一个自己的 ImportBeanDefinitionRegistrar 实现，首先编写一个测试 Bean：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBean</span> &#123;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">()</span>&#123;<br>        System. out. println (<span class="hljs-string">&quot;我被初始化了！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBeanDefinitionRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span> <span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder. rootBeanDefinition (Student. class). getBeanDefinition ();<br>        registry. registerBeanDefinition (<span class="hljs-string">&quot;lbwnb&quot;</span>, definition);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>观察控制台输出，成功加载 Bean 实例。<br>与 <code>BeanPostProcessor</code> 差不多的还有 <code>BeanFactoryPostProcessor</code>，它和前者一样，也是用于我们自己处理后置动作的，不过这里是用于处理 BeanFactory 加载的后置动作，<code>BeanDefinitionRegistryPostProcessor</code> 直接继承自 <code>BeanFactoryPostProcessor</code>，并且还添加了新的动作 <code>postProcessBeanDefinitionRegistry</code>，你可以在这里动态添加 Bean 定义或是修改已经存在的 Bean 定义，这里我们就直接演示 <code>BeanDefinitionRegistryPostProcessor</code> 的实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDefinitionProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span> <span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System. out. println (<span class="hljs-string">&quot;我是 Bean 定义后置处理！&quot;</span>);<br>        <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder. rootBeanDefinition (TestBean. class). getBeanDefinition ();<br>        registry. registerBeanDefinition (<span class="hljs-string">&quot;lbwnb&quot;</span>, definition);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span> <span class="hljs-params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System. out. println (<span class="hljs-string">&quot;我是 Bean 工厂后置处理！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这里注册 Bean 定义其实和之前那种方法效果一样。<br>最后，我们再完善一下 Bean 加载流程（加粗部分是新增的）：<br>[Bean 定义]首先扫描 Bean，加载 Bean 定义 -&gt; <strong>[Bean 定义]Bean 定义和 Bean 工厂后置处理</strong> -&gt; [依赖注入]根据 Bean 定义通过反射创建 Bean 实例 -&gt; [依赖注入]进行依赖注入（顺便解决循环依赖问题）-&gt; [初始化 Bean]BeanPostProcessor 的初始化之前方法 -&gt; [初始化 Bean]Bean 初始化方法 -&gt; [初始化 Bean]BeanPostProcessor 的初始化之前后方法 -&gt; [完成]最终得到的 Bean 加载完成的实例</li></ul><h3 id="应用程序上下文详解"><a href="#应用程序上下文详解" class="headerlink" title="应用程序上下文详解"></a>应用程序上下文详解</h3><p>前面我们详细介绍了 BeanFactory 是如何工作的，接着我们来研究一下 ApplicationContext 的内部，实际上我们真正在项目中使用的就是 ApplicationContext 的实现，那么它又是如何工作的呢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;<br><span class="hljs-meta">@Nullable</span><br>String <span class="hljs-title function_">getId</span> <span class="hljs-params">()</span>;<br>String <span class="hljs-title function_">getApplicationName</span> <span class="hljs-params">()</span>;<br>String <span class="hljs-title function_">getDisplayName</span> <span class="hljs-params">()</span>;<br><span class="hljs-type">long</span> <span class="hljs-title function_">getStartupDate</span> <span class="hljs-params">()</span>;<br><span class="hljs-meta">@Nullable</span><br>ApplicationContext <span class="hljs-title function_">getParent</span> <span class="hljs-params">()</span>;<br>AutowireCapableBeanFactory <span class="hljs-title function_">getAutowireCapableBeanFactory</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException;<br>&#125;<br></code></pre></td></tr></table></figure><p>它本身是一个接口，同时集成了多种类型的 BeanFactory 接口，说明它应该具有这些 BeanFactory 的能力，实际上我们在前面已经提到过，ApplicationContext 是依靠内部维护的 BeanFactory 对象来完成这些功能的，并不是它本身就实现了这些功能。<br>这里我们就先从构造方法开始走起，以我们常用的 AnnotationConfigApplicationContext 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span> <span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> &#123;<br><span class="hljs-built_in">this</span> ();                      <span class="hljs-comment">//1. 首先会调用自己的无参构造</span><br>register (componentClasses);  <span class="hljs-comment">//2. 然后注册我们传入的配置类</span><br>refresh ();                   <span class="hljs-comment">//3. 最后进行刷新操作（关键）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先来看第一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">GenericApplicationContext</span> <span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//父类首先初始化内部维护的 BeanFactory 对象</span><br><span class="hljs-built_in">this</span>. beanFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> ();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigApplicationContext</span> <span class="hljs-params">()</span> &#123;<br><span class="hljs-type">StartupStep</span> <span class="hljs-variable">createAnnotatedBeanDefReader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. getApplicationStartup (). start (<span class="hljs-string">&quot;spring. context. annotated-bean-reader. create&quot;</span>);<br>  <span class="hljs-comment">//创建 AnnotatedBeanDefinitionReader 对象，用于后续处理 @Bean 注解</span><br><span class="hljs-built_in">this</span>. reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span> (<span class="hljs-built_in">this</span>);<br>createAnnotatedBeanDefReader. end ();<br>  <span class="hljs-comment">//创建 ClassPathBeanDefinitionScanner 对象，用于扫描类路径上的 Bean</span><br><span class="hljs-built_in">this</span>. scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span> (<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，AnnotationConfigApplicationContext 的基本内容就初始化好了，不过这里结束之后会将 ConfigurationClassPostProcessor 后置处理器加入到 BeanFactory 中，它继承自 BeanFactoryPostProcessor，也就是说一会会在 BeanFactory 初始化完成之后进行后置处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotatedBeanDefinitionReader</span> <span class="hljs-params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;<br>Assert. notNull (registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br>Assert. notNull (environment, <span class="hljs-string">&quot;Environment must not be null&quot;</span>);<br><span class="hljs-built_in">this</span>. registry = registry;<br><span class="hljs-built_in">this</span>. conditionEvaluator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionEvaluator</span> (registry, environment, <span class="hljs-literal">null</span>);<br>  <span class="hljs-comment">//这里注册了注解处理配置相关的后置处理器</span><br>AnnotationConfigUtils. registerAnnotationConfigProcessors (<span class="hljs-built_in">this</span>. registry);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这个后置处理器的主要目的就是为了读取配置类中的各种 Bean 定义以及其他注解，比如@Import、@ComponentScan 等。<br>同时这里也会注册一个 AutowiredAnnotationBeanPostProcessor 后置处理器到 BeanFactory，它继承自 BeanPostProcessor，用于处理后续生成的 Bean 对象，其实看名字就知道，这玩意就是为了处理@Autowire、@Value 这种注解，用于自动注入，这里就不深入讲解具体实现了。<br>所以，第一步结束之后，就会有这两个关键的后置处理器放在容器中：<br><img src="https://s2.loli.net/2023/07/19/uY4zwEhArUMfP2d.png" alt="image-20230719152546148"><br>接着是第二步，注册配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span> <span class="hljs-params">(Class&lt;?&gt;... componentClasses)</span> &#123;<br>Assert. notEmpty (componentClasses, <span class="hljs-string">&quot;At least one component class must be specified&quot;</span>);<br><span class="hljs-type">StartupStep</span> <span class="hljs-variable">registerComponentClass</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. getApplicationStartup (). start (<span class="hljs-string">&quot;spring. context. component-classes. register&quot;</span>)<br>. tag (<span class="hljs-string">&quot;classes&quot;</span>, () -&gt; Arrays. toString (componentClasses));<br>  <span class="hljs-comment">//使用我们上面创建的 Reader 注册配置类</span><br><span class="hljs-built_in">this</span>. reader. register (componentClasses);<br>registerComponentClass. end ();<br>&#125;<br></code></pre></td></tr></table></figure><p>现在配置类已经成功注册到 IoC 容器中了，我们接着来看第三步，到目前为止，我们已知的仅仅是注册了配置类的 Bean，而刷新操作就是配置所有 Bean 的关键部分了，刷新操作是在 AbstractApplicationContext 中实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>. startupShutdownMonitor) &#123;<br><span class="hljs-type">StartupStep</span> <span class="hljs-variable">contextRefresh</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. applicationStartup. start (<span class="hljs-string">&quot;spring. context. refresh&quot;</span>);<br><span class="hljs-comment">// 准备当前应用程序上下文，进行刷新、设置启动事件和活动标志以及执行其他初始化</span><br>prepareRefresh ();<br><span class="hljs-comment">// 这个方法由子类实现，对内部维护的 BeanFactory 进行刷新操作，然后返回这个 BeanFactory</span><br><span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory ();<br><span class="hljs-comment">// 初始化配置 Bean 工厂，比如一些会用到的类加载器和后置处理器。</span><br>prepareBeanFactory (beanFactory);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 由子类实现对 BeanFactory 的其他后置处理，目前没有看到有实现</span><br>postProcessBeanFactory (beanFactory);<br><span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanPostProcess</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. applicationStartup. start (<span class="hljs-string">&quot;spring. context. beans. post-process&quot;</span>);<br><span class="hljs-comment">// 实例化并调用所有注册的 BeanFactoryPostProcessor 类型的 Bean</span><br>        <span class="hljs-comment">// 这一步中，上面提到的 BeanFactoryPostProcessor 就开始工作了，比如包扫描、解析 Bean 配置等</span><br>        <span class="hljs-comment">// 这一步结束之后，包扫描到的其他 Bean 就注册到 BeanFactory 中了</span><br>invokeBeanFactoryPostProcessors (beanFactory);<br><span class="hljs-comment">// 实例化并注册所有 BeanPostProcessor 类型的 Bean，不急着执行</span><br>registerBeanPostProcessors (beanFactory);<br>beanPostProcess. end ();<br>initMessageSource ();<br>initApplicationEventMulticaster ();<br><span class="hljs-comment">// 依然是提供给子类实现的，目的是用于处理一些其他比较特殊的 Bean，目前似乎也没看到有实现</span><br>onRefresh ();<br><span class="hljs-comment">// 注册所有的监听器</span><br>registerListeners ();<br><span class="hljs-comment">// 将剩余所有非懒加载单例 Bean 全部实例化</span><br>finishBeanFactoryInitialization (beanFactory);<br>finishRefresh ();<br>&#125; <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>...<br><span class="hljs-comment">// 发现异常直接销毁所有 Bean</span><br>destroyBeans ();<br><span class="hljs-comment">// 取消本次刷新操作，重置标记</span><br>cancelRefresh (ex);<br><span class="hljs-comment">// 继续往上抛异常</span><br><span class="hljs-keyword">throw</span> ex;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>resetCommonCaches ();<br>contextRefresh. end ();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，现在流程就很清晰了，实际上最主要的就是 <code>refresh</code> 方法，它从初始化到实例化所有的 Bean 整个流程都已经完成，在这个方法结束之后，整个 IoC 容器基本就可以正常使用了。<br>我们继续来研究一下 <code>finishBeanFactoryInitialization</code> 方法，看看它是怎么加载所有 Bean 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishBeanFactoryInitialization</span> <span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>...<br>beanFactory. preInstantiateSingletons ();   <span class="hljs-comment">//套娃</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>...<br>    <span class="hljs-comment">// 列出全部 bean 名称</span><br>List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>. beanDefinitionNames);<br><span class="hljs-comment">// 开始初始化所有 Bean</span><br><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>      <span class="hljs-comment">//得到 Bean 定义</span><br><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition (beanName);<br>      <span class="hljs-comment">//Bean 不能是抽象类、不能是非单例模式、不能是懒加载的</span><br><span class="hljs-keyword">if</span> (! bd. isAbstract () &amp;&amp; bd. isSingleton () &amp;&amp; !bd. isLazyInit ()) &#123;<br>        <span class="hljs-comment">//针对于 Bean 和 FactoryBean 分开进行处理</span><br><span class="hljs-keyword">if</span> (isFactoryBean (beanName)) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean (FACTORY_BEAN_PREFIX + beanName);<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> SmartFactoryBean&lt;?&gt; smartFactoryBean &amp;&amp; smartFactoryBean. isEagerInit ()) &#123;<br>getBean (beanName);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>getBean (beanName);  <span class="hljs-comment">//最后都是通过调用 getBean 方法来初始化实例，这里就跟我们之前讲的连起来了</span><br>&#125;<br>&#125;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，关于 Spring 容器核心加载流程，我们就探究完毕了，实际单易懂，就是代码量太大了。在后续的 SpringBoot 阶段，我们还会继续深挖 Spring 的某些机制的具体实现细节。</p><h3 id="Mybatis-整合原理"><a href="#Mybatis-整合原理" class="headerlink" title="Mybatis 整合原理"></a>Mybatis 整合原理</h3><p>通过之前的了解，我们再来看 Mybatis 的 <code>@MapperScan</code> 是如何实现的，现在理解起来就非常简单了。<br>我们可以直接打开查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention</span> (RetentionPolicy. RUNTIME)<br><span class="hljs-meta">@Target</span> (&#123;ElementType. TYPE&#125;)<br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import</span> (&#123;MapperScannerRegistrar. class&#125;)<br><span class="hljs-meta">@Repeatable</span> (MapperScans. class)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MapperScan &#123;<br>    String[] value () <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] basePackages () <span class="hljs-keyword">default</span> &#123;&#125;;<br>  ...<br></code></pre></td></tr></table></figure><p>我们发现，和 Aop 一样，它也是通过 Registrar 机制，通过 <code>@Import</code> 来进行 Bean 的注册，我们来看看 <code>MapperScannerRegistrar</code> 是个什么东西，关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span> <span class="hljs-params">(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName)</span> &#123;<br>    <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder. genericBeanDefinition (MapperScannerConfigurer. class);<br>    builder. addPropertyValue (<span class="hljs-string">&quot;processPropertyPlaceHolders&quot;</span>, <span class="hljs-literal">true</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然很长很多，但是这些代码都是在添加一些 Bean 定义的属性，而最关键的则是最上方的 <code>MapperScannerConfigurer</code>，Mybatis 将其 Bean 信息注册到了容器中，那么这个类又是干嘛的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperScannerConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span>, InitializingBean, ApplicationContextAware, BeanNameAware &#123;<br>    <span class="hljs-keyword">private</span> String basePackage;<br></code></pre></td></tr></table></figure><p>它实现了 BeanDefinitionRegistryPostProcessor，也就是说它为 Bean 信息加载提供了后置处理，我们接着来看看它在 Bean 信息后置处理中做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span> <span class="hljs-params">(BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. processPropertyPlaceHolders) &#123;<br>        <span class="hljs-built_in">this</span>. processPropertyPlaceHolders ();<br>    &#125;<br>  <span class="hljs-comment">//初始化类路径 Mapper 扫描器，它相当于是一个工具类，可以快速扫描出整个包下的类定义信息</span><br>  <span class="hljs-comment">//ClassPathMapperScanner 是 Mybatis 自己实现的一个扫描器，修改了一些扫描规则</span><br>    <span class="hljs-type">ClassPathMapperScanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathMapperScanner</span> (registry);<br>    scanner. setAddToConfig (<span class="hljs-built_in">this</span>. addToConfig);<br>    scanner. setAnnotationClass (<span class="hljs-built_in">this</span>. annotationClass);<br>    scanner. setMarkerInterface (<span class="hljs-built_in">this</span>. markerInterface);<br>    scanner. setSqlSessionFactory (<span class="hljs-built_in">this</span>. sqlSessionFactory);<br>    scanner. setSqlSessionTemplate (<span class="hljs-built_in">this</span>. sqlSessionTemplate);<br>    scanner. setSqlSessionFactoryBeanName (<span class="hljs-built_in">this</span>. sqlSessionFactoryBeanName);<br>    scanner. setSqlSessionTemplateBeanName (<span class="hljs-built_in">this</span>. sqlSessionTemplateBeanName);<br>    scanner. setResourceLoader (<span class="hljs-built_in">this</span>. applicationContext);<br>    scanner. setBeanNameGenerator (<span class="hljs-built_in">this</span>. nameGenerator);<br>    scanner. setMapperFactoryBeanClass (<span class="hljs-built_in">this</span>. mapperFactoryBeanClass);<br>    <span class="hljs-keyword">if</span> (StringUtils. hasText (<span class="hljs-built_in">this</span>. lazyInitialization)) &#123;<br>        scanner. setLazyInitialization (Boolean. valueOf (<span class="hljs-built_in">this</span>. lazyInitialization));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (StringUtils. hasText (<span class="hljs-built_in">this</span>. defaultScope)) &#123;<br>        scanner. setDefaultScope (<span class="hljs-built_in">this</span>. defaultScope);<br>    &#125;<br>  <span class="hljs-comment">//添加过滤器，这里会配置为所有的接口都能被扫描（因此即使你不添加@Mapper 注解都能够被扫描并加载）</span><br>    scanner. registerFilters ();<br>  <span class="hljs-comment">//开始扫描</span><br>    scanner. scan (StringUtils. tokenizeToStringArray (<span class="hljs-built_in">this</span>. basePackage, <span class="hljs-string">&quot;,; \t\n&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>开始扫描后，会调用 <code>doScan ()</code> 方法，我们接着来看（这是 <code>ClassPathMapperScanner</code> 中的扫描方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title function_">doScan</span> <span class="hljs-params">(String... basePackages)</span> &#123;<br>    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-built_in">super</span>. doScan (basePackages);<br>  <span class="hljs-comment">//首先从包中扫描所有的 Bean 定义</span><br>    <span class="hljs-keyword">if</span> (beanDefinitions. isEmpty ()) &#123;<br>        LOGGER. warn (() -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays. toString (basePackages) + <span class="hljs-string">&quot;&#x27; package. Please check your configuration.&quot;</span>;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//处理所有的 Bean 定义，实际上就是生成对应 Mapper 的代理对象，并注册到容器中</span><br>        <span class="hljs-built_in">this</span>. processBeanDefinitions (beanDefinitions);<br>    &#125;<br>  <span class="hljs-comment">//最后返回所有的 Bean 定义集合</span><br>    <span class="hljs-keyword">return</span> beanDefinitions;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过断点我们发现，最后处理得到的 Bean 定义发现此 Bean 是一个 MapperFactoryBean，它不同于普通的 Bean，FactoryBean 相当于为普通的 Bean 添加了一层外壳，它并不是依靠 Spring 直接通过反射创建，而是使用接口中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FactoryBean</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;factoryBeanObjectType&quot;</span>;<br>    <span class="hljs-meta">@Nullable</span><br>    T <span class="hljs-title function_">getObject</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-meta">@Nullable</span><br>    Class&lt;?&gt; getObjectType ();<br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>getObject ()</code> 方法，就可以获取到 Bean 的实例了。<br>注意这里一定要区分 FactoryBean 和 BeanFactory 的概念：</p><ul><li>BeanFactory 是个 Factory，也就是 IOC 容器或对象工厂，所有的 Bean 都是由 BeanFactory ( 也就是 IOC 容器 ) 来进行管理。</li><li>FactoryBean 是一个能生产或者修饰生成对象的工厂 Bean (本质上也是一个 Bean)，可以在 BeanFactory（IOC 容器）中被管理，所以它并不是一个简单的 Bean。当使用容器中 factory bean 的时候，该容器不会返回 factory bean 本身，而是返回其生成的对象。要想获取 FactoryBean 的实现类本身，得在 getBean (String BeanName)中的 BeanName 之前加上&amp;, 写成 getBean (String &amp;BeanName)。<br>我们也可以自己编写一个实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> (<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFb</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;Student&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">getObject</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System. out. println (<span class="hljs-string">&quot;获取了学生&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType () &#123;<br>        <span class="hljs-keyword">return</span> Student. class;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    log. info (<span class="hljs-string">&quot;项目正在启动...&quot;</span>);<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> (TestConfiguration. class);<br>    System. out. println (context. getBean (<span class="hljs-string">&quot;&amp;test&quot;</span>));   <span class="hljs-comment">//得到 FactoryBean 本身（得加个&amp;搞得像 C 语言指针一样）</span><br>    System. out. println (context. getBean (<span class="hljs-string">&quot;test&quot;</span>));   <span class="hljs-comment">//得到 FactoryBean 调用 getObject ()之后的结果</span><br>&#125;<br></code></pre></td></tr></table></figure>因此，实际上我们的 Mapper 最终就以 FactoryBean 的形式，被注册到容器中进行加载了：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getObject</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. getSqlSession (). getMapper (<span class="hljs-built_in">this</span>. mapperInterface);<br>&#125;<br></code></pre></td></tr></table></figure>这样，整个 Mybatis 的 <code>@MapperScan</code> 的原理就全部解释完毕了。<br>在了解完了 Spring 的底层原理之后，我们其实已经完全可以根据这些实现原理来手写一个 Spring 框架了。</li></ul><hr><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p><strong>进入之前：</strong>《Spring 核心内容》《JavaWeb》《JDK 9-17 新特性篇》<br>此阶段，我们将再次回到 Tomcat 的 Web 应用程序开发中，去感受 Spring 框架为我们带来的巨大便捷。</p><h2 id="MVC-理论基础"><a href="#MVC-理论基础" class="headerlink" title="MVC 理论基础"></a>MVC 理论基础</h2><p>在之前，我们给大家讲解了三层架构，包括：<br><img src="https://s2.loli.net/2023/02/18/2IiK8YrfhF4zyU1.jpg" alt="img"><br>每一层都有着各自的职责，其中最关键的当属表示层，因为它相当于就是直接与用户的浏览器打交道的一层，并且所有的请求都会经过它进行解析，然后再告知业务层进行处理，任何页面的返回和数据填充也全靠表示层来完成，因此它实际上是整个三层架构中最关键的一层，而在之前的实战开发中，我们编写了大量的 Servlet（也就是表示层实现）来处理来自浏览器的各种请求，但是我们发现，仅仅是几个很小的功能，以及几个很基本的页面，我们都要编写将近十个 Servlet，如果是更加大型的网站系统，比如淘宝、B 站，光是一个页面中可能就包含了几十甚至上百个功能，想想那样的话写起来得多恐怖。<br>因此，SpringMVC 正是为了解决这种问题而生的，它是一个非常优秀的表示层框架，采用 MVC 思想设计实现。<br>MVC 详细解释如下：</p><ul><li>M 是指业务模型（Model）：通俗的讲就是我们之前用于封装数据传递的实体类。</li><li>V 是指用户界面（View）：一般指的是前端页面。</li><li>C 则是控制器（Controller）：控制器就相当于 Servlet 的基本功能，处理请求，返回响应。</li></ul><p><img src="https://s2.loli.net/2023/02/18/voy7HYrIbJuw9R3.jpg" alt="img"><br>SpringMVC 正是希望这三者之间进行解耦，实现各干各的，更加精细地划分对应的职责。最后再将 View 和 Model 进行渲染，得到最终的页面并返回给前端（就像之前使用 Thymeleaf 那样，把实体数据对象和前端页面都给到 Thymeleaf，然后它会将其进行整合渲染得到最终有数据的页面，而本教程也会使用 Thymeleaf 作为视图解析器进行讲解）</p><hr><h2 id="配置环境并搭建项目"><a href="#配置环境并搭建项目" class="headerlink" title="配置环境并搭建项目"></a>配置环境并搭建项目</h2><p>这里我们继续使用之前的 Tomcat 10 服务器，Spring 6 之后要求必须使用 Tomcat 10 或更高版本，跟之前一样，我们直接创建一个新的 JakartaEE 项目。<br><img src="https://s2.loli.net/2023/02/19/4IucyfBKsLzASNJ.png" alt="image-20230219162053172"><br>创建完成后会自动生成相关文件，但是还是请注意检查运行配置中的 URL 和应用程序上下文名称是否一致。</p><h3 id="传统-XML-配置形式"><a href="#传统-XML-配置形式" class="headerlink" title="传统 XML 配置形式"></a>传统 XML 配置形式</h3><p>SpringMvc 项目依然支持多种配置形式，这里我们首先讲解最传统的 XML 配置形式。<br>首先我们需要添加 Mvc 相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们需要配置一下 web. xml，将 DispatcherServlet 替换掉 Tomcat 自带的 Servlet，这里 url-pattern 需要写为 <code>/</code>，即可完成替换：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;5.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着需要为整个 Web 应用程序配置一个 Spring 上下文环境（也就是容器），因为 SpringMVC 是基于 Spring 开发的，它直接利用 Spring 提供的容器来实现各种功能，那么第一步依然跟之前一样，需要编写一个配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们需要为 DispatcherServlet 配置一些初始化参数来指定刚刚创建的配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--     指定我们刚刚创建在类路径下的XML配置文件       --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:application.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就完成了基本的配置，现在我们可以来测试一下是否配置正确，我们删除项目自带的 Servlet 类，创建一个 Mvc 中使用的 Controller 类，现在还没学没关系，跟着写就行了，这里我们只是测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HelloWorld!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要将这个类注册为 Bean 才能正常使用，我们来编写一下 Spring 的配置文件，这里我们直接配置包扫描，XML 下的包扫描需要这样开启：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 需要先引入context命名空间，然后直接配置base-package属性就可以了 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.example&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果可以成功在浏览器中出现 HelloWorld 则说明配置成功：<br><img src="https://s2.loli.net/2023/02/19/D1sAFePzj7d49VL.png" alt="image-20230219170637540"><br>实际上我们上面编写的 Controller 就是负责 Servlet 基本功能的，比如这里我们返回的是 HelloWorld 字符串，那么我们在访问这个地址的时候，得到的就是这里返回的字符串。</p><h3 id="全注解配置形式"><a href="#全注解配置形式" class="headerlink" title="全注解配置形式"></a>全注解配置形式</h3><p>如果你希望完完全全丢弃配置文件，使用纯注解开发，可以直接添加一个类，Tomcat 会在类路径中查找实现 <code>ServletContainerInitializer</code> 接口的类，如果发现的话，就用它来配置 Servlet 容器，Spring 提供了这个接口的实现类 <code>SpringServletContainerInitializer</code> , 通过 <code>@HandlesTypes(WebApplicationInitializer.class)</code> 设置，这个类反过来会查找实现 <code>WebApplicationInitializer</code> 的类，并将配置的任务交给他们来完成，因此直接实现接口即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;WebConfiguration.class&#125;;   <span class="hljs-comment">//基本的Spring配置类，一般用于业务层配置</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>];  <span class="hljs-comment">//配置DispatcherServlet的配置类、主要用于Controller等配置，这里为了教学简单，就不分这么详细了，只使用上面的基本配置类</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;    <span class="hljs-comment">//匹配路径，与上面一致</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要再配置类中添加一些必要的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebMvc</span>   <span class="hljs-comment">//快速配置SpringMvc注解，如果不添加此注解会导致后续无法通过实现WebMvcConfigurer接口进行自定义配置</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们同样可以正常访问：<br><img src="https://s2.loli.net/2023/02/19/D1sAFePzj7d49VL.png" alt="image-20230219170637540"><br>之后为了方便，我们就统一使用全注解形式编写。<br>如果日志科技有报错无法显示 Mvc 相关的日志，请添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-jdk14<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加后就可以正常打印日志了：<br><img src="https://s2.loli.net/2023/06/30/7eti1wuU8Bd4RqZ.png" alt="image-20230630162821105"></p><h2 id="Controller-控制器"><a href="#Controller-控制器" class="headerlink" title="Controller 控制器"></a>Controller 控制器</h2><p>有了 SpringMVC 之后，我们不必再像之前那样一个请求地址创建一个 Servlet 了，它使用 <code>DispatcherServlet</code> 替代 Tomcat 为我们提供的默认的静态资源 Servlet，也就是说，现在所有的请求（除了 jsp，因为 Tomcat 还提供了一个 jsp 的 Servlet）都会经过 <code>DispatcherServlet</code> 进行处理。<br>那么 <code>DispatcherServlet</code> 会帮助我们做什么呢？<br><img src="https://s2.loli.net/2023/02/18/SQNnl3yFjhHbp1G.jpg" alt="img"><br>根据图片我们可以了解，我们的请求到达 Tomcat 服务器之后，会交给当前的 Web 应用程序进行处理，而 SpringMVC 使用 <code>DispatcherServlet</code> 来处理所有的请求，也就是说它被作为一个统一的访问点，所有的请求全部由它来进行调度。<br>当一个请求经过 <code>DispatcherServlet</code> 之后，会先走 <code>HandlerMapping</code>，它会将请求映射为 <code>HandlerExecutionChain</code>，依次经过 <code>HandlerInterceptor</code> 有点类似于之前我们所学的过滤器，不过在 SpringMVC 中我们使用的是拦截器，然后再交给 <code>HandlerAdapter</code>，根据请求的路径选择合适的控制器进行处理，控制器处理完成之后，会返回一个 <code>ModelAndView</code> 对象，包括数据模型和视图，通俗的讲就是页面中数据和页面本身（只包含视图名称即可）。<br>返回 <code>ModelAndView</code> 之后，会交给 <code>ViewResolver</code>（视图解析器）进行处理，视图解析器会对整个视图页面进行解析，SpringMVC 自带了一些视图解析器，但是只适用于 JSP 页面，我们也可以像之前一样使用 Thymeleaf 作为视图解析器，这样我们就可以根据给定的视图名称，直接读取 HTML 编写的页面，解析为一个真正的 View。<br>解析完成后，就需要将页面中的数据全部渲染到 View 中，最后返回给 <code>DispatcherServlet</code> 一个包含所有数据的成形页面，再响应给浏览器，完成整个过程。<br>因此，实际上整个过程我们只需要编写对应请求路径的的 Controller 以及配置好我们需要的 ViewResolver 即可，之后还可以继续补充添加拦截器，而其他的流程已经由 SpringMVC 帮助我们完成了。</p><h3 id="配置视图解析器和控制器"><a href="#配置视图解析器和控制器" class="headerlink" title="配置视图解析器和控制器"></a>配置视图解析器和控制器</h3><p>首先我们需要实现最基本的页面解析并返回，第一步就是配置视图解析器，这里我们使用 Thymeleaf 为我们提供的视图解析器，导入需要的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置视图解析器非常简单，我们只需要将对应的 <code>ViewResolver</code> 注册为 Bean 即可，这里我们直接在配置类中编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-meta">@ComponentScan(&quot;com.example.controller&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfiguration</span> &#123;<br>    <span class="hljs-comment">//我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ThymeleafViewResolver <span class="hljs-title function_">thymeleafViewResolver</span><span class="hljs-params">(SpringTemplateEngine springTemplateEngine)</span>&#123;<br>        <span class="hljs-type">ThymeleafViewResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThymeleafViewResolver</span>();<br>        resolver.setOrder(<span class="hljs-number">1</span>);   <span class="hljs-comment">//可以存在多个视图解析器，并且可以为他们设定解析顺序</span><br>        resolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);   <span class="hljs-comment">//编码格式是重中之重</span><br>        resolver.setTemplateEngine(springTemplateEngine);   <span class="hljs-comment">//和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎</span><br>        <span class="hljs-keyword">return</span> resolver;<br>    &#125;<br>    <span class="hljs-comment">//配置模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SpringResourceTemplateResolver <span class="hljs-title function_">templateResolver</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SpringResourceTemplateResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringResourceTemplateResolver</span>();<br>        resolver.setSuffix(<span class="hljs-string">&quot;.html&quot;</span>);   <span class="hljs-comment">//需要解析的后缀名称</span><br>        resolver.setPrefix(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀</span><br>        <span class="hljs-keyword">return</span> resolver;<br>    &#125;<br>    <span class="hljs-comment">//配置模板引擎Bean</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SpringTemplateEngine <span class="hljs-title function_">springTemplateEngine</span><span class="hljs-params">(ITemplateResolver resolver)</span>&#123;<br>        <span class="hljs-type">SpringTemplateEngine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringTemplateEngine</span>();<br>        engine.setTemplateResolver(resolver);   <span class="hljs-comment">//模板解析器，默认即可</span><br>        <span class="hljs-keyword">return</span> engine;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就完成了视图解析器的配置，我们接着来创建一个 Controller，创建 Controller 也非常简单，只需在一个类上添加一个 <code>@Controller</code> 注解即可，它会被 Spring 扫描并自动注册为 Controller 类型的 Bean，然后我们只需要在类中编写方法用于处理对应地址的请求即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//直接添加注解即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span>   <span class="hljs-comment">//直接填写访问路径</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);  <span class="hljs-comment">//返回ModelAndView对象，这里填入了视图的名称</span><br>      <span class="hljs-comment">//返回后会经过视图解析器进行处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们在类路径根目录下创建一个简单 html 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欢迎来到GayHub全球最大同性交友网站<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们会发现，打开浏览器之后就可以直接访问我们的 HTML 页面了：<br><img src="https://s2.loli.net/2023/02/20/ru4pBgI75JZxG6F.png" alt="image-20230220150905300"><br>我们在之前，使用 Thymeleaf 解析后端的一些数据时，需要通过 Context 进行传递，而使用 SpringMvc 后，数据我们可以直接向 Model 模型层进行提供：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>    modelAndView.getModel().put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;啊这&quot;</span>);   <span class="hljs-comment">//将name传递给Model</span><br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样 Thymeleaf 就能收到我们传递的数据进行解析：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;static/test.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    HelloWorld！<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，为了简便，我们可以直接返回 View 名称，SpringMVC 会将其自动包装为 ModelAndView 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以单独添加一个 Model 作为形参进行设置，SpringMVC 通过依赖注入会自动帮助我们传递实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">(Model model)</span>&#123;  <span class="hljs-comment">//这里不仅仅可以是Model，还可以是Map、ModelMap</span><br>    model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了 Spring 框架的加持，相比我们之前编写的 Web 应用程序，简直方便了一个层次，你就说你爱不爱吧，你爱不爱。<br>注意，一定要保证视图名称下面出现横线并且按住 Ctrl 可以跳转，配置才是正确的（最新版 IDEA）<br>我们的页面中可能还会包含一些静态资源，比如 js、css，因此这里我们还需要配置一下，让静态资源通过 Tomcat 提供的默认 Servlet 进行解析，我们需要让配置类实现一下 <code>WebMvcConfigurer</code> 接口，这样在 Web 应用程序启动时，会根据我们重写方法里面的内容进行进一步的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> &#123;<br>    configurer.enable();   <span class="hljs-comment">//开启默认的Servlet</span><br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>    registry.addResourceHandler(<span class="hljs-string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;/static/&quot;</span>);<br>    <span class="hljs-comment">//配置静态资源的访问路径</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们编写一下前端内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引用静态资源，这里使用Thymeleaf的网址链接表达式，Thymeleaf会自动添加web应用程序的名称到链接前面 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/static/test.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欢迎来到交友网站<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建 <code>test.js</code> 并编写如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;欢迎网站&quot;</span>)<br></code></pre></td></tr></table></figure><p>最后访问页面，页面在加载时就会显示一个弹窗，这样我们就完成了最基本的页面配置。相比之前的方式，这样就简单很多了，直接避免了编写大量的 Servlet 来处理请求。</p><blockquote><p>[!NOTE] 模板视图使用总结</p><ul><li>配置好 <code>WebConfiguration</code> 应用配置，若使用前后端耦合借助模板的方式则添加模板相关配置，包括 <code>ThymeleafViewResolver</code>、<code>SpringResourceTemplateResolver</code>、<code>SpringTemplateEngine</code></li><li>实现 <code>WebMvcConfigurer</code> 接口的 <code>addResourceHandlers</code> 方法处理静态资源访问问题</li><li>编写 <strong>controller</strong> 控制器返回模板视图（modelAndView）或者 html 文件名的字符串即可，在 <strong>modelAndView</strong> 中可以添加参数，结合 <strong>Thymeleaf</strong> 模板语法进行参数渲染。</li></ul></blockquote><hr><h3 id="RequestMapping-详解"><a href="#RequestMapping-详解" class="headerlink" title="@RequestMapping 详解"></a>@RequestMapping 详解</h3><p>前面我们已经了解了如何创建一个控制器来处理我们的请求，接着我们只需要在控制器添加一个方法用于处理对应的请求即可，之前我们需要完整地编写一个 Servlet 来实现，而现在我们只需要添加一个 <code>@RequestMapping</code> 即可实现，其实从它的名字我们也能得知，此注解就是将请求和处理请求的方法建立一个映射关系，当收到请求时就可以根据映射关系调用对应的请求处理方法，那么我们就来先聊聊 <code>@RequestMapping</code> 吧，注解定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RequestMapping &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-meta">@AliasFor(&quot;path&quot;)</span><br>    String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>    String[] path() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    RequestMethod[] method() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] params() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] headers() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] consumes() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] produces() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中最关键的是 path 属性（等价于 value），它决定了当前方法处理的请求路径，注意路径必须全局唯一，任何路径只能有一个方法进行处理，它是一个数组，也就是说此方法不仅仅可以只用于处理某一个请求路径，我们可以使用此方法处理多个请求路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&#123;&quot;/index&quot;, &quot;/test&quot;&#125;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们访问&#x2F;index 或是&#x2F;test 都会经过此方法进行处理。<br>我们也可以直接将 <code>@RequestMapping</code> 添加到类名上，表示为此类中的所有请求映射添加一个路径前缀，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/yyds&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&#123;&quot;/index&quot;, &quot;/test&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在我们需要访问 <code>/yyds/index</code> 或是 <code>/yyds/test</code> 才可以得到此页面。我们可以直接在 IDEA 下方的端点板块中查看当前 Web 应用程序定义的所有请求映射，并且可以通过 IDEA 为我们提供的内置 Web 客户端直接访问某个路径。<br>路径还支持使用通配符进行匹配：</p><ul><li>?：表示任意一个字符，比如 <code>@RequestMapping(&quot;/index/x?&quot;)</code> 可以匹配&#x2F;index&#x2F;xa、&#x2F;index&#x2F;xb 等等。</li><li>*：表示任意 0-n 个字符，比如 <code>@RequestMapping(&quot;/index/*&quot;)</code> 可以匹配&#x2F;index&#x2F;lbwnb、&#x2F;index&#x2F;yyds 等。</li><li>**：表示当前目录或基于当前目录的多级目录，比如 <code>@RequestMapping(&quot;/index/**&quot;)</code> 可以匹配&#x2F;index、&#x2F;index&#x2F;xxx 等。</li></ul><p>我们接着来看下一个 method 属性，顾名思义，它就是请求的方法类型，我们可以限定请求方式，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.POST)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们如果直接使用浏览器访问此页面，会显示 405 方法不支持，因为浏览器默认是直接使用 GET 方法获取页面，而我们这里指定为 POST 方法访问此地址，所以访问失败，我们现在再去端点中用 POST 方式去访问，成功得到页面。<br><img src="https://s2.loli.net/2023/02/20/JVwN2MhrWBAGni9.png" alt="image-20230220152559862"><br>我们也可以使用衍生注解直接设定为指定类型的请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了 <code>@PostMapping</code> 直接指定为 POST 请求类型的请求映射，同样的，还有 <code>@GetMapping</code> 可以直接指定为 GET 请求方式，这里就不一一列举了。<br>我们可以使用 <code>params</code> 属性来指定请求必须携带哪些请求参数，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;, params = &#123;&quot;username&quot;, &quot;password&quot;&#125;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如这里我们要求请求中必须携带 <code>username</code> 和 <code>password</code> 属性，否则无法访问。它还支持表达式，比如我们可以这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;, params = &#123;&quot;!username&quot;, &quot;password&quot;&#125;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 username 之前添加一个感叹号表示请求的不允许携带此参数，否则无法访问，我们甚至可以直接设定一个固定值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;, params = &#123;&quot;username!=test&quot;, &quot;password=123&quot;&#125;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，请求参数 username 不允许为 test，并且 password 必须为 123，否则无法访问。<br><code>header</code> 属性用法与 <code>params</code> 一致，但是它要求的是请求头中需要携带什么内容，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;, headers = &quot;!Connection&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，如果请求头中携带了 <code>Connection</code> 属性，将无法访问。其他两个属性：</p><ul><li>consumes： 指定处理请求的提交内容类型（Content-Type），例如 application&#x2F;json, text&#x2F;html;</li><li>produces:  指定返回的内容类型，仅当 request 请求头中的 (Accept)类型中包含该指定类型才返回；</li></ul><h3 id="RequestParam-和-RequestHeader-详解"><a href="#RequestParam-和-RequestHeader-详解" class="headerlink" title="@RequestParam 和@RequestHeader 详解"></a>@RequestParam 和@RequestHeader 详解</h3><p>我们接着来看，如何获取到请求中的参数。<br>我们只需要为方法添加一个形式参数，并在形式参数前面添加 <code>@RequestParam</code> 注解即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接受到请求参数：&quot;</span>+username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要在 <code>@RequestParam</code> 中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加 <code>@RequestParam</code> 也能获取到参数值。<br>一旦添加 <code>@RequestParam</code>，那么此请求必须携带指定参数，我们也可以将 require 属性设定为 false 来将属性设定为非必须：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;username&quot;, required = false)</span> String username)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接受到请求参数：&quot;</span>+username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以直接设定一个默认值，当请求参数缺失时，可以直接使用默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;username&quot;, required = false, defaultValue = &quot;伞兵一号&quot;)</span> String username)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接受到请求参数：&quot;</span>+username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要使用 Servlet 原本的一些类，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;接受到请求参数：&quot;</span>+request.getParameterMap().keySet());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>直接添加 <code>HttpServletRequest</code> 为形式参数即可，SpringMVC 会自动传递该请求原本的 <code>HttpServletRequest</code> 对象，同理，我们也可以添加 <code>HttpServletResponse</code> 作为形式参数，甚至可以直接将 HttpSession 也作为参数传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(HttpSession session)</span>&#123;<br>    System.out.println(session.getAttribute(<span class="hljs-string">&quot;test&quot;</span>));<br>    session.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;鸡你太美&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以直接将请求参数传递给一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意必须携带 set 方法或是构造方法中包含所有参数，请求参数会自动根据类中的字段名称进行匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(User user)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;获取到cookie值为：&quot;</span>+user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@RequestHeader</code> 与 <code>@RequestParam</code> 用法一致，不过它是用于获取请求头参数的，这里就不再演示了。</p><h3 id="CookieValue-和-SessionAttrbutie"><a href="#CookieValue-和-SessionAttrbutie" class="headerlink" title="@CookieValue 和@SessionAttrbutie"></a>@CookieValue 和@SessionAttrbutie</h3><p>通过使用 <code>@CookieValue</code> 注解，我们也可以快速获取请求携带的 Cookie 信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(HttpServletResponse response,</span><br><span class="hljs-params">                          <span class="hljs-meta">@CookieValue(value = &quot;test&quot;, required = false)</span> String test)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;获取到cookie值为：&quot;</span>+test);<br>    response.addCookie(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;lbwnb&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，Session 也能使用注解快速获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@SessionAttribute(value = &quot;test&quot;, required = false)</span> String test,</span><br><span class="hljs-params">                          HttpSession session)</span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>    System.out.println(test);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="重定向和请求转发"><a href="#重定向和请求转发" class="headerlink" title="重定向和请求转发"></a>重定向和请求转发</h3><p>重定向和请求转发也非常简单，我们只需要在视图名称前面添加一个前缀即可，比如重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:home&quot;</span>;<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">home</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;home&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过添加 <code>redirect:</code> 前缀，就可以很方便地实现重定向，那么请求转发呢，其实也是一样的，使用 <code>forward:</code> 前缀表示转发给其他请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:home&quot;</span>;<br>&#125;<br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">home</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;home&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Bean-的-Web-作用域"><a href="#Bean-的-Web-作用域" class="headerlink" title="Bean 的 Web 作用域"></a>Bean 的 Web 作用域</h3><p>在学习 Spring 时我们讲解了 Bean 的作用域，包括 <code>singleton</code> 和 <code>prototype</code>，Bean 分别会以单例和多例模式进行创建，而在 SpringMVC 中，它的作用域被继续细分：</p><ul><li>request：对于每次 HTTP 请求，使用 request 作用域定义的 Bean 都将产生一个新实例，请求结束后 Bean 也消失。</li><li>session：对于每一个会话，使用 session 作用域定义的 Bean 都将产生一个新实例，会话过期后 Bean 也消失。</li><li>global session：不常用，不做讲解。</li></ul><p>这里我们创建一个测试类来试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBean</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着将其注册为 Bean，注意这里需要添加 <code>@RequestScope</code> 或是 <code>@SessionScope</code> 表示此 Bean 的 Web 作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@RequestScope</span><br><span class="hljs-keyword">public</span> TestBean <span class="hljs-title function_">testBean</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBean</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们将其自动注入到 Controller 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    TestBean bean;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">index</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(bean);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;index&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，每次发起得到的 Bean 实例都不同，接着我们将其作用域修改为 <code>@SessionScope</code>，这样作用域就上升到 Session，只要不清理浏览器的 Cookie，那么都会被认为是同一个会话，只要是同一个会话，那么 Bean 实例始终不变。<br>实际上，它也是通过代理实现的，我们调用 Bean 中的方法会被转发到真正的 Bean 对象去执行。</p><blockquote><p>[!NOTE] 控制器相关内容总结</p><ul><li><code>@RequestMapping</code> 进行对视图函数进行映射，指定 <em>url、method、params、headers</em> 等</li><li><code>@RequestParam</code> 用于获取请求参数，可配置 <em>value、required 和 defaultValue</em></li><li><code>@RequestHeader</code> 用于获取请求头的字段信息，参数同@RequestParam</li><li><code>@CookieValue</code> 用于获取请求头的 cookie，参数同@RequestParam</li><li><code>@SessionAttribute</code> 用于获取 session，参数仅有 value、required</li><li><em>重定向</em>在视图名称前加 <code>redirect:</code>，<em>请求转发</em>则加 <code>forward:</code></li><li>Bean 的常用两种 Web 作用域为：<code>@SessionScope</code>（同一个会话 Bean 不变） 和 <code>@RequestScope</code>（每次请求到的 Bean 都不一样）</li></ul></blockquote><hr><h2 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h2><p>中文释义为“表现层状态转换”，它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用 HTTP 协议的特性，规范资源获取的 URI 路径。通俗的讲，RESTful 风格的设计允许将参数通过 URL 拼接传到服务端，目的是让 URL 看起来更简洁实用，并且我们可以充分使用多种 HTTP 请求方式（<em>POST&#x2F;GET&#x2F;PUT&#x2F;DELETE</em>），来执行相同请求地址的不同类型操作。<br>因此，这种风格的连接，我们就可以直接从请求路径中读取参数，比如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/mvc/index/<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>我们可以直接将 index 的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index/&#123;str&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String str)</span> &#123;<br>    System.out.println(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意请求路径我们可以手动添加类似占位符一样的信息，这样占位符位置的所有内容都会被作为请求参数，而方法的形参列表中必须包括一个与占位符同名的并且添加了 <code>@PathVariable</code> 注解的参数，或是由 <code>@PathVariable</code> 注解指定为占位符名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/index/&#123;str&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;str&quot;)</span> String text)</span>&#123;<br>    System.out.println(text);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有配置正确，方法名称上会出现黄线。<br>我们可以按照不同功能进行划分：</p><ul><li>POST <a href="http://localhost:8080/mvc/index">http://localhost:8080/mvc/index</a> -  添加用户信息，携带表单数据</li><li>GET <a href="http://localhost:8080/mvc/index/">http://localhost:8080/mvc/index/</a> {id} -  获取用户信息，id 直接放在请求路径中</li><li>PUT <a href="http://localhost:8080/mvc/index">http://localhost:8080/mvc/index</a> -  修改用户信息，携带表单数据</li><li>DELETE <a href="http://localhost:8080/mvc/index/">http://localhost:8080/mvc/index/</a> {id} -  删除用户信息，id 直接放在请求路径中</li></ul><p>我们分别编写四个请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/index/&#123;id&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String text)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;获取用户：&quot;</span>+text);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/index&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">post</span><span class="hljs-params">(String username)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;添加用户：&quot;</span>+username);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/index/&#123;id&#125;&quot;</span>, method = RequestMethod. DELETE)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delete</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;id&quot;</span>)</span> String text)&#123;<br>        System.out.println (<span class="hljs-string">&quot;删除用户：&quot;</span>+text);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/index&quot;</span>, method = RequestMethod. PUT)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">put</span> <span class="hljs-params">(String username)</span>&#123;<br>        System.out.println (<span class="hljs-string">&quot;修改用户：&quot;</span>+username);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这只是一种设计风格而已，各位小伙伴了解即可。</p><hr><h2 id="Interceptor-拦截器"><a href="#Interceptor-拦截器" class="headerlink" title="Interceptor 拦截器"></a>Interceptor 拦截器</h2><p>拦截器是整个 SpringMVC 的一个重要内容，拦截器与过滤器类似，都是用于拦截一些非法请求，但是我们之前讲解的过滤器是作用于 Servlet 之前，只有经过层层的过滤器才可以成功到达 Servlet，而拦截器并不是在 Servlet 之前，它在 Servlet 与 RequestMapping 之间，相当于 DispatcherServlet 在将请求交给对应 Controller 中的方法之前进行拦截处理，它只会拦截所有 Controller 中定义的请求映射对应的请求（<strong>不会拦截静态资源</strong>），这里一定要区分两者的不同。<br><img src="https://s2.loli.net/2023/06/30/6J3D98HdkawAOVK.png" alt="image-20230630194651686"></p><h3 id="创建拦截器"><a href="#创建拦截器" class="headerlink" title="创建拦截器"></a>创建拦截器</h3><p>创建一个拦截器我们需要实现一个 <code>HandlerInterceptor</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println (<span class="hljs-string">&quot;我是处理之前！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//只有返回 true 才会继续，否则直接结束</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println (<span class="hljs-string">&quot;我是处理之后！&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">//在 DispatcherServlet 完全处理完请求后被调用</span><br>        System.out.println (<span class="hljs-string">&quot;我是完成之后！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们需要在配置类中进行注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span> <span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    registry.addInterceptor (<span class="hljs-keyword">new</span> <span class="hljs-title class_">MainInterceptor</span> ())<br>      .addPathPatterns (<span class="hljs-string">&quot;/**&quot;</span>)    <span class="hljs-comment">//添加拦截器的匹配路径，只要匹配一律拦截</span><br>      .excludePathPatterns (<span class="hljs-string">&quot;/home&quot;</span>);   <span class="hljs-comment">//拦截器不进行拦截的路径</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们在浏览器中访问 index 页面，拦截器已经生效。<br>得到整理拦截器的执行顺序：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">我是处理之前！<br>我是处理！<br>我是处理之后！<br>我是完成之后！<br></code></pre></td></tr></table></figure><p>也就是说，处理前和处理后，包含了真正的请求映射的处理，在整个流程结束后还执行了一次 <code>afterCompletion</code> 方法，其实整个过程与我们之前所认识的 Filter 类似，不过在处理前，我们只需要返回 true 或是 false 表示是否被拦截即可，而不是再去使用 FilterChain 进行向下传递。<br>那么我们就来看看，如果处理前返回 false，会怎么样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">我是处理之前！<br></code></pre></td></tr></table></figure><p>通过结果发现一旦返回 false，之后的所有流程全部取消，那么如果是在处理中发生异常了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/index&quot;</span>)<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span> <span class="hljs-params">()</span>&#123;<br>    System.out.println (<span class="hljs-string">&quot;我是处理！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">我是处理之前！<br>我是处理！<br>我是完成之后！<br></code></pre></td></tr></table></figure><p>我们发现如果处理过程中抛出异常，那么就不会执行处理后 <code>postHandle</code> 方法，但是会执行 <code>afterCompletion</code> 方法，我们可以在此方法中获取到抛出的异常。</p><h3 id="多级拦截器"><a href="#多级拦截器" class="headerlink" title="多级拦截器"></a>多级拦截器</h3><p>前面介绍了仅仅只有一个拦截器的情况，我们接着来看如果存在多个拦截器会如何执行，我们以同样的方式创建二号拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println (<span class="hljs-string">&quot;二号拦截器：我是处理之前！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println (<span class="hljs-string">&quot;二号拦截器：我是处理之后！&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println (<span class="hljs-string">&quot;二号拦截器：我是完成之后！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册二号拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span> <span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>  <span class="hljs-comment">//一号拦截器</span><br>    registry.addInterceptor (<span class="hljs-keyword">new</span> <span class="hljs-title class_">MainInterceptor</span> ()). addPathPatterns (<span class="hljs-string">&quot;/**&quot;</span>). excludePathPatterns (<span class="hljs-string">&quot;/home&quot;</span>);<br>  <span class="hljs-comment">//二号拦截器</span><br>    registry.addInterceptor (<span class="hljs-keyword">new</span> <span class="hljs-title class_">SubInterceptor</span> ()). addPathPatterns (<span class="hljs-string">&quot;/**&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意拦截顺序就是注册的顺序，因此拦截器会根据注册顺序依次执行，我们可以打开浏览器运行一次：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">一号拦截器：我是处理之前！<br>二号拦截器：我是处理之前！<br>我是处理！<br>二号拦截器：我是处理之后！<br>一号拦截器：我是处理之后！<br>二号拦截器：我是完成之后！<br>一号拦截器：我是完成之后！<br></code></pre></td></tr></table></figure><p>和多级 Filter 相同，在处理之前，是按照顺序从前向后进行拦截的，但是处理完成之后，就按照倒序执行处理后方法，而完成后是在所有的 <code>postHandle</code> 执行之后再同样的以倒序方式执行。<br>那么如果这时一号拦截器在处理前就返回了 false 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    System.out.println (<span class="hljs-string">&quot;一号拦截器：我是处理之前！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">一号拦截器：我是处理之前！<br></code></pre></td></tr></table></figure><p>我们发现，与单个拦截器的情况一样，一旦拦截器返回 false，那么之后无论有无拦截器，都不再继续。</p><blockquote><p>[!NOTE] 拦截器用法总结</p><ol><li>实现拦截器需要实现 <code>HandlerInterceptor</code> 接口并重写 <code>preHandle、postHandle、和afterCompletion</code> 方法实现处理前、后以及整个完成后</li><li>在应用配置中重写 <code>WebMvcConfigurer</code> 接口的 <code>addInterceptors</code> 方法注册拦截器并配置拦截模式和拦截器顺序</li><li>多个拦截器都需要注册并通过 <code>order（int）</code> 方法控制顺序，int 值越小顺序越靠前</li></ol></blockquote><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>当我们的请求映射方法中出现异常时，会直接展示在前端页面，这是因为 SpringMVC 为我们提供了默认的异常处理页面，当出现异常时，我们的请求会被直接转交给专门用于异常处理的控制器进行处理。<br>我们可以自定义一个异常处理控制器，一旦出现指定异常，就会转接到此控制器执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorController</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler</span> (Exception.class)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">error</span> <span class="hljs-params">(Exception e, Model model)</span>&#123;  <span class="hljs-comment">//可以直接添加形参来获取异常</span><br>        e.printStackTrace ();<br>        model.addAttribute (<span class="hljs-string">&quot;e&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;500&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们编写一个专门显示异常的页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>  <span class="hljs-number">500</span> - 服务器出现了一个内部错误 QAQ<br>  &lt;div th:text=<span class="hljs-string">&quot;$&#123;e&#125;&quot;</span>&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>接着修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/index&quot;</span>)<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span> <span class="hljs-params">()</span>&#123;<br>    System.out.println (<span class="hljs-string">&quot;我是处理！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;您的氪金力度不足，无法访问！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问后，我们发现控制台会输出异常信息，同时页面也是我们自定义的一个页面。</p><blockquote><p>[!NOTE] SpringMVC 异常处理总结</p><ul><li>SpringMVC 提供了默认的异常处理页面，当出现异常时，我们的请求会被直接转交给专门用于异常处理的控制器进行处理，通过 <code>@ControllerAdvice</code> 注解声明错误控制器，并通过 <code>@ExceptionHandler(Exception.class)</code> 方法注解声明处理的异常类型。</li></ul></blockquote><hr><h2 id="JSON-数据格式与-Axios-请求"><a href="#JSON-数据格式与-Axios-请求" class="headerlink" title="JSON 数据格式与 Axios 请求"></a>JSON 数据格式与 Axios 请求</h2><p>JSON (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。<br>我们现在推崇的是前后端分离的开发模式，而不是所有的内容全部交给后端渲染再发送给浏览器，也就是说，整个 Web 页面的内容在一开始就编写完成了，而其中的数据由前端执行 JS 代码来向服务器动态获取，再到前端进行渲染（填充），这样可以大幅度减少后端的压力，并且后端只需要传输关键数据即可（在即将到来的 SpringBoot 阶段，我们将完全采用前后端分离的开发模式）</p><h3 id="JSON-数据格式"><a href="#JSON-数据格式" class="headerlink" title="JSON 数据格式"></a>JSON 数据格式</h3><p>既然要实现前后端分离，那么我们就必须约定一种更加高效的数据传输模式，来向前端页面传输后端提供的数据。因此 JSON 横空出世，它非常容易理解，并且与前端的兼容性极好，因此现在比较主流的数据传输方式则是通过 JSON 格式承载的。<br>一个 JSON 格式的数据长这样，以学生对象为例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;杰哥&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>多个学生可以以数组的形式表示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;杰哥&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;阿伟&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>嵌套关系可以表示为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;studentList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;杰哥&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;阿伟&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>它直接包括了属性的名称和属性的值，与 JavaScript 的对象极为相似，它到达前端后，可以直接转换为对象，以对象的形式进行操作和内容的读取，相当于以字符串形式表示了一个 JS 对象，我们可以直接在控制台窗口中测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-property">parse</span> (<span class="hljs-string">&#x27;&#123;&quot;studentList&quot;: [&#123;&quot;name&quot;: &quot;杰哥&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;name&quot;: &quot;阿伟&quot;, &quot;age&quot;: 18&#125;], &quot;count&quot;: 2&#125;&#x27;</span>)<br><span class="hljs-comment">//将 JSON 格式字符串转换为 JS 对象</span><br>obj. studentList[<span class="hljs-number">0</span>]. name   <span class="hljs-comment">//直接访问第一个学生的名称</span><br></code></pre></td></tr></table></figure><p>我们也可以将 JS 对象转换为 JSON 字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-property">stringify</span> (obj)<br></code></pre></td></tr></table></figure><p>我们后端就可以以 JSON 字符串的形式向前端返回数据，这样前端在拿到数据之后，就可以快速获取，非常方便。<br>那么后端如何快速创建一个 JSON 格式的数据呢？我们首先需要导入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JSON 解析框架有很多种，比较常用的是 Jackson 和 FastJSON，这里我们使用阿里巴巴的 FastJSON 进行解析，这是目前号称最快的 JSON 解析框架，并且现在已经强势推出 FastJSON 2 版本。<br>首先要介绍的是 JSONObject，它和 Map 的使用方法一样，并且是有序的（实现了 LinkedHashMap 接口），比如我们向其中存放几个数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/index&quot;</span>)<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span> ();<br>    object.put (<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;杰哥&quot;</span>);<br>    object.put (<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>    System.out.println (object.toJSONString ());   <span class="hljs-comment">//以 JSON 格式输出 JSONObject 字符串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们得到的结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;杰哥&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>实际上 JSONObject 就是对 JSON 数据的一种对象表示。同样的还有 JSONArray，它表示一个数组，用法和 List 一样，数组中可以嵌套其他的 JSONObject 或是 JSONArray：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/index&quot;</span>)<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span> ();<br>    object.put (<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;杰哥&quot;</span>);<br>    object.put (<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-type">JSONArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONArray</span> ();<br>    array.add (object);<br>    System.out.println (array.toJSONString ());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;杰哥&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>当出现循环引用时，会按照以下语法来解析：<br><img src="https://s2.loli.net/2023/08/14/MjO4awH3X1YnlmR.png" alt="img"><br>我们可以也直接创建一个实体类，将实体类转换为 JSON 格式的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/index&quot;</span>, produces = <span class="hljs-string">&quot;application/json&quot;</span>)<br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">data</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>    student.setName (<span class="hljs-string">&quot;杰哥&quot;</span>);<br>    student.setAge (<span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">return</span> JSON.toJSONString (student);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们修改了 <code>produces</code> 的值，将返回的内容类型设定为 <code>application/json</code>，表示服务器端返回了一个 JSON 格式的数据（当然不设置也行，也能展示，这样是为了规范）然后我们在方法上添加一个 <code>@ResponseBody</code> 表示方法返回（也可以在类上添加 <code>@RestController</code> 表示此 Controller 默认返回的是字符串数据）的结果不是视图名称而是直接需要返回一个字符串作为页面数据，这样，返回给浏览器的就是我们直接返回的字符串内容。<br>接着我们使用 JSON 工具类将其转换为 JSON 格式的字符串，打开浏览器，得到 JSON 格式数据。<br>SpringMVC 非常智能，我们可以直接返回一个对象类型，它会被自动转换为 JSON 字符串格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/data&quot;</span>, produces = <span class="hljs-string">&quot;application/json&quot;</span>)<br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">data</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span> ();<br>    student.setName (<span class="hljs-string">&quot;杰哥&quot;</span>);<br>    student.setAge (<span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">return</span> student;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意需要在配置类中添加一下 FastJSON 转换器，这里需要先添加一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2-extension-spring6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后编写配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureMessageConverters</span> <span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br>    converters.add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">FastJsonHttpMessageConverter</span> ());<br>&#125;<br></code></pre></td></tr></table></figure><p>再次尝试，内容就会自动转换为 JSON 格式响应给客户端了。</p><h3 id="Axios-异步请求"><a href="#Axios-异步请求" class="headerlink" title="Axios 异步请求"></a>Axios 异步请求</h3><p>前面我们讲解了如何向浏览器发送一个 JSON 格式的数据，那么我们现在来看看如何向服务器请求数据。<br><img src="https://s2.loli.net/2023/08/14/faYcVC6dpIOuJyA.png" alt="img"><br>前端为什么需要用到异步请求，这是因为我们的网页是动态的（这里的动态不是指有动画效果，而是能够实时更新内容）比如我们点击一个按钮会弹出新的内容、或是跳转到新的页面、更新页面中的数据等等，这些都需要通过 JS 完成异步请求来实现。</p><blockquote><p>前端异步请求指的是在前端中发送请求至服务器或其他资源，并且不阻塞用户界面或其他操作。在传统的同步请求中，当发送请求时，浏览器会等待服务器响应，期间用户无法进行其他操作。而异步请求通过将请求发送到后台，在等待响应的同时，允许用户继续进行其他操作。这种机制能够提升用户体验，并且允许页面进行实时更新。常见的前端异步请求方式包括使用 XMLHttpRequest 对象、Fetch API、以及使用 jQuery 库中的 AJAX 方法，以及目前最常用的 Axios 框架等。</p></blockquote><p>假设我们后端有一个需要实时刷新的数据（随时间而变化）现在需要再前端实时更新展示，这里我们以 axios 框架的简单使用为例子，带各位小伙伴体验如何发起异步请求并更新我们页面中的数据。<br>首先是前端页面，直接抄作业就行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欢迎来到 GayHub 全球最大同性交友网站<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户名: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着我们使用 axios 框架直接对后端请求 JSON 数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInfo</span> () &#123;</span><br><span class="language-javascript">        axios.<span class="hljs-property">get</span> (<span class="hljs-string">&#x27;/mvc/test&#x27;</span>). then (<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">document</span>.<span class="hljs-property">getElementById</span> (<span class="hljs-string">&#x27;username&#x27;</span>). innerText = data. username</span><br><span class="language-javascript">            <span class="hljs-variable language_">document</span>.<span class="hljs-property">getElementById</span> (<span class="hljs-string">&#x27;password&#x27;</span>). innerText = data. password</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样，我们就实现了从服务端获取数据并更新到页面中，前端开发者利用 JS 发起异步请求，可以实现各种各样的效果，而我们后端开发者只需要关心接口返回正确的数据即可，这就已经有前后端分离开发的雏形了（实际上之前，我们在 JavaWeb 阶段使用 XHR 请求也演示过，不过当时是纯粹的数据）<br>那么我们接着来看，如何向服务端发送一个 JS 对象数据并进行解析，这里以简单的登录为例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欢迎来到 GayHub 全球最大同性交友网站<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;login()&quot;</span>&gt;</span>立即登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里依然使用 axios 发送 POST 请求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span> () &#123;</span><br><span class="language-javascript">        axios.<span class="hljs-property">post</span> (<span class="hljs-string">&#x27;/mvc/test&#x27;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;test&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span></span><br><span class="language-javascript">        &#125;, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">headers</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded &#x27;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;). then (<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (data. success) &#123;</span><br><span class="language-javascript">                alert (<span class="hljs-string">&#x27;登录成功&#x27;</span>)</span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">                alert (<span class="hljs-string">&#x27;登录失败&#x27;</span>)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>服务器端只需要在请求参数位置添加一个对象接收即可（和前面是一样的，因为这里也是提交的表单数据）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping</span> (value = <span class="hljs-string">&quot;/test&quot;</span>, produces = <span class="hljs-string">&quot;application/json&quot;</span>)<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span> <span class="hljs-params">(String username, String password)</span>&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>.equals (user.getUsername ()) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals (user.getPassword ());<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span> ();<br>    object.put (<span class="hljs-string">&quot;success&quot;</span>, success);<br>    <span class="hljs-keyword">return</span> object.toString ();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以将 js 对象转换为 JSON 字符串的形式进行传输，这里需要使用 ajax 方法来处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">login</span> () &#123;</span><br><span class="language-javascript">        axios.<span class="hljs-property">post</span> (<span class="hljs-string">&#x27;/mvc/test&#x27;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;test&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span></span><br><span class="language-javascript">        &#125;). then (<span class="hljs-function">(<span class="hljs-params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (data. success) &#123;</span><br><span class="language-javascript">                alert (<span class="hljs-string">&#x27;登录成功&#x27;</span>)</span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">                alert (<span class="hljs-string">&#x27;登录失败&#x27;</span>)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们需要读取前端发送给我们的 JSON 格式数据，那么这个时候就需要添加 <code>@RequestBody</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping</span> (value = <span class="hljs-string">&quot;/test&quot;</span>, produces = <span class="hljs-string">&quot;application/json&quot;</span>)<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span> <span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span>&#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>.equals (user.getUsername ()) &amp;&amp; <span class="hljs-string">&quot;123456&quot;</span>.equals (user.getPassword());<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    object.put (<span class="hljs-string">&quot;success&quot;</span>, success);<br>    <span class="hljs-keyword">return</span> object.toString ();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就实现了前后端使用 JSON 字符串进行通信。</p><blockquote><p>[!NOTE] Json 和Axios总结</p><ul><li>引入 json 格式化和自动转换器 xml 依赖</li><li><code>JsonObject</code> 为 map，<code>JsonArray</code> 为数组</li><li>调用 <code>toString</code> 方法变为 json 字符串</li><li>使用 <code>@RequestParam</code> 用于处理URL传参或表单传参</li><li>使用 <code>@RequestBody</code> 用于json或xml传参</li></ul></blockquote><hr><h2 id="实现文件上传和下载"><a href="#实现文件上传和下载" class="headerlink" title="实现文件上传和下载"></a>实现文件上传和下载</h2><p>利用 SpringMVC，我们可以很轻松地实现文件上传和下载，我们需要在 MainInitializer 中添加一个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;<br>    ...<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customizeRegistration</span> <span class="hljs-params">(ServletRegistration. Dynamic registration)</span> &#123;<br>      <span class="hljs-comment">// 直接通过 registration 配置 Multipart 相关配置，必须配置临时上传路径，建议选择方便打开的</span><br>        <span class="hljs-comment">// 同样可以设置其他属性：maxFileSize, maxRequestSize, fileSizeThreshold</span><br>        registration.setMultipartConfig (<span class="hljs-keyword">new</span> <span class="hljs-title class_">MultipartConfigElement</span> (<span class="hljs-string">&quot;/Users/nagocoler/Download&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们直接编写 Controller 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/upload&quot;</span>, method = RequestMethod. POST)<br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span> <span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> MultipartFile file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">fileObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;test. png&quot;</span>);<br>    file.transferTo (fileObj);<br>    System.out.println (<span class="hljs-string">&quot;用户上传的文件已保存到：&quot;</span>+fileObj.getAbsolutePath ());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;文件上传成功！&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在前端添加一个文件的上传点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;upload&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样，点击提交之后，文件就会上传到服务器了。<br>下载其实和我们之前的写法大致一样，直接使用 HttpServletResponse，并向输出流中传输数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (value = <span class="hljs-string">&quot;/download&quot;</span>, method = RequestMethod. GET)<br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">download</span> <span class="hljs-params">(HttpServletResponse response)</span>&#123;<br>    response.setContentType (<span class="hljs-string">&quot;multipart/form-data&quot;</span>);<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> response.getOutputStream ();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (<span class="hljs-string">&quot;test. png&quot;</span>))&#123;<br>        IOUtils.copy (inputStream, stream);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在前端页面中添加一个下载点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;download&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;test.png&quot;</span>&gt;</span>下载最新资源<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="解读-DispatcherServlet-源码"><a href="#解读-DispatcherServlet-源码" class="headerlink" title="解读 DispatcherServlet 源码"></a>解读 DispatcherServlet 源码</h2><p>注意：本部分作为选学内容！<br>到目前为止，关于 SpringMVC 的相关内容就学习得差不多了，但是我们在最后还是需要深入了解一下 DispatcherServlet 底层是如何进行调度的，因此，我们会从源码角度进行讲解。<br>首先我们需要找到 <code>DispatcherServlet</code> 的最顶层 <code>HttpServletBean</code>，在这里直接继承的 <code>HttpServlet</code>，那么我们首先来看一下，它在初始化方法中做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>  <span class="hljs-comment">//读取配置参数，并进行配置</span><br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServletBean</span>.ServletConfigPropertyValues (<span class="hljs-built_in">this</span>.getServletConfig (), <span class="hljs-built_in">this</span>. requiredProperties);<br>    <span class="hljs-keyword">if</span> (! pvs.isEmpty ()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> PropertyAccessorFactory.forBeanPropertyAccess (<span class="hljs-built_in">this</span>);<br>            <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextResourceLoader</span> (<span class="hljs-built_in">this</span>.getServletContext ());<br>            bw.registerCustomEditor (Resource. class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEditor</span> (resourceLoader, <span class="hljs-built_in">this</span>.getEnvironment ()));<br>            <span class="hljs-built_in">this</span>.initBeanWrapper (bw);<br>            bw.setPropertyValues (pvs, <span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (BeansException <span class="hljs-keyword">var</span> <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isErrorEnabled ()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.error (<span class="hljs-string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.getServletName () + <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-keyword">var</span> <span class="hljs-number">4</span>);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">var</span> <span class="hljs-number">4</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//此初始化阶段由子类实现，</span><br>    <span class="hljs-built_in">this</span>.initServletBean ();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看 <code>initServletBean ()</code> 方法是如何实现的，它是在子类 <code>FrameworkServlet</code> 中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initServletBean</span> <span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-built_in">this</span>.getServletContext (). log (<span class="hljs-string">&quot;Initializing Spring &quot;</span> + <span class="hljs-built_in">this</span>.getClass (). getSimpleName () + <span class="hljs-string">&quot; &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.getServletName () + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isInfoEnabled ()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.info (<span class="hljs-string">&quot;Initializing Servlet &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.getServletName () + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis ();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//注意：我们在一开始说了 SpringMVC 有两个容器，一个是 Web 容器一个是根容器</span><br>      <span class="hljs-comment">//Web 容器只负责 Controller 等表现层内容</span><br>      <span class="hljs-comment">//根容器就是 Spring 容器，它负责 Service、Dao 等，并且它是 Web 容器的父容器。</span><br>      <span class="hljs-comment">//初始化 WebApplicationContext，这个阶段会为根容器和 Web 容器进行父子关系建立</span><br>        <span class="hljs-built_in">this</span>. webApplicationContext = <span class="hljs-built_in">this</span>.initWebApplicationContext ();<br>        <span class="hljs-built_in">this</span>.initFrameworkServlet ();<br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException | ServletException <span class="hljs-keyword">var</span> <span class="hljs-number">4</span>) &#123;<br>      <span class="hljs-comment">//... 以下内容全是打印日志</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/30/6ZAyRrDw2QMU8Xv.png" alt="img"><br>我们来看看 <code>initWebApplicationContext</code> 是如何进行初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">initWebApplicationContext</span> <span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">//这里获取的是根容器，一般用于配置 Service、数据源等</span><br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">rootContext</span> <span class="hljs-operator">=</span> WebApplicationContextUtils.getWebApplicationContext (<span class="hljs-built_in">this</span>.getServletContext ());<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. webApplicationContext != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果 webApplicationContext 在之前已经存在，则直接给到 wac</span><br>        wac = <span class="hljs-built_in">this</span>. webApplicationContext;<br>        <span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;<br>            <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">cwac</span> <span class="hljs-operator">=</span> (ConfigurableWebApplicationContext) wac;<br>            <span class="hljs-keyword">if</span> (! cwac.isActive ()) &#123;<br>                <span class="hljs-keyword">if</span> (cwac.getParent () == <span class="hljs-literal">null</span>) &#123;<br>                  <span class="hljs-comment">//设定根容器为 Web 容器的父容器</span><br>                    cwac.setParent (rootContext);<br>                &#125;<br>                <span class="hljs-built_in">this</span>.configureAndRefreshWebApplicationContext (cwac);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果 webApplicationContext 是空，那么就从 ServletContext 找一下有没有初始化上下文</span><br>        wac = <span class="hljs-built_in">this</span>.findWebApplicationContext ();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//如果还是找不到，直接创个新的，并直接将根容器作为父容器</span><br>        wac = <span class="hljs-built_in">this</span>.createWebApplicationContext (rootContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (! <span class="hljs-built_in">this</span>. refreshEventReceived) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>. onRefreshMonitor) &#123;<br>          <span class="hljs-comment">//此方法由 DispatcherServlet 实现</span><br>            <span class="hljs-built_in">this</span>.onRefresh (wac);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. publishContext) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">attrName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContextAttributeName ();<br>      <span class="hljs-comment">//把 Web 容器丢进 ServletContext</span><br>        <span class="hljs-built_in">this</span>.getServletContext (). setAttribute (attrName, wac);<br>    &#125;<br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看 DispatcherServlet 中实现的 <code>onRefresh ()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRefresh</span> <span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    initStrategies (context);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initStrategies</span> <span class="hljs-params">(ApplicationContext context)</span> &#123;<br>  <span class="hljs-comment">//初始化各种解析器</span><br>    initMultipartResolver (context);<br>    initLocaleResolver (context);<br>    initThemeResolver (context);<br>  <span class="hljs-comment">//在容器中查找所有的 HandlerMapping，放入集合中</span><br>  <span class="hljs-comment">//HandlerMapping 保存了所有的请求映射信息（Controller 中定义的），它可以根据请求找到处理器 Handler，但并不是简单的返回处理器，而是将处理器和拦截器封装，形成一个处理器执行链（类似于之前的 Filter）</span><br>    initHandlerMappings (context);<br>  <span class="hljs-comment">//在容器中查找所有的 HandlerAdapter，它用于处理请求并返回 ModelAndView 对象</span><br>  <span class="hljs-comment">//默认有三种实现 HttpRequestHandlerAdapter，SimpleControllerHandlerAdapter 和 AnnotationMethodHandlerAdapter</span><br>  <span class="hljs-comment">//当 HandlerMapping 找到处理请求的 Controller 之后，会选择一个合适的 HandlerAdapter 处理请求</span><br>  <span class="hljs-comment">//比如我们之前使用的是注解方式配置 Controller，现在有一个请求携带了一个参数，那么 HandlerAdapter 会对请求的数据进行解析，并传入方法作为实参，最后根据方法的返回值将其封装为 ModelAndView 对象</span><br>    initHandlerAdapters (context);<br>  <span class="hljs-comment">//其他的内容</span><br>    initHandlerExceptionResolvers (context);<br>    initRequestToViewNameTranslator (context);<br>    initViewResolvers (context);<br>    initFlashMapManager (context);<br>&#125;<br></code></pre></td></tr></table></figure><p>DispatcherServlet 初始化过程我们已经了解了，那么我们接着来看 DispatcherServlet 是如何进行调度的，首先我们的请求肯定会经过 <code>HttpServlet</code>，然后其交给对应的 doGet、doPost 等方法进行处理，而在 <code>FrameworkServlet</code> 中，这些方法都被重写，并且使用 <code>processRequest</code> 来进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-built_in">this</span>.processRequest (request, response);<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-built_in">this</span>.processRequest (request, response);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看 <code>processRequest</code> 做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>  <span class="hljs-comment">//前期准备工作</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis ();<br>    <span class="hljs-type">Throwable</span> <span class="hljs-variable">failureCause</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">LocaleContext</span> <span class="hljs-variable">previousLocaleContext</span> <span class="hljs-operator">=</span> LocaleContextHolder.getLocaleContext ();<br>    <span class="hljs-type">LocaleContext</span> <span class="hljs-variable">localeContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.buildLocaleContext (request);<br>    <span class="hljs-type">RequestAttributes</span> <span class="hljs-variable">previousAttributes</span> <span class="hljs-operator">=</span> RequestContextHolder.getRequestAttributes ();<br>    <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.buildRequestAttributes (request, response, previousAttributes);<br>    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager (request);<br>    asyncManager.registerCallableInterceptor (FrameworkServlet.class.getName (), <span class="hljs-keyword">new</span> <span class="hljs-title class_">FrameworkServlet</span>.RequestBindingInterceptor ());<br>    <span class="hljs-built_in">this</span>.initContextHolders (request, localeContext, requestAttributes);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//重点在这里，这里进行了 Service 的执行，不过是在 DispatcherServlet 中定义的</span><br>        <span class="hljs-built_in">this</span>.doService (request, response);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException | ServletException <span class="hljs-keyword">var</span> <span class="hljs-number">16</span>) &#123;<br>        <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>请各位一定要耐心，这些大型框架的底层一般都是层层套娃，因为这样写起来层次会更加清晰，那么我们来看看 <code>DispatcherServlet</code> 中是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doService</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>   <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//重点在这里，这才是整个处理过程中最核心的部分</span><br>        <span class="hljs-built_in">this</span>.doDispatch (request, response);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>终于找到最核心的部分了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span> <span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager (request);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                processedRequest = <span class="hljs-built_in">this</span>.checkMultipart (request);<br>                multipartRequestParsed = processedRequest != request;<br>              <span class="hljs-comment">//在 HandlerMapping 集合中寻找可以处理当前请求的 HandlerMapping</span><br>                mappedHandler = <span class="hljs-built_in">this</span>.getHandler (processedRequest);<br>                <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.noHandlerFound (processedRequest, response);<br>                  <span class="hljs-comment">//找不到 HandlerMapping 则无法进行处理</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>              <span class="hljs-comment">//根据 HandlerMapping 提供的信息，找到可以处理的 HandlerAdapter</span><br>                <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getHandlerAdapter (mappedHandler.getHandler ());<br>                <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod ();<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> HttpMethod.GET.matches (method);<br>                <span class="hljs-keyword">if</span> (isGet || HttpMethod.HEAD.matches (method)) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified (request, mappedHandler.getHandler ());<br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span> (request, response)). checkNotModified (lastModified) &amp;&amp; isGet) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-comment">//执行所有拦截器的 preHandle ()方法</span><br>                <span class="hljs-keyword">if</span> (! mappedHandler.applyPreHandle (processedRequest, response)) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>              <span class="hljs-comment">//使用 HandlerAdapter 进行处理（我们编写的请求映射方法在这个位置才真正地执行了）</span><br>              <span class="hljs-comment">//HandlerAdapter 会帮助我们将请求的数据进行处理，再来调用我们编写的请求映射方法</span><br>              <span class="hljs-comment">//最后 HandlerAdapter 会将结果封装为 ModelAndView 返回给 mv</span><br>                mv = ha.handle (processedRequest, response, mappedHandler.getHandler ());<br>                <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted ()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-built_in">this</span>.applyDefaultViewName (processedRequest, mv);<br>              <span class="hljs-comment">//执行所有拦截器的 postHandle ()方法</span><br>                mappedHandler.applyPostHandle (processedRequest, response, mv);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception <span class="hljs-keyword">var</span> <span class="hljs-number">20</span>) &#123;<br>                dispatchException = <span class="hljs-keyword">var</span> <span class="hljs-number">20</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable <span class="hljs-keyword">var</span> <span class="hljs-number">21</span>) &#123;<br>                dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span> (<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, <span class="hljs-keyword">var</span> <span class="hljs-number">21</span>);<br>            &#125;<br>          <span class="hljs-comment">//最后处理结果，对视图进行渲染等，如果抛出异常会出现错误页面</span><br>            <span class="hljs-built_in">this</span>.processDispatchResult (processedRequest, response, mappedHandler, mv, (Exception) dispatchException);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception <span class="hljs-keyword">var</span> <span class="hljs-number">22</span>) &#123;<br>            <span class="hljs-built_in">this</span>.triggerAfterCompletion (processedRequest, response, mappedHandler, <span class="hljs-keyword">var</span> <span class="hljs-number">22</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable <span class="hljs-keyword">var</span> <span class="hljs-number">23</span>) &#123;<br>            <span class="hljs-built_in">this</span>.triggerAfterCompletion (processedRequest, response, mappedHandler, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span> (<span class="hljs-string">&quot;Handler processing failed&quot;</span>, <span class="hljs-keyword">var</span> <span class="hljs-number">23</span>));<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted ()) &#123;<br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                mappedHandler.applyAfterConcurrentHandlingStarted (processedRequest, response);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>            <span class="hljs-built_in">this</span>.cleanupMultipart (processedRequest);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，根据以上源码分析得出最终的流程图：<br><img src="https://s2.loli.net/2023/08/14/IzWB8LGjwo1DPml.png" alt="img"><br>虽然完成本章学习后，我们已经基本能够基于 Spring 去重新编写一个更加高级的图书管理系统了，但是登陆验证复杂的问题依然没有解决，如果我们依然按照之前的方式编写登陆验证，显然太过简单，它仅仅只是一个登陆，但是没有任何的权限划分或是加密处理，我们需要更加高级的权限校验框架来帮助我们实现登陆操作，下一章，我们会详细讲解如何使用更加高级的 SpringSecurity 框架来进行权限验证。</p><hr><h1 id="Spring-常用依赖"><a href="#Spring-常用依赖" class="headerlink" title="Spring 常用依赖"></a>Spring 常用依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        servlet--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        junit测试--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        springmvc--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        slf4j日志--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-jdk14<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        模板解析器--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        lombok--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        json格式化--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        json对象自动转换器--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2-extension-spring6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.34<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--        IO工具--&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- mybatis --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-comment">&lt;!-- 注意，对于Spring 6.0来说，版本需要在3.5以上 --&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- Mybatis针对于Spring专门编写的支持框架 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- Spring的JDBC支持框架 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://itbaima.net/<br>title: &quot;柏码 - 让每一行代码都闪耀智慧的光芒！&quot;<br>host: itbaima.net<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure><p><a href="https://itbaima.net/">柏码 - 让每一行代码都闪耀智慧的光芒！</a></p>]]></content>
    
    
    <summary type="html">Web—study about Spring(IOC,Di,AOP)</summary>
    
    
    
    <category term="Backend_development" scheme="https://alleyf.github.io/categories/Backend-development/"/>
    
    
    <category term="Spring" scheme="https://alleyf.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>后端开发学习</title>
    <link href="https://alleyf.github.io/2023/10/6cd2e75537d2.html"/>
    <id>https://alleyf.github.io/2023/10/6cd2e75537d2.html</id>
    <published>2023-10-08T05:29:26.000Z</published>
    <updated>2023-10-15T08:41:29.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://how2j.cn/">How2J 的 Java教程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://how2j.cn/<br>title: &quot;How2J 的 Java教程&quot;<br>description: &quot;How2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容。 基于实例代码和视频讲解的学习方式为Java职业生涯打下坚实的基础&quot;<br>host: how2j.cn<br></code></pre></td></tr></table></figure><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><p>从小到大自动转，从大到小强制转（精度丢失，值可能不正确）</p><blockquote><p>Java 中进行二元与运算类型的提升规则 </p><ol><li>整数运算： 如果两个操作数有一个为 long，则结果也为 long；没有 long 时，结果为 int。即使操作数全为 short、byte，结果也是 int。 </li><li>浮点运算： 如果两个操作数有一个为 double，则结果为 double；只有两个操作数都是 float，则结果才为 float。注意：int 与 float 运算，结果为 float。</li></ol></blockquote><h3 id="2-命名规则"><a href="#2-命名规则" class="headerlink" title="2. 命名规则"></a>2. 命名规则</h3><ul><li>变量命名只能使用<strong>字母数字 $ _</strong>  </li><li>变量第一个字符只能使用字母 $ _  </li><li>变量第一个字符不能使用数字，不能使用关键字  <blockquote><p>注：_ 是下划线，不是-减号或者—— 破折号</p></blockquote></li></ul><h2 id="java-关键字：-3-final-修饰词当形参被-final-修饰时不能对形参再次赋值，如果形参是对象可以改变内部的属性1-final-修饰类-当-final-修饰类时，该类无法被继承2-final-修饰方法-被-final-修饰的方法不能被重写3-final-修饰基本类型变量-当一个变量被-final-修饰的时候，该变量只有一次赋值的机会4-final-修饰引用-被-final-修饰的引用只能指向一次对象5-final-修饰常量-常量值不变"><a href="#java-关键字：-3-final-修饰词当形参被-final-修饰时不能对形参再次赋值，如果形参是对象可以改变内部的属性1-final-修饰类-当-final-修饰类时，该类无法被继承2-final-修饰方法-被-final-修饰的方法不能被重写3-final-修饰基本类型变量-当一个变量被-final-修饰的时候，该变量只有一次赋值的机会4-final-修饰引用-被-final-修饰的引用只能指向一次对象5-final-修饰常量-常量值不变" class="headerlink" title="java 关键字：### 3. final 修饰词当形参被 final 修饰时不能对形参再次赋值，如果形参是对象可以改变内部的属性1. final 修饰类   - 当 final 修饰类时，该类无法被继承2. final 修饰方法   - 被 final 修饰的方法不能被重写3. final 修饰基本类型变量   - 当一个变量被 final 修饰的时候，该变量只有一次赋值的机会4. final 修饰引用   - 被 final 修饰的引用只能指向一次对象5. final 修饰常量   - 常量值不变"></a>java 关键字：<br><img src="https://stepimagewm.how2j.cn/523.png" alt="|300"><br><img src="https://stepimagewm.how2j.cn/522.png" alt="|300"><br>### 3. final 修饰词<br>当形参被 final 修饰时不能对形参再次赋值，如果形参是对象可以改变内部的属性<br>1. final 修饰类<br>   - 当 final 修饰类时，该类无法被继承<br>2. final 修饰方法<br>   - 被 final 修饰的方法不能被重写<br>3. final 修饰基本类型变量<br>   - 当一个变量被 final 修饰的时候，该变量只有一次赋值的机会<br>4. final 修饰引用<br>   - 被 final 修饰的引用只能指向一次对象<br>5. final 修饰常量<br>   - 常量值不变</h2><h3 id="4-操作符-Scanner"><a href="#4-操作符-Scanner" class="headerlink" title="4. 操作符 Scanner"></a>4. 操作符 Scanner</h3><p>使用 Scanner 类，需要在最前面加上<br><code>import java.util.Scanner;</code></p><blockquote><p>如果在通过 <code>nextInt()</code> 读取了整数后，再接着读取字符串，读出来的是回车换行: <strong>“\r\n”</strong>, 因为 nextInt 仅仅读取数字信息，而不会读取回车换行”\r\n”.<br>    所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该**连续执行两次 nextLine ()**，第一次是取走回车换行，第二次才是读取真正的字符串</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;读取的整数是&quot;</span>+ i);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rn</span> <span class="hljs-operator">=</span> s.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> s.nextLine();<br>        System.out.println(<span class="hljs-string">&quot;读取的字符串是：&quot;</span>+a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h3><p>数组是一个<strong>固定长度</strong>，包含了<strong>相同类型数据</strong>的<strong>容器</strong><br><code>int[] a; 和 int a[]</code> 都声明了一个数组变量，仅仅声明并没有创建分配空间。<br>创建一个长度是 5 的数组，并且使用<strong>引用 a 指向该数组</strong>，a 是一个地址，占据 <strong>4</strong> 个字节<br><code>a = new int[5];</code><br>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String Arrays.toString(数组)                 将数组拼接成一个字符串<br><span class="hljs-type">int</span> Arrays.binarySearch(数组，查找的元素)            二分法查护元素<br><span class="hljs-type">int</span>[] Arrays.copyOf(原数组，新数组长度)              拷贝数组<br><span class="hljs-type">int</span>[]Arrays.copyOfRange(原数组，起始索引，结束索引)   拷贝数组（指定范围）<br><span class="hljs-keyword">void</span> Arrays.fill(数组，元素)                        使用同一元素填充数组<br><span class="hljs-keyword">void</span> Arrays.sort(数组)                              对数组进行排序，也可按照自己自定义的规则<br><span class="hljs-type">boolean</span> Arrays.equals(数组a，数组b)                  返回两个数组是否元素相等的结果<br></code></pre></td></tr></table></figure><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;  <br><span class="hljs-keyword">import</span> java.util.Comparator;  <br><span class="hljs-keyword">import</span> java.util.Random;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">//声明一个引用  </span><br>        Integer[] a;  <br>        <span class="hljs-comment">//创建一个长度是5的数组，并且使用引用a指向该数组  </span><br>        a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">5</span>];  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            a[i]= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>);  <br>        &#125;  <br>        Arrays.sort(a,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;()&#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1,Integer o2)</span> &#123;  <br>                <span class="hljs-comment">// 降序  </span><br>                <span class="hljs-keyword">return</span> o2-o1;  <br>        &#125;&#125;);  <br>        System.out.println(Arrays.toString(a));  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>分配空间，同时赋值<br>写法一： 分配空间同时赋值<br><code>int[] a = new int[]&#123;100,102,444,836,3236&#125;;</code></p><p>写法二： 省略了 new int[], 效果一样<br><code>int[] b = &#123;100,102,444,836,3236&#125;;</code></p></blockquote><h2 id="数组排序：增强型-for-循环遍历-二维数组-6-类和对象-引用引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。Hero-h-new-Hero-引用-h-指向-Hero-对象-多个引用指向同一个对象-一个引用只能指向一个对象-7-包-package-把比较接近的类，规划在同一个包下-在最开始的地方声明该类所处于的包名-使用同一个包下的其他类，直接使用即可-但是要使用其他包下的类，必须-import-8-访问修饰符成员变量有四种修饰符：1-private-私有的-2-package-friendly-default-不写-3-protected-受保护的-4-public-公共的-NOTE-那么什么情况该用什么修饰符呢？-从作用域来看，public-能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用-public-那么到底什么情况该用什么修饰符呢？-1-属性通常使用-private-封装起来-2-方法一般使用-public-用于被调用-3-会被子类继承的方法，通常使用-protected-4-package-用的不多，一般新手会用-package-因为还不知道有修饰符这个东西-再就是作用范围最小原则-简单说，能用-private-就用-private，不行就放大一级，用-package-再不行就用-protected，最后用-public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了-9-类属性（static-变量）1-当一个属性被-static-修饰的时候，就叫做类属性，又叫做静态属性2-当一个属性被声明成类属性，那么所有的对象，都共享一个值访问方式：1-对象-类属性2-类-类属性对象属性初始化：1-声明该属性的时候初始化2-构造方法中初始化3-初始化块静态属性初始化：1-声明该属性的时候初始化2-静态初始化块-初始化顺序：静态属性声明-静态初始化块-对象属性声明-对象属性初始化块-构造方法-10-类方法（static-方法）-类方法：-又叫做静态方法-对象方法：-又叫实例方法，非静态方法-访问一个对象方法，必须建立在有一个对象的前提的基础上-访问类方法，不需要对象的存在，直接就访问-静态方法只能调用静态方法和静态属性，不能调用对象属性和方法-11-单例模式单例模式又叫做-Singleton-模式，指的是一个类，在一个-JVM-里，只有一个实例存在。单例模式的设计目的是确保一个类只有一个实例，并提供全局访问点以供其他对象使用。因此，在传统的单例模式中，不允许继承该类，因为继承会导致类的实例数量增多。-饿汉式单例模式单例模式的类应该只有一个示例，通过私有化其构造方法，使得外部无法通过-new-得到新的实例。这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例-懒汉式单例模式懒汉式单例模式与饿汉式单例模式不同，只有在调用-getInstance-的时候，才会创建实例-NOTE-什么时候使用饿汉式，什么时候使用懒汉式？-饿汉式，是立即加载的方式，无论是否会用到这个对象，都会加载。-如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。-懒汉式，是延迟加载的方式，只有使用的时候才会加载。并且有线程安全的考量-鉴于同学们学习的进度，暂时不对线程的章节做展开-。-使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。-看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式-单例模式的三要素什么是单例模式？1-构造方法私有化2-静态属性指向实例3-public-static-的-getInstance-方法，返回第二步的静态属性-12-枚举（enum）枚举-enum-是一种特殊的类-还是类-，使用枚举可以很方便的定义常量eg：借助增强型-for-循环，可以很方便的遍历一个枚举都有哪些常量："><a href="#数组排序：增强型-for-循环遍历-二维数组-6-类和对象-引用引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。Hero-h-new-Hero-引用-h-指向-Hero-对象-多个引用指向同一个对象-一个引用只能指向一个对象-7-包-package-把比较接近的类，规划在同一个包下-在最开始的地方声明该类所处于的包名-使用同一个包下的其他类，直接使用即可-但是要使用其他包下的类，必须-import-8-访问修饰符成员变量有四种修饰符：1-private-私有的-2-package-friendly-default-不写-3-protected-受保护的-4-public-公共的-NOTE-那么什么情况该用什么修饰符呢？-从作用域来看，public-能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用-public-那么到底什么情况该用什么修饰符呢？-1-属性通常使用-private-封装起来-2-方法一般使用-public-用于被调用-3-会被子类继承的方法，通常使用-protected-4-package-用的不多，一般新手会用-package-因为还不知道有修饰符这个东西-再就是作用范围最小原则-简单说，能用-private-就用-private，不行就放大一级，用-package-再不行就用-protected，最后用-public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了-9-类属性（static-变量）1-当一个属性被-static-修饰的时候，就叫做类属性，又叫做静态属性2-当一个属性被声明成类属性，那么所有的对象，都共享一个值访问方式：1-对象-类属性2-类-类属性对象属性初始化：1-声明该属性的时候初始化2-构造方法中初始化3-初始化块静态属性初始化：1-声明该属性的时候初始化2-静态初始化块-初始化顺序：静态属性声明-静态初始化块-对象属性声明-对象属性初始化块-构造方法-10-类方法（static-方法）-类方法：-又叫做静态方法-对象方法：-又叫实例方法，非静态方法-访问一个对象方法，必须建立在有一个对象的前提的基础上-访问类方法，不需要对象的存在，直接就访问-静态方法只能调用静态方法和静态属性，不能调用对象属性和方法-11-单例模式单例模式又叫做-Singleton-模式，指的是一个类，在一个-JVM-里，只有一个实例存在。单例模式的设计目的是确保一个类只有一个实例，并提供全局访问点以供其他对象使用。因此，在传统的单例模式中，不允许继承该类，因为继承会导致类的实例数量增多。-饿汉式单例模式单例模式的类应该只有一个示例，通过私有化其构造方法，使得外部无法通过-new-得到新的实例。这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例-懒汉式单例模式懒汉式单例模式与饿汉式单例模式不同，只有在调用-getInstance-的时候，才会创建实例-NOTE-什么时候使用饿汉式，什么时候使用懒汉式？-饿汉式，是立即加载的方式，无论是否会用到这个对象，都会加载。-如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。-懒汉式，是延迟加载的方式，只有使用的时候才会加载。并且有线程安全的考量-鉴于同学们学习的进度，暂时不对线程的章节做展开-。-使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。-看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式-单例模式的三要素什么是单例模式？1-构造方法私有化2-静态属性指向实例3-public-static-的-getInstance-方法，返回第二步的静态属性-12-枚举（enum）枚举-enum-是一种特殊的类-还是类-，使用枚举可以很方便的定义常量eg：借助增强型-for-循环，可以很方便的遍历一个枚举都有哪些常量：" class="headerlink" title="数组排序：增强型 for 循环遍历#### 二维数组### 6. 类和对象#### 引用引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。Hero h = new Hero();&gt; 引用 h 指向 Hero 对象&gt; 多个引用指向同一个对象&gt; 一个引用只能指向一个对象### 7. 包 (package)- 把比较接近的类，规划在同一个包下- 在最开始的地方声明该类所处于的包名- 使用同一个包下的其他类，直接使用即可- 但是要使用其他包下的类，必须 import### 8. 访问修饰符成员变量有四种修饰符：1. private 私有的  2. package&#x2F;friendly&#x2F;default 不写  3. protected 受保护的  4. public 公共的&gt; [!NOTE]&gt; 那么什么情况该用什么修饰符呢？&gt; 从作用域来看，public 能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用 public, 那么到底什么情况该用什么修饰符呢？&gt;&gt; 1. 属性通常使用 private 封装起来&gt; 2. 方法一般使用 public 用于被调用&gt; 3. 会被子类继承的方法，通常使用 protected&gt; 4. package 用的不多，一般新手会用 package, 因为还不知道有修饰符这个东西&gt;&gt; 再就是作用范围最小原则&gt; 简单说，能用 private 就用 private，不行就放大一级，用 package, 再不行就用 protected，最后用 public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了### 9. 类属性（static 变量）1. 当一个属性被 static 修饰的时候，就叫做类属性，又叫做静态属性2. 当一个属性被声明成类属性，那么所有的对象，都共享一个值访问方式：1. 对象. 类属性2. 类. 类属性对象属性初始化：1. 声明该属性的时候初始化2. 构造方法中初始化3. 初始化块静态属性初始化：1. 声明该属性的时候初始化2. 静态初始化块&gt; 初始化顺序：静态属性声明&gt;静态初始化块&gt;对象属性声明&gt;对象属性初始化块&gt;构造方法### 10. 类方法（static 方法）- 类方法： 又叫做静态方法- 对象方法： 又叫实例方法，非静态方法&gt; 访问一个对象方法，必须建立在有一个对象的前提的基础上&gt; 访问类方法，不需要对象的存在，直接就访问&gt; 静态方法只能调用静态方法和静态属性，不能调用对象属性和方法### 11. 单例模式单例模式又叫做 Singleton 模式，指的是一个类，在一个 JVM 里，只有一个实例存在。单例模式的设计目的是确保一个类只有一个实例，并提供全局访问点以供其他对象使用。因此，在传统的单例模式中，不允许继承该类，因为继承会导致类的实例数量增多。#### 饿汉式单例模式单例模式的类应该只有一个示例，通过私有化其构造方法，使得外部无法通过 new 得到新的实例。这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例#### 懒汉式单例模式懒汉式单例模式与饿汉式单例模式不同，只有在调用 getInstance 的时候，才会创建实例&gt; [!NOTE]&gt; 什么时候使用饿汉式，什么时候使用懒汉式？&gt; 饿汉式，是立即加载的方式，无论是否会用到这个对象，都会加载。&gt; 如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。&gt;&gt; 懒汉式，是延迟加载的方式，只有使用的时候才会加载。并且有线程安全的考量 (鉴于同学们学习的进度，暂时不对线程的章节做展开)。&gt; 使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。&gt;&gt; 看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式#### 单例模式的三要素什么是单例模式？1. 构造方法私有化2. 静态属性指向实例3. public static 的 getInstance 方法，返回第二步的静态属性### 12. 枚举（enum）枚举 enum 是一种特殊的类 (还是类)，使用枚举可以很方便的定义常量eg：借助增强型 for 循环，可以很方便的遍历一个枚举都有哪些常量："></a>数组排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySort</span> &#123;  <br>    <span class="hljs-type">int</span> [] a;  <br>    MySort(<span class="hljs-type">int</span> []array )&#123;  <br>        <span class="hljs-built_in">this</span>.a = array;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ChoseSort</span><span class="hljs-params">(<span class="hljs-type">int</span> [] array)</span>&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; array.length; j++) &#123;  <br>                <span class="hljs-keyword">if</span> (array[i]&gt; array[j]) &#123;  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];  <br>                    array[i] = array[j];  <br>                    array[j] = temp;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> [] array)</span>&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; array.length-<span class="hljs-number">1</span>-i; j++) &#123;  <br>                <span class="hljs-keyword">if</span> (array[j]&gt; array[j+<span class="hljs-number">1</span>]) &#123;  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[j];  <br>                    array[j] = array[j+<span class="hljs-number">1</span>];  <br>                    array[j+<span class="hljs-number">1</span>] = temp;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MySort</span> <span class="hljs-variable">sort</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySort</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);  <br>        sort.ChoseSort(sort.a);  <br>        sort.BubbleSort(sort.a);  <br>        System.out.println(Arrays.toString(sort.a));  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><br>增强型 for 循环遍历<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> each : values) &#123;<br>    System.out.println (each);<br>&#125;<br></code></pre></td></tr></table></figure><br>#### 二维数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化二维数组，</span><br>     <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]; <span class="hljs-comment">//有两个一维数组，每个一维数组的长度是3</span><br>     a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;  <span class="hljs-comment">//可以直接访问一维数组，因为已经分配了空间</span><br>     <span class="hljs-comment">//只分配了二维数组</span><br>     <span class="hljs-type">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][]; <span class="hljs-comment">//有两个一维数组，每个一维数组的长度暂未分配</span><br>     b[<span class="hljs-number">0</span>]  =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">//必须事先分配长度，才可以访问</span><br>     b[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;<br>     <span class="hljs-comment">//指定内容的同时，分配空间</span><br>     <span class="hljs-type">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>             &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;,<br>             &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,<br>             &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br>     &#125;;<br></code></pre></td></tr></table></figure><br>### 6. 类和对象<br>#### 引用<br>引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。<br><code>Hero h = new Hero();</code><br><img src="https://stepimagewm.how2j.cn/618.png"><br>&gt; 引用 h 指向 Hero 对象<br><img src="https://stepimagewm.how2j.cn/617.png"><br>&gt; 多个引用指向同一个对象<br><img src="https://stepimagewm.how2j.cn/619.png"><br>&gt; 一个引用只能指向一个对象<br>### 7. 包 (package)<br>- 把比较接近的类，规划在同一个包下<br>- 在最开始的地方声明该类所处于的包名<br>- 使用同一个包下的其他类，直接使用即可<br>- 但是要使用其他包下的类，必须 import<br>### 8. 访问修饰符<br>成员变量有四种修饰符：<br><span style="background:rgba(240, 200, 0, 0.2)">1. private 私有的  </span><br><span style="background:rgba(240, 200, 0, 0.2)">2. package&#x2F;friendly&#x2F;default 不写  </span><br><span style="background:rgba(240, 200, 0, 0.2)">3. protected 受保护的  </span><br><span style="background:rgba(240, 200, 0, 0.2)">4. public 公共的</span><br><img src="https://stepimagewm.how2j.cn/604.png"><br><img src="https://stepimagewm.how2j.cn/610.png"><br><img src="https://stepimagewm.how2j.cn/611.png"><br><img src="https://stepimagewm.how2j.cn/612.png"><br>&gt; [!NOTE]<br>&gt; 那么什么情况该用什么修饰符呢？<br>&gt; 从作用域来看，public 能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用 public, 那么到底什么情况该用什么修饰符呢？<br>&gt;<br>&gt; 1. 属性通常使用 private 封装起来<br>&gt; 2. 方法一般使用 public 用于被调用<br>&gt; 3. 会被子类继承的方法，通常使用 protected<br>&gt; 4. package 用的不多，一般新手会用 package, 因为还不知道有修饰符这个东西<br>&gt;<br>&gt; 再就是作用范围最小原则<br>&gt; 简单说，能用 private 就用 private，不行就放大一级，用 package, 再不行就用 protected，最后用 public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了<br>### 9. 类属性（static 变量）<br>1. 当一个属性被 <strong>static</strong> 修饰的时候，就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong><br>2. 当一个属性被声明成类属性，那么<strong>所有的对象，都共享一个值</strong><br>访问方式：<br>1. 对象. 类属性<br>2. 类. 类属性<br>对象属性初始化：<br>1. 声明该属性的时候初始化<br>2. 构造方法中初始化<br>3. 初始化块<br>静态属性初始化：<br>1. 声明该属性的时候初始化<br>2. 静态初始化块<br>&gt; 初始化顺序：<font color="#ff0000">静态属性声明&gt;静态初始化块&gt;对象属性声明&gt;对象属性初始化块&gt;构造方法</font><br>### 10. 类方法（static 方法）<br>- 类方法： 又叫做<strong>静态方法</strong><br>- 对象方法： 又叫<strong>实例方法</strong>，非静态方法<br>&gt; 访问一个对象方法，必须建立在<strong>有一个对象的前提</strong>的基础上<br>&gt; 访问类方法，不需要对象的存在，直接就访问<br>&gt; 静态方法只能调用静态方法和静态属性，不能调用对象属性和方法<br>### 11. 单例模式<br>单例模式又叫做 Singleton 模式，指的是一个类，在一个 JVM 里，<strong>只有一个实例存在</strong>。<br><em>单例模式的设计目的是确保一个类只有一个实例，并提供全局访问点以供其他对象使用。因此，在传统的单例模式中，不允许继承该类，因为继承会导致类的实例数量增多。</em><br>#### 饿汉式单例模式<br>单例模式的类应该只有一个示例，通过<strong>私有化其构造方法</strong>，使得外部无法通过 new 得到新的实例。<br>这种单例模式又叫做<em>饿汉式单例模式</em>，无论如何都会创建一个实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GiantDragon</span> &#123;<br>    <span class="hljs-comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">GiantDragon</span><span class="hljs-params">()</span>&#123;<br>&#125;<br><span class="hljs-comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">GiantDragon</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GiantDragon</span>();<br><span class="hljs-comment">//public static 方法，提供给调用者获取12行定义的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GiantDragon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>#### 懒汉式单例模式<br><strong>懒汉式</strong>单例模式与<strong>饿汉式</strong>单例模式不同，只有在调用 getInstance 的时候，才会创建实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GiantDragon</span> &#123;<br>    <span class="hljs-comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">GiantDragon</span><span class="hljs-params">()</span>&#123;        <br>    &#125;<br>    <span class="hljs-comment">//准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GiantDragon instance;<br>    <span class="hljs-comment">//public static 方法，返回实例对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GiantDragon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span>==instance)&#123;<br>    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GiantDragon</span>();<br>    &#125;<br>    <span class="hljs-comment">//返回 instance指向的对象</span><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>&gt; [!NOTE]<br>&gt; <strong>什么时候使用饿汉式，什么时候使用懒汉式？</strong><br>&gt; 饿汉式，是<strong>立即加载</strong>的方式，无论是否会用到这个对象，都会加载。<br>&gt; 如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。<br>&gt;<br>&gt; 懒汉式，是<strong>延迟加载</strong>的方式，只有使用的时候才会加载。并且有线程安全的考量 (鉴于同学们学习的进度，暂时不对线程的章节做展开)。<br>&gt; 使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。<br>&gt;<br>&gt; 看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式<br>#### 单例模式的三要素<br>什么是单例模式？<br>1. 构造方法私有化<br>2. 静态属性指向实例<br>3. public static 的 getInstance 方法，返回第二步的静态属性<br>### 12. 枚举（enum）<br>枚举 enum 是一种特殊的类 (还是类)，使用枚举可以很方便的定义常量<br>eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> &#123;<br>SPRING,SUMMER,AUTUMN,WINTER<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Season</span> <span class="hljs-variable">season</span> <span class="hljs-operator">=</span> Season.SPRING;<br><span class="hljs-keyword">switch</span> (season) &#123;<br><span class="hljs-keyword">case</span> SPRING:<br>System.out.println(<span class="hljs-string">&quot;春天&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SUMMER:<br>System.out.println(<span class="hljs-string">&quot;夏天&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> AUTUMN:<br>System.out.println(<span class="hljs-string">&quot;秋天&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WINTER:<br>System.out.println(<span class="hljs-string">&quot;冬天&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>借助增强型 for 循环，可以很方便的遍历一个枚举都有哪些常量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">for</span> (Season s : Season.values()) &#123;<br>System.out.println(s);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></h2><h3 id="13-接口与继承"><a href="#13-接口与继承" class="headerlink" title="13. 接口与继承"></a>13. 接口与继承</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h2 id="接口就像是一种约定，对类进行约束规范，便于顶层设计规范化eg：-对象转型-子类转父类（向上转型）引用类型和对象类型不一致时，需要进行类型转换，类型转换有时候会成功，有时候会失败。转换是否成功判别方法：把右边的当做左边来用，看是否能说通-子类向父类转型（向上转型）一般都是可以的，父类引用指向子类对象-父类转子类-向下转型-父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。强制转换的意思就是转换有风险，风险自担。转换总结：-10-行：-把-ad-当做-Hero-使用，一定可以，转换之后，h-引用指向一个-ad-对象-11-行：-h-引用有可能指向一个-ad-对象，也有可能指向一个-support-对象，所以把-h-引用转换成-AD-类型的时候，就有可能成功，有可能失败，因此要进行强制转换，换句话说转换后果自负，到底能不能转换成功，要看引用-h-到底指向的是哪种对象-在这个例子里，h-指向的是一个-ad-对象，所以转换成-ADHero-类型，是可以的-12-行：把一个-support-对象当做-Hero-使用，一定可以，转换之后，h-引用指向一个-support-对象-13-行：这个时候，h-指向的是一个-support-对象，所以转换成-ADHero-类型，会失败。失败的表现形式是抛出异常-ClassCastException-类型转换异常-NOTE-没有继承关系的两个类，互相转换一定会失败，抛出异常-实现类转换成接口-向上转型-类似于子类转父类，一样可行。-接口转换成实现类-向下转型-7-行：-ad-引用指向-ADHero，而-adi-引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功-8-行-adi-实际上是指向一个-ADHero-的，所以能够转换成功-9-行：-adi-引用所指向的对象是一个-ADHero，要转换为-ADAPHero-就会失败。-instanceofa-instanceof-className-判断一个引用所指向的对象，是否是类的对象，或者子类的对象。-重写子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖-override-调用子类的方法首先调用重写的方法，如果没有再调用父类方法。"><a href="#接口就像是一种约定，对类进行约束规范，便于顶层设计规范化eg：-对象转型-子类转父类（向上转型）引用类型和对象类型不一致时，需要进行类型转换，类型转换有时候会成功，有时候会失败。转换是否成功判别方法：把右边的当做左边来用，看是否能说通-子类向父类转型（向上转型）一般都是可以的，父类引用指向子类对象-父类转子类-向下转型-父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。强制转换的意思就是转换有风险，风险自担。转换总结：-10-行：-把-ad-当做-Hero-使用，一定可以，转换之后，h-引用指向一个-ad-对象-11-行：-h-引用有可能指向一个-ad-对象，也有可能指向一个-support-对象，所以把-h-引用转换成-AD-类型的时候，就有可能成功，有可能失败，因此要进行强制转换，换句话说转换后果自负，到底能不能转换成功，要看引用-h-到底指向的是哪种对象-在这个例子里，h-指向的是一个-ad-对象，所以转换成-ADHero-类型，是可以的-12-行：把一个-support-对象当做-Hero-使用，一定可以，转换之后，h-引用指向一个-support-对象-13-行：这个时候，h-指向的是一个-support-对象，所以转换成-ADHero-类型，会失败。失败的表现形式是抛出异常-ClassCastException-类型转换异常-NOTE-没有继承关系的两个类，互相转换一定会失败，抛出异常-实现类转换成接口-向上转型-类似于子类转父类，一样可行。-接口转换成实现类-向下转型-7-行：-ad-引用指向-ADHero，而-adi-引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功-8-行-adi-实际上是指向一个-ADHero-的，所以能够转换成功-9-行：-adi-引用所指向的对象是一个-ADHero，要转换为-ADAPHero-就会失败。-instanceofa-instanceof-className-判断一个引用所指向的对象，是否是类的对象，或者子类的对象。-重写子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖-override-调用子类的方法首先调用重写的方法，如果没有再调用父类方法。" class="headerlink" title="接口就像是一种约定，对类进行约束规范，便于顶层设计规范化eg：#### 对象转型##### 子类转父类（向上转型）引用类型和对象类型不一致时，需要进行类型转换，类型转换有时候会成功，有时候会失败。转换是否成功判别方法：把右边的当做左边来用，看是否能说通&gt; 子类向父类转型（向上转型）一般都是可以的，父类引用指向子类对象##### 父类转子类 (向下转型)父类转子类，有的时候行，有的时候不行，所以必须进行强制转换。强制转换的意思就是转换有风险，风险自担。转换总结：&gt; 10 行： 把 ad 当做 Hero 使用，一定可以，转换之后，h 引用指向一个 ad 对象&gt; 11 行： h 引用有可能指向一个 ad 对象，也有可能指向一个 support 对象，所以把 h 引用转换成 AD 类型的时候，就有可能成功，有可能失败，因此要进行强制转换，换句话说转换后果自负，到底能不能转换成功，要看引用 h 到底指向的是哪种对象&gt; 在这个例子里，h 指向的是一个 ad 对象，所以转换成 ADHero 类型，是可以的&gt; 12 行：把一个 support 对象当做 Hero 使用，一定可以，转换之后，h 引用指向一个 support 对象&gt; 13 行：这个时候，h 指向的是一个 support 对象，所以转换成 ADHero 类型，会失败。失败的表现形式是抛出异常 ClassCastException 类型转换异常&gt; [!NOTE]&gt; &gt; 没有继承关系的两个类，互相转换一定会失败，抛出异常##### 实现类转换成接口 (向上转型)类似于子类转父类，一样可行。##### 接口转换成实现类 (向下转型)&gt; 7 行： ad 引用指向 ADHero，而 adi 引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功&gt; 8 行: adi 实际上是指向一个 ADHero 的，所以能够转换成功&gt; 9 行： adi 引用所指向的对象是一个 ADHero，要转换为 ADAPHero 就会失败。##### instanceofa instanceof className 判断一个引用所指向的对象，是否是类的对象，或者子类的对象。#### 重写子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖 override&gt; 调用子类的方法首先调用重写的方法，如果没有再调用父类方法。"></a>接口就像是一种约定，对类进行约束规范，便于顶层设计规范化<br>eg：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Healer</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">heal</span><span class="hljs-params">(<span class="hljs-type">int</span> healAmount)</span>;  <br>&#125;<br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Support</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Healer</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heal</span><span class="hljs-params">(<span class="hljs-type">int</span> healAmount)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.setHp(<span class="hljs-built_in">this</span>.getHp() + healAmount);  <br>        System.out.println(<span class="hljs-string">&quot;当前英雄的血量为&quot;</span> + <span class="hljs-built_in">this</span>.getHp() + <span class="hljs-string">&quot;点&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><br>#### 对象转型<br>##### 子类转父类（向上转型）<br>引用类型和对象类型不一致时，需要进行类型转换，类型转换有时候会成功，有时候会失败。<br><em>转换是否成功判别方法：<strong>把右边的当做左边来用，看是否能说通</strong></em><br>&gt; 子类向父类转型（向上转型）一般都是可以的，父类引用指向子类对象<br><img src="https://stepimagewm.how2j.cn/624.png"><br>##### 父类转子类 (向下转型)<br>父类转子类，有的时候行，有的时候不行，所以必须进行<strong>强制转换</strong>。强制转换的意思就是转换有风险，风险自担。<br>转换总结：<br><img src="https://stepimagewm.how2j.cn/625.png"><br>&gt; 10 行： 把 ad 当做 Hero 使用，一定可以，转换之后，h 引用指向一个 ad 对象<br>&gt; 11 行： h 引用有可能指向一个 ad 对象，也有可能指向一个 support 对象，所以把 h 引用转换成 AD 类型的时候，就有可能成功，有可能失败，因此要进行强制转换，换句话说转换后果自负，到底能不能转换成功，要看引用 h 到底指向的是哪种对象<br>&gt; 在这个例子里，<strong>h 指向的是一个 ad 对象</strong>，所以转换成 ADHero 类型，是可以的<br>&gt; 12 行：把一个 support 对象当做 Hero 使用，一定可以，转换之后，<strong>h 引用指向一个 support 对象</strong><br>&gt; 13 行：这个时候，h 指向的是一个 <strong>support</strong> 对象，所以转换成 <strong>ADHero</strong> 类型，会失败。失败的表现形式是抛出异常 ClassCastException 类型转换异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">import</span> charactor1.Support;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        <span class="hljs-type">ADHero</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span>();<br>        <span class="hljs-type">Support</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Support</span>();<br>        h = ad;<br>        ad = (ADHero) h;<br>        h = s;<br>        ad = (ADHero)h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>&gt; [!NOTE]<br>&gt; <img src="https://stepimagewm.how2j.cn/626.png"><br>&gt; <strong>没有继承关系</strong>的两个类，互相转换一定会失败，抛出异常<br>##### 实现类转换成接口 (向上转型)<br>类似于子类转父类，一样可行。<br><img src="https://stepimagewm.how2j.cn/627.png"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ADHero</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span>();<br>        <span class="hljs-type">AD</span> <span class="hljs-variable">adi</span> <span class="hljs-operator">=</span> ad;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>##### 接口转换成实现类 (向下转型)<br><img src="https://stepimagewm.how2j.cn/628.png"><br>&gt; 7 行： ad 引用指向 ADHero，而 adi 引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功<br>&gt; 8 行: <strong>adi</strong> 实际上是<strong>指向</strong>一个 <strong>ADHero</strong> 的，所以能够转换成功<br>&gt; 9 行： adi 引用所指向的对象是一个 ADHero，要转换为 ADAPHero 就会失败。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ADHero</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span>();<br>        <span class="hljs-type">AD</span> <span class="hljs-variable">adi</span> <span class="hljs-operator">=</span> ad;<br>        <span class="hljs-type">ADHero</span> <span class="hljs-variable">adHero</span> <span class="hljs-operator">=</span> (ADHero) adi;<br>        <span class="hljs-type">ADAPHero</span> <span class="hljs-variable">adapHero</span> <span class="hljs-operator">=</span> (ADAPHero) adi;<br>        adapHero.magicAttack();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>##### instanceof<br><code>a instanceof className</code> 判断一个引用所指向的对象，是否是类的对象，或者子类的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ADHero</span> <span class="hljs-variable">ad</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span>();<br>        <span class="hljs-type">APHero</span> <span class="hljs-variable">ap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">APHero</span>();<br>        Hero h1= ad;<br>        Hero h2= ap;<br>        <span class="hljs-comment">//判断引用h1指向的对象，是否是ADHero类型</span><br>        System.out.println(h1 <span class="hljs-keyword">instanceof</span> ADHero);<br>        <span class="hljs-comment">//判断引用h2指向的对象，是否是APHero类型</span><br>        System.out.println(h2 <span class="hljs-keyword">instanceof</span> APHero);<br>        <span class="hljs-comment">//判断引用h1指向的对象，是否是Hero的子类型</span><br>        System.out.println(h1 <span class="hljs-keyword">instanceof</span> Hero);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>#### 重写<br>子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖 override<br>&gt; 调用子类的方法首先调用重写的方法，如果没有再调用父类方法。</h2><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h2 id="操作符的多态-可以作为算数运算，也可以作为字符串连接类的多态-父类引用指向子类对象"><a href="#操作符的多态-可以作为算数运算，也可以作为字符串连接类的多态-父类引用指向子类对象" class="headerlink" title="操作符的多态+ 可以作为算数运算，也可以作为字符串连接类的多态- 父类引用指向子类对象"></a>操作符的多态<br>+ 可以作为算数运算，也可以作为字符串连接<br>类的多态<br>- 父类引用指向子类对象</h2><h5 id="操作符多态"><a href="#操作符多态" class="headerlink" title="操作符多态"></a>操作符多态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i+j; <span class="hljs-comment">//如果+号两侧都是整型，那么+代表 数字相加</span><br>    System.out.println(k);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;5&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a+b; <span class="hljs-comment">//如果+号两侧，任意一个是字符串，那么+代表字符串连接</span><br>    System.out.println(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="类多态"><a href="#类多态" class="headerlink" title="类多态"></a>类多态</h5><h2 id="父类引用指向子类，调用父类引用被重写的方法，优先执行指向的子类的重写方法，即同类型调用同一方法，呈现不同的状态。-NOTE-类的多态条件-1-父类（接口）引用指向子类对象-2-调用重写的方法-使用类多态-VS-不使用类多态不使用：使用：-由此可知，使用类多态可以简化设计，减少冗余的相同逻辑方法的设计实现，提高开发效率。-练习-immortal-是不朽的，不死的意思-mortal-就是终有一死的，凡人的意思-1-设计一个接口-接口叫做-Mortal-其中有一个方法叫做-die-2-实现接口-分别让-ADHero-APHero-ADAPHero-这三个类，实现-Mortal-接口，不同的类实现-die-方法的时候，都打印出不一样的字符串-3-为-Hero-类，添加一个方法-在这个方法中调用-m-的-die-方法。-public-void-kill-Mortal-m-4-在主方法中-首先实例化出一个-Hero-对象-盖伦-然后实例化出-3-个对象，分别是-ADHero-APHero-ADAPHero-的实例-然后让盖伦-kill-这-3-个对象"><a href="#父类引用指向子类，调用父类引用被重写的方法，优先执行指向的子类的重写方法，即同类型调用同一方法，呈现不同的状态。-NOTE-类的多态条件-1-父类（接口）引用指向子类对象-2-调用重写的方法-使用类多态-VS-不使用类多态不使用：使用：-由此可知，使用类多态可以简化设计，减少冗余的相同逻辑方法的设计实现，提高开发效率。-练习-immortal-是不朽的，不死的意思-mortal-就是终有一死的，凡人的意思-1-设计一个接口-接口叫做-Mortal-其中有一个方法叫做-die-2-实现接口-分别让-ADHero-APHero-ADAPHero-这三个类，实现-Mortal-接口，不同的类实现-die-方法的时候，都打印出不一样的字符串-3-为-Hero-类，添加一个方法-在这个方法中调用-m-的-die-方法。-public-void-kill-Mortal-m-4-在主方法中-首先实例化出一个-Hero-对象-盖伦-然后实例化出-3-个对象，分别是-ADHero-APHero-ADAPHero-的实例-然后让盖伦-kill-这-3-个对象" class="headerlink" title="父类引用指向子类，调用父类引用被重写的方法，优先执行指向的子类的重写方法，即同类型调用同一方法，呈现不同的状态。&gt; [!NOTE] 类的多态条件&gt; 1. 父类（接口）引用指向子类对象&gt; 2. 调用重写的方法##### 使用类多态 VS 不使用类多态不使用：使用：&gt; 由此可知，使用类多态可以简化设计，减少冗余的相同逻辑方法的设计实现，提高开发效率。##### 练习- immortal 是不朽的，不死的意思- mortal 就是终有一死的，凡人的意思&gt; 1. 设计一个接口&gt; 接口叫做 Mortal, 其中有一个方法叫做 die&gt; 2. 实现接口&gt; 分别让 ADHero, APHero, ADAPHero 这三个类，实现 Mortal 接口，不同的类实现 die 方法的时候，都打印出不一样的字符串&gt; 3. 为 Hero 类，添加一个方法, 在这个方法中调用 m 的 die 方法。&gt; public void kill (Mortal m)&gt; 4. 在主方法中&gt; 首先实例化出一个 Hero 对象: 盖伦&gt; 然后实例化出 3 个对象，分别是 ADHero, APHero, ADAPHero 的实例&gt; 然后让盖伦 kill 这 3 个对象"></a>父类引用指向子类，调用父类引用被重写的方法，优先执行指向的子类的重写方法，即同类型调用同一方法，呈现不同的状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> property;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span> &#123;<br>String name;<br><span class="hljs-type">int</span> price;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;购买&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">effect</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;物品使用后，可以有效果 &quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Item i1= <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifePotion</span>();<br><span class="hljs-type">Item</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicPotion</span>();<br>System.out.print(<span class="hljs-string">&quot;i1是Item类型，执行effect打印:&quot;</span>);<br>i1.effect();<br>System.out.print(<span class="hljs-string">&quot;i2也是Item类型，执行effect打印:&quot;</span>);<br>i2.effect();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>&gt; [!NOTE] <strong>类的多态条件</strong><br>&gt; 1. 父类（接口）引用指向子类对象<br>&gt; 2. 调用重写的方法<br>##### 使用类多态 VS 不使用类多态<br>不使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">import</span> property.LifePotion;<br><span class="hljs-keyword">import</span> property.MagicPotion;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useLifePotion</span><span class="hljs-params">(LifePotion lp)</span>&#123;<br>    lp.effect();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useMagicPotion</span><span class="hljs-params">(MagicPotion mp)</span>&#123;<br>    mp.effect();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Hero</span> <span class="hljs-variable">garen</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        garen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>    <span class="hljs-type">LifePotion</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">LifePotion</span>();<br>    <span class="hljs-type">MagicPotion</span> <span class="hljs-variable">mp</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicPotion</span>();<br>    garen.useLifePotion(lp);<br>    garen.useMagicPotion(mp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">import</span> property.Item;<br><span class="hljs-keyword">import</span> property.LifePotion;<br><span class="hljs-keyword">import</span> property.MagicPotion;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useItem</span><span class="hljs-params">(Item i)</span>&#123;<br>    i.effect();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Hero</span> <span class="hljs-variable">garen</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>        garen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br>    <span class="hljs-type">LifePotion</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">LifePotion</span>();<br>    <span class="hljs-type">MagicPotion</span> <span class="hljs-variable">mp</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">MagicPotion</span>();<br>    garen.useItem(lp);<br>    garen.useItem(mp);    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>&gt; 由此可知，使用类多态可以简化设计，减少冗余的相同逻辑方法的设计实现，提高开发效率。<br>##### 练习<br>- immortal 是不朽的，不死的意思<br>- mortal 就是终有一死的，凡人的意思<br>&gt; 1. 设计一个接口<br>&gt; 接口叫做 Mortal, 其中有一个方法叫做 die<br>&gt; 2. 实现接口<br>&gt; 分别让 ADHero, APHero, ADAPHero 这三个类，实现 Mortal 接口，不同的类实现 die 方法的时候，都打印出不一样的字符串<br>&gt; 3. 为 Hero 类，添加一个方法, 在这个方法中调用 m 的 die 方法。<br>&gt; public void kill (Mortal m)<br>&gt; 4. 在主方法中<br>&gt; 首先实例化出一个 Hero 对象: 盖伦<br>&gt; 然后实例化出 3 个对象，分别是 ADHero, APHero, ADAPHero 的实例<br>&gt; 然后让盖伦 kill 这 3 个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Hero</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> hp;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> armor;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">garLen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();  <br>        garLen.setName(<span class="hljs-string">&quot;Garlen&quot;</span>);  <br>        <span class="hljs-type">ADHero</span> <span class="hljs-variable">adHero</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span>();  <br>        adHero.setName(<span class="hljs-string">&quot;ADHero&quot;</span>);  <br>        <span class="hljs-type">APHero</span> <span class="hljs-variable">apHero</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">APHero</span>();  <br>        apHero.setName(<span class="hljs-string">&quot;APHero&quot;</span>);  <br>        <span class="hljs-type">ADAPHero</span> <span class="hljs-variable">adapHero</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ADAPHero</span>();  <br>        adapHero.setName(<span class="hljs-string">&quot;ADAPHero&quot;</span>);  <br>        garLen.kill(adHero, apHero, adapHero);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(Mortal... ms)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Mortal m : ms) &#123;  <br>            m.die();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHp</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> hp;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHp</span><span class="hljs-params">(<span class="hljs-type">float</span> hp)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.hp = hp;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getArmor</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> armor;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArmor</span><span class="hljs-params">(<span class="hljs-type">int</span> armor)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.armor = armor;  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">//Mortal</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mortal</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">die</span><span class="hljs-params">()</span>;  <br>&#125;<br><span class="hljs-comment">//ADHero</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ADHero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AD</span>, Mortal &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">physicAttack</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;ADHero 物理攻击&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">die</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;阵亡&quot;</span>);  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">//APHero</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">APHero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AP</span>, Mortal &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">magicAttack</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;AP Hero magic attack!&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">die</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;阵亡&quot;</span>);  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">//ADAPHero</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ADAPHero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AD</span>, AP, Mortal &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">physicAttack</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;进行物理攻击&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">magicAttack</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;进行魔法攻击&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">die</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;阵亡&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></h2><h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><h2 id="与重写类似，方法的重写是子类覆盖父类的对象方法，隐藏，就是子类覆盖父类的类方法-NOTE-父类引用指向子类调用隐藏方法（类方法不存在多态）？-在-Java-中，对于类方法（静态方法），编译时会根据引用类型（即变量类型）来决定调用的方法。实际上，类方法并不具有多态性，也不会被子类的重写所影响。由于-h-是父类类型的引用，即使它指向一个子类对象（ADHero），编译器仍然会根据引用类型（Hero）来决定调用的方法。-super实例化子类对象时，其父类的构造方法也会被调用，并且是父类构造方法先调用，子类构造方法会默认调用父类的无参的构造方法（1）使用关键字-super-显式调用父类带参的构造方法（2）通过-super-调用父类属性（3）通过-super-调用父类方法"><a href="#与重写类似，方法的重写是子类覆盖父类的对象方法，隐藏，就是子类覆盖父类的类方法-NOTE-父类引用指向子类调用隐藏方法（类方法不存在多态）？-在-Java-中，对于类方法（静态方法），编译时会根据引用类型（即变量类型）来决定调用的方法。实际上，类方法并不具有多态性，也不会被子类的重写所影响。由于-h-是父类类型的引用，即使它指向一个子类对象（ADHero），编译器仍然会根据引用类型（Hero）来决定调用的方法。-super实例化子类对象时，其父类的构造方法也会被调用，并且是父类构造方法先调用，子类构造方法会默认调用父类的无参的构造方法（1）使用关键字-super-显式调用父类带参的构造方法（2）通过-super-调用父类属性（3）通过-super-调用父类方法" class="headerlink" title="与重写类似，方法的重写是子类覆盖父类的对象方法，隐藏，就是子类覆盖父类的类方法&gt; [!NOTE] 父类引用指向子类调用隐藏方法（类方法不存在多态）？&gt; 在 Java 中，对于类方法（静态方法），编译时会根据引用类型（即变量类型）来决定调用的方法。实际上，类方法并不具有多态性，也不会被子类的重写所影响。由于 h 是父类类型的引用，即使它指向一个子类对象（ADHero），编译器仍然会根据引用类型（Hero）来决定调用的方法。#### super实例化子类对象时，其父类的构造方法也会被调用，并且是父类构造方法先调用，子类构造方法会默认调用父类的无参的构造方法（1）使用关键字 super 显式调用父类带参的构造方法（2）通过 super 调用父类属性（3）通过 super 调用父类方法"></a>与<strong>重写</strong>类似，方法的重写是<strong>子类覆盖父类</strong>的<strong>对象方法</strong>，<strong>隐藏</strong>，就是<strong>子类覆盖父类</strong>的<strong>类方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> hp;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> armor;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">battle</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Hero battleWin&quot;</span>);  <br>    &#125; <br>&#125;<br><span class="hljs-comment">//子类隐藏父类的类方法</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ADHero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AD</span>, Mortal &#123;  <br>    <span class="hljs-comment">//隐藏父类的battleWin方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">battle</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;ad hero battle win&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Hero.battle();  <br>        ADHero.battle();  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">physicAttack</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;ADHero 物理攻击&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">die</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;阵亡&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><br>&gt; [!NOTE] 父类引用指向子类调用隐藏方法（<strong>类方法不存在多态</strong>）？<br>&gt; 在 Java 中，对于类方法（静态方法），编译时会根据引用类型（即变量类型）来决定调用的方法。实际上，类方法并不具有多态性，也不会被子类的重写所影响。由于 h 是父类类型的引用，即使它指向一个子类对象（ADHero），编译器仍然会<strong>根据引用类型</strong>（Hero）来<strong>决定调用的方法</strong>。<br>#### super<br>实例化子类对象时，其父类的构造方法也会被调用，并且是<strong>父类构造方法先调用</strong>，子类构造方法会<strong>默认调用父类的无参的构造方法</strong><br>（1）使用关键字 super <strong>显式调用父类带参的构造方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ADHero</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        System.out.println(<span class="hljs-string">&quot;AD Hero的构造方法&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><br>（2）通过 super 调用父类属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMoveSpeed2</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.moveSpeed;<br>&#125;<br></code></pre></td></tr></table></figure><br>（3）通过 super 调用父类方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重写useItem，并在其中调用父类的userItem方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useItem</span><span class="hljs-params">(Item i)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;adhero use item&quot;</span>);<br><span class="hljs-built_in">super</span>.useItem(i);<br>&#125;<br></code></pre></td></tr></table></figure></h2><h4 id="Object-超类"><a href="#Object-超类" class="headerlink" title="Object 超类"></a>Object 超类</h4><h2 id="Object-类是所有类的父类，即基类，声明一个类的时候，默认是继承了-Object1-Object-类提供一个-toString-方法，所以所有的类都有-toString-方法toString-的意思是返回当前对象的字符串表达2-当一个对象没有任何引用指向它的时候，它就满足垃圾回收的条件，当它被垃圾回收的时候，它的-finalize-方法就会被调用。finalize-不是开发人员主动调用的方法，而是由虚拟机-JVM-调用的。3-equals-用于判断两个对象的内容是否相同，假设，当两个英雄的-hp-相同的时候，我们就认为这两个英雄相同4-这不是-Object-的方法，但是用于判断两个对象是否相同，更准确的讲，用于判断两个引用，是否指向了同一个对象5-hashCode-方法返回一个对象的哈希值，但是在了解哈希值的意义之前，讲解这个方法没有意义。6-Object-还提供线程同步相关方法：wait-，notify-，notifyAll-7-getClass-会返回一个对象的类对象，属于反射原理。"><a href="#Object-类是所有类的父类，即基类，声明一个类的时候，默认是继承了-Object1-Object-类提供一个-toString-方法，所以所有的类都有-toString-方法toString-的意思是返回当前对象的字符串表达2-当一个对象没有任何引用指向它的时候，它就满足垃圾回收的条件，当它被垃圾回收的时候，它的-finalize-方法就会被调用。finalize-不是开发人员主动调用的方法，而是由虚拟机-JVM-调用的。3-equals-用于判断两个对象的内容是否相同，假设，当两个英雄的-hp-相同的时候，我们就认为这两个英雄相同4-这不是-Object-的方法，但是用于判断两个对象是否相同，更准确的讲，用于判断两个引用，是否指向了同一个对象5-hashCode-方法返回一个对象的哈希值，但是在了解哈希值的意义之前，讲解这个方法没有意义。6-Object-还提供线程同步相关方法：wait-，notify-，notifyAll-7-getClass-会返回一个对象的类对象，属于反射原理。" class="headerlink" title="Object 类是所有类的父类，即基类，声明一个类的时候，默认是继承了 Object1. Object 类提供一个 toString 方法，所以所有的类都有 toString 方法toString ()的意思是返回当前对象的字符串表达2. 当一个对象没有任何引用指向它的时候，它就满足垃圾回收的条件，当它被垃圾回收的时候，它的 finalize () 方法就会被调用。finalize () 不是开发人员主动调用的方法，而是由虚拟机 JVM 调用的。3. equals () 用于判断两个对象的内容是否相同，假设，当两个英雄的 hp 相同的时候，我们就认为这两个英雄相同4. == 这不是 Object 的方法，但是用于判断两个对象是否相同，更准确的讲，用于判断两个引用，是否指向了同一个对象5. hashCode 方法返回一个对象的哈希值，但是在了解哈希值的意义之前，讲解这个方法没有意义。6. Object 还提供线程同步相关方法：wait ()，notify ()，notifyAll ()7. getClass ()会返回一个对象的类对象，属于反射原理。"></a>Object 类是所有类的父类，即基类，声明一个类的时候，默认是继承了 Object<br>1. Object 类提供一个 <strong>toString 方法</strong>，所以所有的类都有 toString 方法<br>toString ()的意思是返回当前对象的<strong>字符串表达</strong><br>2. 当一个对象<strong>没有任何引用指向它</strong>的时候，它就满足垃圾回收的条件，当它被垃圾回收的时候，它的 <strong>finalize ()</strong> 方法就会被调用。finalize () 不是开发人员主动调用的方法，而是由虚拟机 JVM 调用的。<br>3. <strong>equals ()</strong> 用于判断两个对象的内容是否相同，假设，当两个英雄的 hp 相同的时候，我们就认为这两个英雄相同<br>4. <code>==</code> 这不是 Object 的方法，但是用于判断两个对象是否相同，更准确的讲，用于判断两个引用，是否指向了同一个对象<br>5. <strong>hashCode 方法</strong>返回一个对象的<strong>哈希值</strong>，但是在了解哈希值的意义之前，讲解这个方法没有意义。<br>6. Object 还提供<strong>线程同步</strong>相关方法：<strong>wait ()，notify ()，notifyAll ()</strong><br>7. getClass ()会返回一个对象的类对象，属于<strong>反射</strong>原理。</h2><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>在类中声明一个方法，这个方法<strong>没有方法体</strong>，是一个“空”方法，这样的方法就叫<strong>抽象方法</strong>，使用修饰符“<strong>abstract</strong>“，当一个类有抽象方法的时候，该类必须被声明为<strong>抽象类</strong>，不能被实例化。<br>抽象类可以没有抽象方法，也可以有具体方法</p><blockquote><p>[!NOTE] 抽象类和接口的区别</p><ol><li>区别 1：</li></ol><ul><li>子类<strong>只能继承一个抽象类</strong>，不能继承多个  </li><li>子类<strong>可以实现多个接口</strong></li></ul><ol start="2"><li>区别 2：</li></ol><ul><li>抽象类可以定义 public, protected, package, private 静态和非静态属性，final 和非 final 属性  </li><li>但是接口中声明的属性，只能是 public 静态 final 的，即便没有显式的声明<br>注: <strong>抽象类和接口都可以有实体方法</strong>。 <strong>接口</strong>中的实体方法，叫做<strong>默认方法</strong></li></ul></blockquote><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>分类：</p><ul><li>非静态内部类  </li><li>静态内部类  </li><li>匿名类  </li><li>本地类</li></ul><h5 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h5><p>非静态内部类可以直接在一个类里面定义，当外部类对象存在时内部类才有意义。<br>语法: <code>new 外部类().new 内部类()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br><span class="hljs-keyword">private</span> String name; <span class="hljs-comment">// 姓名</span><br><span class="hljs-type">float</span> hp; <span class="hljs-comment">// 血量</span><br><span class="hljs-type">float</span> armor; <span class="hljs-comment">// 护甲</span><br><span class="hljs-type">int</span> moveSpeed; <span class="hljs-comment">// 移动速度</span><br><span class="hljs-comment">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="hljs-comment">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BattleScore</span> &#123;<br><span class="hljs-type">int</span> kill;<br><span class="hljs-type">int</span> die;<br><span class="hljs-type">int</span> assit;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">legendary</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (kill &gt;= <span class="hljs-number">8</span>)<br>System.out.println(name + <span class="hljs-string">&quot;超神！&quot;</span>);<br><span class="hljs-keyword">else</span><br>System.out.println(name + <span class="hljs-string">&quot;尚未超神！&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Hero</span> <span class="hljs-variable">garen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>garen.name = <span class="hljs-string">&quot;盖伦&quot;</span>;<br><span class="hljs-comment">// 实例化内部类</span><br><span class="hljs-comment">// BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="hljs-comment">// 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="hljs-type">BattleScore</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> garen.<span class="hljs-keyword">new</span> <span class="hljs-title class_">BattleScore</span>();<br>score.kill = <span class="hljs-number">9</span>;<br>score.legendary();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>与<strong>非静态内部类</strong>不同，静态内部类水晶类的实例化<strong>不需要一个外部类的实例为基础</strong>，可以<strong>直接实例化</strong><br>语法：<code>new 外部类.静态内部类()</code>;<br>因为没有一个外部类的实例，所以在<strong>静态内部类里面不可以访问外部类的实例属性和方法</strong>，除了可以访问外部类的<strong>私有静态成员</strong>外，静态内部类和普通类没什么大的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String name; <br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">float</span> hp; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">battleWin</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;battle win&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//敌方的水晶</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnemyCrystal</span>&#123;<br>    <span class="hljs-type">int</span> hp=<span class="hljs-number">5000</span>;<br>    <span class="hljs-comment">//如果水晶的血量为0，则宣布胜利</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkIfVictory</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(hp==<span class="hljs-number">0</span>)&#123;<br>    Hero.battleWin();<br>    <span class="hljs-comment">//静态内部类不能直接访问外部类的对象属性</span><br>    System.out.println(name + <span class="hljs-string">&quot; win this game&quot;</span>);<br>    &#125;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//实例化静态内部类</span><br>    Hero.<span class="hljs-type">EnemyCrystal</span> <span class="hljs-variable">crystal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>.EnemyCrystal();<br>    crystal.checkIfVictory();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h5><p>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练<br>通常情况下，要使用一个接口或者抽象类，都必须创建一个子类<br>有的时候，为了快速使用，<strong>直接实例化一个抽象类，并“当场”实现其抽象方法</strong>。<br>既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做<strong>匿名类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    String name; <span class="hljs-comment">//姓名</span><br>    <span class="hljs-type">float</span> hp; <span class="hljs-comment">//血量</span><br>    <span class="hljs-type">float</span> armor; <span class="hljs-comment">//护甲</span><br>    <span class="hljs-type">int</span> moveSpeed; <span class="hljs-comment">//移动速度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ADHero adh=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span>();<br>        <span class="hljs-comment">//通过打印adh，可以看到adh这个对象属于ADHero类</span><br>        adh.attack();<br>        System.out.println(adh);<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>()&#123;<br>            <span class="hljs-comment">//当场实现attack方法</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;新的进攻手段&quot;</span>);<br>            &#125;<br>        &#125;;<br>        h.attack();<br>        <span class="hljs-comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br>        System.out.println(h);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>在匿名类中使用外部的局部变量，外部的局部变量必须修饰为 final，否则报错（jdk 8 中不需要强制用 final 修饰，因为编译器会自动加上）</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">damage</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;新的进攻手段，造成%d点伤害&quot;</span>,damage );<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="本地类"><a href="#本地类" class="headerlink" title="本地类"></a>本地类</h5><p>本地类可以理解为有名字的匿名类<br><strong>内部类与匿名类</strong>不一样的是，<strong>内部类必须声明在成员的位置</strong>，即与属性和方法平等的位置。本地类和匿名类一样，<strong>直接声明在代码块里面</strong>，可以是主方法，for 循环里等等地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    String name; <span class="hljs-comment">//姓名</span><br>    <span class="hljs-type">float</span> hp; <span class="hljs-comment">//血量</span><br>    <span class="hljs-type">float</span> armor; <span class="hljs-comment">//护甲</span><br>    <span class="hljs-type">int</span> moveSpeed; <span class="hljs-comment">//移动速度</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//与匿名类的区别在于，本地类有了自定义的类名</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeHero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span> &#123;<br>                System.out.println( name+ <span class="hljs-string">&quot; 新的进攻手段&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">SomeHero</span> <span class="hljs-variable">h</span>  <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">SomeHero</span>();<br>        h.name =<span class="hljs-string">&quot;地卜师&quot;</span>;<br>        h.attack();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>jdk 8 新特性，指接口也可以提供具体方法，不单单只能提供抽象方法<br>Mortal 这个接口，增加了一个默认方法 revive，这个方法有实现体，并且必须被声明为 <strong>default</strong>，实现接口功能扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mortal</span> &#123;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">die</span><span class="hljs-params">()</span>;  <br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">revive</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;我又回来啦&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h4><p>UML-Unified Module Language 统一建模语言，可以很方便的用于描述类的属性，方法，以及类和类之间的关系。<br><img src="https://stepimagewm.how2j.cn/2305.png"><br><img src="https://stepimagewm.how2j.cn/2318.png"><br><img src="https://stepimagewm.how2j.cn/2319.png"></p><blockquote><p>带箭头的实线，表示 Spider，Cat, Fish 都继承于 Animal 这个父类.<br><img src="https://stepimagewm.how2j.cn/2320.png"><br>表示 Fish 实现了 Pet 这个接口<br><img src="https://stepimagewm.how2j.cn/2321.png"> </p></blockquote><h3 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h3><h4 id="封装类"><a href="#封装类" class="headerlink" title="封装类"></a>封装类</h4><p>数字封装类有<br><strong>Byte, Short, Integer, Long, Float, Double</strong><br>这些类都是抽象类<strong>Number</strong>的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本类型转换成封装类型</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span> (i);<br>        <span class="hljs-comment">//封装类型转换成基本类型</span><br>        <span class="hljs-type">int</span> i <span class="hljs-number">2</span> = it.intValue ();<br></code></pre></td></tr></table></figure><ol><li>自动装箱：<ul><li>不需要调用构造方法，通过 <code>=</code> 符号自动把基本类型转换为类类型就叫装箱</li><li><code>int i = 5;//自动转换就叫装箱 Integer it 2 = i;</code></li></ul></li><li>自动拆箱<ul><li>不需要调用 Integer 的 intValue 方法，通过&#x3D;就自动转换成 int 类型，就叫拆箱</li><li><code> int i = 5; Integer it = new Integer (i);//封装类型转换成基本类型 int i 2 = it. intValue ();//自动转换就叫拆箱 int i 3 = it;</code></li></ul></li></ol><ul><li>int 的最大值可以通过其对应的封装类 <strong>Integer. MAX_VALUE</strong> 获取</li><li>int 的最小值可以通过其对应的封装类 <strong>Integer. MIN_VALUE</strong> 获取</li></ul><h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><h5 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h5><ol><li>方法 1： 使用 String 类的静态方法 <strong>valueOf</strong>  </li><li>方法 2： 先把基本类型装箱为对象，然后调用对象的<strong>toString</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> NumberString;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumToStr</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br><span class="hljs-comment">//        方法 1  </span><br>        String s <span class="hljs-number">1</span> = String.valueOf (i);  <br><span class="hljs-comment">//        方法 2  </span><br>        Integer i <span class="hljs-number">1</span> = i;  <br>        String s <span class="hljs-number">2</span> = i <span class="hljs-number">1.</span>toString ();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h5><p>调用 Integer 的<strong>静态方法 parseInt</strong><br><code>int i 3 = Integer.parseInt (s 1);</code></p><h4 id="数学-Math-包"><a href="#数学-Math-包" class="headerlink" title="数学 Math 包"></a>数学 Math 包</h4><p>java. lang. Math 提供了一些常用的数学运算方法，并且都是以静态方法的形式存在<br><strong>四舍五入, 随机数，开方，次方，π，自然常数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUse</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">float</span> f <span class="hljs-number">1</span> = <span class="hljs-number">3.4</span> f;  <br>        <span class="hljs-type">float</span> f <span class="hljs-number">2</span> = <span class="hljs-number">3.5</span> f;  <br>        System.out.printf (<span class="hljs-string">&quot;%d, %d&quot;</span>, Math.round (f <span class="hljs-number">1</span>), Math.round (f <span class="hljs-number">2</span>));  <br>        <span class="hljs-comment">//得到一个 0-1 之间的随机浮点数（取不到 1）  </span><br>        System.out.println (Math.random ());  <br>        <span class="hljs-comment">//得到一个 0-10 之间的随机整数 （取不到 10）  </span><br>        System.out.println ((<span class="hljs-type">int</span>) (Math.random () * <span class="hljs-number">10</span>));  <br>        <span class="hljs-comment">//开方  </span><br>        System.out.println (Math.sqrt (<span class="hljs-number">9</span>));  <br>        <span class="hljs-comment">//次方（2 的 4 次方）  </span><br>        System.out.println (Math.pow (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>));  <br>        <span class="hljs-comment">//π  </span><br>        System.out.println (Math. PI);  <br>        <span class="hljs-comment">//自然常数  </span><br>        System.out.println (Math. E);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐<br>使用格式化输出，就可以简洁明了  </p><ul><li>%s 表示字符串  </li><li>%d 表示数字  </li><li>%n 表示换行<br>printf 和 format 格式化输出效果一样，printf 中调用了 format<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用格式化输出  </span><br><span class="hljs-comment">//%s 表示字符串，%d 表示数字,%n 表示换行  </span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;亚瑟&quot;</span>;  <br><span class="hljs-type">String</span> <span class="hljs-variable">sentenceFormat</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;</span>;  <br><span class="hljs-type">int</span> <span class="hljs-variable">kill</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <br><span class="hljs-type">String</span> <span class="hljs-variable">title</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;超神&quot;</span>;  <br>System. out. printf (sentenceFormat, name, kill, title);<br>System. out. format (sentenceFormat, name, kill, title);<br></code></pre></td></tr></table></figure></li><li><strong>换行符</strong>就是<strong>另起一行</strong> — ‘\n’ 换行（newline）  </li><li><strong>回车符</strong>就是<strong>回到一行的开头</strong> — ‘\r’ 回车（return）</li></ul><h4 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h4><p>immutable 是指不可改变的, 比如创建了一个字符串对象, String garen &#x3D;”盖伦”;<br><strong>不可改变</strong>的具体含义是指：</p><ul><li>不能增加长度</li><li>不能减少长度</li><li>不能插入字符</li><li>不能删除字符</li><li>不能修改字符<br>一旦创建好这个字符串，里面的内容永远不能改变, String 的表现就像是一个<strong>常量</strong></li></ul><h4 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">简介</th><th></th></tr></thead><tbody><tr><td align="center">charAt</td><td align="center">获取字符</td><td></td></tr><tr><td align="center">toCharArray</td><td align="center">获取对应的字符数组</td><td></td></tr><tr><td align="center">subString</td><td align="center">截取子字符串</td><td></td></tr><tr><td align="center">split</td><td align="center">分隔</td><td></td></tr><tr><td align="center">trim</td><td align="center">去掉首尾空格</td><td></td></tr><tr><td align="center">toLowerCase  <br>toUpperCase</td><td align="center">大小写</td><td></td></tr><tr><td align="center">indexOf  <br>lastIndexOf  <br>contains</td><td align="center">定位</td><td></td></tr><tr><td align="center">replaceAll  <br>replaceFirst</td><td align="center">替换</td><td></td></tr></tbody></table><h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><ol><li>是否是同一个对象<br><code>==</code> 用于用于判断两个字符串对象是否相同（不是内容是否相同）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String str <span class="hljs-number">1</span> = <span class="hljs-string">&quot;the light&quot;</span>;<br>        String str <span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (str <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//==用于判断是否是同一个字符串对象</span><br>        System. out. println ( str <span class="hljs-number">1</span>  ==  str <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>特例：str 3 与 str 1 内容完全一样，复用之前的对象并未创建新 String 对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String str <span class="hljs-number">1</span> = <span class="hljs-string">&quot;the light&quot;</span>;<br>      String str <span class="hljs-number">3</span> = <span class="hljs-string">&quot;the light&quot;</span>;<br>      System. out. println ( str <span class="hljs-number">1</span>  ==  str <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li>是否内容相同<br>使用 <strong>equals</strong> 进行字符串内容的比较，必须大小写一致<br><strong>equalsIgnoreCase</strong>，忽略大小写判断内容是否一致<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System. out. println (str <span class="hljs-number">1.</span> equals (str <span class="hljs-number">3</span>));<span class="hljs-comment">//大小写不一样，返回 false</span><br>      System. out. println (str <span class="hljs-number">1.</span> equalsIgnoreCase (str <span class="hljs-number">3</span>));<span class="hljs-comment">//忽略大小写的比较，返回 true</span><br></code></pre></td></tr></table></figure></li><li>是否以子字符串开始或者结束<br><strong>startsWith</strong> &#x2F;&#x2F;以… 开始，<strong>endsWith</strong> &#x2F;&#x2F;以… 结束</li></ol><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>StringBuffer 是<strong>可变长</strong>的字符串</p><table><thead><tr><th>关键字</th><th>描述</th><th></th></tr></thead><tbody><tr><td>append delete insert reverse</td><td>追加删除插入反转</td><td></td></tr><tr><td>length capacity</td><td>长度容量</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> NumberString;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStringBuffer</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        String str <span class="hljs-number">1</span> = <span class="hljs-string">&quot;let there &quot;</span>;  <br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span> (str <span class="hljs-number">1</span>); <span class="hljs-comment">//根据 str 1 创建一个 StringBuffer 对象  </span><br>        sb. append (<span class="hljs-string">&quot;be light&quot;</span>); <span class="hljs-comment">//在最后追加  </span><br>        System. out. println (sb);  <br>        sb. delete (<span class="hljs-number">4</span>, <span class="hljs-number">10</span>);<span class="hljs-comment">//删除 4-10 之间的字符  </span><br>        System. out. println (sb);  <br>        sb. insert (<span class="hljs-number">4</span>, <span class="hljs-string">&quot;there &quot;</span>);<span class="hljs-comment">//在 4 这个位置插入 there  </span><br>        System. out. println (sb);  <br>        sb. reverse (); <span class="hljs-comment">//反转  </span><br>        System. out. println (sb);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>StringBuffer 性能明显优于<strong>字符串拼接</strong></p></blockquote><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>时间原点概念：</p><blockquote><p>所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。<br>日期类型也不例外，换句话说，一个日期，比如 2020 年 10 月 1 日，在计算机里，会用一个数字来代替。<br>那么最特殊的一个数字，就是零. 零这个数字，就代表 Java 中的时间原点，其对应的日期是 1970 年 1 月 1 日 8 点 0 分 0 秒。 (为什么是 8 点，因为中国的太平洋时区是 UTC-8，刚好和格林威治时间差 8 个小时)<br>为什么对应 1970 年呢？ 因为 1969 年发布了第一个 UNIX 版本：AT&amp;T，综合考虑，当时就把 1970 年当做了时间原点。<br>所有的日期，都是以为这个 0 点为基准，每过一毫秒，就+1。</p></blockquote><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><h5 id="创建日期对象"><a href="#创建日期对象" class="headerlink" title="创建日期对象"></a>创建日期对象</h5><p><code>import java. util. Date</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java. util. Date;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDate</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> ();  <br><span class="hljs-comment">//        输出当前系统时间  </span><br>        System. out. println (date);  <br>        Date date <span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> (<span class="hljs-number">10000</span> L);  <br><span class="hljs-comment">//        输出距离 1970-1-1 08:00:00过了 10000 毫秒的时间  </span><br>        System. out. println (date <span class="hljs-number">1</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>getTime () 获得一个长整型距离 1970-1-1 08:00:00所经过的毫秒数</li><li>System. currentTimeMillis ()效果与 getTime（）相同，可能有几十毫秒误差。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前日期的毫秒数</span><br>        System. out. println (<span class="hljs-string">&quot;Date. getTime () \t\t\t 返回值: &quot;</span>+now. getTime ());<br>        <span class="hljs-comment">//通过 System. currentTimeMillis ()获取当前日期的毫秒数</span><br>        System. out. println (<span class="hljs-string">&quot;System. currentTimeMillis () \t 返回值: &quot;</span>+System. currentTimeMillis ());<br></code></pre></td></tr></table></figure></li></ul><h5 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h5><blockquote><p>y 代表年<br>M 代表月<br>d 代表日<br>H 代表 24 进制的小时<br>h 代表 12 进制的小时<br>m 代表分钟<br>s 代表秒<br>S 代表毫秒</p></blockquote><h6 id="日期转字符串"><a href="#日期转字符串" class="headerlink" title="日期转字符串"></a>日期转字符串</h6><p><code>SimpleDateFormat</code> 类对象通过 <code>format</code> 方法对日期进行格式化为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span> (<span class="hljs-string">&quot;yyyy-MM-dd HH:mm: ss SSS&quot;</span>);  <br><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> ();  <br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sdf. format (d);  <br>System. out. println (<span class="hljs-string">&quot;当前时间通过 yyyy-MM-dd HH:mm: ss SSS 格式化后的输出: &quot;</span> + str);  <br>SimpleDateFormat sdf <span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span> (<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);  <br>Date d <span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> ();  <br>String str <span class="hljs-number">1</span> = sdf <span class="hljs-number">1.</span> format (d <span class="hljs-number">1</span>);  <br>System. out. println (<span class="hljs-string">&quot;当前时间通过 yyyy-MM-dd 格式化后的输出: &quot;</span> + str <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h6 id="字符串转日期"><a href="#字符串转日期" class="headerlink" title="字符串转日期"></a>字符串转日期</h6><p><code>SimpleDateFormat</code> 格式（yyyy&#x2F;MM&#x2F;dd HH:mm:ss）需要和<strong>字符串格式保持一致</strong>，如果不一样就会抛出解析异常 ParseException，通过调用 SimpleDateFormat 对象的 <code>parse</code> 方法将字符串转为日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span> (<span class="hljs-string">&quot;yyyy-MM-dd HH:mm: ss&quot;</span>);  <br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2016-1-5 12:12:12&quot;</span>;  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> sdf. parse (str);  <br>    System. out. printf (<span class="hljs-string">&quot;字符串 %s 通过格式  yyyy/MM/dd HH:mm: ss %n 转换为日期对象: %s&quot;</span>, str, d.toString ());  <br>&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;  <br>    <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>    e.printStackTrace ();  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h4><p>Calendar 类即<strong>日历类</strong>，常用于进行“翻日历”，比如下个月的今天是多久<br>采用<a href="https://how2j.cn/k/class-object/class-object-singleton/349.html">单例模式</a>获取日历对象 <code>Calendar. getInstance ()</code>;<br>日历对象的 <code>getTime</code> 方法获取当前日期，<code>setTime</code> 方法设置日历日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//采用单例模式获取日历对象 Calendar. getInstance ();  </span><br><span class="hljs-type">Calendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Calendar. getInstance ();  <br><span class="hljs-comment">//通过日历对象得到日期对象  </span><br><span class="hljs-type">Date</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> c.getTime ();  <br>System. out. println (d);  <br>Date d <span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span> (<span class="hljs-number">0</span>);  <br>c.setTime (d <span class="hljs-number">2</span>); <span class="hljs-comment">//把这个日历，调成日期 : 1970.1.1 08:00:00  </span><br>System. out. println (c.getTime ());<br></code></pre></td></tr></table></figure><h5 id="翻日历"><a href="#翻日历" class="headerlink" title="翻日历"></a>翻日历</h5><ol><li><code>add</code> 方法，在原日期上增加年&#x2F;月&#x2F;日  </li><li><code>set</code> 方法，直接设置年&#x2F;月&#x2F;日<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java. text. SimpleDateFormat;  <br><span class="hljs-keyword">import</span> java. util. Calendar;  <br><span class="hljs-keyword">import</span> java. util. Date;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCalendar</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span> (<span class="hljs-string">&quot;yyyy-MM-dd HH:mm: ss&quot;</span>);  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Calendar. getInstance ();  <br>        <span class="hljs-type">Date</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> c.getTime ();  <br>        <span class="hljs-comment">// 当前日期  </span><br>        System. out. println (<span class="hljs-string">&quot;当前日期：\t&quot;</span> + format (c.getTime ()));  <br>        <span class="hljs-comment">// 下个月的今天  </span><br>        c.setTime (now);  <br>        c.add (Calendar. MONTH, <span class="hljs-number">1</span>);  <br>        System. out. println (<span class="hljs-string">&quot;下个月的今天:\t&quot;</span> + format (c.getTime ()));  <br>        <span class="hljs-comment">// 去年的今天  </span><br>        c.setTime (now);  <br>        c.add (Calendar. YEAR, -<span class="hljs-number">1</span>);  <br>        System. out. println (<span class="hljs-string">&quot;去年的今天:\t&quot;</span> + format (c.getTime ()));  <br>        <span class="hljs-comment">// 上个月的第三天  </span><br>        c.setTime (now);  <br>        c.add (Calendar. MONTH, -<span class="hljs-number">1</span>);  <br>        c.set (Calendar. DATE, <span class="hljs-number">3</span>);  <br>        System. out. println (<span class="hljs-string">&quot;上个月的第三天:\t&quot;</span> + format (c.getTime ()));  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">format</span> <span class="hljs-params">(Date time)</span> &#123;  <br>        <span class="hljs-keyword">return</span> sdf. format (time);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>对日期需要<strong>修改</strong>的时候<strong>用 Calendar</strong>，直接获取当前日期用 Date</p></blockquote></li></ol><h2 id="Java-中级"><a href="#Java-中级" class="headerlink" title="Java 中级"></a>Java 中级</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><p><img src="https://stepimagewm.how2j.cn/2412.png"><br>可查异常，运行时异常和错误 3 种，其中，运行时异常和错误又叫非可查异常</p><h5 id="可查异常：-CheckedException"><a href="#可查异常：-CheckedException" class="headerlink" title="可查异常： CheckedException"></a>可查异常： CheckedException</h5><p>可查异常即必须进行处理的异常，<strong>要么 try catch 住, 要么往外抛，谁调用，谁处理</strong>，比如 FileNotFoundException ，如果不处理，编译器，就不让你通过</p><h5 id="运行时异常：RuntimeException"><a href="#运行时异常：RuntimeException" class="headerlink" title="运行时异常：RuntimeException"></a>运行时异常：RuntimeException</h5><p><strong>不是必须进行 try catch 的异常</strong>  ，但是运行会报错。<br>常见运行时异常:<br>    - 除数不能为 0 异常: ArithmeticException<br>    - 下标越界异常: ArrayIndexOutOfBoundsException<br>    - 空指针异常:NullPointerException</p><h5 id="错误：Error"><a href="#错误：Error" class="headerlink" title="错误：Error"></a>错误：Error</h5><p>错误 Error，指的是系统级别的异常，通常是内存用光了，在默认设置下，一般 java 程序启动的时候，最大可以使用 16 m 的内存，如例不停的给 StringBuffer 追加字符，很快就把内存使用光了。抛出 OutOfMemoryError<br>与运行时异常一样，错误也是不要求强制捕捉的，并且无法人为处理。</p><h4 id="try-catch-finally-捕捉处理异常"><a href="#try-catch-finally-捕捉处理异常" class="headerlink" title="try catch finally 捕捉处理异常"></a>try catch finally 捕捉处理异常</h4><ol><li>将可能抛出 FileNotFoundException 文件不存在异常的代码放在 try 里  </li><li>如果文件存在，就会顺序往下执行，并且不执行 catch 块中的代码</li><li>如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的 catch 块中  </li><li>e. <code>printStackTrace</code> (); 会打印出方法的调用痕迹，如此例，会打印出异常开始于 TestException 的第 16 行，这样就便于定位和分析到底哪里出了异常</li><li>无论是否出现异常，<strong>finally 中的代码都会被执行</strong></li></ol><h4 id="多异常捕捉办法"><a href="#多异常捕捉办法" class="headerlink" title="多异常捕捉办法"></a>多异常捕捉办法</h4><ol><li>分别进行 catch</li><li>把多个异常，放在一个 catch 里统一捕捉 <code>catch (FileNotFoundException | ParseException e) &#123;&#125;</code></li></ol><h4 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h4><p>throws 与 throw 这两个关键字接近，不过意义不一样，有如下区别：  </p><ol><li><strong>throws</strong> 出现在<strong>方法声明上</strong>，而 <strong>throw</strong> 通常都出现在<strong>方法体内</strong>。  </li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某个异常对象。</li></ol><h4 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h4><p>Throwable 是类，Exception 和 Error 都继承了该类, 所以在捕捉的时候，也可以使用 Throwable 进行捕捉<br>如图： 异常分 Error 和 Exception<br>Exception 里又分运行时异常和可查异常。<br><img src="https://stepimagewm.how2j.cn/742.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> exception;  <br><span class="hljs-keyword">import</span> java. io. File;  <br><span class="hljs-keyword">import</span> java. io. FileInputStream;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThrowable</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;d:/LOL. exe&quot;</span>);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (f);  <br>            <span class="hljs-comment">//使用 Throwable 进行异常捕捉  </span><br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;  <br>            <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>            t.printStackTrace ();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>Java 中的异常是通过<strong>继承 Throwable 类</strong>来实现的。因此，要<strong>自定义异常类</strong>，只需创建一个<strong>继承 Exception 或 RuntimeException 的类</strong>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">import</span> exception. EnemyHeroIsDeadException;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Mortal</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> hp;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> armor;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hero</span> <span class="hljs-params">(String name, <span class="hljs-type">float</span> hp, <span class="hljs-type">int</span> armor)</span> &#123;  <br>        System. out. println (<span class="hljs-built_in">this</span>. getName () + <span class="hljs-string">&quot; is born&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hero</span> <span class="hljs-params">()</span> &#123;  <br>        System. out. println (<span class="hljs-string">&quot;Hero 构造&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">garLen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">yase</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        garLen. setName (<span class="hljs-string">&quot;Garlen&quot;</span>);  <br>        yase. setName (<span class="hljs-string">&quot;Yase&quot;</span>);  <br>        yase. setHp (<span class="hljs-number">0</span>);  <br>        <span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span> () &#123;  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">disposable</span> <span class="hljs-params">()</span> &#123;  <br>                System. out. println (garLen. getName () + <span class="hljs-string">&quot;的物品毁坏&quot;</span>);  <br>            &#125;  <br>        &#125;;  <br>        item. disposable ();  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            garLen. attack (yase);  <br>        &#125; <span class="hljs-keyword">catch</span> (EnemyHeroIsDeadException e) &#123;  <br>            System. out. println (e.getMessage ());  <br>        &#125; <br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span> <span class="hljs-params">(Hero hero)</span> <span class="hljs-keyword">throws</span> EnemyHeroIsDeadException &#123;  <br>        <span class="hljs-keyword">if</span> (hero. hp == <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-type">EnemyHeroIsDeadException</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnemyHeroIsDeadException</span> (hero. getName () + <span class="hljs-string">&quot;挂了&quot;</span>);  <br>            <span class="hljs-keyword">throw</span> exception;  <br>        &#125;  <br>    &#125; <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span> <span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. name = name;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHp</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> hp;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHp</span> <span class="hljs-params">(<span class="hljs-type">float</span> hp)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. hp = hp;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getArmor</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> armor;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArmor</span> <span class="hljs-params">(<span class="hljs-type">int</span> armor)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. armor = armor;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><h4 id="File"><a href="#File" class="headerlink" title="File"></a>File</h4><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;d:/LOLFolder/skin/garen. ski&quot;</span>);<br>        <span class="hljs-comment">// 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span><br>        f.list ();<br>        <span class="hljs-comment">// 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）</span><br>        File[]fs= f.listFiles ();<br>        <span class="hljs-comment">// 以字符串形式返回获取所在文件夹</span><br>        f.getParent ();<br>        <span class="hljs-comment">// 以文件形式返回获取所在文件夹</span><br>        f.getParentFile ();<br>        <span class="hljs-comment">// 创建文件夹，如果父文件夹 skin 不存在，创建就无效</span><br>        f.mkdir ();<br>        <span class="hljs-comment">// 创建文件夹，如果父文件夹 skin 不存在，就会创建父文件夹</span><br>        f.mkdirs ();<br>        <span class="hljs-comment">// 创建一个空文件, 如果父文件夹 skin 不存在，就会抛出异常</span><br>        f.createNewFile ();<br>        <span class="hljs-comment">// 所以创建一个空文件之前，通常都会创建父目录</span><br>        f.getParentFile (). mkdirs ();<br>        <span class="hljs-comment">// 列出所有的盘符 c: d: e: 等等</span><br>        f.listRoots ();<br>        <span class="hljs-comment">// 刪除文件</span><br>        f.delete ();<br>        <span class="hljs-comment">// JVM 结束的时候，刪除文件，常用于临时文件的删除</span><br>        f.deleteOnExit ();<br></code></pre></td></tr></table></figure><p>eg：获取文件夹中最大和最小文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;C:\\WINDOWS&quot;</span>);  <br>File[] files = file. listFiles ();  <br><span class="hljs-type">File</span> <span class="hljs-variable">minFile</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-type">File</span> <span class="hljs-variable">maxFile</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br><span class="hljs-keyword">for</span> (File f : files) &#123;  <br>    <span class="hljs-keyword">if</span> (f.length () != <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">if</span> (minFile == <span class="hljs-literal">null</span> || f.length () &lt; minFile. length ())  <br>            minFile = f;  <br>        <span class="hljs-keyword">if</span> (maxFile == <span class="hljs-literal">null</span> || f.length () &gt; maxFile. length ())  <br>            maxFile = f;  <br>    &#125;  <br>&#125;  <br>System. out. println (<span class="hljs-string">&quot;minFile: &quot;</span> + minFile. getName () + <span class="hljs-string">&quot; &quot;</span> + minFile. length () + <span class="hljs-string">&quot; bytes&quot;</span>);  <br>System. out. println (<span class="hljs-string">&quot;maxFile: &quot;</span> + maxFile. getName () + <span class="hljs-string">&quot; &quot;</span> + maxFile. length () / <span class="hljs-number">1</span> e <span class="hljs-number">6</span> + <span class="hljs-string">&quot;Mbytes&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="Stream（流）"><a href="#Stream（流）" class="headerlink" title="Stream（流）"></a>Stream（流）</h4><p>当不同的介质之间有数据交互的时候，JAVA 就使用流来实现。<br>数据源可以是文件，还可以是数据库，网络甚至是其他的程序<br><img src="https://stepimagewm.how2j.cn/5678.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;D:\\Java\\JavaSE\\src\\MyIO\\test. txt&quot;</span>);  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (f);  <br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;  <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>InputStream 字节输入流，OutputStream 字节输出流，用于以字节的形式读取和写入数据<br>ASCII 码：</p><blockquote><p><strong>所有的数据</strong>存放在计算机中都是以<strong>数字的形式存放</strong>的。所以<strong>字母就需要转换为数字</strong>才能够存放。<br>比如 A 就对应的数字 65，a 对应的数字 97. 不同的字母和符号对应不同的数字，就是一张码表。<br>ASCII 是这样的一种码表。只包含简单的<strong>英文字母，符号，数字</strong>等等。不包含中文，德文，俄语等复杂的。<br><strong>InputStream 是字节输入流，同时也是抽象类</strong>，只提供方法声明，不提供方法的具体实现。 <strong>FileInputStream</strong> 是 InputStream<strong>子类</strong>，<strong>read</strong> 方法进行读文件数据到（字节数组）内存为 <strong>ASCII 码</strong>，以 FileInputStream 为例进行文件读取<br><strong>OutputStream 是字节输出流</strong>，同时也是抽象类，只提供方法声明，不提供方法的具体实现。<strong>FileOutputStream</strong> 是 OutputStream<strong>子类</strong>,<strong>write</strong>方法将字节数组数据写入到文件中, 如果<strong>写入数字即转为对应 ASCII 码字符</strong>，如<strong>写入字符则无变化</strong>，以 FileOutputStream 为例向文件写出数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyIO;  <br><span class="hljs-keyword">import</span> java. io.*;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStream</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;D:\\testFios. txt&quot;</span>);  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span> (f);  <br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (f);  <br>            <span class="hljs-type">byte</span>[] out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">64</span>, <span class="hljs-number">65</span>, <span class="hljs-number">66</span>&#125;;  <br>            <span class="hljs-type">byte</span>[] in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">3</span>];  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                fos. write (out);  <br>                fis. read (in);  <br>                fis. close ();  <br>                fos. close ();  <br>                System. out. println (<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (in));  <br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>关闭流：<br>把<strong>流定义在 try ()里</strong>, try, catch 或者 finally 结束的时候，会<strong>自动关闭</strong><br>这种编写代码的方式叫做 <strong>try-with-resources</strong>，这是从 JDK 7 开始支持的技术<br>所有的流，都实现了一个接口叫做 <strong>AutoCloseable</strong>，任何类实现了这个接口，都可以在 try ()中进行实例化。并且在 try, catch, finally 结束的时候自动关闭，回收相关资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;d:/lol. txt&quot;</span>);<br>        <span class="hljs-comment">//把流定义在 try ()里, try, catch 或者 finally 结束的时候，会自动关闭</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (f)) &#123;<br>            <span class="hljs-type">byte</span>[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>) f.length ()];<br>            fis. read (all);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : all) &#123;<br>                System. out. println (b);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace ();<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p><strong>Reader</strong> 字符输入流，<strong>Writer</strong> 字符输出流，专门用于字符的形式读取和写入数据</p><ul><li>FileReader 是 Reader 子类，以 FileReader 为例进行文件读取</li><li>FIleWriter 是 Writer 子类，以 FileWriter 为例进行文件写入<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyIO;  <br><span class="hljs-keyword">import</span> java. io.*;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestReaderAndWriter</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;D:/testrw. txt&quot;</span>);  <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span> (f)) &#123;  <br>            <span class="hljs-type">char</span>[] rw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;中&#x27;</span>, <span class="hljs-string">&#x27;国&#x27;</span>&#125;;  <br>            fw. write (rw);  <br>            System. out. println (<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (rw));  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>        &#125;  <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span> (f)) &#123;  <br>            <span class="hljs-type">char</span>[] rc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[(<span class="hljs-type">int</span>) f.length ()];  <br>            fr. read (rc);  <br>            System. out. println (<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (rc));  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p><span style="background:rgba(240, 200, 0, 0.2)">Java 采用的是 Unicode</span><br>工作后经常接触的编码方式有如下几种：  </p><blockquote><p>ISO-8859-1 ASCII 数字和西欧字母<br>GBK GB 2312 BIG 5 中文<br>UNICODE (统一码，万国码)<br>其中<br>ISO-8859-1 包含 ASCII<br>GB 2312 是简体中文，BIG 5 是繁体中文，GBK 同时包含简体和繁体以及日文。<br>UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含<br><img src="https://stepimagewm.how2j.cn/2482.png"><br>UNICODE 对所有字符采用 <strong>2 个字节</strong>浪费空间，于是出现各种减肥子编码, 比如 UTF-8 对<strong>数字和字母</strong>就使用<strong>一个字节</strong>，而对<strong>汉字</strong>就使用<strong>3 个字节</strong>，从而达到了减肥还能保证健康的效果，UTF-8，UTF-16 和 UTF-32 针对不同类型的数据有不同的减肥效果，一般说来 UTF-8 是比较常用的方式<br>UTF-8 编码的字节转中文：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;(<span class="hljs-type">byte</span>) <span class="hljs-number">0</span> xE <span class="hljs-number">5</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span> xB <span class="hljs-number">1</span>, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span> x <span class="hljs-number">8</span> C&#125;;  <br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span> (bs, StandardCharsets. UTF_8);  <br>System. out. println (s);<br></code></pre></td></tr></table></figure><h4 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h4><p>避免字节流、字符流每次读写都频繁访问磁盘，严重增加磁盘压力，为了减少 IO 操作，采用缓存流对待读写的内容放到<strong>缓存中</strong>进行临时存储，结束读写时一次性读写磁盘。</p><blockquote><p><strong>缓存流必须建立在一个存在的流（FileReader，FileWriter 等）的基础上</strong></p></blockquote><h5 id="缓存流读取数据"><a href="#缓存流读取数据" class="headerlink" title="缓存流读取数据"></a>缓存流读取数据</h5><p>缓存字符输入流 <code>BufferedReader</code> 可以<strong>一次读取一行数据</strong></p><h5 id="缓存流写出数据"><a href="#缓存流写出数据" class="headerlink" title="缓存流写出数据"></a>缓存流写出数据</h5><p><code>PrintWriter</code> 缓存字符输出流，可以<strong>一次写出一行数据</strong></p><blockquote><p>[!NOTE] BufferWriter 和 PrintWriter 对比<br><code>BufferedWriter</code>: 将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write ()方法可以将获取到的字符输出，然后通过 newLine ()进行换行操作。BufferedWriter 中的字符流必须通过<strong>调用 flush 方法才能将其刷出去</strong>。并且 BufferedWriter <strong>只能对字符流进行操作</strong>。如果要对字节流操作，则使用 BufferedInputStream。<br><code>PrintWriter</code>: 向文本输出流打印对象的格式化表示形式 (Prints formatted representations of objects to a text-output stream)。PrintWriter 相对于 BufferedWriter 的好处在于，如果 PrintWriter 开启了<strong>自动刷新</strong>，那么当 PrintWriter 调用 println，prinlf 或 format 方法时，输出流中的数据就会自动刷新出去。PrintWriter 不但能接收字符流，<strong>也能接收字节流</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;D:/testbr. txt&quot;</span>);  <br><span class="hljs-comment">//        逐行写入字符到磁盘  </span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span> (f)) &#123;  <br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span> (fw);  <br>            pw. println (<span class="hljs-string">&quot;Hello, World!&quot;</span>);  <br>            pw. println (<span class="hljs-string">&quot;Writer StringLine!&quot;</span>);  <br><span class="hljs-comment">//            提前刷新缓存将数据写入磁盘  </span><br>            pw. flush ();  <br>            pw. println (<span class="hljs-string">&quot;Success!&quot;</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>        &#125;  <br><span class="hljs-comment">//        逐行读文件到内存  </span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span> (f)) &#123;  <br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span> (fr);  <br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>                <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> br. readLine ();  <br>                <span class="hljs-keyword">if</span> (line == <span class="hljs-literal">null</span>)  <br>                    <span class="hljs-keyword">break</span>;  <br>                System. out. println (line);  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><ul><li><code>DataInputStream</code> 数据输入流  </li><li><code>DataOutputStream</code> 数据输出流<blockquote><p>[!NOTE] 注<br>要用 DataInputStream 读取一个文件，这个文件必须是由 DataOutputStream 写出的，否则会出现 EOFException，因为 DataOutputStream 在写出的时候会做一些特殊标记，只有 DataInputStream 才能成功的读取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyIO;  <br><span class="hljs-keyword">import</span> java. io.*;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataStream</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;D:/testds. txt&quot;</span>);  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (f)) &#123;  <br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span> (fs);  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">utfs</span> <span class="hljs-operator">=</span> ds. readUTF ();  <br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> ds. readInt ();  <br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ds. readBoolean ();  <br>            System. out. println (utfs);  <br>            System. out. println (i);  <br>            System. out. println (b);  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>            e.printStackTrace ();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span> (f)) &#123;  <br>            <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span> (fo);  <br>            dos. writeUTF (<span class="hljs-string">&quot;hello&quot;</span>);  <br>            dos. writeInt (<span class="hljs-number">100</span>);  <br>            dos. writeBoolean (<span class="hljs-literal">true</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        write ();  <br>        read ();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><p>对象流指的是可以<strong>直接把一个对象以流的形式传输给其他的介质</strong>，比如硬盘<br>一个<strong>对象以流的形式进行传输</strong>，叫做<strong>序列化</strong>。该对象所对应的类，必须是实现 <code>Serializable</code> 接口，并且使用 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 对流对象使用 <code>writeObject</code> 和 <code>readObject</code> 方法进行写读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Hero. java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;  <br>    <span class="hljs-comment">//表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> L;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> hp;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> armor;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hero</span> <span class="hljs-params">(String name, <span class="hljs-type">float</span> hp, <span class="hljs-type">int</span> armor)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. name = name;  <br>        <span class="hljs-built_in">this</span>. hp = hp;  <br>        <span class="hljs-built_in">this</span>. armor = armor;  <br>        System. out. println (<span class="hljs-built_in">this</span>. getName () + <span class="hljs-string">&quot; is born&quot;</span>);  <br>    &#125;<br>&#125;    <br><span class="hljs-comment">//TestSerializable. java</span><br><span class="hljs-keyword">package</span> MyIO;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> java. io.*;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSerializable</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">garlen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;Garlen&quot;</span>, (<span class="hljs-type">float</span>) (Math. random () * <span class="hljs-number">100</span>), <span class="hljs-number">100</span>);  <br>        Hero[] heroes = &#123;garlen, garlen, garlen, garlen, garlen&#125;;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span> (<span class="hljs-string">&quot;D:\\garlen. txt&quot;</span>);  <br>        <span class="hljs-keyword">try</span> (  <br>                <span class="hljs-comment">//创建对象输出流  </span><br>                <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span> (f);  <br>                <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span> (fos);  <br><span class="hljs-comment">//            创建对象输入流  </span><br>                <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span> (f);  <br>                <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span> (fis)  <br>        ) &#123;  <br>            oos. writeObject (heroes);  <br>            Hero[] heros = (Hero[]) ois. readObject ();  <br>            <span class="hljs-keyword">for</span> (Hero hero : heros) &#123;  <br>                System. out. println (hero. getName () + <span class="hljs-string">&quot;信息为：\n&quot;</span> + hero. getHp () + <span class="hljs-string">&quot;血量，护甲为：&quot;</span> + hero. getArmor ());  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="系统输入输出流"><a href="#系统输入输出流" class="headerlink" title="系统输入输出流"></a>系统输入输出流</h4><ul><li><code>System. out</code> 是常用的在控制台输出数据的  </li><li><code>System. in</code> 可以从控制台输入数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyIO;  <br><span class="hljs-keyword">import</span> java. io. IOException;  <br><span class="hljs-keyword">import</span> java. io. InputStream;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSystemIO</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> System. in;  <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                <span class="hljs-comment">/*  </span><br><span class="hljs-comment">                  敲入 a, 然后敲回车可以看到                                   97 10                                   97 是 a 的 ASCII 码                                  10 分别对应回车换行                  */</span>  <br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> is. read ();  <br>                System. out. println (i);  <br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="Scanner-读取字符串"><a href="#Scanner-读取字符串" class="headerlink" title="Scanner 读取字符串"></a>Scanner 读取字符串</h5><p>使用 <strong>System. in. read</strong> 虽然可以读取数据，但是很不方便，使用 <code>Scanner</code> 就可以<strong>逐行读取</strong>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scanner</span> <span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span> (System. in);  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>        String s <span class="hljs-number">1</span> = s.next ();  <br>        <span class="hljs-keyword">if</span> (s <span class="hljs-number">1.</span> equals (<span class="hljs-string">&quot;exit&quot;</span>))  <br>            <span class="hljs-keyword">break</span>;  <br>        System. out. println (s <span class="hljs-number">1</span>);  <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList 相当于 C++里的 Vector，动态数组，可以自动扩容<br>ArrayList 实现了 List 接口，通常会定义 List 引用指向 ArrayList 对象，便于多态。</p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">add</td><td align="center">增加</td></tr><tr><td align="center">contains</td><td align="center">判断是否存在</td></tr><tr><td align="center">get</td><td align="center">获取指定位置的对象</td></tr><tr><td align="center">indexOf</td><td align="center">获取对象所处的位置</td></tr><tr><td align="center">remove</td><td align="center">删除</td></tr><tr><td align="center">set</td><td align="center">替换</td></tr><tr><td align="center">size</td><td align="center">获取大小</td></tr><tr><td align="center">toArray</td><td align="center">转换为数组</td></tr><tr><td align="center">addAll</td><td align="center">把另一个容器所有对象都加进来</td></tr><tr><td align="center">clear</td><td align="center">清空</td></tr><tr><td align="center">eg：toArray</td><td align="center"></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Myvector;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> java. util. ArrayList;  <br><span class="hljs-keyword">import</span> java. util. HashMap;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestArrayList</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        ArrayList&lt;Hero&gt; heroList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;() &#123;  <br>            &#123;  <br><span class="hljs-comment">//                匿名内部类 ArrayList 对象初始化块  </span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;  <br>                    add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;  <br>                        <span class="hljs-comment">//                        匿名内部类 Hero 对象初始化块  </span><br>                        &#123;  <br>                            put (<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span> + finalI);  <br>                            put (<span class="hljs-string">&quot;hp&quot;</span>, (<span class="hljs-type">float</span>) Math. random () * <span class="hljs-number">100</span>);  <br>                            put (<span class="hljs-string">&quot;armor&quot;</span>, <span class="hljs-number">10</span>);  <br>                        &#125;  <br>                    &#125;));  <br>                &#125;  <br>            &#125;  <br>        &#125;;  <br>        <span class="hljs-keyword">for</span> (Object o : heroList. toArray ()) &#123;  <br>            System. out. println (o.toString ());  <br>        &#125;  <br>        heroList. clear ();  <br>        System. out. println (heroList. size ());  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="泛型-Generic"><a href="#泛型-Generic" class="headerlink" title="泛型 Generic"></a>泛型 Generic</h4><ul><li>不指定泛型的容器，可以存放任何类型的元素</li><li>指定了泛型的容器，只能存放指定类型的元素以及其子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//对于不使用泛型的容器，可以往里面放英雄，也可以往里面放物品</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">heros</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span> ();<br>        heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;盖伦&quot;</span>));<br>        <span class="hljs-comment">//本来用于存放英雄的容器，现在也可以存放物品了</span><br>        heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span> (<span class="hljs-string">&quot;冰杖&quot;</span>));<br>        <span class="hljs-comment">//对象转型会出现问题</span><br>        Hero h <span class="hljs-number">1</span>=  (Hero) heros. get (<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//尤其是在容器里放的对象太多的时候，就记不清楚哪个位置放的是哪种类型的对象了</span><br>        Hero h <span class="hljs-number">2</span>=  (Hero) heros. get (<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//引入泛型 Generic</span><br>        <span class="hljs-comment">//声明容器的时候，就指定了这种容器，只能放 Hero，放其他的就会出错</span><br>        List&lt;Hero&gt; genericheros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();<br>        genericheros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;盖伦&quot;</span>));<br>        <span class="hljs-comment">//如果不是 Hero 类型，根本就放不进去</span><br>        <span class="hljs-comment">//genericheros. add (new Item (&quot;冰杖&quot;));</span><br>        <span class="hljs-comment">//除此之外，还能存放 Hero 的子类</span><br>        genericheros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">APHero</span> ());<br>        <span class="hljs-comment">//并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的 Hero 或者其子类</span><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> genericheros. get (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>List&lt;Hero&gt; genericheros = new ArrayList&lt;Hero&gt;();</code> 可以简写为 <code>List&lt;Hero&gt; genericheros 2 = new ArrayList&lt;&gt;();</code><br>ArrayList 容器有迭代器，可以通过迭代器进行遍历全部元素，<code>iterator</code> 方法得到迭代器, 迭代器通过 <code>hasNext</code> 方法进行迭代并自动更新位置。<br><img src="https://stepimagewm.how2j.cn/806.png"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();<br><span class="hljs-comment">//放 5 个 Hero 进入容器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero name &quot;</span> +i));<br>&#125;<br><span class="hljs-comment">//第二种遍历，使用迭代器</span><br>System. out. println (<span class="hljs-string">&quot;--------使用 while 的 iterator-------&quot;</span>);<br>Iterator&lt;Hero&gt; it= heros. iterator ();<br><span class="hljs-comment">//从最开始的位置判断&quot;下一个&quot;位置是否有数据</span><br><span class="hljs-comment">//如果有就通过 next 取出来，并且把指针向下移动</span><br><span class="hljs-comment">//直到&quot;下一个&quot;位置没有数据</span><br><span class="hljs-keyword">while</span> (it. hasNext ())&#123;<br>    <span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> it. next ();<br>    System. out. println (h);<br>&#125;<br><span class="hljs-comment">//迭代器的 for 写法</span><br>System. out. println (<span class="hljs-string">&quot;--------使用 for 的 iterator-------&quot;</span>);<br><span class="hljs-keyword">for</span> (Iterator&lt;Hero&gt; iterator = heros. iterator (); iterator. hasNext ();) &#123;<br>    <span class="hljs-type">Hero</span> <span class="hljs-variable">hero</span> <span class="hljs-operator">=</span> (Hero) iterator. next ();<br>    System. out. println (hero);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="其他集合"><a href="#其他集合" class="headerlink" title="其他集合"></a>其他集合</h4><p>序列分先进先出 FIFO, 先进后出 FILO<br>    - FIFO 在 Java 中又叫 Queue 队列<br>    - FILO 在 Java 中又叫 Stack 栈</p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>LinkedList 也实现了 List 接口，诸如 add, remove, contains 等等方法</p><h6 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h6><p>除了实现了 List 接口外，LinkedList 还实现了双向链表结构 <code>Deque</code>，可以很方便的在<strong>头尾插入删除数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//LinkedList 是一个双向链表结构的 list</span><br>        LinkedList&lt;Hero&gt; ll =<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Hero&gt;();<br>        <span class="hljs-comment">//所以可以很方便的在头部和尾部插入数据</span><br>        <span class="hljs-comment">//在最后插入新的英雄</span><br>        ll. addLast (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero 1&quot;</span>));<br>        ll. addLast (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero 2&quot;</span>));<br>        ll. addLast (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero 3&quot;</span>));<br>        System. out. println (ll);<br>        <span class="hljs-comment">//在最前面插入新的英雄</span><br>        ll. addFirst (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;heroX&quot;</span>));<br>        System. out. println (ll);<br>        <span class="hljs-comment">//查看最前面的英雄</span><br>        System. out. println (ll. getFirst ());<br>        <span class="hljs-comment">//查看最后面的英雄</span><br>        System. out. println (ll. getLast ());<br>        <span class="hljs-comment">//查看不会导致英雄被删除</span><br>        System. out. println (ll);<br>        <span class="hljs-comment">//取出最前面的英雄</span><br>        System. out. println (ll. removeFirst ());<br>        <span class="hljs-comment">//取出最后面的英雄</span><br>        System. out. println (ll. removeLast ());<br>        <span class="hljs-comment">//取出会导致英雄被删除</span><br>        System. out. println (ll);<br></code></pre></td></tr></table></figure><h6 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h6><p>LinkedList 除了实现了 List 和 Deque 外，还实现了 <strong>Queue 接口</strong> (队列)。<br>Queue 是先进先出队列 FIFO，常用方法：  </p><blockquote><ol><li><code>offer</code> 在最后添加元素  </li><li><code>poll</code> 取出第一个元素  </li><li><code>peek</code> 查看第一个元素</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//和 ArrayList 一样，LinkedList 也实现了 List 接口</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">ll</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Hero&gt;();<br>        <span class="hljs-comment">//所不同的是 LinkedList 还实现了 Deque，进而又实现了 Queue 这个接口</span><br>        <span class="hljs-comment">//Queue 代表 FIFO 先进先出的队列</span><br>        Queue&lt;Hero&gt; q= <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Hero&gt;();<br>        <span class="hljs-comment">//加在队列的最后面</span><br>        System. out. print (<span class="hljs-string">&quot;初始化队列：\t&quot;</span>);<br>        q.offer (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;Hero 1&quot;</span>));<br>        q.offer (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;Hero 2&quot;</span>));<br>        q.offer (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;Hero 3&quot;</span>));<br>        q.offer (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;Hero 4&quot;</span>));<br>        System. out. println (q);<br>        System. out. print (<span class="hljs-string">&quot;把第一个元素取 poll ()出来:\t&quot;</span>);<br>        <span class="hljs-comment">//取出第一个 Hero，FIFO 先进先出</span><br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> q.poll ();<br>        System. out. println (h);<br>        System. out. print (<span class="hljs-string">&quot;取出第一个元素之后的队列:\t&quot;</span>);<br>        System. out. println (q);<br>        <span class="hljs-comment">//把第一个拿出来看一看，但是不取出来</span><br>        h=q.peek ();<br>        System. out. print (<span class="hljs-string">&quot;查看 peek ()第一个元素:\t&quot;</span>);<br>        System. out. println (h);<br>        System. out. print (<span class="hljs-string">&quot;查看并不会导致第一个元素被取出来:\t&quot;</span>);<br>        System. out. println (q);<br></code></pre></td></tr></table></figure><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>二叉树由各种节点组成<br>二叉树特点：  </p><blockquote><ul><li>每个节点都可以有<strong>左子节点</strong>，<strong>右子节点</strong>  </li><li>每一个节点都有一个<strong>值</strong><br><img src="https://stepimagewm.how2j.cn/1008.png"></li></ul></blockquote><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> collection;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 左子节点</span><br>    <span class="hljs-keyword">public</span> Node leftNode;<br>    <span class="hljs-comment">// 右子节点</span><br>    <span class="hljs-keyword">public</span> Node rightNode;<br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-keyword">public</span> Object value;<br>    <span class="hljs-comment">// 插入数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(Object v)</span> &#123;<br>        <span class="hljs-comment">// 如果当前节点没有值，就把数据放在当前节点上</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == value)<br>            value = v;<br>        <span class="hljs-comment">// 如果当前节点有值，就进行判断，新增的值与当前值的大小关系</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 新增的值，比当前值小或者相同</span><br>            <span class="hljs-keyword">if</span> ((Integer) v -((Integer) value) &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == leftNode)<br>                    leftNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span> ();<br>                leftNode. add (v);<br>            &#125;<br>            <span class="hljs-comment">// 新增的值，比当前值大</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == rightNode)<br>                    rightNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span> ();<br>                rightNode. add (v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> randoms[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; <span class="hljs-number">67</span>, <span class="hljs-number">7</span>, <span class="hljs-number">30</span>, <span class="hljs-number">73</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">78</span>, <span class="hljs-number">81</span>, <span class="hljs-number">10</span>, <span class="hljs-number">74</span> &#125;;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">roots</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span> ();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> number : randoms) &#123;<br>            roots. add (number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><p>二叉树的遍历分左序，中序，右序  </p><blockquote><ol><li>左序即： 中间的数遍历后放在左边  </li><li>中序即： 中间的数遍历后放在中间  </li><li>右序即： 中间的数遍历后放在右边<br>eg：中序遍历（递归）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中序遍历所有的节点</span><br>    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">values</span> <span class="hljs-params">()</span> &#123;<br>        List&lt;Object&gt; values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 左节点的遍历结果</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != leftNode)<br>            values. addAll (leftNode. values ());<br>        <span class="hljs-comment">// 当前节点</span><br>        values. add (value);<br>        <span class="hljs-comment">// 右节点的遍历结果</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != rightNode)<br>            values. addAll (rightNode. values ());<br>        <span class="hljs-keyword">return</span> values;<br>    &#125;<br></code></pre></td></tr></table></figure><p>eg：英雄 tree</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Myvector;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> java. util. ArrayList;  <br><span class="hljs-keyword">import</span> java. util. HashMap;  <br><span class="hljs-keyword">import</span> java. util. List;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeroTree</span> &#123;  <br>    <span class="hljs-type">HeroTree</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-type">HeroTree</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    Hero value;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">HeroTree</span> <span class="hljs-variable">heroTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroTree</span> () &#123;  <br>            &#123;  <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;  <br>                    add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;() &#123;  <br>                        &#123;  <br>                            put (<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span> + finalI);  <br>                            put (<span class="hljs-string">&quot;hp&quot;</span>, (<span class="hljs-type">float</span>) Math. random () * <span class="hljs-number">100</span>);  <br>                            put (<span class="hljs-string">&quot;armor&quot;</span>, <span class="hljs-number">10</span>);  <br>                        &#125;  <br>                    &#125;));  <br>                &#125;  <br>            &#125;  <br>        &#125;;  <br>        inorderTraversal (heroTree);  <br><span class="hljs-comment">//        System. out. println (heroTree. values ());  </span><br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorderTraversal</span> <span class="hljs-params">(HeroTree tree)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (tree != <span class="hljs-literal">null</span>) &#123;  <br>            inorderTraversal (tree. left);  <br>            System. out. println (tree. value. toString ());  <br>            inorderTraversal (tree. right);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 中序遍历所有的节点  </span><br>    <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">values</span> <span class="hljs-params">()</span> &#123;  <br>        List&lt;Object&gt; values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-comment">// 左节点的遍历结果  </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != left)  <br>            values. addAll (left. values ());  <br>        <span class="hljs-comment">// 当前节点  </span><br>        values. add (value);  <br>        <span class="hljs-comment">// 右节点的遍历结果  </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != right)  <br>            values. addAll (right. values ());  <br>        <span class="hljs-keyword">return</span> values;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(Hero hero)</span> &#123;  <br><span class="hljs-comment">//        添加根节点  </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. value == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-built_in">this</span>. value = hero;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-keyword">if</span> (hero. getHp () &lt;= <span class="hljs-built_in">this</span>. value. getHp ()) &#123;  <br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. left == <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-built_in">this</span>. left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroTree</span> ();  <br>                &#125;  <br>                <span class="hljs-built_in">this</span>. left. add (hero);  <br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>. right == <span class="hljs-literal">null</span>) &#123;  <br>                    <span class="hljs-built_in">this</span>. right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroTree</span> ();  <br>                &#125;  <br>                <span class="hljs-built_in">this</span>. right. add (hero);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>HashMap 储存数据的方式是—— 键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String,String&gt; dictionary = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        dictionary. put (<span class="hljs-string">&quot;adc&quot;</span>, <span class="hljs-string">&quot;物理英雄&quot;</span>);<br>        dictionary. put (<span class="hljs-string">&quot;apc&quot;</span>, <span class="hljs-string">&quot;魔法英雄&quot;</span>);<br>        dictionary. put (<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;坦克&quot;</span>);<br></code></pre></td></tr></table></figure><p>（1）<strong>键唯一，值可重复</strong><br>对于 HashMap 而言，key 是唯一的，不可以重复的。<br>所以，以相同的 key 把不同的 value 插入到 Map 中会导致旧元素被覆盖，只留下最后插入的元素。<br>不过，同一个对象可以作为值插入到 map 中，只要对应的 key 不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String,Hero&gt; heroMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String,Hero&gt;();<br>        heroMap. put (<span class="hljs-string">&quot;gareen&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;gareen 1&quot;</span>));<br>        System. out. println (heroMap);<br>        <span class="hljs-comment">//key 为 gareen 已经有 value 了，再以 gareen 作为 key 放入数据，会导致原英雄，被覆盖</span><br>        <span class="hljs-comment">//不会增加新的元素到 Map 中</span><br>        heroMap. put (<span class="hljs-string">&quot;gareen&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;gareen 2&quot;</span>));<br>        System. out. println (heroMap);<br>        <span class="hljs-comment">//清空 map</span><br>        heroMap. clear ();<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;gareen&quot;</span>);<br>        <span class="hljs-comment">//同一个对象可以作为值插入到 map 中，只要对应的 key 不一样</span><br>        heroMap. put (<span class="hljs-string">&quot;hero 1&quot;</span>, gareen);<br>        heroMap. put (<span class="hljs-string">&quot;hero 2&quot;</span>, gareen);<br>        System. out. println (heroMap);<br></code></pre></td></tr></table></figure><h6 id="HashMap-性能卓越的原因"><a href="#HashMap-性能卓越的原因" class="headerlink" title="HashMap 性能卓越的原因"></a>HashMap 性能卓越的原因</h6><blockquote><p><strong>哈希计算数组索引，同哈希值采用链表进行延长存储。</strong></p></blockquote><ol><li><strong>hashcode 概念</strong><br>所有的对象，都有一个对应的 hashcode（散列值）<br>比如字符串“gareen”对应的是 1001 (实际上不是，这里是方便理解，假设的值)<br>比如字符串“temoo”对应的是 1004<br>比如字符串“db”对应的是 1008<br>比如字符串“annie”对应的也是 1008  </li><li><strong>保存数据</strong><br>准备一个数组，其长度是 2000，并且设定特殊的 hashcode 算法，使得所有字符串对应的 hashcode，都会落在 0-1999 之间<br>要存放名字是”gareen”的英雄，就把该英雄和名称组成一个键值对，存放在数组的 1001 这个位置上<br>要存放名字是”temoo”的英雄，就把该英雄存放在数组的 1004 这个位置上<br>要存放名字是”db”的英雄，就把该英雄存放在数组的 1008 这个位置上<br>要存放名字是”annie”的英雄，然而 “annie”的 hashcode 1008 对应的位置已经有 db 英雄了，那么就在这里创建一个链表，接在 db 英雄后面存放 annie  </li><li><strong>查找数据</strong><br>比如要查找 gareen，首先计算”gareen”的 hashcode 是 1001，根据 1001 这个下标，到数组中进行定位，（根据数组下标进行定位，是非常快速的） 发现 1001 这个位置就只有一个英雄，那么该英雄就是 gareen.<br>比如要查找 annie，首先计算”annie”的 hashcode 是 1008，根据 1008 这个下标，到数组中进行定位，发现 1008 这个位置有两个英雄，那么就对两个英雄的名字进行逐一比较 (equals)，因为此时需要比较的量就已经少很多了，很快也就可以找出目标英雄，这就是使用 hashmap 进行查询，非常快原理。</li></ol><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>（1）<strong>元素不能重复</strong><br>Set 中的元素，不能重复<br>（2）<strong>没有顺序</strong><br>Set 中的元素，没有顺序。<br>严格的说，是没有按照元素的插入顺序排列<br>HashSet 的具体顺序，既不是按照插入顺序，也不是按照 hashcode 的顺序。<br>（3）<strong>遍历</strong><br>Set 不提供 get ()来获取指定位置的元素<br>所以遍历需要用到<strong>迭代器</strong>，或者<strong>增强型 for 循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历 Set 可以采用迭代器 iterator</span><br>        <span class="hljs-keyword">for</span> (Iterator&lt;Integer&gt; iterator = numbers. iterator (); iterator. hasNext ();) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (Integer) iterator. next ();<br>            System. out. println (i);<br>        &#125;<br>        <span class="hljs-comment">//或者采用增强型 for 循环</span><br>        <span class="hljs-keyword">for</span> (Integer i : numbers) &#123;<br>            System. out. println (i);<br>        &#125;<br></code></pre></td></tr></table></figure><p>（4）<strong>HashSet 和 HashMap 的关系</strong><br>通过观察 HashSet 的源代码（<a href="https://how2j.cn/k/helloworld/helloworld-eclipse-tips/300.html#step706">如何查看源代码</a>）<br>可以发现 HashSet 自身并没有独立的实现，而是在里面<strong>封装了一个 Map</strong>.<br>HashSet 是作为<strong>Map 的 key</strong>而存在的<br>而 value 是一个命名为 PRESENT 的 static 的 Object 对象，因为是一个类属性，所以只会有一个。</p><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection 是一个<strong>接口</strong></p><ul><li>Collection 是 Set List Queue 和 Deque 的接口  </li><li>Queue: 先进先出队列  </li><li>Deque: 双向链表  <blockquote><p>注：Collection 和 Map 之间没有关系，Collection 是放一个一个对象的，Map 是放键值对的<br>注：Deque 继承 Queue, 间接的继承了 Collection<br><img src="https://stepimagewm.how2j.cn/830.png"></p></blockquote></li></ul><h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><p>Collections 是一个类，<strong>容器的工具类</strong>, 就如同 Arrays 是数组的工具类</p><p>|关键字|简介|示例代码|<br>|:—:|:—:|<br>|reverse|反转|<br>|shuffle|混淆|<br>|sort|排序|<br>|swap|交换|<br>|rotate|滚动|<br>|synchronizedList|线程安全化|</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections. reverse (numbers);<br>Collections. shuffle (numbers);<br>Collections. sort (numbers);<br>Collections. swap (numbers, <span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br>Collections. rotate (numbers, <span class="hljs-number">2</span>);<span class="hljs-comment">//把集合向右滚动 2 个单位</span><br>List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections. synchronizedList (numbers);<span class="hljs-comment">//把非线程安全的 List 转换为线程安全的 List</span><br></code></pre></td></tr></table></figure><h4 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h4><p>ArrayList: 有顺序, 可重复<br>HashSet: 无顺序，不可重复</p><h4 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h4><p>HashMap 和 Hashtable 都实现了 Map 接口，都是键值对保存数据的方式  </p><blockquote><ol><li>区别 1：<br>HashMap 可以存放 <strong>null</strong><br>Hashtable 不能存放 null  </li><li>区别 2：<br>HashMap 不是<a href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全的类</a><br>Hashtable 是<strong>线程安全的类</strong></li></ol></blockquote><h4 id="HashSet-LinkedHashSet-TreeSet"><a href="#HashSet-LinkedHashSet-TreeSet" class="headerlink" title="HashSet LinkedHashSet TreeSet"></a>HashSet LinkedHashSet TreeSet</h4><p>HashSet： 无序<br>LinkedHashSet： 按照插入顺序<br>TreeSet： 从小到大排序</p><h4 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h4><h5 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h5><p>Comparator 是一个用于比较对象的类，通过重写该类的 compare 方法按照指定规则对类对象进行比较实现排序，<code>compare</code> 方法中<strong>返回正数</strong>表示<strong>第一个形参大于第二个形参</strong>，返回<strong>负数则相反</strong>，<strong>返回 0 则相等</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Hero&gt; heroes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <br>            heroes. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero&quot;</span> + i, r.nextFloat (), r.nextInt ()));  <br>        &#125;  <br>        System. out. println (<span class="hljs-string">&quot;初始化后的集合：&quot;</span>);  <br>        System. out. println (heroes);  <br>        Collections. sort (heroes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Hero&gt;() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br><span class="hljs-comment">//            正数表示 h 1 比 h 2 要大  </span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span> <span class="hljs-params">(Hero h <span class="hljs-number">1</span>, Hero h <span class="hljs-number">2</span>)</span> &#123;  <br>                <span class="hljs-keyword">if</span> (h <span class="hljs-number">1.</span> getHp () &gt; h <span class="hljs-number">2.</span> getHp ())  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (h <span class="hljs-number">1.</span> getHp () &lt; h <span class="hljs-number">2.</span> getHp ()) &#123;  <br>                    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>                &#125;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>            &#125;  <br>        &#125;);  <br>        System. out. println (<span class="hljs-string">&quot;按照血量排序后的集合：&quot;</span>);  <br>        System. out. println (heroes);<br></code></pre></td></tr></table></figure><h5 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h5><p>类实现 <strong>Comparable</strong> 接口重写 <code>compareTo</code> 方法，在类里面提供<strong>比较算法</strong><br><code>Collections. sort</code> 就有足够的信息进行排序了，也<strong>无需额外提供比较器 Comparator</strong>   </p><blockquote><p>注： <strong>如果返回-1, 就表示当前的更小，否则就是更大</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Hero. java 实现 Comparable 接口重写 compareTo 方法</span><br><span class="hljs-keyword">package</span> MyCharacter;  <br><span class="hljs-keyword">import</span> exception. EnemyHeroIsDeadException;  <br><span class="hljs-keyword">import</span> java. io. Serializable;  <br><span class="hljs-keyword">import</span> java. util. Map;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Mortal</span>, Serializable, Comparable&lt;Hero&gt; &#123;  <br>    <span class="hljs-comment">//表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> L;  <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> hp;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> armor;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hero</span> <span class="hljs-params">()</span> &#123;  <br>        System. out. println (<span class="hljs-string">&quot;Hero 构造&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hero</span> <span class="hljs-params">(String name, <span class="hljs-type">float</span> hp, <span class="hljs-type">int</span> armor)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. name = name;  <br>        <span class="hljs-built_in">this</span>. hp = hp;  <br>        <span class="hljs-built_in">this</span>. armor = armor;  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-built_in">super</span>. toString ();  <br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;的血量是 &quot;</span> + hp;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span> <span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. name = name;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getHp</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> hp;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHp</span> <span class="hljs-params">(<span class="hljs-type">float</span> hp)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. hp = hp;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getArmor</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> armor;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArmor</span> <span class="hljs-params">(<span class="hljs-type">int</span> armor)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. armor = armor;  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span> <span class="hljs-params">(Hero h)</span> &#123;  <br>        <span class="hljs-keyword">if</span> (hp &lt; h.getHp ())  <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">//TestComparable. java</span><br>List&lt;Hero&gt; heroes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <br>            heroes. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero&quot;</span> + i, r.nextFloat (), r.nextInt ()));  <br>        &#125;  <br>        System. out. println (<span class="hljs-string">&quot;初始化后的集合：&quot;</span>);  <br>        System. out. println (heroes);<br>        System. out. println (<span class="hljs-string">&quot;按照血量排序后的集合：&quot;</span>);  <br>        System. out. println (heroes);<br></code></pre></td></tr></table></figure><h4 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h4><p>JDK 8 之后，引入了<strong>对集合的聚合操作</strong>，可以非常容易的<strong>遍历，筛选，比较</strong>集合中的元素。用好聚合的前提是必须先掌握 <a href="https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html">Lambda表达式</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span>heros<br>.stream ()<br>.sorted ((h <span class="hljs-number">1</span>, h <span class="hljs-number">2</span>)-&gt;h <span class="hljs-number">1.</span> hp&gt;h <span class="hljs-number">2.</span> hp?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>)<br>.skip (<span class="hljs-number">2</span>)<br>.map (h-&gt;h.getName ())<br>.findFirst ()<br>.get ();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();<br>        List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero &quot;</span> + i, r.nextInt (<span class="hljs-number">1000</span>), r.nextInt (<span class="hljs-number">100</span>)));<br>        &#125;<br>        System. out. println (<span class="hljs-string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);<br>        System. out. println (heros);<br>        <span class="hljs-comment">//传统方式</span><br>        Collections. sort (heros, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Hero&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span> <span class="hljs-params">(Hero o <span class="hljs-number">1</span>, Hero o <span class="hljs-number">2</span>)</span> &#123;<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (o <span class="hljs-number">2.</span> hp-o <span class="hljs-number">1.</span> hp);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">hero</span> <span class="hljs-operator">=</span> heros. get (<span class="hljs-number">2</span>);<br>        System. out. println (<span class="hljs-string">&quot;通过传统方式找出来的 hp 第三高的英雄名称是: &quot;</span> + hero. name);<br>        <span class="hljs-comment">//聚合方式</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span>heros<br>            .stream ()<br>            .sorted ((h <span class="hljs-number">1</span>, h <span class="hljs-number">2</span>)-&gt;h <span class="hljs-number">1.</span> hp&gt;h <span class="hljs-number">2.</span> hp?-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>)<br>            .skip (<span class="hljs-number">2</span>)<br>            .map (h-&gt;h.getName ())<br>            .findFirst ()<br>            .get ();<br>        System. out. println (<span class="hljs-string">&quot;通过聚合操作找出来的 hp 第三高的英雄名称是: &quot;</span> + name);<br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="容器的泛型"><a href="#容器的泛型" class="headerlink" title="容器的泛型"></a>容器的泛型</h4><p>优点：  </p><blockquote><ul><li>泛型的用法是在容器后面添加 <code>&lt;Type&gt;</code>  </li><li>Type 可以是类，抽象类，接口  </li><li>泛型表示这种容器，只能存放指定的类型。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;APHero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;APHero&gt;();<br>        <span class="hljs-comment">//只有 APHero 可以放进去    </span><br>        heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">APHero</span> ());<br>        <span class="hljs-comment">//ADHero 甚至放不进去</span><br>        <span class="hljs-comment">//heros. add (new ADHero ());</span><br>        <span class="hljs-comment">//获取的时候也不需要进行转型，因为取出来一定是 APHero</span><br>        <span class="hljs-type">APHero</span> <span class="hljs-variable">apHero</span> <span class="hljs-operator">=</span>  heros. get (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h4 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h4><p>设计一个支持泛型的栈 MyStack<br>设计这个类的时候，在类的声明上，加上一个 <code>&lt;T&gt;</code>，表示该类支持泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Generics;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> MyCharacter. Item;  <br><span class="hljs-keyword">import</span> java. util. LinkedList;  <br><span class="hljs-keyword">import</span> java. util. Random;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span>&lt;T&gt; &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;T&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        MyStack&lt;Hero&gt; heroMyStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyStack</span>&lt;&gt;();  <br>        heroMyStack. push (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;Hero 1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> (). nextFloat (), <span class="hljs-number">100</span>));  <br>        MyStack&lt;Item&gt; itemMyStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyStack</span>&lt;&gt;();  <br>        itemMyStack. push (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span> () &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">disposable</span> <span class="hljs-params">()</span> &#123;  <br>                System. out. println (<span class="hljs-string">&quot;物品销毁了&quot;</span>);  <br>            &#125;  <br>        &#125;);  <br>        System. out. println (heroMyStack. peek ());  <br>        System. out. println (itemMyStack. peek ());  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span> <span class="hljs-params">(T t)</span> &#123;  <br>        list. addLast (t);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pull</span> <span class="hljs-params">()</span> &#123;  <br>        list. removeLast ();  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">peek</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> list. getLast ();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><h5 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h5><p><code>ArrayList heroList&lt;? extends Hero&gt;</code> 表示这是一个 Hero 泛型或者<strong>其子类</strong>泛型</p><ul><li>heroList 的泛型可能是 Hero  </li><li>heroList 的泛型可能是 APHero  </li><li>heroList 的泛型可能是 ADHero<br>所以可以确凿的是，从 heroList 取出来的对象，一定是可以转型成 Hero 的, 但是，不能往里面放东西，因为  </li><li>放 APHero 就不满足 <code>&lt;ADHero&gt;</code>  </li><li>放 ADHero 又不满足 <code>&lt;APHero&gt;</code><br><img src="https://stepimagewm.how2j.cn/837.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;APHero&gt; apHeroList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;APHero&gt;();  <br>apHeroList. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">APHero</span> ());  <br>ArrayList&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span>&gt; heroList = apHeroList;  <br><span class="hljs-comment">//? extends Hero 表示这是一个 Hero 泛型的子类泛型  </span><br><span class="hljs-comment">//heroList 的泛型可以是 Hero  </span><br><span class="hljs-comment">//heroList 的泛型可以使 APHero  </span><br><span class="hljs-comment">//heroList 的泛型可以使 ADHero  </span><br><span class="hljs-comment">//可以确凿的是，从 heroList 取出来的对象，一定是可以转型成 Hero 的  </span><br><span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> heroList. get (<span class="hljs-number">0</span>);  <br><span class="hljs-comment">//但是，不能往里面放东西, 编译错误  </span><br>heroList. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span> ()); <span class="hljs-comment">//编译错误，因为 heroList 的泛型有可能是 APHero</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="super"><a href="#super" class="headerlink" title="? super"></a>? super</h5><p><code>ArrayList heroList&lt;? super Hero&gt;</code> 表示这是一个 Hero 泛型或者其<strong>父类泛型</strong></p><ul><li>heroList 的泛型可能是 Hero  </li><li>heroList 的泛型可能是 Object  <blockquote><p>可以往里面插入 Hero 以及 Hero 的子类<br>但是取出来有风险，因为不确定取出来是 Hero 还是 Object<br><img src="https://stepimagewm.how2j.cn/838.png"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;? <span class="hljs-built_in">super</span> Hero&gt; heroList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();  <br><span class="hljs-comment">//? super Hero 表示 heroList 的泛型是 Hero 或者其父类泛型  </span><br><span class="hljs-comment">//heroList 的泛型可以是 Hero  </span><br><span class="hljs-comment">//heroList 的泛型可以是 Object  </span><br><span class="hljs-comment">//所以就可以插入 Hero  </span><br>heroList. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ());  <br><span class="hljs-comment">//也可以插入 Hero 的子类  </span><br>heroList. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">APHero</span> ());  <br>heroList. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ADHero</span> ());  <br><span class="hljs-comment">//但是，不能从里面取数据出来, 因为其泛型可能是 Object, 而 Object 是强转 Hero 会失败  </span><br><span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> heroList. get (<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h5 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符?"></a>泛型通配符?</h5><p>泛型通配符? 代表<strong>任意泛型</strong>  ，这个容器什么泛型都有可能 ,所以只能以 <strong>Object</strong> 的形式取出来 ,并且<strong>不能往里面放对象</strong>，因为不知道到底是一个什么泛型的容器<br><img src="https://stepimagewm.how2j.cn/836.png"></p><blockquote><ol><li>如果希望只取出，不插入，就使用? extends Hero  </li><li>如果希望只插入，不取出，就使用? super Hero  </li><li>如果希望，又能插入，又能取出，就不要用通配符？</li></ol></blockquote><h5 id="泛型转型"><a href="#泛型转型" class="headerlink" title="泛型转型"></a>泛型转型</h5><h6 id="子类泛型转父类泛型"><a href="#子类泛型转父类泛型" class="headerlink" title="子类泛型转父类泛型"></a>子类泛型转父类泛型</h6><blockquote><p><strong>子类泛型无法转为父类泛型</strong><br><img src="https://stepimagewm.how2j.cn/835.png"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Hero&gt; hs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br>ArrayList&lt;ADHero&gt; adhs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();  <br><span class="hljs-comment">//子类泛型转父类泛型  </span><br>hs = adhs;<br></code></pre></td></tr></table></figure><h6 id="父类泛型转子类泛型"><a href="#父类泛型转子类泛型" class="headerlink" title="父类泛型转子类泛型"></a>父类泛型转子类泛型</h6><blockquote><p><strong>父类泛型不可以转子类泛型</strong><br>[!NOTE]<br><strong>引用类型</strong>决定容器<strong>取出元素的类型</strong>，引用指向的<strong>对象的类型</strong>决定容器可以<strong>操作（增删改查）的类型</strong></p></blockquote><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://zhuanlan.zhihu.com/p/593602322<br>title: &quot;万字长文详解Java lambda表达式&quot;<br>description: &quot;简介： 详细介绍java lambda的各种使用方式以及lambda的实行原理和序列化原理 本文的脉络如下 Lambda介绍何为lambda咱们首先来说说 Lambda 这个名字，Lambda 并不是一个什么的缩写，它是希腊第十一个字母 λ 的读…&quot;<br>host: zhuanlan.zhihu.com<br>image: https://pic1.zhimg.com/v2-1d5b8bd96ea9c5504d75317a26522be1_720w.jpg?source=172ae18b<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/593602322">万字长文详解Java lambda表达式 - 知乎</a><br>它们要么返回一个值要么执行一段方法<br>缺点：</p><ol><li>可读性差，与啰嗦的但是清晰的匿名类代码结构比较起来，Lambda 表达式一旦变得比较长，就难以理解  </li><li>不便于调试，很难在 Lambda 表达式中增加调试信息，比如日志  </li><li>版本支持，Lambda 表达式在 JDK 8 版本中才开始支持，如果系统使用的是以前的版本，考虑系统的稳定性等原因，而不愿意升级，那么就无法使用。</li></ol><h4 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h4><p>使用一个普通方法，在 for 循环遍历中进行条件判断，筛选出满足条件的数据<br>&#x3D;&#x3D;hp&gt;100 &amp;&amp; damage&lt;50&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();<br>    List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero &quot;</span> + i, r.nextInt (<span class="hljs-number">1000</span>), r.nextInt (<span class="hljs-number">100</span>)));<br>    &#125;<br>    System. out. println (<span class="hljs-string">&quot;初始化后的集合：&quot;</span>);<br>    System. out. println (heros);<br>    System. out. println (<span class="hljs-string">&quot;筛选出 hp&gt;100 &amp;&amp; damange&lt;50 的英雄&quot;</span>);<br>    filter (heros);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filter</span> <span class="hljs-params">(List&lt;Hero&gt; heros)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Hero hero : heros) &#123;<br>        <span class="hljs-keyword">if</span> (hero. hp&gt;<span class="hljs-number">100</span> &amp;&amp; hero. damage&lt;<span class="hljs-number">50</span>)<br>            System. out. print (hero);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名类方式"><a href="#匿名类方式" class="headerlink" title="匿名类方式"></a>匿名类方式</h4><p>首先准备一个接口 HeroChecker，提供一个 test (Hero)方法，然后通过匿名类的方式，实现这个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();<br>    List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero &quot;</span> + i, r.nextInt (<span class="hljs-number">1000</span>), r.nextInt (<span class="hljs-number">100</span>)));<br>    &#125;<br>    System. out. println (<span class="hljs-string">&quot;初始化后的集合：&quot;</span>);<br>    System. out. println (heros);<br>    System. out. println (<span class="hljs-string">&quot;使用匿名类的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50 的英雄&quot;</span>);<br>    <span class="hljs-type">HeroChecker</span> <span class="hljs-variable">checker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroChecker</span> () &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span> <span class="hljs-params">(Hero h)</span> &#123;<br>            <span class="hljs-keyword">return</span> (h.hp&gt;<span class="hljs-number">100</span> &amp;&amp; h.damage&lt;<span class="hljs-number">50</span>);<br>        &#125;<br>    &#125;;<br>    filter (heros, checker);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filter</span> <span class="hljs-params">(List&lt;Hero&gt; heros, HeroChecker checker)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Hero hero : heros) &#123;<br>        <span class="hljs-keyword">if</span> (checker. test (hero))<br>            System. out. print (hero);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lambda-方式"><a href="#Lambda-方式" class="headerlink" title="Lambda 方式"></a>Lambda 方式</h4><p>使用 Lambda 方式筛选出数据<br><code>filter (heros, (h)-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</code><br>同样是调用 <code>filter</code> 方法，从上一步的传递匿名类对象，变成了传递一个 Lambda 表达式进去<br><code>h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TestLambda. java</span><br>        <span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();  <br>        List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>            heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero &quot;</span> + i, r.nextFloat (<span class="hljs-number">1000</span>), r.nextInt (<span class="hljs-number">100</span>)));  <br>        &#125;  <br>        System. out. println (<span class="hljs-string">&quot;初始化后的集合：&quot;</span>);  <br>        System. out. println (heros);  <br>        System. out. println (<span class="hljs-string">&quot;使用 Lamdba 的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50 的英雄&quot;</span>);  <br>        filter (heros, h -&gt; h.getHp () &gt; <span class="hljs-number">100</span> &amp;&amp; h.getArmor () &lt; <span class="hljs-number">50</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filter</span> <span class="hljs-params">(List&lt;Hero&gt; heros, HeroChecker checker)</span> &#123;  <br>        <span class="hljs-keyword">for</span> (Hero hero : heros) &#123;  <br>            <span class="hljs-keyword">if</span> (checker. test (hero))  <br>                System. out. print (hero);  <br>        &#125;  <br>    &#125;<br><span class="hljs-comment">//HeroChecker. java</span><br><span class="hljs-keyword">package</span> Lambda;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HeroChecker</span> &#123;  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span> <span class="hljs-params">(Hero h)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名类-Lambda-表达式"><a href="#匿名类-Lambda-表达式" class="headerlink" title="匿名类-&gt;Lambda 表达式"></a>匿名类-&gt;Lambda 表达式</h4><ol><li>匿名类的正常写法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">HeroChecker c <span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeroChecker</span> () &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span> <span class="hljs-params">(Hero h)</span> &#123;<br><span class="hljs-keyword">return</span> (h.hp&gt;<span class="hljs-number">100</span> &amp;&amp; h.damage&lt;<span class="hljs-number">50</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>把外面的壳子去掉<br>只保留方法参数和方法体<br>参数和方法体之间加上符号 -&gt;  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">HeroChecker c <span class="hljs-number">2</span> = (Hero h) -&gt;&#123;<br><span class="hljs-keyword">return</span> h.hp&gt;<span class="hljs-number">100</span> &amp;&amp; h.damage&lt;<span class="hljs-number">50</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>把 return 和{}去掉<br><code>HeroChecker c 3 = (Hero h) -&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50;</code></li><li>把参数类型和圆括号去掉 (只有一个参数的时候，才可以去掉圆括号)<br><code>HeroChecker c 4 = h -&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50;</code></li><li>把 c 4 作为参数传递进去<br><code>filter (heros, c 4);</code></li><li>直接把表达式传递进去<br><code>filter (heros, h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50);</code><blockquote><p>[!NOTE]<br>与<a href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a> 概念相比较，<br>Lambda 其实就是<strong>匿名方法</strong>，这是一种把<strong>方法作为参数进行传递</strong>的编程思想。</p></blockquote></li></ol><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><h5 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h5><p>首先为 TestLambda 添加一个静态方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">testHero</span> <span class="hljs-params">(Hero h)</span> &#123;<br><span class="hljs-keyword">return</span> h.hp&gt;<span class="hljs-number">100</span> &amp;&amp; h.damage&lt;<span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lambda 表达式：<br><code>filter (heros, h-&gt;h.hp&gt;100 &amp;&amp; h.damage&lt;50);</code><br>在 Lambda 表达式中调用这个静态方法：<br><code>filter (heros, h -&gt; TestLambda. testHero (h) );</code><br>调用静态方法还可以改写为：<br><code>filter (heros, TestLambda::testHero);</code></p><h5 id="引用对象方法"><a href="#引用对象方法" class="headerlink" title="引用对象方法"></a>引用对象方法</h5><p>与引用静态方法很类似，只是传递方法的时候，需要一个对象的存在<br><code>TestLambda testLambda = new TestLambda ();</code><br><code>filter (heros, testLambda::testHero);</code></p><h5 id="引用容器中的对象的方法"><a href="#引用容器中的对象的方法" class="headerlink" title="引用容器中的对象的方法"></a>引用容器中的对象的方法</h5><p>首先为 Hero 添加一个方法  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matched</span> <span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>. hp&gt;<span class="hljs-number">100</span> &amp;&amp; <span class="hljs-built_in">this</span>. damage&lt;<span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 Lambda 表达式<br><code>filter (heros, h-&gt; h.hp&gt;100 &amp;&amp; h.damage&lt;50 );</code><br>在 Lambda 表达式中调用容器中的对象 Hero 的方法 matched<br><code>filter (heros, h-&gt; h.matched () );</code><br>matched 恰好就是容器中的对象 Hero 的方法，那就可以进一步改写为<br><code>filter (heros, Hero::matched);</code></p><h5 id="用构造器"><a href="#用构造器" class="headerlink" title="用构造器"></a>用构造器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Lambda;  <br><span class="hljs-keyword">import</span> java. util. ArrayList;  <br><span class="hljs-keyword">import</span> java. util. List;  <br><span class="hljs-keyword">import</span> java. util. function. Supplier;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConstructor</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        Supplier&lt;List&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;List&gt;() &#123;  <br>            <span class="hljs-keyword">public</span> List <span class="hljs-title function_">get</span> <span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span> ();  <br>            &#125;  <br>        &#125;;  <br>        <span class="hljs-comment">//匿名类  </span><br>        List list <span class="hljs-number">1</span> = getList (s);  <br>        <span class="hljs-comment">//Lambda 表达式  </span><br>        List list <span class="hljs-number">2</span> = getList (() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span> ());  <br>        <span class="hljs-comment">//引用构造器  </span><br>        List list <span class="hljs-number">3</span> = getList (ArrayList::<span class="hljs-keyword">new</span>);  <br>        System. out. println (list <span class="hljs-number">1.</span> hashCode ());  <br>        System. out. println (list <span class="hljs-number">2.</span> hashCode ());  <br>        System. out. println (list <span class="hljs-number">3.</span> hashCode ());  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List <span class="hljs-title function_">getList</span> <span class="hljs-params">(Supplier&lt;List&gt; s)</span> &#123;  <br>        <span class="hljs-keyword">return</span> s.get ();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="聚合操作-1"><a href="#聚合操作-1" class="headerlink" title="聚合操作"></a>聚合操作</h4><h5 id="传统方式与聚合操作方式遍历数据"><a href="#传统方式与聚合操作方式遍历数据" class="headerlink" title="传统方式与聚合操作方式遍历数据"></a>传统方式与聚合操作方式遍历数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();  <br>List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>    heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero &quot;</span> + i, r.nextInt (<span class="hljs-number">1000</span>), r.nextInt (<span class="hljs-number">100</span>)));  <br>&#125;  <br>System. out. println (<span class="hljs-string">&quot;初始化后的集合：&quot;</span>);  <br>System. out. println (heros);  <br>System. out. println (<span class="hljs-string">&quot;查询条件：hp&gt;100 &amp;&amp; damage&lt;50&quot;</span>);  <br>System. out. println (<span class="hljs-string">&quot;通过传统操作方式找出满足条件的数据：&quot;</span>);  <br><span class="hljs-keyword">for</span> (Hero h : heros) &#123;  <br>    <span class="hljs-keyword">if</span> (h.getHp () &gt; <span class="hljs-number">100</span> &amp;&amp; h.getArmor () &lt; <span class="hljs-number">50</span>)  <br>        System. out. println (h.getName ());  <br>&#125;  <br>System. out. println (<span class="hljs-string">&quot;通过聚合操作方式找出满足条件的数据：&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .filter (h -&gt; h.getHp () &gt; <span class="hljs-number">100</span> &amp;&amp; h.getArmor () &lt; <span class="hljs-number">50</span>)  <br>        .forEach (h -&gt; System. out. println (h.getName ()));<br></code></pre></td></tr></table></figure><h5 id="Stream-和管道的概念"><a href="#Stream-和管道的概念" class="headerlink" title="Stream 和管道的概念"></a>Stream 和管道的概念</h5><p>要了解聚合操作，首先要建立 Stream 和管道的概念</p><blockquote><p><strong>Stream</strong> 和 <strong>Collection</strong> 结构化的数据不一样，Stream 是<strong>一系列的元素</strong>，就像是生产线上的罐头一样，一串串的出来。<br><strong>管道</strong>指的是<strong>一系列的聚合操作</strong>。<br>管道又分 3 个部分： </p><ol><li><strong>管道源</strong>：在这个例子里，源是一个 List  </li><li><strong>中间操作</strong>： 每个中间操作，又会返回一个 Stream，比如. filter ()又返回一个 Stream, <strong>中间操作是“懒”操作，并不会真正进行遍历</strong>。  </li><li><strong>结束操作</strong>：当这个操作执行后，流就被使用“光”了，<strong>无法再被操作</strong>。所以这必定是流的最后一个操作。结束操作不会返回 Stream，但是会返回 int、float、String、 Collection 或者像 forEach，什么都不返回, <strong>结束操作才进行真正的遍历行为</strong>，在遍历的时候，才会去进行中间操作的相关判断<br>（1）管道源<br>把 Collection 切换成管道源很简单，调用 <code>stream ()</code> 就行了。<br><code>heros. stream ()</code><br>但是<strong>数组</strong>却<strong>没有 stream ()方法</strong>，需要使用<br><code>Arrays. stream (hs)</code> 或者 <code>Stream. of (hs)</code><br>（2）中间操作<br>中间操作比较多，主要分两类<br>对元素进行<strong>筛选和转换</strong>为其他形式的流</li></ol></blockquote><ul><li>&#x3D;&#x3D;对元素进行筛选&#x3D;&#x3D;：  <blockquote><ol><li>filter 匹配  </li><li>distinct 去除重复 (根据 equals 判断)  </li><li>sorted 自然排序  </li><li>sorted (<code>Comparator&lt;T&gt;</code>) 指定排序  </li><li>limit 保留  </li><li>skip 忽略</li></ol></blockquote></li><li>&#x3D;&#x3D;转换为其他形式的流&#x3D;&#x3D;  <blockquote><ol><li>mapToDouble 转换为 double 的流  </li><li>map 转换为任意类型的流</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();  <br>List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>    heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero &quot;</span> + i, r.nextFloat (<span class="hljs-number">1000</span>), r.nextInt (<span class="hljs-number">100</span>)));  <br>&#125;  <br><span class="hljs-comment">//制造一个重复数据  </span><br>heros. add (heros. get (<span class="hljs-number">0</span>));  <br>System. out. println (<span class="hljs-string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);  <br>System. out. println (heros);  <br>System. out. println (<span class="hljs-string">&quot;满足条件 getgetHp ()()&gt;100&amp;&amp;damage&lt;50 的数据&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .filter (h -&gt; h.getHp () &gt; <span class="hljs-number">100</span> &amp;&amp; h.getArmor () &lt; <span class="hljs-number">50</span>)  <br>        .forEach (h -&gt; System. out. print (h));  <br>System. out. println (<span class="hljs-string">&quot;去除重复的数据，去除标准是看 equals&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .distinct ()  <br>        .forEach (h -&gt; System. out. print (h));  <br>System. out. println (<span class="hljs-string">&quot;按照血量排序&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .sorted ((h <span class="hljs-number">1</span>, h <span class="hljs-number">2</span>) -&gt; h <span class="hljs-number">1.</span> getHp () &gt;= h <span class="hljs-number">2.</span> getHp () ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>)  <br>        .forEach (h -&gt; System. out. print (h));  <br>System. out. println (<span class="hljs-string">&quot;保留 3 个&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .limit (<span class="hljs-number">3</span>)  <br>        .forEach (h -&gt; System. out. print (h));  <br>System. out. println (<span class="hljs-string">&quot;忽略前 3 个&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .skip (<span class="hljs-number">3</span>)  <br>        .forEach (h -&gt; System. out. print (h));  <br>System. out. println (<span class="hljs-string">&quot;转换为 double 的 Stream&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .mapToDouble (Hero::getHp)  <br>        .forEach (h -&gt; System. out. println (h));  <br>System. out. println (<span class="hljs-string">&quot;转换任意类型的 Stream&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .map ((h) -&gt; h.getName () + <span class="hljs-string">&quot; - &quot;</span> + h.getHp () + <span class="hljs-string">&quot; - &quot;</span> + h.getArmor ())  <br>        .forEach (h -&gt; System. out. println (h));<br></code></pre></td></tr></table></figure>（3）结束操作<br>结束操作才真正进行遍历行为，前面的中间操作也在这个时候，才真正的执行。<br>常见结束操作如下：  <blockquote><ol><li>forEach () 遍历每个元素  </li><li>toArray () 转换为数组  </li><li>min (<code>Comparator&lt;T&gt;</code>) 取最小的元素  </li><li>max (<code>Comparator&lt;T&gt;</code>) 取最大的元素  </li><li>count () 总数  </li><li>findFirst () 第一个元素</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span> ();  <br>List&lt;Hero&gt; heros = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Hero&gt;();  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <br>    heros. add (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;hero &quot;</span> + i, r.nextFloat (<span class="hljs-number">1000</span>), r.nextInt (<span class="hljs-number">100</span>)));  <br>&#125;  <br>System. out. println (<span class="hljs-string">&quot;遍历集合中的每个数据&quot;</span>);  <br>heros  <br>        .stream ()  <br>        .forEach (h -&gt; System. out. print (h));  <br>System. out. println (<span class="hljs-string">&quot;返回一个数组&quot;</span>);  <br>Object[] hs = heros  <br>        .stream ()  <br>        .toArray ();  <br>System. out. println (Arrays. toString (hs));  <br>System. out. println (<span class="hljs-string">&quot;返回护甲最低的那个英雄&quot;</span>);  <br><span class="hljs-type">Hero</span> <span class="hljs-variable">minDamageHero</span> <span class="hljs-operator">=</span>  <br>        heros  <br>                .stream ()  <br>                .min ((h <span class="hljs-number">1</span>, h <span class="hljs-number">2</span>) -&gt; h <span class="hljs-number">1.</span> getArmor () - h <span class="hljs-number">2.</span> getArmor ())  <br>                .get ();  <br>System. out. print (minDamageHero);  <br>System. out. println (<span class="hljs-string">&quot;返回护甲最高的那个英雄&quot;</span>);  <br><span class="hljs-type">Hero</span> <span class="hljs-variable">mxnDamageHero</span> <span class="hljs-operator">=</span>  <br>        heros  <br>                .stream ()  <br>                .max ((h <span class="hljs-number">1</span>, h <span class="hljs-number">2</span>) -&gt; h <span class="hljs-number">1.</span> getArmor () - h <span class="hljs-number">2.</span> getArmor ())  <br>                .get ();  <br>System. out. print (mxnDamageHero);  <br>System. out. println (<span class="hljs-string">&quot;流中数据的总数&quot;</span>);  <br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> heros  <br>        .stream ()  <br>        .count ();  <br>System. out. println (count);  <br>System. out. println (<span class="hljs-string">&quot;第一个英雄&quot;</span>);  <br><span class="hljs-type">Hero</span> <span class="hljs-variable">firstHero</span> <span class="hljs-operator">=</span>  <br>        heros  <br>                .stream ()  <br>                .findFirst ()  <br>                .get ();  <br>System. out. println (firstHero);<br></code></pre></td></tr></table></figure></li></ul><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>获取本机 IP 地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InetAddress</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> InetAddress. getLocalHost ();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span>host. getHostAddress ();<br>        System. out. println (<span class="hljs-string">&quot;本机 ip 地址：&quot;</span> + ip);<br></code></pre></td></tr></table></figure><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>使用 Socket (套接字)进行不同的程序之间的通信</p><h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><ol><li>服务端开启 8888 端口，并监听着，时刻等待着客户端的连接请求  </li><li>客户端知道服务端的 ip 地址和监听端口号，发出请求到服务端<br>客户端的端口地址是系统分配的，通常都会大于 1024<br>一旦建立了连接，<strong>服务端</strong>会得到一个新的<strong>Socket 对象</strong>，该对象负责与客户端进行通信。  <blockquote><p>注意： 在开发调试的过程中，如果修改过了服务器 Server 代码，要关闭启动的 Server, 否则新的 Server 不能启动，因为 8888 端口被占用了<br><img src="https://stepimagewm.how2j.cn/882.png"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Server. java</span><br><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. net. ServerSocket;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//服务端打开端口 8888</span><br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span> (<span class="hljs-number">8888</span>);<br>            <span class="hljs-comment">//在 8888 端口上监听，看是否有连接请求过来</span><br>            System. out. println (<span class="hljs-string">&quot;监听在端口号: 8888&quot;</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span>  ss. accept ();<br>            System. out. println (<span class="hljs-string">&quot;有连接过来&quot;</span> + s);<br>            s.close ();<br>            ss. close ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Client. java</span><br><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">import</span> java. net. UnknownHostException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//连接到本机的 8888 端口</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span> (<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>            System. out. println (s);<br>            s.close ();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="收发数字"><a href="#收发数字" class="headerlink" title="收发数字"></a>收发数字</h5><p>一旦建立了连接，服务端和客户端就可以通过 Socket 进行通信了  </p><ol><li>客户端打开输出流，并发送数字 110  </li><li>服务端打开输入流，接受数字 110，并打印<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Server. java</span><br><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. io. InputStream;<br><span class="hljs-keyword">import</span> java. net. ServerSocket;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span> (<span class="hljs-number">8888</span>);<br>            System. out. println (<span class="hljs-string">&quot;监听在端口号: 8888&quot;</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> ss. accept ();<br>            <span class="hljs-comment">//打开输入流</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> s.getInputStream ();<br>            <span class="hljs-comment">//读取客户端发送的数据</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> is. read ();<br>            <span class="hljs-comment">//打印出来</span><br>            System. out. println (msg);<br>            is. close ();<br>            s.close ();<br>            ss. close ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Client. java</span><br><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. io. OutputStream;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">import</span> java. net. UnknownHostException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span> (<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>            <span class="hljs-comment">// 打开输出流</span><br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> s.getOutputStream ();<br>            <span class="hljs-comment">// 发送数字 110 到服务端</span><br>            os. write (<span class="hljs-number">110</span>);<br>            os. close ();<br>            s.close ();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="收发字符串"><a href="#收发字符串" class="headerlink" title="收发字符串"></a>收发字符串</h5><p>直接使用字节流收发字符串比较麻烦，使用<a href="https://how2j.cn/k/io/io-datastream/350.html#step771">数据流</a>对字节流进行封装，这样收发字符串就容易了  </p><ol><li>把输出流封装在 <strong>DataOutputStream</strong> 中<br>使用 <strong>writeUTF</strong> 发送字符串 “Legendary!”  </li><li>把输入流封装在 <strong>DataInputStream</strong><br>使用 <strong>readUTF</strong> 读取字符串, 并打印<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Server. java</span><br><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. DataInputStream;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. io. InputStream;<br><span class="hljs-keyword">import</span> java. net. ServerSocket;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span> (<span class="hljs-number">8888</span>);<br>            System. out. println (<span class="hljs-string">&quot;监听在端口号: 8888&quot;</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> ss. accept ();<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> s.getInputStream ();<br>            <span class="hljs-comment">//把输入流封装在 DataInputStream</span><br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span> (is);<br>            <span class="hljs-comment">//使用 readUTF 读取字符串</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis. readUTF ();<br>            System. out. println (msg);<br>            dis. close ();<br>            s.close ();<br>            ss. close ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//Client. java</span><br><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. DataOutputStream;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. io. OutputStream;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">import</span> java. net. UnknownHostException;<br><span class="hljs-keyword">import</span> java. util. Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span> (<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> s.getOutputStream ();<br>            <span class="hljs-comment">//把输出流封装在 DataOutputStream 中</span><br>            <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span> (os);<br>            <span class="hljs-comment">//使用 writeUTF 发送字符串</span><br>            dos. writeUTF (<span class="hljs-string">&quot;Legendary!&quot;</span>);<br>            dos. close ();<br>            s.close ();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="使用-Scanner"><a href="#使用-Scanner" class="headerlink" title="使用 Scanner"></a>使用 Scanner</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. DataOutputStream;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. io. OutputStream;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">import</span> java. net. UnknownHostException;<br><span class="hljs-keyword">import</span> java. util. Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span> (<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> s.getOutputStream ();<br>            <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span> (os);<br>            <span class="hljs-comment">//使用 Scanner 读取控制台的输入，并发送到服务端</span><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span> (System. in);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc. next ();<br>            dos. writeUTF (str);<br>            dos. close ();<br>            s.close ();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多线程聊天"><a href="#多线程聊天" class="headerlink" title="多线程聊天"></a>多线程聊天</h4><p>为了实现<strong>同时收发消息</strong>，就需要用到多线程<br>因为接受和发送都在主线程中，不能同时进行。为了实现同时收发消息，基本设计思路是把收发分别放在不同的线程中进行  </p><blockquote><ol><li>SendThread 发送消息线程  </li><li>RecieveThread 接受消息线程  </li><li>Server 一旦接受到连接，就启动收发两个线程  </li><li>Client 一旦建立了连接，就启动收发两个线程<br>（1）SendThread. java</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. DataOutputStream;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. io. OutputStream;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">import</span> java. util. Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> Socket s;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SendThread</span> <span class="hljs-params">(Socket s)</span>&#123;<br>        <span class="hljs-built_in">this</span>. s = s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> s.getOutputStream ();<br>            <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span> (os);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span> (System. in);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc. next ();<br>                dos. writeUTF (str);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(2) RecieveThread. java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. DataInputStream;<br><span class="hljs-keyword">import</span> java. io. DataOutputStream;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. io. InputStream;<br><span class="hljs-keyword">import</span> java. io. OutputStream;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">import</span> java. util. Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecieveThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket s;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RecieveThread</span> <span class="hljs-params">(Socket s)</span> &#123;<br>        <span class="hljs-built_in">this</span>. s = s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> s.getInputStream ();<br>            <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span> (is);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> dis. readUTF ();<br>                System. out. println (msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3) Server. java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. net. ServerSocket;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span> (<span class="hljs-number">8888</span>);<br>            System. out. println (<span class="hljs-string">&quot;监听在端口号: 8888&quot;</span>);<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> ss. accept ();<br>            <span class="hljs-comment">//启动发送消息线程</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendThread</span> (s). start ();<br>            <span class="hljs-comment">//启动接受消息线程</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecieveThread</span> (s). start ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(4) Server. java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> socket;<br><span class="hljs-keyword">import</span> java. io. IOException;<br><span class="hljs-keyword">import</span> java. net. Socket;<br><span class="hljs-keyword">import</span> java. net. UnknownHostException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span> (<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br>            <span class="hljs-comment">// 启动发送消息线程</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SendThread</span> (s). start ();<br>            <span class="hljs-comment">// 启动接受消息线程</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecieveThread</span> (s). start ();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>3 种方式：</p><ol><li>继承 Thread 类，重写 run 方法</li><li>实现 Runnable 接口</li><li>匿名类<br>（1）继承 Thread 类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MutiThreads;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> exception. EnemyHeroIsDeadException;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Hero h <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Hero h <span class="hljs-number">2</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTread</span> <span class="hljs-params">(Hero h <span class="hljs-number">1</span>, Hero h <span class="hljs-number">2</span>)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. h <span class="hljs-number">1</span> = h <span class="hljs-number">1</span>;  <br>        <span class="hljs-built_in">this</span>. h <span class="hljs-number">2</span> = h <span class="hljs-number">2</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (! h <span class="hljs-number">2.</span> isDead ()) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                h <span class="hljs-number">1.</span> attack (h <span class="hljs-number">2</span>, <span class="hljs-number">40.0</span> f);  <br>            &#125; <span class="hljs-keyword">catch</span> (EnemyHeroIsDeadException e) &#123;  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">//test</span><br><span class="hljs-keyword">package</span> MutiThreads;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMyThread</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">galen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;盖伦&quot;</span>, <span class="hljs-number">320.0</span> f, <span class="hljs-number">100</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">timo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;提莫&quot;</span>, <span class="hljs-number">200.0</span> f, <span class="hljs-number">120</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">libai</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;李白&quot;</span>, <span class="hljs-number">210.0</span> f, <span class="hljs-number">100</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">hanxin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> (<span class="hljs-string">&quot;韩信&quot;</span>, <span class="hljs-number">220.0</span> f, <span class="hljs-number">110</span>);  <br>        MyTread killThread <span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTread</span> (galen, timo);  <br>        MyTread killThread <span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTread</span> (libai, hanxin);  <br>        killThread <span class="hljs-number">1.</span> start ();  <br>        killThread <span class="hljs-number">2.</span> start ();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>（2）实现 Runnab 接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MutiThreads;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> exception. EnemyHeroIsDeadException;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Battle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Hero h <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Hero h <span class="hljs-number">2</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Battle</span> <span class="hljs-params">(Hero h <span class="hljs-number">1</span>, Hero h <span class="hljs-number">2</span>)</span> &#123;  <br>        <span class="hljs-built_in">this</span>. h <span class="hljs-number">1</span> = h <span class="hljs-number">1</span>;  <br>        <span class="hljs-built_in">this</span>. h <span class="hljs-number">2</span> = h <span class="hljs-number">2</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">while</span> (! h <span class="hljs-number">2.</span> isDead ()) &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                h <span class="hljs-number">1.</span> attack (h <span class="hljs-number">2</span>, h <span class="hljs-number">1.</span> getDamage ());  <br>            &#125; <span class="hljs-keyword">catch</span> (EnemyHeroIsDeadException e) &#123;  <br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">//test</span><br><span class="hljs-keyword">package</span> MutiThreads;  <br><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> exception. EnemyHeroIsDeadException;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBattle</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        gareen. setName (<span class="hljs-string">&quot;盖伦&quot;</span>);  <br>        gareen. setHp (<span class="hljs-number">616</span>);  <br>        gareen. setDamage (<span class="hljs-number">50</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        teemo. setName (<span class="hljs-string">&quot;提莫&quot;</span>);  <br>        teemo. setHp (<span class="hljs-number">300</span>);  <br>        teemo. setDamage (<span class="hljs-number">30</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        bh. setName (<span class="hljs-string">&quot;赏金猎人&quot;</span>);  <br>        bh. setHp (<span class="hljs-number">500</span>);  <br>        bh. setDamage (<span class="hljs-number">65</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        leesin. setName (<span class="hljs-string">&quot;盲僧&quot;</span>);  <br>        leesin. setHp (<span class="hljs-number">455</span>);  <br>        leesin. setDamage (<span class="hljs-number">80</span>);  <br>        Battle battle <span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Battle</span> (gareen, teemo);  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (battle <span class="hljs-number">1</span>). start ();  <br>        Battle battle <span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Battle</span> (bh, leesin);  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (battle <span class="hljs-number">2</span>). start ();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>（3）匿名类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> MyCharacter. Hero;  <br><span class="hljs-keyword">import</span> exception. EnemyHeroIsDeadException;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">anonymousThread</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">gareen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        gareen. setName (<span class="hljs-string">&quot;盖伦&quot;</span>);  <br>        gareen. setHp (<span class="hljs-number">616</span>);  <br>        gareen. setDamage (<span class="hljs-number">50</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">teemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        teemo. setName (<span class="hljs-string">&quot;提莫&quot;</span>);  <br>        teemo. setHp (<span class="hljs-number">300</span>);  <br>        teemo. setDamage (<span class="hljs-number">30</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">bh</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        bh. setName (<span class="hljs-string">&quot;赏金猎人&quot;</span>);  <br>        bh. setHp (<span class="hljs-number">500</span>);  <br>        bh. setDamage (<span class="hljs-number">65</span>);  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">leesin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();  <br>        leesin. setName (<span class="hljs-string">&quot;盲僧&quot;</span>);  <br>        leesin. setHp (<span class="hljs-number">455</span>);  <br>        leesin. setDamage (<span class="hljs-number">80</span>);  <br>        <span class="hljs-comment">//匿名类  </span><br>        Thread t <span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> () &#123;  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-comment">//匿名类中用到外部的局部变量 teemo，必须把 teemo 声明为 final  </span><br>                <span class="hljs-comment">//但是在 JDK 7 以后，就不是必须加 final 的了                while (! teemo. isDead ()) &#123;  </span><br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        gareen. attack (teemo, gareen. getDamage ());  <br>                    &#125; <span class="hljs-keyword">catch</span> (EnemyHeroIsDeadException e) &#123;  <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;;  <br>        t <span class="hljs-number">1.</span> start ();  <br>        Thread t <span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> () &#123;  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-keyword">while</span> (! leesin. isDead ()) &#123;  <br>                    <span class="hljs-keyword">try</span> &#123;  <br>                        bh. attack (leesin, bh. getDamage ());  <br>                    &#125; <span class="hljs-keyword">catch</span> (EnemyHeroIsDeadException e) &#123;  <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (e);  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;;  <br>        t <span class="hljs-number">2.</span> start ();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注： 启动线程是 <code>start</code> ()方法，<code>run</code> ()并不能启动一个新的线程</p></blockquote></li></ol><h4 id="常见线程方法"><a href="#常见线程方法" class="headerlink" title="常见线程方法"></a>常见线程方法</h4><table><thead><tr><th>关键字</th><th>简介</th><th>示例代码</th></tr></thead><tbody><tr><td>sleep</td><td>当前线程暂停</td><td><a href="https://how2j.cn/k/thread/thread-methods/354.html#step781">示例代码</a></td></tr><tr><td>join</td><td>加入到当前线程中</td><td><a href="https://how2j.cn/k/thread/thread-methods/354.html#step782">示例代码</a></td></tr><tr><td>setPriority</td><td>线程优先级</td><td><a href="https://how2j.cn/k/thread/thread-methods/354.html#step783">示例代码</a></td></tr><tr><td>yield</td><td>临时暂停</td><td><a href="https://how2j.cn/k/thread/thread-methods/354.html#step784">示例代码</a></td></tr><tr><td>setDaemon</td><td>守护线程</td><td><a href="https://how2j.cn/k/thread/thread-methods/354.html#step2403">示例代码</a></td></tr><tr><td>守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</td><td></td><td></td></tr></tbody></table><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题，多线程的问题，<strong>又叫 Concurrency</strong> 问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://how2j.cn/k/thread/thread-synchronized/355.html<br>title: &quot;多线程系列教材 （三）- Java 多线程同步 synchronized  详解&quot;<br>description: &quot;多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题, 多线程的问题，又叫 Concurrency, 问题; 演示同步问题, 假设盖伦有 10000 滴血，并且在基地里，同时又被对方多个英雄攻击, 就是有多个线程在减少盖伦的 hp, 同时又有多个线程在回复盖伦的 hp, 假设线程的数量是一样的，并且每次改...&quot;<br>host: how 2 j. cn<br></code></pre></td></tr></table></figure><p><a href="https://how2j.cn/k/thread/thread-synchronized/355.html">多线程系列教材 （三）- Java 多线程同步 synchronized 详解</a></p><h5 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h5><blockquote><p>synchronized 表示当前线程，独占对象 someObject<br>当前线程独占了对象 someObject，如果有其他线程试图占有对象 someObject，就会等待，直到当前线程释放对 someObject 的占用。<br>someObject 又叫同步对象，所有的对象，都可以作为同步对象<br>为了达到同步的效果，必须使用同一个同步对象</p></blockquote><h5 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h5><p>与 synchronized 类似的，lock 也能够达到同步的效果</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>每一个线程的启动和结束都是比较消耗时间和占用资源的。<br>如果在系统中用到了很多的线程，大量的启动和结束动作会导致系统的性能变卡，响应变慢。<br>为了解决这个问题，引入线程池这种设计思想。<br>线程池的模式很像<a href="https://how2j.cn/k/thread/thread-wait-notify/358.html#step2591">生产者消费者模式</a>，消费的对象是一个一个的能够运行的任务</p><h4 id="原子访问"><a href="#原子访问" class="headerlink" title="原子访问"></a>原子访问</h4><p>所谓的原子性操作即不可中断的操作，比如赋值操作<br><code>int i = 5;</code><br>原子性操作本身是线程安全的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://how2j.cn/k/thread/thread-atomic-access/683.html<br>title: &quot;多线程系列教材 （九）- 原子访问&quot;<br>description: &quot;; 原子性操作概念, 所谓的原子性操作即不可中断的操作，比如赋值操作 int, i,=, 5; 原子性操作本身是线程安全的, 但是, i++, 这个行为，事实上是有 3 个原子性操作组成的。步骤, 1., 取, i, 的值步骤, 2., i,+, 1 步骤, 3., 把新的值赋予 i 这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子...&quot;<br>host: how 2 j. cn<br></code></pre></td></tr></table></figure><p><a href="https://how2j.cn/k/thread/thread-atomic-access/683.html">多线程系列教材 （九）- 原子访问</a></p><h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><p>JDK 6 以后，新增加了一个包<strong>java. util. concurrent. atomic</strong>，里面有各种原子类，比如 AtomicInteger。<br>而 AtomicInteger 提供了各<strong>种自增，自减</strong>等方法，这些方法都是原子性的。换句话说，自增方法 <strong>incrementAndGet 是线程安全</strong>的，同一个时间，只有一个线程可以调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> multiplethread;<br><span class="hljs-keyword">import</span> java. util. concurrent. atomic. AtomicInteger;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestThread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicI</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span> ();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> atomicI.decrementAndGet ();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> atomicI.incrementAndGet ();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> atomicI.addAndGet (<span class="hljs-number">3</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://how2j.cn/k/jdbc/jdbc-mysql/386.html<br>title: &quot;JDBC 系列教材 （一）- Java 使用 JDBC 之前，先要准备 mysql&quot;<br>description: &quot;JDBC, (Java, DataBase, Connection), 是通过 JAVA 访问数据库, 所以需要对数据库有基本的理解和应用; MySQL, Mysql 是常见的数据库, 在中小型网站经常被使用, 如果以前没有接触过 Mysql, 请参考, MySQL 入门, 章节的学习, 其中包含了 mysql, 服务器安装，客户端...&quot;<br>host: how 2 j. cn<br></code></pre></td></tr></table></figure><p><a href="https://how2j.cn/k/jdbc/jdbc-mysql/386.html">JDBC系列教材 （一）- Java 使用JDBC之前，先要准备mysql</a></p><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Jdbc;  <br><span class="hljs-keyword">import</span> java. sql.*;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConnection</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span> <span class="hljs-params">(Statement s, String sql)</span> <span class="hljs-keyword">throws</span> SQLException &#123;  <br>        s.execute (sql);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Class.forName (<span class="hljs-string">&quot;com. mysql. jdbc. Driver&quot;</span>);  <br>            <span class="hljs-comment">/*  </span><br><span class="hljs-comment">             建立与数据库的 Connection 连接这里需要提供：             数据库所处于的 ip: 127.0.0.1 (本机)             数据库的端口号： 3306 （mysql 专用端口号）             数据库名称 how 2 java             编码方式 UTF-8             账号 root             密码 123456             */</span>            <span class="hljs-keyword">try</span> (  <br>                    <span class="hljs-type">Connection</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> DriverManager  <br>                            .getConnection (  <br>                                    <span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/how 2 java? characterEncoding=UTF-8&quot;</span>,  <br>                                    <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);  <br>                    <span class="hljs-type">Statement</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> c.createStatement ()  <br>            ) &#123;  <br>                <span class="hljs-comment">// 准备 sql 语句  </span><br>                <span class="hljs-comment">// 注意： 字符串要用单引号&#x27;//                String sql = &quot;insert into hero values (&quot; + null + &quot;,&quot; + &quot;&#x27;李白&#x27;&quot; + &quot;,&quot; + 100 + &quot;,&quot; + 313 + &quot;,&quot; + 200.0 f + &quot;)&quot;; //增  </span><br><span class="hljs-comment">//                String sql = &quot;delete from hero where id = 1&quot;; //删  </span><br><span class="hljs-comment">//                String sql = &quot;update hero set damage = 120 where id = 2&quot;; //改  </span><br><span class="hljs-comment">//                execute (s, sql);  </span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from hero&quot;</span>; <span class="hljs-comment">//查  </span><br>                <span class="hljs-comment">// 执行查询语句，并把结果集返回给 ResultSet                ResultSet rs = s.executeQuery (sql);  </span><br>                <span class="hljs-keyword">while</span> (rs.next ()) &#123;  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt (<span class="hljs-string">&quot;id&quot;</span>);<span class="hljs-comment">// 可以使用字段名  </span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString (<span class="hljs-number">2</span>);<span class="hljs-comment">// 也可以使用字段的顺序  </span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">armor</span> <span class="hljs-operator">=</span> rs.getInt (<span class="hljs-string">&quot;armor&quot;</span>);  <br>                    <span class="hljs-type">float</span> <span class="hljs-variable">hp</span> <span class="hljs-operator">=</span> rs.getFloat (<span class="hljs-string">&quot;hp&quot;</span>);  <br>                    <span class="hljs-type">int</span> <span class="hljs-variable">damage</span> <span class="hljs-operator">=</span> rs.getInt (<span class="hljs-number">4</span>);  <br>                    System.out.printf (<span class="hljs-string">&quot;%d\t%s\t%d\t%f\t%d%n&quot;</span>, id, name, armor, hp, damage);  <br>                &#125;  <br>                System.out.println (<span class="hljs-string">&quot;执行查询语句成功&quot;</span>);  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;  <br>            <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>            e.printStackTrace ();  <br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;  <br>            <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>            e.printStackTrace ();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="预编译-PreparedStatement"><a href="#预编译-PreparedStatement" class="headerlink" title="预编译 PreparedStatement"></a>预编译 PreparedStatement</h4><p>和 Statement 一样，PreparedStatement 也是用来<strong>执行 sql 语句</strong>的<br>与创建 Statement 不同的是，需要<strong>根据 sql 语句创建 PreparedStatement</strong><br>除此之外，还能够通过<strong>设置参数，指定相应的值</strong>，而不是 Statement 那样使用字符串拼接<br>注： 这是 JAVA 里唯二的基 1 的地方，另一个是<a href="https://how2j.cn/k/jdbc/jdbc-resultset/390.html#step866">查询语句</a>中的 ResultSet 也是基 1 的。<br>优点：</p><ol><li>参数设置<ul><li>Statement 需要进行字符串拼接，可读性和维护性比较差<br> <code>String sql = &quot;insert into hero values (null,&quot;+&quot;&#39;提莫&#39;&quot;+&quot;,&quot;+313.0 f+&quot;,&quot;+50+&quot;)&quot;;</code></li><li>PreparedStatement 使用参数设置，可读性好，不易犯错<br> <code>String sql = &quot;insert into hero values (null,?,?,?)&quot;;</code></li></ul></li><li>性能表现<ul><li>PreparedStatement 有预编译机制，性能比 Statement 更快<ol><li>Statement 执行 10 次，需要 10 次把 SQL 语句传输到数据库端<br>数据库要对<strong>每一次来的 SQL 语句进行编译</strong>处理</li><li>PreparedStatement 执行 10 次，只需要<strong>1 次</strong>把 SQL 语句传输到数据库端<br>数据库对带? 的 SQL 进行预编译<br>每次执行，只需要<strong>传输参数</strong>到数据库端<ul><li><strong>网络传输量</strong>比 Statement 更小</li><li>数据库<strong>不需要再进行编译</strong>，响应更快</li></ul></li></ol></li></ul></li><li>防止 SQL 注入式攻击<br>假设 name 是用户提交来的数据<br>String name &#x3D; “‘盖伦’ OR 1&#x3D;1”;<br>使用 Statement 就需要进行<strong>字符串拼接</strong>，拼接出来的语句是：select * from hero where name &#x3D; ‘盖伦’ OR 1&#x3D;1，因为有 OR 1&#x3D;1，这是恒成立的，那么就会把所有的英雄都查出来，而不只是盖伦如果 Hero 表里的数据是海量的，比如几百万条，把这个表里的数据全部查出来，会让<strong>数据库负载变高</strong>，CPU 100%，内存消耗光，响应变得极其缓慢，而 PreparedStatement 使用的是参数设置，就不会有这个问题</li></ol><h4 id="execute-和-executeUpdate"><a href="#execute-和-executeUpdate" class="headerlink" title="execute 和 executeUpdate"></a>execute 和 executeUpdate</h4><ol><li>相同点：<br>都可以执行<strong>增加，删除，修改</strong></li><li>不同点<ul><li>不同 1：<br>execute 可以<strong>执行查询</strong>语句，然后通过 <code>getResultSet</code>，把结果集取出来<br>executeUpdate 不能执行查询语句</li><li>不同 2：<br>execute 返回<strong>boolean 类型</strong>，<strong>true</strong> 表示执行的是<strong>查询语句</strong>，<strong>false</strong> 表示执行的是<strong>insert, delete, update</strong>等等<br>executeUpdate 返回的是<strong>int</strong>，表示<strong>有多少条数据受到了影响</strong></li></ul></li></ol><h4 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h4><h5 id="获取自增长-id"><a href="#获取自增长-id" class="headerlink" title="获取自增长 id"></a>获取自增长 id</h5><p>在 Statement 通过 execute 或者 executeUpdate 执行完插入语句后，MySQL 会为新插入的数据分配一个自增长 id，(前提是这个表的 id 设置为了自增长, 在 Mysql 创建表的时候，AUTO_INCREMENT 就表示自增长)，需要通过 Statement 的 getGeneratedKeys 获取该 id<br><code>PreparedStatement ps = c.prepareStatement (sql, Statement. RETURN_GENERATED_KEYS);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在执行完插入语句后，MySQL 会为新插入的数据分配一个自增长 id</span><br>           <span class="hljs-comment">// JDBC 通过 getGeneratedKeys 获取该 id</span><br>           <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> ps.getGeneratedKeys ();<br>           <span class="hljs-keyword">if</span> (rs.next ()) &#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> rs.getInt (<span class="hljs-number">1</span>);<br>               System.out.println (id);<br>           &#125;<br></code></pre></td></tr></table></figure><h5 id="获取表的元数据"><a href="#获取表的元数据" class="headerlink" title="获取表的元数据"></a>获取表的元数据</h5><p>元数据概念：<br>和数据库服务器相关的数据，比如数据库版本，有哪些表，表有哪些字段，字段类型是什么等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;  <br>    Class.forName (<span class="hljs-string">&quot;com. mysql. jdbc. Driver&quot;</span>);  <br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;  <br>    e.printStackTrace ();  <br>&#125;  <br><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> DriverManager.getConnection (<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/how 2 java? characterEncoding=UTF-8&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>))  <br><span class="hljs-comment">// 查看数据库层面的元数据  </span><br><span class="hljs-comment">// 即数据库服务器版本，驱动版本，都有哪些数据库等等  </span><br>&#123;  <br>    <span class="hljs-type">DatabaseMetaData</span> <span class="hljs-variable">dbmd</span> <span class="hljs-operator">=</span> c.getMetaData ();  <br>    <span class="hljs-comment">// 获取数据库服务器产品名称  </span><br>    System.out.println (<span class="hljs-string">&quot;数据库产品名称:\t&quot;</span> + dbmd.getDatabaseProductName ());  <br>    <span class="hljs-comment">// 获取数据库服务器产品版本号  </span><br>    System.out.println (<span class="hljs-string">&quot;数据库产品版本:\t&quot;</span> + dbmd.getDatabaseProductVersion ());  <br>    <span class="hljs-comment">// 获取数据库服务器用作类别和表名之间的分隔符如 test. user  </span><br>    System.out.println (<span class="hljs-string">&quot;数据库和表分隔符:\t&quot;</span> + dbmd.getCatalogSeparator ());  <br>    <span class="hljs-comment">// 获取驱动版本  </span><br>    System.out.println (<span class="hljs-string">&quot;驱动版本:\t&quot;</span> + dbmd.getDriverVersion ());  <br>    System.out.println (<span class="hljs-string">&quot;可用的数据库列表：&quot;</span>);  <br>    <span class="hljs-comment">// 获取数据库名称  </span><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> dbmd.getCatalogs ();  <br>    <span class="hljs-keyword">while</span> (rs.next ()) &#123;  <br>        System.out.println (<span class="hljs-string">&quot;数据库名称:\t&quot;</span> + rs.getString (<span class="hljs-number">1</span>));  <br>    &#125;  <br>&#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;  <br>    <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>    e.printStackTrace ();  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实务"><a href="#实务" class="headerlink" title="实务"></a>实务</h4><p>四大特性：ACID（原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation)、持久性 (Durability)）</p><ol><li>不使用事务的情况<br>没有事务的前提下  <blockquote><p>假设业务操作是：加血，减血各做一次<br>结束后，英雄的血量不变<br>而减血的 SQL<br>不小心写错写成了 updata (而非 update)<br>那么最后结果是血量增加了，而非期望的不变</p></blockquote></li><li>使用事务<br>在事务中的多个操作，<strong>要么都成功，要么都失败</strong>  <blockquote><p>通过 c.setAutoCommit (false); 关闭自动提交<br>使用 c.commit (); 进行手动提交<br>在 22 行-35 行之间的数据库操作，就处于同一个事务当中，要么都成功，要么都失败<br>所以，虽然第一条 SQL 语句是可以执行的，但是第二条 SQL 语句有错误，其结果就是两条 SQL 语句都没有被提交。除非两条 SQL 语句都是正确的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有事务的前提下</span><br>            <span class="hljs-comment">// 在事务中的多个操作，要么都成功，要么都失败</span><br>            c.setAutoCommit (<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">// 加血的 SQL</span><br>            String sql <span class="hljs-number">1</span> = <span class="hljs-string">&quot;update hero set hp = hp +1 where id = 22&quot;</span>;<br>            s.execute (sql <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 减血的 SQL</span><br>            <span class="hljs-comment">// 不小心写错写成了 updata (而非 update)</span><br>            String sql <span class="hljs-number">2</span> = <span class="hljs-string">&quot;updata hero set hp = hp -1 where id = 22&quot;</span>;<br>            s.execute (sql <span class="hljs-number">2</span>);<br>            <span class="hljs-comment">// 手动提交</span><br>            c.commit ();<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>MYSQL 表的类型必须是 <strong>INNODB</strong> 才支持事务<br>在 Mysql 中，只有当表的类型是 INNODB 的时候，才支持事务，所以需要把表的类型设置为 INNODB, 否则无法观察到事务.<br>修改表的类型为 INNODB 的 SQL：<br><code>alter table hero ENGINE = innodb;</code><br>查看表的类型的 SQL<br><code>show table status from how 2 java;</code></p></blockquote></li></ol><h4 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h4><p><strong>ORM&#x3D;Object Relationship Database Mapping</strong><br>对象和关系数据库的映射，简单说，<strong>一个对象</strong>，对应数据库里的<strong>一条记录</strong><br>eg：根据 id 返回一个 Hero 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Hero. java</span><br><span class="hljs-keyword">package</span> charactor;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-comment">//增加 id 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> hp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> damage;<br>&#125;<br><span class="hljs-comment">//TestORM</span><br><span class="hljs-keyword">package</span> jdbc;<br><span class="hljs-keyword">import</span> java. sql. Connection;<br><span class="hljs-keyword">import</span> java. sql. DriverManager;<br><span class="hljs-keyword">import</span> java. sql. ResultSet;<br><span class="hljs-keyword">import</span> java. sql. SQLException;<br><span class="hljs-keyword">import</span> java. sql. Statement;<br><span class="hljs-keyword">import</span> charactor. Hero;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestJDBC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Hero <span class="hljs-title function_">get</span> <span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">hero</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class.forName (<span class="hljs-string">&quot;com. mysql. jdbc. Driver&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace ();<br>        &#125;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> DriverManager.getConnection (<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/how 2 java? characterEncoding=UTF-8&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>            <span class="hljs-type">Statement</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> c.createStatement ();) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from hero where id = &quot;</span> + id;<br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> s.executeQuery (sql);<br>            <span class="hljs-comment">// 因为 id 是唯一的，ResultSet 最多只能有一条记录</span><br>            <span class="hljs-comment">// 所以使用 if 代替 while</span><br>            <span class="hljs-keyword">if</span> (rs.next ()) &#123;<br>                hero = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span> ();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString (<span class="hljs-number">2</span>);<br>                <span class="hljs-type">float</span> <span class="hljs-variable">hp</span> <span class="hljs-operator">=</span> rs.getFloat (<span class="hljs-string">&quot;hp&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">damage</span> <span class="hljs-operator">=</span> rs.getInt (<span class="hljs-number">4</span>);<br>                hero. name = name;<br>                hero. hp = hp;<br>                hero. damage = damage;<br>                hero. id = id;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace ();<br>        &#125;<br>        <span class="hljs-keyword">return</span> hero;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> get (<span class="hljs-number">22</span>);<br>        System.out.println (h.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h4><p><strong>DAO&#x3D;DataAccess Object</strong> 数据访问对象<br>实际上就是运用了<a href="https://how2j.cn/k/jdbc/jdbc-orm/391.html#step2641">练习-ORM</a> 中的思路，把数据库相关的操作都封装在这个类里面，其他地方看不到 JDBC 的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://how2j.cn/k/jdbc/jdbc-dao/392.html#nowhere<br>title: &quot;JDBC 系列教材 （十）- 基于 JDBC 设计 DAO 的实例&quot;<br>description: &quot;DAO=Database, Access, Object, 数据库访问对象, 和数据库相关的操作都被封装在这个类里面，其他地方看不到 JDBC 的代码; DAO 接口,; HeroDAO, 设计类 HeroDAO，实现接口 DAO;&quot;<br>host: how 2 j. cn<br></code></pre></td></tr></table></figure><p><a href="https://how2j.cn/k/jdbc/jdbc-dao/392.html#nowhere">JDBC系列教材 （十）- 基于JDBC设计DAO的实例</a></p><h4 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h4><p><a href="https://how2j.cn/k/jdbc/jdbc-connection-pool/610.html">JDBC系列教材 （十一）- 数据库连接池</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://how2j.cn/k/jdbc/jdbc-connection-pool/610.html<br>title: &quot;JDBC 系列教材 （十一）- 数据库连接池&quot;<br>description: &quot;设计一个类：ConnectionPool, 构造方法 ConnectionPool (int, min, int, max, long, idle),,ConnectionPool.getConnection ();&quot;<br>host: how 2 j. cn<br></code></pre></td></tr></table></figure><p>与<a href="https://how2j.cn/k/thread/thread-threadpool/357.html">线程池</a>类似的，数据库也有一个数据库连接池。不过他们的实现思路是不一样的。</p><ol><li>传统连接方式<br><img src="https://stepimagewm.how2j.cn/2654.png"></li><li>连接池方式<br><img src="https://stepimagewm.how2j.cn/2655.png"></li></ol><h2 id="Java高级"><a href="#Java高级" class="headerlink" title="Java高级"></a>Java高级</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><p>实例对象之间的区别：</p><ul><li>属性不同<br>类之间的区别：</li><li>属性和方法不同</li></ul><h4 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h4><p>获取类对象的 3 种方式：</p><ol><li><strong>Class. forName</strong>  </li><li><strong>Hero. class</strong>  </li><li><strong>new Hero (). getClass ()</strong></li></ol><blockquote><p>在一个 JVM 中，<strong>一种类</strong>，<strong>只会有一个类对象</strong>存在。所以以上三种方式取出来的类对象，都是一样的。<br>准确的讲是一个 <strong>ClassLoader</strong> 下，一种类，只会有一个类对象存在。通常一个 JVM 下，只会有一个 ClassLoader。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Reflect;  <br><span class="hljs-keyword">import</span> MyCharacter.Hero;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestGetClassObj</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MyCharacter.Hero&quot;</span>;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            <span class="hljs-type">Class</span> <span class="hljs-variable">pClass1</span> <span class="hljs-operator">=</span> Class.forName(className);  <br>            <span class="hljs-type">Class</span> <span class="hljs-variable">pClass2</span> <span class="hljs-operator">=</span> Hero.class;  <br>            <span class="hljs-type">Class</span> <span class="hljs-variable">pClass3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>().getClass();  <br>            System.out.println(pClass1 == pClass2);  <br>            System.out.println(pClass1 == pClass3);  <br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;  <br>            <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE] 注意<br>获取类对象的时候，会导致类属性被初始化<br>为 Hero 增加一个静态属性, 并且在静态初始化块里进行初始化，参考 <a href="https://how2j.cn/k/class-object/class-object-init/297.html#step589">类属性初始化</a>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String copyright;<br><span class="hljs-keyword">static</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;初始化 copyright&quot;</span>);<br>copyright = <span class="hljs-string">&quot;版权由Riot Games公司所有&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论什么途径获取类对象，都会导致<strong>静态属性被初始化</strong>，而且<strong>只会执行一次</strong>。（除了直接使用 <code>Class c = Hero.class</code> 这种方式，这种方式<strong>不会导致静态属性被初始化</strong>）</p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>与传统的通过 new 来获取对象的方式不同，反射机制，会<strong>先拿到</strong> Hero 的“<strong>类对象</strong>”, 然后通过类对象获取“<strong>构造器对象</strong>”  ，再通过构造器对象<strong>创建一个对象</strong></p><ol><li>获取<strong>类对象</strong>（类锁，3 种方式）</li><li>获取构造器对象 <code>getConstructor</code> </li><li>创建一个对象 <code>newInstance</code></li></ol><p>（1）通过反射机制创建一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">//使用反射的方式创建对象  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MyCharacter.Hero&quot;</span>;  <br>    <span class="hljs-comment">//类对象  </span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">hClass</span> <span class="hljs-operator">=</span> Class.forName(className);  <br>    <span class="hljs-comment">//构造器  </span><br>    <span class="hljs-type">Constructor</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> hClass.getConstructor();  <br>    <span class="hljs-comment">//通过构造器实例化  </span><br>    <span class="hljs-type">Hero</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> (Hero) c.newInstance();  <br>    h2.setName(<span class="hljs-string">&quot;gareen&quot;</span>);  <br>    System.out.println(h2);  <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>    <span class="hljs-comment">// TODO Auto-generated catch block  </span><br>    e.printStackTrace();  <br>&#125;<br></code></pre></td></tr></table></figure><p>（2）通过配置文件获取对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Reflect;  <br><span class="hljs-keyword">import</span> MyCharacter.Hero;  <br><span class="hljs-keyword">import</span> java.io.*;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;  <br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetCObjByFile</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Hero <span class="hljs-title function_">getHero</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/hero.config&quot;</span>;  <br>        save(path, <span class="hljs-string">&quot;MyCharacter.ADHero&quot;</span>);  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> read(path);  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(className);  <br>        Constructor&lt;Hero&gt; constructor = c.getConstructor();  <br>        <span class="hljs-keyword">return</span> constructor.newInstance();  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;  <br>        <span class="hljs-type">Hero</span> <span class="hljs-variable">hero</span> <span class="hljs-operator">=</span> getHero();  <br>        hero.setName(<span class="hljs-string">&quot;韩信&quot;</span>);  <br>        System.out.println(hero);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(String path, String className)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);  <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(f))  <br>        ) &#123;  <br>            dos.writeUTF(className);  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">read</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);  <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f))) &#123;  <br>            <span class="hljs-keyword">return</span> dis.readUTF();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h4><p>通过反射机制修改对象的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">Hero</span> <span class="hljs-variable">hero</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> hero.getClass().getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);  <br><span class="hljs-comment">//        对于private属性需要先设置可访问修改，对于public属性可直接访问修改  </span><br>        name.setAccessible(<span class="hljs-literal">true</span>);  <br>        name.set(hero, <span class="hljs-string">&quot;zhaoyun&quot;</span>);  <br>        System.out.println(hero.getName());<br></code></pre></td></tr></table></figure><h5 id="getField-和-getDeclaredField-的区别"><a href="#getField-和-getDeclaredField-的区别" class="headerlink" title="getField 和 getDeclaredField 的区别"></a>getField 和 getDeclaredField 的区别</h5><p>这两个方法都是<strong>用于获取字段</strong>  </p><ul><li><code>getField</code> 只能获取 <strong>public</strong> 的，<strong>包括从父类继承</strong>来的字段。  </li><li><code>getDeclaredField</code> 可以获取<strong>本类所有的字段，包括 private</strong> 的，但是<strong>不能获取继承来的字段</strong>。 (注： 这里只能获取到 private 的字段，但并不能访问该 private 字段的值, 除非加上 <code>setAccessible(true)</code>)</li></ul><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>通过反射机制，调用一个对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Hero</span> <span class="hljs-variable">hero</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();  <br><span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> hero.getClass().getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);  <br>    setName.invoke(hero, <span class="hljs-string">&quot;李白&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) hero.getClass().getMethod(<span class="hljs-string">&quot;getName&quot;</span>).invoke(hero);  <br>    System.out.println(name);  <br>    <span class="hljs-comment">//            System.out.println(hero.getName());  </span><br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;  <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>反射非常强大，在学习了 <a href="https://how2j.cn/k/spring/spring-ioc-di/87.html">Spring</a> 的依赖注入，反转控制之后，才会对反射有更好的理解。</p></blockquote><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="基本内置注解"><a href="#基本内置注解" class="headerlink" title="基本内置注解"></a>基本内置注解</h4><h5 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h5><p>@Override 用在方法上，表示这个方法<strong>重写了父类的方法</strong>，如 toString ()。如果父类没有这个方法，那么就无法编译通过。</p><h5 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h5><p>@Deprecated 表示这个<strong>方法已经过期</strong>，<strong>不建议开发者使用</strong>。(暗示在将来某个不确定的版本，就有可能会取消掉)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hackMap</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h5><p>@SuppressWarnings Suppress 英文的意思是抑制的意思，这个注解的用处是<strong>忽略警告信息</strong>。<br><code>@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unused&quot; &#125;)</code><br>就对这些警告进行了抑制，即忽略掉这些警告信息。<br>@SuppressWarnings 有常见的值，分别对应如下意思  </p><ol><li>deprecation：使用了不赞成使用的类或方法时的警告 (使用@Deprecated 使得编译器产生的警告)；  </li><li>unchecked：执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告  </li><li>fallthrough：当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;  </li><li>path：在类路径、源文件路径等中有不存在的路径时的警告;  </li><li>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告;  </li><li>finally：任何 finally 子句不能正常完成时的警告;  </li><li>rawtypes 泛型类型未指明  </li><li>unused 引用定义了，但是没有被使用  </li><li>all：关于以上所有情况的警告。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unused&quot; &#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">heros</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h5><p>@SafeVarargs 这是 1.7 之后新加入的基本注解. 如例所示，当使用<a href="https://how2j.cn/k/class-object/class-object-overload/291.html#step705">可变数量的参数</a>的时候，而参数的类型又是泛型 T 的话，就会出现警告。这个时候，就使用@SafeVarargs 来去掉这个警告<br>@SafeVarargs 注解<strong>只能用在参数长度可变的方法或构造方法上</strong>，且方法必须声明为<strong>static 或 final</strong>，否则会出现编译错误。一个方法使用@SafeVarargs 注解的前提是，开发人员必须确保这个方法的实现中<strong>对泛型类型参数的处理不会引发类型安全问题</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getFirstOne</span><span class="hljs-params">(T... elements)</span> &#123;<br>        <span class="hljs-keyword">return</span> elements.length &gt; <span class="hljs-number">0</span> ? elements[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h5><p>@FunctionalInterface 这是 Java 1.8 新增的注解，用于<strong>约定函数式接口</strong>。  </p><blockquote><p>函数式接口概念： 如果接口中<strong>只有一个抽象方法</strong>（可以包含多个<strong>默认方法或多个 static 方法</strong>），该接口称为函数式接口。函数式接口其存在的意义，主要是配合 <a href="https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html">Lambda 表达式</a> 来使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可注解函数接口，仅有一个抽象方法</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AD</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adAttack</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//不可注解函数接口，有两个抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apAttack</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apAttack2</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><h5 id="自定义注解-JDBCConfig"><a href="#自定义注解-JDBCConfig" class="headerlink" title="自定义注解@JDBCConfig"></a>自定义注解@JDBCConfig</h5><ol><li>创建注解类型的时候即不使用 class 也不使用 interface, 而是使用 <code>@interface</code><br><code>public @interface JDBCConfig</code></li><li>元注解<br><code>@Target(&#123;METHOD,TYPE&#125;)</code> 表示这个注解可以用<strong>用在类&#x2F;接口</strong>上，还可以<strong>用在方法</strong>上<br><code>@Retention(RetentionPolicy.RUNTIME)</code> 表示这是一个<strong>运行时注解</strong>，即运行起来之后，才获取注解中的相关信息，而不像基本注解如 <a href="https://how2j.cn/k/annotation/annotation-system/1060.html#step4028">@Override</a> 那种不用运行，在编译时 eclipse 就可以进行相关工作的编译时注解。<br><code>@Inherited</code> 表示这个<strong>注解可以被子类继承</strong><br><code>@Documented</code> 表示当<strong>执行 javadoc</strong>的时候，<strong>本注解会生成相关文档</strong>  </li><li>注解元素，这些注解元素就用于<strong>存放注解信息</strong>，在解析的时候获取出来</li></ol><ul><li>String ip ();</li><li>int port () default 3306;</li><li>String database ();</li><li>String encoding ();</li><li>String loginName ();</li><li>String password ();</li></ul><h5 id="注解方式-DBUtil"><a href="#注解方式-DBUtil" class="headerlink" title="注解方式 DBUtil"></a>注解方式 DBUtil</h5><p>有了<a href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 之后，我们就把<a href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4034">非注解方式DBUtil</a> 改造成为注解方式 DBUtil。<br>如例所示，数据库相关配置信息本来是<strong>以属性的方式存放</strong>的，现在改为了以注解的方式，提供这些信息了。  </p><blockquote><p>注： 目前只是以注解的方式提供这些信息，但是<strong>还没有解析</strong>，接下来进行解析</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Annotation;  <br><span class="hljs-meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;how2java&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;123456&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtil</span> &#123;  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="解析注解"><a href="#解析注解" class="headerlink" title="解析注解"></a>解析注解</h5><p>通过<strong>反射</strong>，<strong>获取这个 DBUtil 这个类上的注解对象</strong><br><code>JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);</code><br>拿到注解对象之后，通过其方法，<strong>获取各个注解元素的值</strong>：  </p><ul><li>String ip &#x3D; config. ip ();</li><li>int port &#x3D; config. port ();</li><li>String database &#x3D; config. database ();</li><li>String encoding &#x3D; config. encoding ();</li><li>String loginName &#x3D; config. loginName ();</li><li>String password &#x3D; config. password ();<br>后续就一样了，根据这些配置信息得到一个数据库连接<strong>Connection 实例</strong>。  <blockquote><p>注： 运行需要用到连接 mysql 的 jar 包，如果没有，可在右侧下载</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Annotation;  <br><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-keyword">import</span> java.sql.DriverManager;  <br><span class="hljs-keyword">import</span> java.sql.SQLException;  <br><span class="hljs-meta">@JDBCConfig(ip = &quot;127.0.0.1&quot;, database = &quot;how2java&quot;, encoding = &quot;UTF-8&quot;, loginName = &quot;root&quot;, password = &quot;123456&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtil</span> &#123;  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, SecurityException &#123;  <br>        <span class="hljs-type">JDBCConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> DBUtil.class.getAnnotation(JDBCConfig.class);  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> config.ip();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> config.port();  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">database</span> <span class="hljs-operator">=</span> config.database();  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">encoding</span> <span class="hljs-operator">=</span> config.encoding();  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">loginName</span> <span class="hljs-operator">=</span> config.loginName();  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> config.password();  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;</span>, ip, port, database, encoding);  <br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, loginName, password);  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException, SQLException &#123;  <br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getConnection();  <br>        System.out.println(c);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元数据在英语中对应单词 <strong>metadata</strong>, <a href="https://en.wikipedia.org/wiki/Metadata">metadata在wiki中的解释</a>是：Metadata is data [information] that provides information about other data，为其他数据提供信息的数据<br>元注解 meta annotation<strong>用于注解自定义注解的注解</strong>。<br>元注解有这么几种：  </p><ul><li>@Target  </li><li>@Retention  </li><li>@Inherited  </li><li>@Documented  </li><li>@Repeatable (java 1.8 新增)</li></ul><h5 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h5><p>@Target 表示这个注解能放在什么位置上，是只能放在类上？还是即可以放在方法上，又可以放在属性上。<a href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 这个注解上的@Target 是：@Target ({METHOD, TYPE})，表示他可以用在方法和类型上（类和接口），但是不能放在属性等其他位置。可以选择的位置列表如下：  </p><ul><li>ElementType. TYPE：能修饰<strong>类、接口或枚举类型</strong>  </li><li>ElementType. FIELD：能修饰<strong>成员变量</strong>  </li><li>ElementType. METHOD：能修饰<strong>方法</strong></li><li>ElementType. PARAMETER：能修饰<strong>参数</strong>  </li><li>ElementType. CONSTRUCTOR：能修饰<strong>构造器</strong>  </li><li>ElementType. LOCAL_VARIABLE：能修饰<strong>局部变量</strong>  </li><li>ElementType. ANNOTATION_TYPE：能修饰<strong>注解</strong>  </li><li>ElementType. PACKAGE：能修饰<strong>包</strong></li></ul><h5 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h5><p>@Retention 表示<strong>生命周期</strong>，<a href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 上的值是 RetentionPolicy. RUNTIME, 表示可以在运行的时候依然可以使用。 @Retention 可选的值有 3 个：  </p><ul><li><strong>RetentionPolicy. SOURCE</strong>： 注解只在源代码中存在，编译成 class 之后，就没了。<a href="https://how2j.cn/k/annotation/annotation-system/1060.html#step4028">@Override</a> 就是这种注解。  </li><li><strong>RetentionPolicy. CLASS</strong>： 注解在 java 文件编程成. class 文件后，依然存在，但是运行起来后就没了。@Retention 的默认值，即当没有显式指定@Retention 的时候，就会是这种类型。  </li><li><strong>RetentionPolicy. RUNTIME</strong>： 注解在<strong>运行起来之后依然存在，程序可以通过反射获取这些信息</strong>，<a href="https://how2j.cn/k/annotation/annotation-customize/1056.html#step4035">自定义注解@JDBCConfig</a> 就是这样。</li></ul><h5 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h5><p>@Inherited 表示该注解<strong>具有继承性</strong>。如例，设计一个 DBUtil 的子类，其 getConnection 2 方法，可以获取到父类 DBUtil 上的注解信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> util;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> anno.JDBCConfig;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtilChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DBUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException, NoSuchMethodException, SecurityException &#123;<br>        <span class="hljs-type">JDBCConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> DBUtilChild.class.getAnnotation(JDBCConfig.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> config.ip();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> config.port();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">database</span> <span class="hljs-operator">=</span> config.database();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">encoding</span> <span class="hljs-operator">=</span> config.encoding();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">loginName</span> <span class="hljs-operator">=</span> config.loginName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> config.password();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;jdbc:mysql://%s:%d/%s?characterEncoding=%s&quot;</span>, ip, port, database, encoding);<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, loginName, password);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, SecurityException, SQLException &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getConnection2();<br>        System.out.println(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h5><p>@Documented 如图所示，在用 javadoc 命令生成 API 文档后，DBUtil 的文档里会出现该注解说明。</p><h5 id="Repeatable-java-1-8-新增"><a href="#Repeatable-java-1-8-新增" class="headerlink" title="@Repeatable (java 1.8 新增)"></a>@Repeatable (java 1.8 新增)</h5><p>当<strong>没有@Repeatable 修饰</strong>的时候，注解在同一个位置，<strong>只能出现一次</strong>，如例所示：<br>@JDBCConfig (ip &#x3D; “127.0.0.1”, database &#x3D; “test”, encoding &#x3D; “UTF-8”, loginName &#x3D; “root”, password &#x3D; “admin”)<br>@JDBCConfig (ip &#x3D; “127.0.0.1”, database &#x3D; “test”, encoding &#x3D; “UTF-8”, loginName &#x3D; “root”, password &#x3D; “admin”)<br>重复做两次就会报错了。<br>使用@Repeatable 之后，再配合一些其他动作，就可以在同一个地方<strong>使用多次</strong>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> annotation;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.ElementType.METHOD;<br><span class="hljs-keyword">import</span> java.lang.annotation.Repeatable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FindFiles</span> &#123;<br>    <span class="hljs-meta">@Target( METHOD)</span><br>    <span class="hljs-meta">@Retention( RetentionPolicy.RUNTIME )</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FileTypes &#123;<br>        FileType[] value();<br>    &#125;<br>    <span class="hljs-meta">@Target(  METHOD )</span><br>    <span class="hljs-meta">@Retention( RetentionPolicy.RUNTIME )</span><br>    <span class="hljs-meta">@Repeatable( FileTypes.class )</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> FileType &#123;<br>        String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    &#125;;<br>    <span class="hljs-meta">@FileType( &quot;.java&quot; )</span><br>    <span class="hljs-meta">@FileType( &quot;.html&quot; )</span><br>    <span class="hljs-meta">@FileType( &quot;.css&quot; )</span><br>    <span class="hljs-meta">@FileType( &quot;.js&quot; )</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileType[] fileTypes= <span class="hljs-built_in">this</span>.getClass().getMethod(<span class="hljs-string">&quot;work&quot;</span>).getAnnotationsByType(FileType.class);<br>            System.out.println(<span class="hljs-string">&quot;将从如下后缀名的文件中查找文件内容&quot;</span>);<br>            <span class="hljs-keyword">for</span> (FileType fileType : fileTypes) &#123;<br>                System.out.println(fileType.value());<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;查找过程略。。。&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | SecurityException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">FindFiles</span>().work();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h4><h5 id="按照作用域分"><a href="#按照作用域分" class="headerlink" title="按照作用域分"></a>按照作用域分</h5><p>根据注解的作用域@Retention，注解分为:</p><ul><li>RetentionPolicy. SOURCE： Java 源文件上的注解  </li><li>RetentionPolicy. CLASS： Class 类文件上的注解  </li><li>RetentionPolicy. RUNTIME： 运行时的注解</li></ul><h5 id="按照来源分"><a href="#按照来源分" class="headerlink" title="按照来源分"></a>按照来源分</h5><p>按照注解的来源，也是分为 3 类:</p><ol><li>内置注解如@Override，@Deprecated 等等  </li><li>第三方注解，如 Hibernate, Struts 等等  </li><li>自定义注解，如<a href="https://how2j.cn/k/annotation/annotation-like-hibernate/1058.html#step4046">仿hibernate的自定义注解</a></li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="hutool"><a href="#hutool" class="headerlink" title="hutool"></a>hutool</h3><ul><li>包含多种工具类：</li><li>日期与字符串转换  </li><li>文件操作  </li><li>转码与反转码  </li><li>随机数生成  </li><li>压缩与解压  </li><li>编码与解码  </li><li>CVS文件操作  </li><li>缓存处理  </li><li>加密解密  </li><li>定时任务  </li><li>邮件收发  </li><li>二维码创建  </li><li>FTP 上传与下载  </li><li>图形验证码生成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://hutool.cn/<br>title: &quot;Hutool — 🍬A set of tools that keep Java sweet.&quot;<br>description: &quot;Hutool: A set of tools that keep Java sweet. Java工具集、类库&quot;<br>host: hutool.cn<br>favicon: https://plus.hutool.cn/images/logo_484.png<br></code></pre></td></tr></table></figure><p><a href="https://hutool.cn/">Hutool — 🍬A set of tools that keep Java sweet.</a></p>]]></content>
    
    
    <summary type="html">Web—study about Java、Mysql、Redis、Linux</summary>
    
    
    
    <category term="Backend_development" scheme="https://alleyf.github.io/categories/Backend-development/"/>
    
    
    <category term="Mysql" scheme="https://alleyf.github.io/tags/Mysql/"/>
    
    <category term="Java" scheme="https://alleyf.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深度学习论文阅读总结</title>
    <link href="https://alleyf.github.io/2023/10/777b5316f710.html"/>
    <id>https://alleyf.github.io/2023/10/777b5316f710.html</id>
    <published>2023-10-05T07:42:18.703Z</published>
    <updated>2023-11-18T15:15:19.123Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">序号</th><th>作者</th><th>来源</th><th align="center">标题</th><th>关键词</th><th>研究对象</th><th>主要实验方法</th><th>结论</th><th>阅读日期</th></tr></thead><tbody><tr><td align="center">1</td><td>Kaiming He</td><td>2015-CVPR</td><td align="center">[[Deep residual learning for image recognition]]</td><td>深度神经网络，残差，短接</td><td>网络深度</td><td>提出层之间跳跃短接的残差块</td><td>解决深层网络退化问题，并提升了网络效果，是后续深层网络的基石</td><td>2023-08-10 16:06:07</td></tr><tr><td align="center">2</td><td>Ashish Vaswani</td><td>2017-NIPS</td><td align="center">[[Attention is All you Need  ]]</td><td>Transformer，注意力机制，编码器，解码器</td><td>网络架构，特称提取</td><td></td><td></td><td></td></tr><tr><td align="center">3</td><td></td><td></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">4</td><td></td><td></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">5</td><td></td><td></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">6</td><td></td><td></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="center">7</td><td></td><td></td><td align="center"></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">some overview about NLP papers。</summary>
    
    
    
    <category term="科研学习" scheme="https://alleyf.github.io/categories/%E7%A7%91%E7%A0%94%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="NLP" scheme="https://alleyf.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch快速入门</title>
    <link href="https://alleyf.github.io/2023/05/891ff30b7b9b.html"/>
    <id>https://alleyf.github.io/2023/05/891ff30b7b9b.html</id>
    <published>2023-05-31T06:27:39.000Z</published>
    <updated>2023-11-14T10:14:38.412Z</updated>
    
    <content type="html"><![CDATA[<ol><li>[[#1.python|1.python]]</li><li>[[#1.数据加载|1.数据加载]]<ol><li>[[#1.数据加载#1.1DataSet|1.1DataSet]]</li></ol></li><li>[[#2.TensorBoard|2.TensorBoard]]<ol><li>[[#2.TensorBoard#2.1 绘图|2.1 绘图]]</li><li>[[#2.TensorBoard#2.2 添加图片|2.2 添加图片]]</li></ol></li><li>[[#3.Transforms|3.Transforms]]<ol><li>[[#3.Transforms#3.1 ToTensor|3.1 ToTensor]]</li><li>[[#3.Transforms#3.2 Compose|3.2 Compose]]</li></ol></li></ol><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><hr><h2 id="1-python"><a href="#1-python" class="headerlink" title="1. python"></a>1. python</h2><blockquote><p>Python 类中的双下划线 (double underscore)开头的方法通常被称为”魔法方法” (magic methods)。这些方法可以实现一些特殊的功能或对类进行修改。以下是一些常见的双下划线方法及其作用:</p></blockquote><ul><li><p><strong>init</strong>(): 构造函数, 用于初始化类的实例。</p></li><li><p><strong>str</strong>(): 当使用 print 输出对象时, 打印该方法的返回值。</p></li><li><p><strong>repr</strong>(): 返回对象的机器可读字符串表示形式。</p></li><li><p><strong>del</strong>(): 析构函数, 删除对象时被调用。</p></li><li><p><strong>call</strong>(): 允许将对象视为函数调用。</p></li><li><p><strong>getitem</strong>(): 通过索引访问元素的方法, 使得对象可以像列表那样进行切片。</p></li><li><p><strong>len</strong>(): 返回对象长度的方法, 使得对象可以对 len () 函数生效。</p></li><li><p><strong>eq</strong>(): 判断两个对象是否相等的方法, 使得对象可以使用 &#x3D;&#x3D; 进行比较。</p></li><li><p><strong>lt</strong>(): 小于比较的方法, 可以使用 &lt; 进行比较。</p></li><li><p><strong>add</strong>(): 实现对象的加法运算。</p></li><li><p><strong>iter</strong>(): 实现迭代器接口, 使得对象可以被用于 for 循环。</p></li><li><p><strong>metaclass</strong>: 元类, 用于创建类对象。</p></li></ul><blockquote><p>所以双下划线方法主要是实现一些内置的功能或魔法方法, 让 Python 类拥有一些特殊的行为。我们自己编写类时, 如果需要实现某些特殊功能, 可以通过编写双下划线方法来实现。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><h2 id="1-数据加载"><a href="#1-数据加载" class="headerlink" title="1. 数据加载"></a>1. 数据加载</h2><h3 id="1-1-DataSet"><a href="#1-1-DataSet" class="headerlink" title="1.1 DataSet"></a>1.1 DataSet</h3><blockquote><p>继承 DataSet 类并重写__getitem__和 <strong>len</strong> 方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">import</span> os<br><span class="hljs-comment"># 快捷键ctrl+B快速打开关闭文件编辑区</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root_dir,label_dir</span>):<br>        self.root_dir = root_dir<br>        self.label_dir = label_dir<br>        self.path = os.path.join(self.root_dir,self.label_dir)<br>        self.img_path = os.listdir(self.path)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        <span class="hljs-comment"># 根据索引index获取数据和标签</span><br>        img_name = self.img_path[index]<br>        img_item_path = os.path.join(self.path,img_name)<br>        img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>        label = self.label_dir<br>        <span class="hljs-keyword">return</span> img,label<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 返回数据集的长度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_path)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">root_dir = <span class="hljs-string">&#x27;dataset/train&#x27;</span><br>ants_label_dir = <span class="hljs-string">&#x27;ants_image&#x27;</span><br>bees_label_dir = <span class="hljs-string">&#x27;bees_image&#x27;</span><br>ants_dataset = CustomDataset(root_dir,ants_label_dir)<br>bees_dataset = CustomDataset(root_dir,bees_label_dir)<br></code></pre></td></tr></table></figure><blockquote><p><strong>小数据集可以通过➕叠加为大数据集</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">img,label = ants_dataset[<span class="hljs-number">1</span>]<br>img.show()<br>img,label = bees_dataset[<span class="hljs-number">0</span>]<br>img.show()<br>train_dataset = ants_dataset+bees_dataset<br>img,label = train_dataset[<span class="hljs-number">124</span>]<br>img.show()<br></code></pre></td></tr></table></figure><blockquote><p>加载或下载数据集</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br>dataset_trans = torchvision.transforms.Compose([<br>    torchvision.transforms.ToTensor()<br>])<br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>, train=<span class="hljs-literal">True</span>, transform=dataset_trans, download=<span class="hljs-literal">False</span>)<br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>, train=<span class="hljs-literal">False</span>, transform=dataset_trans, download=<span class="hljs-literal">False</span>)<br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img_tensor, target = test_set[i]<br>    writer.add_image(<span class="hljs-string">&quot;test_set&quot;</span>, img_tensor, i)<br>writer.close()<br></code></pre></td></tr></table></figure><h3 id="1-2-DataLoder"><a href="#1-2-DataLoder" class="headerlink" title="1.2 DataLoder"></a>1.2 DataLoder</h3><blockquote><p>加载数据集将多个数据 Tensor 和和标签分别打包成一个大的整体 batch</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>,train=<span class="hljs-literal">True</span>,transform=torchvision.transforms.ToTensor(),download=<span class="hljs-literal">False</span>)<br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>,train=<span class="hljs-literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="hljs-literal">False</span>)<br>test_loder = DataLoader(dataset=test_set,batch_size=<span class="hljs-number">64</span>,shuffle=<span class="hljs-literal">True</span>,num_workers=<span class="hljs-number">0</span>,drop_last=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># for data in test_loder:</span><br><span class="hljs-comment">#   imgs,target = data</span><br><span class="hljs-comment">#   print(imgs.shape,target)</span><br><span class="hljs-comment">#   print(type(imgs))</span><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>  step = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> test_loder:<br>      imgs,targets = data<br>      <span class="hljs-comment"># imgs = imgs.permute(0, 2, 3, 1)</span><br>      writer.add_image(<span class="hljs-string">&quot;epoch_&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch), imgs, step, dataformats=<span class="hljs-string">&#x27;NCHW&#x27;</span>)<br>      step+=<span class="hljs-number">1</span><br>writer.close()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308172314315.png" alt="image.png|400"></p><blockquote><p>[!NOTE] Tip</p><ul><li><code>shuttle = true</code>，则每轮打包成 batch 的数据顺序不同，提高训练效果</li><li><code>writer.add_image(&quot;epoch_&#123;&#125;&quot;.format(epoch), imgs, step, dataformats=&#39;NCHW&#39;)</code> 需要指定图片数据类型 <code>dataformats</code></li></ul></blockquote><h2 id="2-TensorBoard"><a href="#2-TensorBoard" class="headerlink" title="2. TensorBoard"></a>2. TensorBoard</h2><blockquote><p>TensorBoard 是一个用于可视化和监控机器学习模型训练过程的工具。它可以帮助您跟踪实验指标（如损失和准确率）、呈现模型计算图以及将嵌入向量投影到较低维度的空间等[1]。以下是使用 TensorBoard 的一般步骤：</p></blockquote><ol><li><p>安装 TensorBoard：您可以使用 pip 安装 TensorBoard，例如 <code>pip install tensorboard</code>。</p></li><li><p>导入 TensorBoard：在 Python 代码中，导入 TensorBoard 库，例如 <code>import tensorflow as tf</code>。</p></li><li><p>在代码中添加 TensorBoard 回调：在您的机器学习模型训练代码中，添加 TensorBoard 回调函数。这将允许 TensorBoard 在训练过程中记录指定的指标和数据。</p></li><li><p>启动 TensorBoard 服务器：在终端中，使用命令 <code>tensorboard --logdir=&lt;log_directory&gt;</code> 启动 TensorBoard 服务器。其中，<code>&lt;log_directory&gt;</code> 是您保存 TensorBoard 日志文件的目录。</p></li><li><p>在浏览器中查看 TensorBoard：在浏览器中输入 <code>http://localhost:6006</code>，您将能够查看 TensorBoard 的可视化界面。</p></li></ol><blockquote><p>在 TensorBoard 界面中，您可以查看训练过程中的损失曲线、准确率曲线等指标图表。您还可以查看模型计算图、嵌入向量的投影等[1]。</p></blockquote><h3 id="2-1-绘图"><a href="#2-1-绘图" class="headerlink" title="2.1 绘图"></a>2.1 绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br>writer  = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=x&quot;</span>,i,i)<br>writer.close()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308161754456.png" alt="image.png|500"></p><h3 id="2-2-添加图片"><a href="#2-2-添加图片" class="headerlink" title="2.2 添加图片"></a>2.2 添加图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>writer  = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>img_path = <span class="hljs-string">&quot;dataset/train/ants_image/1030023514_aad5c608f9.jpg&quot;</span><br>img_pil = Image.<span class="hljs-built_in">open</span>(img_path)<br>img_array = np.array(img_pil)<br>writer.add_image(<span class="hljs-string">&quot;ant_test&quot;</span>,img_array,<span class="hljs-number">2</span>,dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br>writer.close()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308161755844.png" alt="image.png|400"></p><h2 id="3-Transforms"><a href="#3-Transforms" class="headerlink" title="3. Transforms"></a>3. Transforms</h2><h3 id="3-1-ToTensor"><a href="#3-1-ToTensor" class="headerlink" title="3.1 ToTensor"></a>3.1 ToTensor</h3><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308162052347.png" alt="image.png|500"></p><blockquote><p>通过 transforms. ToTensor 去看两个问题</p><ol><li>transforms 该如何使用 (python)？</li><li>为什么我们需要 Tensor 数据类型？</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> cv2<br>img_path = <span class="hljs-string">&quot;./dataset/train/ants_image/0013035.jpg&quot;</span><br>img_PIL=Image.<span class="hljs-built_in">open</span>(img_path)<br>img_cv = cv2.imread(img_path)<br>transform_tensor = transforms.ToTensor()<br>img_tensor = transform_tensor(img_cv)<br><span class="hljs-built_in">print</span>(img_tensor.shape)<br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>writer.add_image(<span class="hljs-string">&quot;tensor_image&quot;</span>,img_tensor)<br>writer.close()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308171038445.png" alt="image.png|400"></p><blockquote><p>[!NOTE] Tips</p><ol><li><strong>cv 2 的 imread</strong> 读取的图片类型为 <code>ndarray</code></li><li><strong>PIL 的 Image. open</strong> 读取的图片类型为 <code>JpegImageFile</code></li></ol></blockquote><h3 id="3-2-Compose"><a href="#3-2-Compose" class="headerlink" title="3.2 Compose"></a>3.2 Compose</h3><blockquote><p>Compose 类是将多种 transforms 操作叠加在一起, 初始化 compose 类后, 执行__call__​​方法循环执行组合操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">transform_compose = transforms.Compose([transforms.CenterCrop(<span class="hljs-number">10</span>),transforms.ToTensor(),transforms.ConvertImageDtype(torch.<span class="hljs-built_in">float</span>),])<br>img_compose = transform_compose(img_PIL)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(img_compose))<br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br>writer.add_image(<span class="hljs-string">&quot;compose_tensor_image&quot;</span>,img_compose)<br>writer.close()<br></code></pre></td></tr></table></figure><h3 id="3-3-Normalize"><a href="#3-3-Normalize" class="headerlink" title="3.3 Normalize"></a>3.3 Normalize</h3><blockquote><p>对图像进行正则化, 传参包括各通道均值和标准差</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">trans_normalize = transforms.Normalize([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>],[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>img_norm = trans_normalize(img_tensor)<br><span class="hljs-built_in">print</span>(img_norm[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>writer.add_image(<span class="hljs-string">&quot;Normalize&quot;</span>,img_norm)<br></code></pre></td></tr></table></figure><p><img src="/!%5B%5D(https:/raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308171425731.png)" alt="image"></p><h3 id="3-4-Resize"><a href="#3-4-Resize" class="headerlink" title="3.4 Resize"></a>3.4 Resize</h3><blockquote><p>改变 PILImage 图像尺寸</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-comment"># 将图像缩放到256x256</span><br>trans_resize= transforms.Resize(<span class="hljs-number">256</span>) <br><span class="hljs-comment"># 将图像按比例缩放,短边为256</span><br>trans_resize= transforms.Resize(size=(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>), interpolation=Image.BICUBIC)<br><span class="hljs-comment"># 最长边不超过256,短边按2:1的比例缩放 </span><br>trans_resize= transforms.Resize(max_size=<span class="hljs-number">256</span>, ratio=<span class="hljs-number">2</span>)<br>img_resize = trans_resize(img_tensor)<br><span class="hljs-built_in">print</span>(img_resize.shape)<br></code></pre></td></tr></table></figure><h3 id="3-5-RandomCrop"><a href="#3-5-RandomCrop" class="headerlink" title="3.5 RandomCrop"></a>3.5 RandomCrop</h3><blockquote><p>随机裁剪图像, 指定裁剪后的图像大小进行随机裁剪, 支持输入格式为 PILImage 和 Tensor​​</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">trans_randomcrop = transforms.RandomCrop(<span class="hljs-number">512</span>)<br>img_randomcrop = trans_randomcrop(img_tensor)<br><span class="hljs-built_in">print</span>(img_randomcrop.shape)<br>writer.add_image(<span class="hljs-string">&quot;randomcrop&quot;</span>,img_randomcrop)<br></code></pre></td></tr></table></figure><p>​​ <img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308171458436.png" alt="|400"> ​<br>​​</p><h2 id="神经网络基本骨架"><a href="#神经网络基本骨架" class="headerlink" title="神经网络基本骨架"></a>神经网络基本骨架</h2><h3 id="4-1-nn-module"><a href="#4-1-nn-module" class="headerlink" title="4.1 nn_module"></a>4.1 nn_module</h3><blockquote><p>module 是是所有网络模块的<strong>基类</strong>，必须继承该类并重写部分方法，构造方法、前向传播等</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch  <br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple_Nn</span>(nn.Module):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>) -&gt; <span class="hljs-literal">None</span>:  <br>        <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):  <br>        output = <span class="hljs-built_in">input</span> + <span class="hljs-number">1</span>  <br>        <span class="hljs-keyword">return</span> output  <br>simple_nn = Simple_Nn()  <br><span class="hljs-built_in">input</span> = torch.tensor(<span class="hljs-number">1.0</span>)  <br>output = simple_nn(<span class="hljs-built_in">input</span>)  <br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><h3 id="4-2-nn-Conv2d（卷积）"><a href="#4-2-nn-Conv2d（卷积）" class="headerlink" title="4.2 nn.Conv2d（卷积）"></a>4.2 nn.Conv2d（卷积）</h3><blockquote><p>卷积层的使用，Conv2d是神经网络结构中的二维卷积结构，也是最常用的模块之一。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch  <br><span class="hljs-keyword">import</span> torchvision  <br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn  <br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Conv2d, MaxPool2d, ReLU  <br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader  <br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter  <br>  <br>test_sets = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>, train=<span class="hljs-literal">False</span>,  <br>                                         transform=torchvision.transforms.ToTensor(),  <br>                                         download=<span class="hljs-literal">True</span>)  <br>dataloader = DataLoader(test_sets, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_Cnn</span>(nn.Module):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, </span>):  <br>        <span class="hljs-built_in">super</span>(My_Cnn, self).__init__()  <br>        self.conv1 = Conv2d(in_channels=<span class="hljs-number">3</span>, out_channels=<span class="hljs-number">6</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)  <br>        <span class="hljs-comment"># self.maxpool1 = MaxPool2d(6, stride=2, padding=0)  </span><br>        <span class="hljs-comment"># self.nonlinear1 = ReLU()  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):  <br>        map1 = self.conv1(x)  <br>        output = self.nonlinear1(map1)  <br>        <span class="hljs-keyword">return</span> output  <br>  <br>  <br>mycnn = My_Cnn()  <br><span class="hljs-built_in">print</span>(mycnn)  <br>step = <span class="hljs-number">0</span>  <br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)  <br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:  <br>    imgs, targets = data  <br>    output = mycnn(imgs)  <br>    output = torch.reshape(output, [-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>])  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Batch:&quot;</span> + <span class="hljs-built_in">str</span>(step), imgs.shape)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Batch:&quot;</span> + <span class="hljs-built_in">str</span>(step), output.shape)  <br>    writer.add_image(<span class="hljs-string">&quot;input_img&quot;</span>, imgs, step, dataformats=<span class="hljs-string">&quot;NCHW&quot;</span>)  <br>    writer.add_image(<span class="hljs-string">&quot;output_img&quot;</span>, output, step, dataformats=<span class="hljs-string">&quot;NCHW&quot;</span>)  <br>    step += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p><strong>Tensorboard结果：</strong></p><p><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308261350971.png" alt="|350"></p><hr><h3 id="4-3-nn-MaxPool2d（最大池化）"><a href="#4-3-nn-MaxPool2d（最大池化）" class="headerlink" title="4.3 nn.MaxPool2d（最大池化）"></a>4.3 nn.MaxPool2d（最大池化）</h3><blockquote><p>最大池化保持特征图通道数不变的前提下，大小减少约一半左右，起到减小网络参数，提取关键特征，加快收敛速度（本身不具备特征提取作用）。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch  <br><span class="hljs-keyword">import</span> torchvision  <br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> MaxPool2d  <br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn  <br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader  <br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter  <br>  <br>test_sets = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>, train=<span class="hljs-literal">False</span>,  <br>                                         transform=torchvision.transforms.ToTensor(),  <br>                                         download=<span class="hljs-literal">True</span>)  <br>dataloader = DataLoader(test_sets, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NiuMa</span>(nn.Module):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">super</span>(NiuMa, self).__init__()  <br>        self.maxpool = MaxPool2d(<span class="hljs-number">3</span>, ceil_mode=<span class="hljs-literal">True</span>)  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):  <br>        <span class="hljs-keyword">return</span> self.maxpool(<span class="hljs-built_in">input</span>)  <br>  <br>  <br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)  <br>niuma = NiuMa()  <br>step = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:  <br>    imgs, targets = data  <br>    output = niuma(imgs)  <br>    writer.add_image(<span class="hljs-string">&quot;input_maxpool&quot;</span>, imgs, step, dataformats=<span class="hljs-string">&quot;NCHW&quot;</span>)  <br>    writer.add_image(<span class="hljs-string">&quot;output_maxpool&quot;</span>, output, step, dataformats=<span class="hljs-string">&quot;NCHW&quot;</span>)  <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;batch:&quot;</span> + <span class="hljs-built_in">str</span>(step), imgs.shape, output.shape)  <br>    step += <span class="hljs-number">1</span>  <br>  <br>writer.close()<br><br></code></pre></td></tr></table></figure><p><strong>Tensorboard结果：</strong><br><em>输入图像</em><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308261448451.png" alt="image.png | 225"><br><em>最大池化输出图像</em><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308261448510.png" alt="image.png | 250"></p><hr><h3 id="4-4-非线性激活"><a href="#4-4-非线性激活" class="headerlink" title="4.4 非线性激活"></a>4.4 非线性激活</h3><blockquote><p>非线性激活对输入进行非线性处理，从而拟合出需要的模型，非线性越多拟合效果越好，但容易过拟合，<code>ReLU激活函数</code>是最常用的非线性激活函数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch  <br><span class="hljs-keyword">import</span> torchvision.datasets  <br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn  <br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> ReLU, Sigmoid  <br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader  <br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter  <br>    <br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>, train=<span class="hljs-literal">False</span>,  <br>                                       transform=torchvision.transforms.ToTensor(), download=<span class="hljs-literal">True</span>)  <br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NiuMa</span>(nn.Module):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">super</span>(NiuMa, self).__init__()  <br>        self.relu = ReLU()  <br>        self.sigmoid = Sigmoid()  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):  <br>        <span class="hljs-keyword">return</span> self.sigmoid(<span class="hljs-built_in">input</span>)  <br>  <br>  <br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)  <br>niuma = NiuMa()  <br>step = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:  <br>    imgs, targets = data  <br>    output = niuma(imgs)  <br>    writer.add_image(<span class="hljs-string">&quot;output_sigmoid&quot;</span>, output, global_step=step, dataformats=<span class="hljs-string">&quot;NCHW&quot;</span>)  <br>    step += <span class="hljs-number">1</span>  <br>writer.close()<br><br></code></pre></td></tr></table></figure><p><strong>TensorBoard结果：</strong></p><p><em>Sigmoid非线性激活</em><br><img src="https://raw.githubusercontent.com/Alleyf/PictureMap/main/web_icons/202308261517218.png" alt="image.png|350"></p><h3 id="4-5-线性层"><a href="#4-5-线性层" class="headerlink" title="4.5 线性层"></a>4.5 线性层</h3><blockquote><p>线性层一般为网络最后的全连接层，分类问题则经过softmax得到各个类别的概率。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch  <br><span class="hljs-keyword">import</span> torchvision.datasets  <br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn  <br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> Linear  <br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader  <br>  <br>dataset = torchvision.datasets.CIFAR10(<span class="hljs-string">&quot;./data/datasets/CIFAR&quot;</span>, train=<span class="hljs-literal">False</span>,  <br>                                       transform=torchvision.transforms.ToTensor(), download=<span class="hljs-literal">True</span>)  <br>dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">True</span>)  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NiuMa</span>(nn.Module):  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-built_in">super</span>(NiuMa, self).__init__()  <br>        <span class="hljs-comment"># Linear的参数为输入特征数和输出特征数  </span><br>        self.linear = Linear(<span class="hljs-number">196608</span>, <span class="hljs-number">10</span>)  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):  <br>        <span class="hljs-keyword">return</span> self.linear(<span class="hljs-built_in">input</span>)  <br>  <br>  <br>niuma = NiuMa()  <br>  <br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataloader:  <br>    imgs, targets = data  <br>    imgs = torch.flatten(imgs)  <br>    <span class="hljs-built_in">print</span>(imgs.shape)  <br>    output = niuma(imgs)  <br>    <span class="hljs-built_in">print</span>(output.shape, output)<br><br></code></pre></td></tr></table></figure><h1 id="常用函数手册"><a href="#常用函数手册" class="headerlink" title="常用函数手册"></a>常用函数手册</h1><p>![[pytorch常用函数手册.pdf]]</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.bilibili.com/video/BV1hE411t7RN?p=6&vd_source=9c896fa9c3f9023797e8efe7be0c113e">PyTorch快速入门（小土堆）</a></p>]]></content>
    
    
    <summary type="html">Machine and Deep learning</summary>
    
    
    
    <category term="机器学习" scheme="https://alleyf.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="DL" scheme="https://alleyf.github.io/tags/DL/"/>
    
  </entry>
  
</feed>
