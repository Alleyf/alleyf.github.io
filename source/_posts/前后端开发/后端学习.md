---
title: 后端开发学习
tags:
  - Mysql
  - Java
categories: Backend_development
date: 2023-10-08 13:29:26
sticky: 90
excerpt: Web—study about Java、Mysql、Redis、Linux
---
# Java
## Java 基础
### 1.变量
从小到大自动转，从大到小强制转（精度丢失，值可能不正确）
> Java 中进行二元与运算类型的提升规则 
> 1. 整数运算： 如果两个操作数有一个为 long，则结果也为 long；没有 long 时，结果为 int。即使操作数全为 short、byte，结果也是 int。 
> 2. 浮点运算： 如果两个操作数有一个为 double，则结果为 double；只有两个操作数都是 float，则结果才为 float。注意：int 与 float 运算，结果为 float。

### 2.命名规则
- 变量命名只能使用**字母数字 $ \_**  
- 变量第一个字符只能使用字母 $ _  
- 变量第一个字符不能使用数字，不能使用关键字  
> 注：_ 是下划线，不是-减号或者—— 破折号

java 关键字：
![|300](https://stepimagewm.how2j.cn/523.png)
![|300](https://stepimagewm.how2j.cn/522.png)
### 3.final 修饰词
当一个变量被 final 修饰的时候，该变量只有一次赋值的机会
当形参被 final 修饰时不能对形参再次赋值，如果形参是对象可以改变内部的属性
### 4.操作符 Scanner
使用 Scanner 类，需要在最前面加上  
`import java.util.Scanner;`
> 如果在通过 `nextInt()` 读取了整数后，再接着读取字符串，读出来的是回车换行: **"\r\n"**, 因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\r\n".  
	所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该**连续执行两次 nextLine ()**，第一次是取走回车换行，第二次才是读取真正的字符串
```java
import java.util.Scanner;
public class HelloWorld {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int i = s.nextInt();
        System.out.println("读取的整数是"+ i);
        String rn = s.nextLine();
        String a = s.nextLine();
        System.out.println("读取的字符串是："+a);
    }
}
```
### 5.数组
数组是一个**固定长度**，包含了**相同类型数据**的**容器**
`int[] a; 和 int a[]` 都声明了一个数组变量，仅仅声明并没有创建分配空间。
创建一个长度是 5 的数组，并且使用**引用 a 指向该数组**，a 是一个地址，占据 **4** 个字节
`a = new int[5];`
常用方法：
```java
String Arrays.toString(数组)                 将数组拼接成一个字符串
int Arrays.binarySearch(数组，查找的元素)            二分法查护元素
int[] Arrays.copyOf(原数组，新数组长度)              拷贝数组
int[]Arrays.copyOfRange(原数组，起始索引，结束索引)   拷贝数组（指定范围）
void Arrays.fill(数组，元素)                        使用同一元素填充数组
void Arrays.sort(数组)                              对数组进行排序，也可按照自己自定义的规则
boolean Arrays.equals(数组a，数组b)                  返回两个数组是否元素相等的结果
```
eg：
```java
import java.util.Arrays;  
import java.util.Comparator;  
import java.util.Random;  
public class MyArray {  
    public static void main(String[] args) {  
        //声明一个引用  
        Integer[] a;  
        //创建一个长度是5的数组，并且使用引用a指向该数组  
        a = new Integer[5];  
        for (int i = 0; i < 5; i++) {  
            a[i]= new Random().nextInt(5);  
        }  
        Arrays.sort(a,new Comparator<Integer>(){  
            @Override  
            public int compare(Integer o1,Integer o2) {  
                // 降序  
                return o2-o1;  
        }});  
        System.out.println(Arrays.toString(a));  
    }  
}
```
> [!NOTE]
> 分配空间，同时赋值
> 写法一： 分配空间同时赋值
> `int[] a = new int[]{100,102,444,836,3236};`
>  
> 写法二： 省略了 new int[], 效果一样
> `int[] b = {100,102,444,836,3236};`

数组排序：
```java
import java.util.Arrays;  
public class MySort {  
    int [] a;  
    MySort(int []array ){  
        this.a = array;  
    }  
    public void ChoseSort(int [] array){  
        for (int i = 0; i < array.length; i++) {  
            for (int j = i+1; j < array.length; j++) {  
                if (array[i]> array[j]) {  
                    int temp = array[i];  
                    array[i] = array[j];  
                    array[j] = temp;  
                }  
            }  
        }  
    }  
    public  void BubbleSort(int [] array){  
        for (int i = 0; i < array.length; i++) {  
            for (int j = 0; j < array.length-1-i; j++) {  
                if (array[j]> array[j+1]) {  
                    int temp = array[j];  
                    array[j] = array[j+1];  
                    array[j+1] = temp;  
                }  
            }  
        }  
    }  
    public static void main(String[] args) {  
        MySort sort = new MySort(new int[]{1, 3, 4, 6, 2, 7, 8, 5, 9, 10});  
        sort.ChoseSort(sort.a);  
        sort.BubbleSort(sort.a);  
        System.out.println(Arrays.toString(sort.a));  
    }  
}
```
增强型 for 循环遍历
```java
for (int each : values) {
    System.out.println (each);
}
```
#### 二维数组
```java
		//初始化二维数组，
       int[][] a = new int[2][3]; //有两个一维数组，每个一维数组的长度是3
       a[1][2] = 5;  //可以直接访问一维数组，因为已经分配了空间
       //只分配了二维数组
       int[][] b = new int[2][]; //有两个一维数组，每个一维数组的长度暂未分配
       b[0]  =new int[3]; //必须事先分配长度，才可以访问
       b[0][2] = 5;
       //指定内容的同时，分配空间
       int[][] c = new int[][]{
               {1,2,4},
               {4,5},
               {6,7,8,9}
       };
```
### 6.类和对象
#### 引用
引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。
`Hero h = new Hero();`
![](https://stepimagewm.how2j.cn/618.png)
> 引用 h 指向 Hero 对象

![](https://stepimagewm.how2j.cn/617.png)
> 多个引用指向同一个对象

![](https://stepimagewm.how2j.cn/619.png)
> 一个引用只能指向一个对象

### 7.包 (package)
- 把比较接近的类，规划在同一个包下
- 在最开始的地方声明该类所处于的包名
- 使用同一个包下的其他类，直接使用即可  
- 但是要使用其他包下的类，必须 import

### 8.访问修饰符
成员变量有四种修饰符：
<span style="background:rgba(240, 200, 0, 0.2)">1. private 私有的  </span>
<span style="background:rgba(240, 200, 0, 0.2)">2. package/friendly/default 不写  </span>
<span style="background:rgba(240, 200, 0, 0.2)">3. protected 受保护的  </span>
<span style="background:rgba(240, 200, 0, 0.2)">4. public 公共的</span>
![](https://stepimagewm.how2j.cn/604.png)
![](https://stepimagewm.how2j.cn/610.png)
![](https://stepimagewm.how2j.cn/611.png)
![](https://stepimagewm.how2j.cn/612.png)
> [!NOTE]
> 那么什么情况该用什么修饰符呢？
> 从作用域来看，public 能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用 public, 那么到底什么情况该用什么修饰符呢？
> 
> 1. 属性通常使用 private 封装起来
> 2. 方法一般使用 public 用于被调用
> 3. 会被子类继承的方法，通常使用 protected
> 4. package 用的不多，一般新手会用 package, 因为还不知道有修饰符这个东西
> 
> 再就是作用范围最小原则
> 简单说，能用 private 就用 private，不行就放大一级，用 package, 再不行就用 protected，最后用 public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了

### 9.类属性（static 变量）
1. 当一个属性被 **static** 修饰的时候，就叫做**类属性**，又叫做**静态属性**  
2. 当一个属性被声明成类属性，那么**所有的对象，都共享一个值**

访问方式：
1. 对象. 类属性
2. 类. 类属性

对象属性初始化：
1. 声明该属性的时候初始化  
2. 构造方法中初始化  
3. 初始化块

静态属性初始化：
1. 声明该属性的时候初始化  
2. 静态初始化块

> 初始化顺序：<font color="#ff0000">静态属性声明>静态初始化块>对象属性声明>对象属性初始化块>构造方法</font>
### 10.类方法（static 方法）
- 类方法： 又叫做**静态方法**
- 对象方法： 又叫**实例方法**，非静态方法  
  
> 访问一个对象方法，必须建立在**有一个对象的前提**的基础上  
> 访问类方法，不需要对象的存在，直接就访问
> 静态方法只能调用静态方法和静态属性，不能调用对象属性和方法

### 11.单例模式
单例模式又叫做 Singleton 模式，指的是一个类，在一个 JVM 里，**只有一个实例存在**。
*单例模式的设计目的是确保一个类只有一个实例，并提供全局访问点以供其他对象使用。因此，在传统的单例模式中，不允许继承该类，因为继承会导致类的实例数量增多。*
#### 饿汉式单例模式
单例模式的类应该只有一个示例，通过**私有化其构造方法**，使得外部无法通过 new 得到新的实例。
这种单例模式又叫做*饿汉式单例模式*，无论如何都会创建一个实例
```java
package charactor;
public class GiantDragon {
    //私有化构造方法使得该类无法在外部通过new 进行实例化
	private GiantDragon(){
	}
	//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个
	private static GiantDragon instance = new GiantDragon();
	//public static 方法，提供给调用者获取12行定义的对象
	public static GiantDragon getInstance(){
		return instance;
	}
}
```
#### 懒汉式单例模式
**懒汉式**单例模式与**饿汉式**单例模式不同，只有在调用 getInstance 的时候，才会创建实例
```java
package charactor;
public class GiantDragon {
    //私有化构造方法使得该类无法在外部通过new 进行实例化
    private GiantDragon(){        
    }
    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null
    private static GiantDragon instance;
    //public static 方法，返回实例对象
    public static GiantDragon getInstance(){
    	//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象
    	if(null==instance){
    		instance = new GiantDragon();
    	}
    	//返回 instance指向的对象
        return instance;
    }
}
```
> [!NOTE]
> **什么时候使用饿汉式，什么时候使用懒汉式？**
> 饿汉式，是**立即加载**的方式，无论是否会用到这个对象，都会加载。
> 如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。
> 
> 懒汉式，是**延迟加载**的方式，只有使用的时候才会加载。并且有线程安全的考量 (鉴于同学们学习的进度，暂时不对线程的章节做展开)。
> 使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。
> 
> 看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式

#### 单例模式的三要素
什么是单例模式？
1. 构造方法私有化  
2. 静态属性指向实例  
3. public static 的 getInstance 方法，返回第二步的静态属性

### 12.枚举（enum）
枚举 enum 是一种特殊的类 (还是类)，使用枚举可以很方便的定义常量
eg：
```java
public enum Season {
SPRING,SUMMER,AUTUMN,WINTER
}
public class HelloWorld {
	public static void main(String[] args) {
		Season season = Season.SPRING;
		switch (season) {
		case SPRING:
			System.out.println("春天");
			break;
		case SUMMER:
			System.out.println("夏天");
			break;
		case AUTUMN:
			System.out.println("秋天");
			break;
		case WINTER:
			System.out.println("冬天");
			break;
		}
	}
}
```
借助增强型 for 循环，可以很方便的遍历一个枚举都有哪些常量：
```java
public class HelloWorld {
	public static void main(String[] args) {
		for (Season s : Season.values()) {
			System.out.println(s);
		}
	}
}
```
---
### 13.接口与继承
#### 接口
接口就像是一种约定，对类进行约束规范，便于顶层设计规范化
eg：
```java
package MyCharacter;  
public interface Healer {  
    void heal(int healAmount);  
}
package MyCharacter;  
public class Support extends Hero implements Healer {  
    @Override  
    public void heal(int healAmount) {  
        this.setHp(this.getHp() + healAmount);  
        System.out.println("当前英雄的血量为" + this.getHp() + "点");  
    }  
}
```
#### 对象转型
##### 子类转父类（向上转型）
引用类型和对象类型不一致时，需要进行类型转换，类型转换有时候会成功，有时候会失败。
*转换是否成功判别方法：**把右边的当做左边来用，看是否能说通***
> 子类向父类转型（向上转型）一般都是可以的，父类引用指向子类对象

![](https://stepimagewm.how2j.cn/624.png)
##### 父类转子类 (向下转型)
父类转子类，有的时候行，有的时候不行，所以必须进行**强制转换**。强制转换的意思就是转换有风险，风险自担。
转换总结：
![](https://stepimagewm.how2j.cn/625.png)
> 14行： 把 ad 当做 Hero 使用，一定可以，转换之后，h 引用指向一个 ad 对象  
> 15行： h 引用有可能指向一个 ad 对象，也有可能指向一个 support 对象，所以把 h 引用转换成 AD 类型的时候，就有可能成功，有可能失败，因此要进行强制转换，换句话说转换后果自负，到底能不能转换成功，要看引用 h 到底指向的是哪种对象  
> 在这个例子里，**h指向的是一个ad对象**，所以转换成ADHero类型，是可以的  
> 16行：把一个 support 对象当做 Hero 使用，一定可以，转换之后，**h引用指向一个support对象**  
> 17行：这个时候，h 指向的是一个 **support** 对象，所以转换成 **ADHero** 类型，会失败。失败的表现形式是抛出异常 ClassCastException 类型转换异常
```java
package charactor;
import charactor1.Support;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        Hero h =new Hero();
        ADHero ad = new ADHero();
        Support s =new Support();
        h = ad;
        ad = (ADHero) h;
        h = s;
        ad = (ADHero)h;
    }
}
```
> [!NOTE]
> ![](https://stepimagewm.how2j.cn/626.png)
> **没有继承关系**的两个类，互相转换一定会失败，抛出异常

##### 实现类转换成接口(向上转型)
类似于子类转父类，一样可行。
![](https://stepimagewm.how2j.cn/627.png)
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        AD adi = ad;
    }
}
```
##### 接口转换成实现类(向下转型)
![]( https://stepimagewm.how2j.cn/628.png )
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        AD adi = ad;
        ADHero adHero = (ADHero) adi;
        ADAPHero adapHero = (ADAPHero) adi;
        adapHero.magicAttack();
    }
}
```

