---
title: 后端开发学习
tags:
  - Mysql
  - Java
categories: Backend_development
date: 2023-10-08 13:29:26
sticky: 90
excerpt: Web—study about Java、Mysql、Redis、Linux
---
# Java
## Java 基础
### 1. 变量
从小到大自动转，从大到小强制转（精度丢失，值可能不正确）
> Java 中进行二元与运算类型的提升规则 
> 1. 整数运算： 如果两个操作数有一个为 long，则结果也为 long；没有 long 时，结果为 int。即使操作数全为 short、byte，结果也是 int。 
> 2. 浮点运算： 如果两个操作数有一个为 double，则结果为 double；只有两个操作数都是 float，则结果才为 float。注意：int 与 float 运算，结果为 float。

### 2. 命名规则
- 变量命名只能使用**字母数字 $ \_**  
- 变量第一个字符只能使用字母 $ _  
- 变量第一个字符不能使用数字，不能使用关键字  
> 注：_ 是下划线，不是-减号或者—— 破折号

java 关键字：
![|300](https://stepimagewm.how2j.cn/523.png)
![|300](https://stepimagewm.how2j.cn/522.png)
### 3. final 修饰词
当形参被 final 修饰时不能对形参再次赋值，如果形参是对象可以改变内部的属性
1. final 修饰类
   - 当 final 修饰类时，该类无法被继承
2. final 修饰方法
   - 被 final 修饰的方法不能被重写
3. final 修饰基本类型变量
   - 当一个变量被 final 修饰的时候，该变量只有一次赋值的机会
4. final 修饰引用
   - 被 final 修饰的引用只能指向一次对象
5. final 修饰常量
   - 常量值不变
- 

### 4. 操作符 Scanner
使用 Scanner 类，需要在最前面加上  
`import java.util.Scanner;`
> 如果在通过 `nextInt()` 读取了整数后，再接着读取字符串，读出来的是回车换行: **"\r\n"**, 因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\r\n".  
	所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该**连续执行两次 nextLine ()**，第一次是取走回车换行，第二次才是读取真正的字符串
```java
import java.util.Scanner;
public class HelloWorld {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int i = s.nextInt();
        System.out.println("读取的整数是"+ i);
        String rn = s.nextLine();
        String a = s.nextLine();
        System.out.println("读取的字符串是："+a);
    }
}
```
### 5. 数组
数组是一个**固定长度**，包含了**相同类型数据**的**容器**
`int[] a; 和 int a[]` 都声明了一个数组变量，仅仅声明并没有创建分配空间。
创建一个长度是 5 的数组，并且使用**引用 a 指向该数组**，a 是一个地址，占据 **4** 个字节
`a = new int[5];`
常用方法：
```java
String Arrays.toString(数组)                 将数组拼接成一个字符串
int Arrays.binarySearch(数组，查找的元素)            二分法查护元素
int[] Arrays.copyOf(原数组，新数组长度)              拷贝数组
int[]Arrays.copyOfRange(原数组，起始索引，结束索引)   拷贝数组（指定范围）
void Arrays.fill(数组，元素)                        使用同一元素填充数组
void Arrays.sort(数组)                              对数组进行排序，也可按照自己自定义的规则
boolean Arrays.equals(数组a，数组b)                  返回两个数组是否元素相等的结果
```
eg：
```java
import java.util.Arrays;  
import java.util.Comparator;  
import java.util.Random;  
public class MyArray {  
    public static void main(String[] args) {  
        //声明一个引用  
        Integer[] a;  
        //创建一个长度是5的数组，并且使用引用a指向该数组  
        a = new Integer[5];  
        for (int i = 0; i < 5; i++) {  
            a[i]= new Random().nextInt(5);  
        }  
        Arrays.sort(a,new Comparator<Integer>(){  
            @Override  
            public int compare(Integer o1,Integer o2) {  
                // 降序  
                return o2-o1;  
        }});  
        System.out.println(Arrays.toString(a));  
    }  
}
```
> [!NOTE]
> 分配空间，同时赋值
> 写法一： 分配空间同时赋值
> `int[] a = new int[]{100,102,444,836,3236};`
>  
> 写法二： 省略了 new int[], 效果一样
> `int[] b = {100,102,444,836,3236};`

数组排序：
```java
import java.util.Arrays;  
public class MySort {  
    int [] a;  
    MySort(int []array ){  
        this.a = array;  
    }  
    public void ChoseSort(int [] array){  
        for (int i = 0; i < array.length; i++) {  
            for (int j = i+1; j < array.length; j++) {  
                if (array[i]> array[j]) {  
                    int temp = array[i];  
                    array[i] = array[j];  
                    array[j] = temp;  
                }  
            }  
        }  
    }  
    public  void BubbleSort(int [] array){  
        for (int i = 0; i < array.length; i++) {  
            for (int j = 0; j < array.length-1-i; j++) {  
                if (array[j]> array[j+1]) {  
                    int temp = array[j];  
                    array[j] = array[j+1];  
                    array[j+1] = temp;  
                }  
            }  
        }  
    }  
    public static void main(String[] args) {  
        MySort sort = new MySort(new int[]{1, 3, 4, 6, 2, 7, 8, 5, 9, 10});  
        sort.ChoseSort(sort.a);  
        sort.BubbleSort(sort.a);  
        System.out.println(Arrays.toString(sort.a));  
    }  
}
```
增强型 for 循环遍历
```java
for (int each : values) {
    System.out.println (each);
}
```
#### 二维数组
```java
		//初始化二维数组，
       int[][] a = new int[2][3]; //有两个一维数组，每个一维数组的长度是3
       a[1][2] = 5;  //可以直接访问一维数组，因为已经分配了空间
       //只分配了二维数组
       int[][] b = new int[2][]; //有两个一维数组，每个一维数组的长度暂未分配
       b[0]  =new int[3]; //必须事先分配长度，才可以访问
       b[0][2] = 5;
       //指定内容的同时，分配空间
       int[][] c = new int[][]{
               {1,2,4},
               {4,5},
               {6,7,8,9}
       };
```
### 6. 类和对象
#### 引用
引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。
`Hero h = new Hero();`
![](https://stepimagewm.how2j.cn/618.png)
> 引用 h 指向 Hero 对象

![](https://stepimagewm.how2j.cn/617.png)
> 多个引用指向同一个对象

![](https://stepimagewm.how2j.cn/619.png)
> 一个引用只能指向一个对象

### 7. 包 (package)
- 把比较接近的类，规划在同一个包下
- 在最开始的地方声明该类所处于的包名
- 使用同一个包下的其他类，直接使用即可  
- 但是要使用其他包下的类，必须 import

### 8. 访问修饰符
成员变量有四种修饰符：
<span style="background:rgba(240, 200, 0, 0.2)">1. private 私有的  </span>
<span style="background:rgba(240, 200, 0, 0.2)">2. package/friendly/default 不写  </span>
<span style="background:rgba(240, 200, 0, 0.2)">3. protected 受保护的  </span>
<span style="background:rgba(240, 200, 0, 0.2)">4. public 公共的</span>
![](https://stepimagewm.how2j.cn/604.png)
![](https://stepimagewm.how2j.cn/610.png)
![](https://stepimagewm.how2j.cn/611.png)
![](https://stepimagewm.how2j.cn/612.png)
> [!NOTE]
> 那么什么情况该用什么修饰符呢？
> 从作用域来看，public 能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用 public, 那么到底什么情况该用什么修饰符呢？
> 
> 1. 属性通常使用 private 封装起来
> 2. 方法一般使用 public 用于被调用
> 3. 会被子类继承的方法，通常使用 protected
> 4. package 用的不多，一般新手会用 package, 因为还不知道有修饰符这个东西
> 
> 再就是作用范围最小原则
> 简单说，能用 private 就用 private，不行就放大一级，用 package, 再不行就用 protected，最后用 public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了

### 9. 类属性（static 变量）
1. 当一个属性被 **static** 修饰的时候，就叫做**类属性**，又叫做**静态属性**  
2. 当一个属性被声明成类属性，那么**所有的对象，都共享一个值**

访问方式：
1. 对象. 类属性
2. 类. 类属性

对象属性初始化：
1. 声明该属性的时候初始化  
2. 构造方法中初始化  
3. 初始化块

静态属性初始化：
1. 声明该属性的时候初始化  
2. 静态初始化块

> 初始化顺序：<font color="#ff0000">静态属性声明>静态初始化块>对象属性声明>对象属性初始化块>构造方法</font>
### 10. 类方法（static 方法）
- 类方法： 又叫做**静态方法**
- 对象方法： 又叫**实例方法**，非静态方法  
  
> 访问一个对象方法，必须建立在**有一个对象的前提**的基础上  
> 访问类方法，不需要对象的存在，直接就访问
> 静态方法只能调用静态方法和静态属性，不能调用对象属性和方法

### 11. 单例模式
单例模式又叫做 Singleton 模式，指的是一个类，在一个 JVM 里，**只有一个实例存在**。
*单例模式的设计目的是确保一个类只有一个实例，并提供全局访问点以供其他对象使用。因此，在传统的单例模式中，不允许继承该类，因为继承会导致类的实例数量增多。*
#### 饿汉式单例模式
单例模式的类应该只有一个示例，通过**私有化其构造方法**，使得外部无法通过 new 得到新的实例。
这种单例模式又叫做*饿汉式单例模式*，无论如何都会创建一个实例
```java
package charactor;
public class GiantDragon {
    //私有化构造方法使得该类无法在外部通过new 进行实例化
	private GiantDragon(){
	}
	//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个
	private static GiantDragon instance = new GiantDragon();
	//public static 方法，提供给调用者获取12行定义的对象
	public static GiantDragon getInstance(){
		return instance;
	}
}
```
#### 懒汉式单例模式
**懒汉式**单例模式与**饿汉式**单例模式不同，只有在调用 getInstance 的时候，才会创建实例
```java
package charactor;
public class GiantDragon {
    //私有化构造方法使得该类无法在外部通过new 进行实例化
    private GiantDragon(){        
    }
    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null
    private static GiantDragon instance;
    //public static 方法，返回实例对象
    public static GiantDragon getInstance(){
    	//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象
    	if(null==instance){
    		instance = new GiantDragon();
    	}
    	//返回 instance指向的对象
        return instance;
    }
}
```
> [!NOTE]
> **什么时候使用饿汉式，什么时候使用懒汉式？**
> 饿汉式，是**立即加载**的方式，无论是否会用到这个对象，都会加载。
> 如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。
> 
> 懒汉式，是**延迟加载**的方式，只有使用的时候才会加载。并且有线程安全的考量 (鉴于同学们学习的进度，暂时不对线程的章节做展开)。
> 使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。
> 
> 看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式

#### 单例模式的三要素
什么是单例模式？
1. 构造方法私有化  
2. 静态属性指向实例  
3. public static 的 getInstance 方法，返回第二步的静态属性

### 12. 枚举（enum）
枚举 enum 是一种特殊的类 (还是类)，使用枚举可以很方便的定义常量
eg：
```java
public enum Season {
SPRING,SUMMER,AUTUMN,WINTER
}
public class HelloWorld {
	public static void main(String[] args) {
		Season season = Season.SPRING;
		switch (season) {
		case SPRING:
			System.out.println("春天");
			break;
		case SUMMER:
			System.out.println("夏天");
			break;
		case AUTUMN:
			System.out.println("秋天");
			break;
		case WINTER:
			System.out.println("冬天");
			break;
		}
	}
}
```
借助增强型 for 循环，可以很方便的遍历一个枚举都有哪些常量：
```java
public class HelloWorld {
	public static void main(String[] args) {
		for (Season s : Season.values()) {
			System.out.println(s);
		}
	}
}
```
---
### 13. 接口与继承
#### 接口
接口就像是一种约定，对类进行约束规范，便于顶层设计规范化
eg：
```java
package MyCharacter;  
public interface Healer {  
    void heal(int healAmount);  
}
package MyCharacter;  
public class Support extends Hero implements Healer {  
    @Override  
    public void heal(int healAmount) {  
        this.setHp(this.getHp() + healAmount);  
        System.out.println("当前英雄的血量为" + this.getHp() + "点");  
    }  
}
```
#### 对象转型
##### 子类转父类（向上转型）
引用类型和对象类型不一致时，需要进行类型转换，类型转换有时候会成功，有时候会失败。
*转换是否成功判别方法：**把右边的当做左边来用，看是否能说通***
> 子类向父类转型（向上转型）一般都是可以的，父类引用指向子类对象

![](https://stepimagewm.how2j.cn/624.png)
##### 父类转子类 (向下转型)
父类转子类，有的时候行，有的时候不行，所以必须进行**强制转换**。强制转换的意思就是转换有风险，风险自担。
转换总结：
![](https://stepimagewm.how2j.cn/625.png)
> 10 行： 把 ad 当做 Hero 使用，一定可以，转换之后，h 引用指向一个 ad 对象  
> 11 行： h 引用有可能指向一个 ad 对象，也有可能指向一个 support 对象，所以把 h 引用转换成 AD 类型的时候，就有可能成功，有可能失败，因此要进行强制转换，换句话说转换后果自负，到底能不能转换成功，要看引用 h 到底指向的是哪种对象  
> 在这个例子里，**h 指向的是一个 ad 对象**，所以转换成 ADHero 类型，是可以的  
> 12 行：把一个 support 对象当做 Hero 使用，一定可以，转换之后，**h 引用指向一个 support 对象**  
> 13 行：这个时候，h 指向的是一个 **support** 对象，所以转换成 **ADHero** 类型，会失败。失败的表现形式是抛出异常 ClassCastException 类型转换异常
```java
package charactor;
import charactor1.Support;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        Hero h =new Hero();
        ADHero ad = new ADHero();
        Support s =new Support();
        h = ad;
        ad = (ADHero) h;
        h = s;
        ad = (ADHero)h;
    }
}
```
> [!NOTE]
> ![](https://stepimagewm.how2j.cn/626.png)
> **没有继承关系**的两个类，互相转换一定会失败，抛出异常

##### 实现类转换成接口 (向上转型)
类似于子类转父类，一样可行。
![](https://stepimagewm.how2j.cn/627.png)
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        AD adi = ad;
    }
}
```
##### 接口转换成实现类 (向下转型)
![]( https://stepimagewm.how2j.cn/628.png )
> 7 行： ad 引用指向 ADHero，而 adi 引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功  
> 8 行: **adi** 实际上是**指向**一个 **ADHero** 的，所以能够转换成功  
> 9 行： adi 引用所指向的对象是一个 ADHero，要转换为 ADAPHero 就会失败。
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        AD adi = ad;
        ADHero adHero = (ADHero) adi;
        ADAPHero adapHero = (ADAPHero) adi;
        adapHero.magicAttack();
    }
}
```
##### instanceof 
`a instanceof className` 判断一个引用所指向的对象，是否是类的对象，或者子类的对象。
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        APHero ap = new APHero();
        Hero h1= ad;
        Hero h2= ap;
        //判断引用h1指向的对象，是否是ADHero类型
        System.out.println(h1 instanceof ADHero);
        //判断引用h2指向的对象，是否是APHero类型
        System.out.println(h2 instanceof APHero);
        //判断引用h1指向的对象，是否是Hero的子类型
        System.out.println(h1 instanceof Hero);
    }
}
```
#### 重写
子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖 override
> 调用子类的方法首先调用重写的方法，如果没有再调用父类方法。
---
#### 多态
操作符的多态  
+ 可以作为算数运算，也可以作为字符串连接  
类的多态
- 父类引用指向子类对象
---
##### 操作符多态
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
    	int i = 5;
    	int j = 6;
    	int k = i+j; //如果+号两侧都是整型，那么+代表 数字相加
    	System.out.println(k);
    	int a = 5;
    	String b = "5";
    	String c = a+b; //如果+号两侧，任意一个是字符串，那么+代表字符串连接
    	System.out.println(c);
    }
}
```
##### 类多态
父类引用指向子类，调用父类引用被重写的方法，优先执行指向的子类的重写方法，即同类型调用同一方法，呈现不同的状态。
```java
package property;
public class Item {
	String name;
	int price;
	public void buy(){
		System.out.println("购买");
	}
	public void effect() {
		System.out.println("物品使用后，可以有效果 ");
	}
	public static void main(String[] args) {
		Item i1= new LifePotion();
		Item i2 = new MagicPotion();
		System.out.print("i1是Item类型，执行effect打印:");
		i1.effect();
		System.out.print("i2也是Item类型，执行effect打印:");
		i2.effect();
	}
}
```
> [!NOTE] **类的多态条件**
> 1. 父类（接口）引用指向子类对象  
> 2. 调用重写的方法

##### 使用类多态 VS 不使用类多态
不使用：
```java
package charactor;
import property.LifePotion;
import property.MagicPotion;
public class Hero {
    public String name; 
    protected float hp;
    public void useLifePotion(LifePotion lp){
    	lp.effect();
    }
    public void useMagicPotion(MagicPotion mp){
    	mp.effect();
    }
    public static void main(String[] args) {
    	Hero garen =  new Hero();
        garen.name = "盖伦";
    	LifePotion lp =new LifePotion();
    	MagicPotion mp =new MagicPotion();
    	garen.useLifePotion(lp);
    	garen.useMagicPotion(mp);
    }
}
```
使用：
```java
package charactor;
import property.Item;
import property.LifePotion;
import property.MagicPotion;
public class Hero {
    public String name; 
    protected float hp;
    public void useItem(Item i){
    	i.effect();
    }
    public static void main(String[] args) {
    	Hero garen =  new Hero();
        garen.name = "盖伦";
    	LifePotion lp =new LifePotion();
    	MagicPotion mp =new MagicPotion();
    	garen.useItem(lp);
    	garen.useItem(mp);    	
    }
}
```
> 由此可知，使用类多态可以简化设计，减少冗余的相同逻辑方法的设计实现，提高开发效率。

##### 练习
- immortal 是不朽的，不死的意思
- mortal 就是终有一死的，凡人的意思
 
> 1. 设计一个接口
> 接口叫做 Mortal, 其中有一个方法叫做 die
> 2. 实现接口
> 分别让 ADHero, APHero, ADAPHero 这三个类，实现 Mortal 接口，不同的类实现 die 方法的时候，都打印出不一样的字符串
> 3. 为 Hero 类，添加一个方法, 在这个方法中调用 m 的 die 方法。
> public void kill (Mortal m)
> 4. 在主方法中
> 首先实例化出一个 Hero 对象: 盖伦
> 然后实例化出 3 个对象，分别是 ADHero, APHero, ADAPHero 的实例
> 然后让盖伦 kill 这 3 个对象

```java
//Hero
package MyCharacter;  
public class Hero {  
    private String name;  
    private float hp;  
    private int armor;  
    public static void main(String[] args) {  
        Hero garLen = new Hero();  
        garLen.setName("Garlen");  
        ADHero adHero = new ADHero();  
        adHero.setName("ADHero");  
        APHero apHero = new APHero();  
        apHero.setName("APHero");  
        ADAPHero adapHero = new ADAPHero();  
        adapHero.setName("ADAPHero");  
        garLen.kill(adHero, apHero, adapHero);  
    }  
    public void kill(Mortal... ms) {  
        for (Mortal m : ms) {  
            m.die();  
        }  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public float getHp() {  
        return hp;  
    }  
    public void setHp(float hp) {  
        this.hp = hp;  
    }  
    public int getArmor() {  
        return armor;  
    }  
    public void setArmor(int armor) {  
        this.armor = armor;  
    }  
}
//Mortal
package MyCharacter;  
public interface Mortal {  
    void die();  
}
//ADHero
package MyCharacter;  
public class ADHero extends Hero implements AD, Mortal {  
    @Override  
    public void physicAttack() {  
        System.out.println("ADHero 物理攻击");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
//APHero
package MyCharacter;  
public class APHero extends Hero implements AP, Mortal {  
    @Override  
    public void magicAttack() {  
        System.out.println("AP Hero magic attack!");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
//ADAPHero
package MyCharacter;  
public class ADAPHero extends Hero implements AD, AP, Mortal {  
    @Override  
    public void physicAttack() {  
        System.out.println("进行物理攻击");  
    }  
    @Override  
    public void magicAttack() {  
        System.out.println("进行魔法攻击");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
```
---
#### 隐藏
与**重写**类似，方法的重写是**子类覆盖父类**的**对象方法**，**隐藏**，就是**子类覆盖父类**的**类方法**
```java
//父类
package MyCharacter;  
public class Hero {  
    private String name;  
    private float hp;  
    private int armor;  
    public static void battle() {  
        System.out.println("Hero battleWin");  
    } 
}
//子类隐藏父类的类方法
package MyCharacter;  
public class ADHero extends Hero implements AD, Mortal {  
    //隐藏父类的battleWin方法  
    public static void battle() {  
        System.out.println("ad hero battle win");  
    }  
    public static void main(String[] args) {  
        Hero.battle();  
        ADHero.battle();  
    }  
    @Override  
    public void physicAttack() {  
        System.out.println("ADHero 物理攻击");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
```
> [!NOTE] 父类引用指向子类调用隐藏方法（**类方法不存在多态**）？
> 在 Java 中，对于类方法（静态方法），编译时会根据引用类型（即变量类型）来决定调用的方法。实际上，类方法并不具有多态性，也不会被子类的重写所影响。由于 h 是父类类型的引用，即使它指向一个子类对象（ADHero），编译器仍然会**根据引用类型**（Hero）来**决定调用的方法**。

#### super
实例化子类对象时，其父类的构造方法也会被调用，并且是**父类构造方法先调用**，子类构造方法会**默认调用父类的无参的构造方法**
（1）使用关键字 super **显式调用父类带参的构造方法**
```java
public ADHero(String name){
        super(name);
        System.out.println("AD Hero的构造方法");
    }
```
（2）通过 super 调用父类属性
```java
public int getMoveSpeed2(){
return super.moveSpeed;
}
```
（3）通过 super 调用父类方法
```java
// 重写useItem，并在其中调用父类的userItem方法
	public void useItem(Item i) {
		System.out.println("adhero use item");
		super.useItem(i);
	}
```
---
#### Object 超类
Object 类是所有类的父类，即基类，声明一个类的时候，默认是继承了 Object
1. Object 类提供一个 **toString 方法**，所以所有的类都有 toString 方法  
toString ()的意思是返回当前对象的**字符串表达**
2. 当一个对象**没有任何引用指向它**的时候，它就满足垃圾回收的条件，当它被垃圾回收的时候，它的 **finalize ()** 方法就会被调用。finalize () 不是开发人员主动调用的方法，而是由虚拟机 JVM 调用的。
3. **equals ()** 用于判断两个对象的内容是否相同，假设，当两个英雄的 hp 相同的时候，我们就认为这两个英雄相同
4. `==` 这不是 Object 的方法，但是用于判断两个对象是否相同，更准确的讲，用于判断两个引用，是否指向了同一个对象
5. **hashCode 方法**返回一个对象的**哈希值**，但是在了解哈希值的意义之前，讲解这个方法没有意义。
6. Object 还提供**线程同步**相关方法：**wait ()，notify ()，notifyAll ()**
7. getClass ()会返回一个对象的类对象，属于**反射**原理。
---
#### 抽象类
在类中声明一个方法，这个方法**没有方法体**，是一个“空”方法，这样的方法就叫**抽象方法**，使用修饰符“**abstract**"，当一个类有抽象方法的时候，该类必须被声明为**抽象类**，不能被实例化。
抽象类可以没有抽象方法，也可以有具体方法
> [!NOTE] 抽象类和接口的区别
> 1. 区别 1：  
> - 子类**只能继承一个抽象类**，不能继承多个  
> - 子类**可以实现多个接口**
> 2. 区别 2：  
> - 抽象类可以定义 public, protected, package, private 静态和非静态属性，final 和非 final 属性  
> - 但是接口中声明的属性，只能是 public 静态 final 的，即便没有显式的声明  
> 注: **抽象类和接口都可以有实体方法**。 **接口**中的实体方法，叫做**默认方法**

#### 内部类
分类：
- 非静态内部类  
- 静态内部类  
- 匿名类  
- 本地类

##### 非静态内部类
非静态内部类可以直接在一个类里面定义，当外部类对象存在时内部类才有意义。
语法: `new 外部类().new 内部类()`
```java
package charactor;
public class Hero {
	private String name; // 姓名
	float hp; // 血量
	float armor; // 护甲
	int moveSpeed; // 移动速度
	// 非静态内部类，只有一个外部类对象存在的时候，才有意义
	// 战斗成绩只有在一个英雄对象存在的时候才有意义
	class BattleScore {
		int kill;
		int die;
		int assit;
		public void legendary() {
			if (kill >= 8)
				System.out.println(name + "超神！");
			else
				System.out.println(name + "尚未超神！");
		}
	}
	public static void main(String[] args) {
		Hero garen = new Hero();
		garen.name = "盖伦";
		// 实例化内部类
		// BattleScore对象只有在一个英雄对象存在的时候才有意义
		// 所以其实例化必须建立在一个外部类对象的基础之上
		BattleScore score = garen.new BattleScore();
		score.kill = 9;
		score.legendary();
	}
}
```
##### 静态内部类
与**非静态内部类**不同，静态内部类水晶类的实例化**不需要一个外部类的实例为基础**，可以**直接实例化**  
语法：`new 外部类.静态内部类()`;  
因为没有一个外部类的实例，所以在**静态内部类里面不可以访问外部类的实例属性和方法**，除了可以访问外部类的**私有静态成员**外，静态内部类和普通类没什么大的区别
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp; 
    private static void battleWin(){
        System.out.println("battle win");
    }
    //敌方的水晶
    static class EnemyCrystal{
    	int hp=5000;
    	//如果水晶的血量为0，则宣布胜利
    	public void checkIfVictory(){
    		if(hp==0){
    			Hero.battleWin();
    			//静态内部类不能直接访问外部类的对象属性
    			System.out.println(name + " win this game");
    		}
    	}
    }
    public static void main(String[] args) {
    	//实例化静态内部类
    	Hero.EnemyCrystal crystal = new Hero.EnemyCrystal();
    	crystal.checkIfVictory();
	}
}
```
##### 匿名类
匿名类指的是在**声明一个类的同时实例化它**，使代码更加简洁精练  
通常情况下，要使用一个接口或者抽象类，都必须创建一个子类  
有的时候，为了快速使用，**直接实例化一个抽象类，并“当场”实现其抽象方法**。  
既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做**匿名类**
```java
package charactor;
public abstract class Hero {
    String name; //姓名
    float hp; //血量
    float armor; //护甲
    int moveSpeed; //移动速度
    public abstract void attack();
    public static void main(String[] args) {
        ADHero adh=new ADHero();
        //通过打印adh，可以看到adh这个对象属于ADHero类
        adh.attack();
        System.out.println(adh);
        Hero h = new Hero(){
            //当场实现attack方法
            public void attack() {
                System.out.println("新的进攻手段");
            }
        };
        h.attack();
        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名
        System.out.println(h);
    }
}
```
> **在匿名类中使用外部的局部变量，外部的局部变量必须修饰为 final，否则报错（jdk 8 中不需要强制用 final 修饰，因为编译器会自动加上）**
```java
package charactor;
public abstract class Hero {
    public abstract void attack();
    public static void main(String[] args) {
    	//在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final
    	final int damage = 5;
        Hero h = new Hero(){
            public void attack() {
                System.out.printf("新的进攻手段，造成%d点伤害",damage );
            }
        };
    }
}
```
##### 本地类
本地类可以理解为有名字的匿名类  
**内部类与匿名类**不一样的是，**内部类必须声明在成员的位置**，即与属性和方法平等的位置。本地类和匿名类一样，**直接声明在代码块里面**，可以是主方法，for 循环里等等地方
```java
package charactor;
public abstract class Hero {
    String name; //姓名
    float hp; //血量
    float armor; //护甲
    int moveSpeed; //移动速度
    public abstract void attack();
    public static void main(String[] args) {
        //与匿名类的区别在于，本地类有了自定义的类名
        class SomeHero extends Hero{
        	public void attack() {
                System.out.println( name+ " 新的进攻手段");
            }
        }
        SomeHero h  =new SomeHero();
        h.name ="地卜师";
        h.attack();
    }
}
```
#### 默认方法
jdk 8 新特性，指接口也可以提供具体方法，不单单只能提供抽象方法
Mortal 这个接口，增加了一个默认方法 revive，这个方法有实现体，并且必须被声明为 **default**，实现接口功能扩展。
```java
package MyCharacter;  
public interface Mortal {  
    void die();  
    default void revive() {  
        System.out.println("我又回来啦");  
    }  
}
```
#### UML
UML-Unified Module Language 统一建模语言，可以很方便的用于描述类的属性，方法，以及类和类之间的关系。
![](https://stepimagewm.how2j.cn/2305.png)
![](https://stepimagewm.how2j.cn/2318.png)
![](https://stepimagewm.how2j.cn/2319.png)
> 带箭头的实线，表示 Spider，Cat, Fish 都继承于 Animal 这个父类.
![](https://stepimagewm.how2j.cn/2320.png)
> 表示 Fish 实现了 Pet 这个接口
![](https://stepimagewm.how2j.cn/2321.png) 

---
### 数字与字符串
#### 封装类
数字封装类有  
**Byte, Short, Integer, Long, Float, Double**  
这些类都是抽象类**Number**的子类
```java
//基本类型转换成封装类型
        Integer it = new Integer(i);
        //封装类型转换成基本类型
        int i2 = it.intValue();
```
1. 自动装箱：
   - 不需要调用构造方法，通过 `=` 符号自动把基本类型转换为类类型就叫装箱
   - `int i = 5;//自动转换就叫装箱Integer it2 = i;`
2. 自动拆箱
   - 不需要调用 Integer 的 intValue 方法，通过=就自动转换成 int 类型，就叫拆箱
   - `  int i = 5;Integer it = new Integer (i);//封装类型转换成基本类型int i2 = it.intValue ();//自动转换就叫拆箱 int i3 = it; `

- int 的最大值可以通过其对应的封装类 **Integer. MAX_VALUE** 获取
- int 的最小值可以通过其对应的封装类 **Integer. MIN_VALUE** 获取

#### 字符串转换
##### 数字转字符串
1. 方法 1： 使用 String 类的静态方法 **valueOf**  
2. 方法 2： 先把基本类型装箱为对象，然后调用对象的**toString**
```java
package NumberString;  
public class NumToStr {  
    public static void main(String[] args) {  
        int i = 10;  
//        方法1  
        String s1 = String.valueOf(i);  
//        方法2  
        Integer i1 = i;  
        String s2 = i1.toString();  
    }  
}
```
##### 字符串转数字
调用 Integer 的**静态方法 parseInt**
`int i3 = Integer.parseInt(s1);`
#### 数学 Math 包
java. lang. Math 提供了一些常用的数学运算方法，并且都是以静态方法的形式存在
**四舍五入, 随机数，开方，次方，π，自然常数：**
```java
public class MathUse {  
    public static void main(String[] args) {  
        float f1 = 3.4f;  
        float f2 = 3.5f;  
        System.out.printf("%d, %d", Math.round(f1), Math.round(f2));  
        //得到一个0-1之间的随机浮点数（取不到1）  
        System.out.println(Math.random());  
        //得到一个0-10之间的随机整数 （取不到10）  
        System.out.println((int) (Math.random() * 10));  
        //开方  
        System.out.println(Math.sqrt(9));  
        //次方（2的4次方）  
        System.out.println(Math.pow(2, 4));  
        //π  
        System.out.println(Math.PI);  
        //自然常数  
        System.out.println(Math.E);  
    }  
}
```
#### 格式化输出
如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐  
使用格式化输出，就可以简洁明了  
- %s 表示字符串  
- %d 表示数字  
- %n 表示换行

printf 和 format 格式化输出效果一样，printf 中调用了 format
```java
//使用格式化输出  
//%s表示字符串，%d表示数字,%n表示换行  
String name = "亚瑟";  
String sentenceFormat = "%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n";  
int kill = 1;  
String title = "超神";  
System.out.printf(sentenceFormat, name, kill, title);
System.out.format(sentenceFormat, name, kill, title);
```
- **换行符**就是**另起一行** --- '\\n' 换行（newline）  
- **回车符**就是**回到一行的开头** --- '\\r' 回车（return）

#### immutable
immutable 是指不可改变的, 比如创建了一个字符串对象, String garen ="盖伦";
**不可改变**的具体含义是指：
- 不能增加长度
- 不能减少长度
- 不能插入字符
- 不能删除字符
- 不能修改字符
一旦创建好这个字符串，里面的内容永远不能改变, String 的表现就像是一个**常量**
#### 字符串常用方法
|                 方法名                 |        简介        |     |
|:--------------------------------------:|:------------------:| --- |
|                 charAt                 |      获取字符      |     |
|              toCharArray               | 获取对应的字符数组 |     |
|               subString                |    截取子字符串    |     |
|                 split                  |        分隔        |     |
|                  trim                  |    去掉首尾空格    |     |
|      toLowerCase  <br>toUpperCase      |       大小写       |     |
| indexOf  <br>lastIndexOf  <br>contains |        定位        |     |
|      replaceAll  <br>replaceFirst      |        替换        |     |
#### 比较字符串
1. 是否是同一个对象
`==` 用于用于判断两个字符串对象是否相同（不是内容是否相同）
```java
String str1 = "the light";
        String str2 = new String(str1);
        //==用于判断是否是同一个字符串对象
        System.out.println( str1  ==  str2);
```
特例：str 3 与 str 1 内容完全一样，复用之前的对象并未创建新 String 对象
```java
		String str1 = "the light";
        String str3 = "the light";
        System.out.println( str1  ==  str3);
```
2. 是否内容相同
使用 **equals** 进行字符串内容的比较，必须大小写一致  
**equalsIgnoreCase**，忽略大小写判断内容是否一致
```java
		System.out.println(str1.equals(str3));//大小写不一样，返回false
        System.out.println(str1.equalsIgnoreCase(str3));//忽略大小写的比较，返回true
```
3. 是否以子字符串开始或者结束
**startsWith** //以... 开始，**endsWith** //以... 结束
#### StringBuffer
StringBuffer 是**可变长**的字符串
| 关键字                       | 描述                |     |
| ---------------------------- | ------------------- | --- |
| append delete insert reverse | 追加删除插入反转 |     |
| length capacity              | 长度容量            |     |
```java
package NumberString;  
public class MyStringBuffer {  
    public static void main(String[] args) {  
        String str1 = "let there ";  
        StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象  
        sb.append("be light"); //在最后追加  
        System.out.println(sb);  
        sb.delete(4, 10);//删除4-10之间的字符  
        System.out.println(sb);  
        sb.insert(4, "there ");//在4这个位置插入 there  
        System.out.println(sb);  
        sb.reverse(); //反转  
        System.out.println(sb);  
    }  
}
```
> StringBuffer 性能明显优于**字符串拼接**

### 日期
时间原点概念：
> 所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。
> 日期类型也不例外，换句话说，一个日期，比如 2020 年 10 月 1 日，在计算机里，会用一个数字来代替。
> 那么最特殊的一个数字，就是零. 零这个数字，就代表 Java 中的时间原点，其对应的日期是 1970 年 1 月 1 日 8 点 0 分 0 秒。 (为什么是 8 点，因为中国的太平洋时区是 UTC-8，刚好和格林威治时间差 8 个小时)
> 为什么对应 1970 年呢？ 因为 1969 年发布了第一个 UNIX 版本：AT&T，综合考虑，当时就把 1970 年当做了时间原点。
> 所有的日期，都是以为这个 0 点为基准，每过一毫秒，就+1。

#### Date
##### 创建日期对象
`import java.util.Date`
```java
import java.util.Date;  
public class MyDate {  
    public static void main(String[] args) {  
        Date date = new Date();  
//        输出当前系统时间  
        System.out.println(date);  
        Date date1 = new Date(10000L);  
//        输出距离1970-1-1 08:00:00过了10000毫秒的时间  
        System.out.println(date1);  
    }  
}
```
- getTime () 获得一个长整型距离 1970-1-1 08:00:00所经过的毫秒数
- System. currentTimeMillis ()效果与 getTime（）相同，可能有几十毫秒误差。

```java
//当前日期的毫秒数
        System.out.println("Date.getTime() \t\t\t返回值: "+now.getTime());
        //通过System.currentTimeMillis()获取当前日期的毫秒数
        System.out.println("System.currentTimeMillis() \t返回值: "+System.currentTimeMillis());
```
##### 日期格式化
> y 代表年
> M 代表月
> d 代表日
> H 代表 24 进制的小时
> h 代表 12 进制的小时
> m 代表分钟
> s 代表秒
> S 代表毫秒
###### 日期转字符串
`SimpleDateFormat` 类对象通过 `format` 方法对日期进行格式化为字符串
```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");  
Date d = new Date();  
String str = sdf.format(d);  
System.out.println("当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: " + str);  
SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");  
Date d1 = new Date();  
String str1 = sdf1.format(d1);  
System.out.println("当前时间通过 yyyy-MM-dd 格式化后的输出: " + str1);
```
###### 字符串转日期
`SimpleDateFormat` 格式（yyyy/MM/dd HH:mm:ss）需要和**字符串格式保持一致**，如果不一样就会抛出解析异常 ParseException，通过调用 SimpleDateFormat 对象的 `parse` 方法将字符串转为日期。
```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
String str = "2016-1-5 12:12:12";  
try {  
    Date d = sdf.parse(str);  
    System.out.printf("字符串 %s 通过格式  yyyy/MM/dd HH:mm:ss %n转换为日期对象: %s", str, d.toString());  
} catch (ParseException e) {  
    // TODO Auto-generated catch block  
    e.printStackTrace();  
}
```
#### Calendar 
Calendar 类即**日历类**，常用于进行“翻日历”，比如下个月的今天是多久
采用[单例模式](https://how2j.cn/k/class-object/class-object-singleton/349.html)获取日历对象 `Calendar.getInstance()`;
日历对象的 `getTime` 方法获取当前日期，`setTime` 方法设置日历日期。
```java
//采用单例模式获取日历对象Calendar.getInstance();  
Calendar c = Calendar.getInstance();  
//通过日历对象得到日期对象  
Date d = c.getTime();  
System.out.println(d);  
Date d2 = new Date(0);  
c.setTime(d2); //把这个日历，调成日期 : 1970.1.1 08:00:00  
System.out.println(c.getTime());
```
##### 翻日历
1. `add` 方法，在原日期上增加年/月/日  
2. `set` 方法，直接设置年/月/日
```java
import java.text.SimpleDateFormat;  
import java.util.Calendar;  
import java.util.Date;  
public class TestCalendar {  
    private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
    public static void main(String[] args) {  
        Calendar c = Calendar.getInstance();  
        Date now = c.getTime();  
        // 当前日期  
        System.out.println("当前日期：\t" + format(c.getTime()));  
        // 下个月的今天  
        c.setTime(now);  
        c.add(Calendar.MONTH, 1);  
        System.out.println("下个月的今天:\t" + format(c.getTime()));  
        // 去年的今天  
        c.setTime(now);  
        c.add(Calendar.YEAR, -1);  
        System.out.println("去年的今天:\t" + format(c.getTime()));  
        // 上个月的第三天  
        c.setTime(now);  
        c.add(Calendar.MONTH, -1);  
        c.set(Calendar.DATE, 3);  
        System.out.println("上个月的第三天:\t" + format(c.getTime()));  
    }  
    private static String format(Date time) {  
        return sdf.format(time);  
    }  
}
```
> [!NOTE]
> 对日期需要**修改**的时候**用 Calendar**，直接获取当前日期用 Date

## Java 中级
### 异常处理
#### 异常分类
![](https://stepimagewm.how2j.cn/2412.png)
可查异常，运行时异常和错误 3 种，其中，运行时异常和错误又叫非可查异常
##### 可查异常： CheckedException  
可查异常即必须进行处理的异常，**要么 try catch 住, 要么往外抛，谁调用，谁处理**，比如 FileNotFoundException ，如果不处理，编译器，就不让你通过
##### 运行时异常：RuntimeException
**不是必须进行 try catch 的异常**  ，但是运行会报错。
常见运行时异常:  
	- 除数不能为 0 异常: ArithmeticException  
	- 下标越界异常: ArrayIndexOutOfBoundsException  
	- 空指针异常:NullPointerException
##### 错误：Error
错误 Error，指的是系统级别的异常，通常是内存用光了，在默认设置下，一般 java 程序启动的时候，最大可以使用 16 m 的内存，如例不停的给 StringBuffer 追加字符，很快就把内存使用光了。抛出 OutOfMemoryError  
与运行时异常一样，错误也是不要求强制捕捉的，并且无法人为处理。
#### try catch finally 捕捉处理异常
1. 将可能抛出 FileNotFoundException 文件不存在异常的代码放在 try 里  
2. 如果文件存在，就会顺序往下执行，并且不执行 catch 块中的代码
3. 如果文件不存在，try 里的代码会立即终止，程序流程会运行到对应的 catch 块中  
4. e. `printStackTrace` (); 会打印出方法的调用痕迹，如此例，会打印出异常开始于 TestException 的第 16 行，这样就便于定位和分析到底哪里出了异常
5. 无论是否出现异常，**finally 中的代码都会被执行**

#### 多异常捕捉办法
1. 分别进行 catch
2. 把多个异常，放在一个 catch 里统一捕捉 `catch (FileNotFoundException | ParseException e) {}`

#### throw 和 throws 的区别
throws 与 throw 这两个关键字接近，不过意义不一样，有如下区别：  
1. **throws** 出现在**方法声明上**，而 **throw** 通常都出现在**方法体内**。  
2. throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某个异常对象。

#### Throwable
Throwable 是类，Exception 和 Error 都继承了该类, 所以在捕捉的时候，也可以使用 Throwable 进行捕捉  
如图： 异常分 Error 和 Exception  
Exception 里又分运行时异常和可查异常。
![](https://stepimagewm.how2j.cn/742.png)
```java
package exception;  
import java.io.File;  
import java.io.FileInputStream;  
public class TestThrowable {  
    public static void main(String[] args) {  
        File f = new File("d:/LOL.exe");  
        try {  
            new FileInputStream(f);  
            //使用Throwable进行异常捕捉  
        } catch (Throwable t) {  
            // TODO Auto-generated catch block  
            t.printStackTrace();  
        }  
    }  
}
```
#### 自定义异常
Java 中的异常是通过**继承 Throwable 类**来实现的。因此，要**自定义异常类**，只需创建一个**继承 Exception 或 RuntimeException 的类**即可
```java
package MyCharacter;  
import exception.EnemyHeroIsDeadException;  
public class Hero implements Mortal {  
    private String name;  
    private float hp;  
    private int armor;  
    public Hero(String name, float hp, int armor) {  
        System.out.println(this.getName() + " is born");  
    }  
    public Hero() {  
        System.out.println("Hero 构造");  
    }  
    public static void main(String[] args) {  
        Hero garLen = new Hero();  
        Hero yase = new Hero();  
        garLen.setName("Garlen");  
        yase.setName("Yase");  
        yase.setHp(0);  
        Item item = new Item() {  
            public void disposable() {  
                System.out.println(garLen.getName() + "的物品毁坏");  
            }  
        };  
        item.disposable();  
        try {  
            garLen.attack(yase);  
        } catch (EnemyHeroIsDeadException e) {  
            System.out.println(e.getMessage());  
        } 
    } 
    public void attack(Hero hero) throws EnemyHeroIsDeadException {  
        if (hero.hp == 0) {  
            EnemyHeroIsDeadException exception = new EnemyHeroIsDeadException(hero.getName() + "挂了");  
            throw exception;  
        }  
    } 
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public float getHp() {  
        return hp;  
    }  
    public void setHp(float hp) {  
        this.hp = hp;  
    }  
    public int getArmor() {  
        return armor;  
    }  
    public void setArmor(int armor) {  
        this.armor = armor;  
    }
}
```
### I/O
#### File
常用方法：
```java
File f = new File("d:/LOLFolder/skin/garen.ski");
        // 以字符串数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）
        f.list();
        // 以文件数组的形式，返回当前文件夹下的所有文件（不包含子文件及子文件夹）
        File[]fs= f.listFiles();
        // 以字符串形式返回获取所在文件夹
        f.getParent();
        // 以文件形式返回获取所在文件夹
        f.getParentFile();
        // 创建文件夹，如果父文件夹skin不存在，创建就无效
        f.mkdir();
        // 创建文件夹，如果父文件夹skin不存在，就会创建父文件夹
        f.mkdirs();
        // 创建一个空文件,如果父文件夹skin不存在，就会抛出异常
        f.createNewFile();
        // 所以创建一个空文件之前，通常都会创建父目录
        f.getParentFile().mkdirs();
        // 列出所有的盘符c: d: e: 等等
        f.listRoots();
        // 刪除文件
        f.delete();
        // JVM结束的时候，刪除文件，常用于临时文件的删除
        f.deleteOnExit();
```
eg：获取文件夹中最大和最小文件
```java
File file = new File("C:\\WINDOWS");  
File[] files = file.listFiles();  
File minFile = null;  
File maxFile = null;  
for (File f : files) {  
    if (f.length() != 0) {  
        if (minFile == null || f.length() < minFile.length())  
            minFile = f;  
        if (maxFile == null || f.length() > maxFile.length())  
            maxFile = f;  
    }  
}  
System.out.println("minFile: " + minFile.getName() + " " + minFile.length() + " bytes");  
System.out.println("maxFile: " + maxFile.getName() + " " + maxFile.length() / 1e6 + "Mbytes");
```
#### Stream（流）
当不同的介质之间有数据交互的时候，JAVA 就使用流来实现。  
数据源可以是文件，还可以是数据库，网络甚至是其他的程序
![](https://stepimagewm.how2j.cn/5678.png)
```java
File f = new File("D:\\Java\\JavaSE\\src\\MyIO\\test.txt");  
try {  
    FileInputStream fileInputStream = new FileInputStream(f);  
} catch (FileNotFoundException e) {  
    throw new RuntimeException(e);  
}
```
#### 字节流
InputStream 字节输入流，OutputStream 字节输出流，用于以字节的形式读取和写入数据
ASCII 码：
> **所有的数据**存放在计算机中都是以**数字的形式存放**的。所以**字母就需要转换为数字**才能够存放。  
> 比如 A 就对应的数字 65，a 对应的数字 97. 不同的字母和符号对应不同的数字，就是一张码表。  
> ASCII 是这样的一种码表。只包含简单的**英文字母，符号，数字**等等。不包含中文，德文，俄语等复杂的。

**InputStream 是字节输入流，同时也是抽象类**，只提供方法声明，不提供方法的具体实现。 **FileInputStream** 是 InputStream**子类**，**read** 方法进行读文件数据到（字节数组）内存为 **ASCII 码**，以 FileInputStream 为例进行文件读取
**OutputStream 是字节输出流**，同时也是抽象类，只提供方法声明，不提供方法的具体实现。**FileOutputStream** 是 OutputStream**子类**,**write**方法将字节数组数据写入到文件中, 如果**写入数字即转为对应 ASCII 码字符**，如**写入字符则无变化**，以 FileOutputStream 为例向文件写出数据
```java
package MyIO;  
import java.io.*;  
public class TestStream {  
    public static void main(String[] args) {  
        File f = new File("D:\\testFios.txt");  
        try {  
            FileOutputStream fos = new FileOutputStream(f);  
            FileInputStream fis = new FileInputStream(f);  
            byte[] out = new byte[]{64, 65, 66};  
            byte[] in = new byte[3];  
            try {  
                fos.write(out);  
                fis.read(in);  
                fis.close();  
                fos.close();  
                System.out.println(new String(in));  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        } catch (FileNotFoundException e) {  
            throw new RuntimeException(e);  
        }  
    }  
}
```
关闭流：
把**流定义在 try ()里**, try, catch 或者 finally 结束的时候，会**自动关闭**  
这种编写代码的方式叫做 **try-with-resources**，这是从 JDK 7 开始支持的技术  
所有的流，都实现了一个接口叫做 **AutoCloseable**，任何类实现了这个接口，都可以在 try ()中进行实例化。并且在 try, catch, finally 结束的时候自动关闭，回收相关资源。
```java
File f = new File("d:/lol.txt");
        //把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
        try (FileInputStream fis = new FileInputStream(f)) {
            byte[] all = new byte[(int) f.length()];
            fis.read(all);
            for (byte b : all) {
                System.out.println(b);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
```
#### 字符流
**Reader** 字符输入流，**Writer** 字符输出流，专门用于字符的形式读取和写入数据
- FileReader 是 Reader 子类，以 FileReader 为例进行文件读取
- FIleWriter 是 Writer 子类，以 FileWriter 为例进行文件写入

```java
package MyIO;  
import java.io.*;  
public class TestReaderAndWriter {  
    public static void main(String[] args) {  
        File f = new File("D:/testrw.txt");  
        try (FileWriter fw = new FileWriter(f)) {  
            char[] rw = new char[]{'中', '国'};  
            fw.write(rw);  
            System.out.println(new String(rw));  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
        try (FileReader fr = new FileReader(f)) {  
            char[] rc = new char[(int) f.length()];  
            fr.read(rc);  
            System.out.println(new String(rc));  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
}
```
#### 编码
<span style="background:rgba(240, 200, 0, 0.2)">Java 采用的是 Unicode</span>
工作后经常接触的编码方式有如下几种：  
> ISO-8859-1 ASCII 数字和西欧字母  
> GBK GB 2312 BIG 5 中文  
> UNICODE (统一码，万国码)  
> 其中  
> ISO-8859-1 包含 ASCII  
> GB 2312 是简体中文，BIG 5 是繁体中文，GBK 同时包含简体和繁体以及日文。  
> UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含

![](https://stepimagewm.how2j.cn/2482.png)
UNICODE 对所有字符采用 **2 个字节**浪费空间，于是出现各种减肥子编码, 比如 UTF-8 对**数字和字母**就使用**一个字节**，而对**汉字**就使用**3 个字节**，从而达到了减肥还能保证健康的效果，UTF-8，UTF-16 和 UTF-32 针对不同类型的数据有不同的减肥效果，一般说来 UTF-8 是比较常用的方式
UTF-8 编码的字节转中文：
```java
byte[] bs = new byte[]{(byte) 0xE5, (byte) 0xB1, (byte) 0x8C};  
String s = new String(bs, StandardCharsets.UTF_8);  
System.out.println(s);
```
#### 缓存流
避免字节流、字符流每次读写都频繁访问磁盘，严重增加磁盘压力，为了减少 IO 操作，采用缓存流对待读写的内容放到**缓存中**进行临时存储，结束读写时一次性读写磁盘。
> **缓存流必须建立在一个存在的流（FileReader，FileWriter 等）的基础上**
##### 缓存流读取数据
缓存字符输入流 `BufferedReader` 可以**一次读取一行数据**
##### 缓存流写出数据
`PrintWriter` 缓存字符输出流，可以**一次写出一行数据**
> [!NOTE] BufferWriter 和 PrintWriter 对比
> `BufferedWriter`: 将文本写入字符输出流，缓冲各个字符从而提供单个字符，数组和字符串的高效写入。通过 write ()方法可以将获取到的字符输出，然后通过 newLine ()进行换行操作。BufferedWriter 中的字符流必须通过**调用 flush 方法才能将其刷出去**。并且 BufferedWriter **只能对字符流进行操作**。如果要对字节流操作，则使用 BufferedInputStream。
> `PrintWriter`: 向文本输出流打印对象的格式化表示形式 (Prints formatted representations of objects to a text-output stream)。PrintWriter 相对于 BufferedWriter 的好处在于，如果 PrintWriter 开启了**自动刷新**，那么当 PrintWriter 调用 println，prinlf 或 format 方法时，输出流中的数据就会自动刷新出去。PrintWriter 不但能接收字符流，**也能接收字节流**。

```java
File f = new File("D:/testbr.txt");  
//        逐行写入字符到磁盘  
        try (FileWriter fw = new FileWriter(f)) {  
            PrintWriter pw = new PrintWriter(fw);  
            pw.println("Hello,World!");  
            pw.println("Writer StringLine!");  
//            提前刷新缓存将数据写入磁盘  
            pw.flush();  
            pw.println("Success!");  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
//        逐行读文件到内存  
        try (FileReader fr = new FileReader(f)) {  
            BufferedReader br = new BufferedReader(fr);  
            while (true) {  
                String line = br.readLine();  
                if (line == null)  
                    break;  
                System.out.println(line);  
            }  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }
```
#### 数据流
- `DataInputStream` 数据输入流  
- `DataOutputStream` 数据输出流

> [!NOTE] 注
> 要用 DataInputStream 读取一个文件，这个文件必须是由 DataOutputStream 写出的，否则会出现 EOFException，因为 DataOutputStream 在写出的时候会做一些特殊标记，只有 DataInputStream 才能成功的读取。

```java
package MyIO;  
import java.io.*;  
public class DataStream {  
    static File f = new File("D:/testds.txt");  
    public static void read() {  
        try (FileInputStream fs = new FileInputStream(f)) {  
            DataInputStream ds = new DataInputStream(fs);  
            String utfs = ds.readUTF();  
            int i = ds.readInt();  
            boolean b = ds.readBoolean();  
            System.out.println(utfs);  
            System.out.println(i);  
            System.out.println(b);  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
    public static void write() {  
        try (FileOutputStream fo = new FileOutputStream(f)) {  
            DataOutputStream dos = new DataOutputStream(fo);  
            dos.writeUTF("hello");  
            dos.writeInt(100);  
            dos.writeBoolean(true);  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
    public static void main(String[] args) {  
        write();  
        read();  
    }  
}
```
#### 对象流
对象流指的是可以**直接把一个对象以流的形式传输给其他的介质**，比如硬盘 
一个**对象以流的形式进行传输**，叫做**序列化**。该对象所对应的类，必须是实现 `Serializable` 接口，并且使用 `ObjectOutputStream` 和 `ObjectInputStream` 对流对象使用 `writeObject` 和 `readObject` 方法进行写读。
```java
//Hero.java
public class Hero implements Serializable {  
    //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号  
    private static final long serialVersionUID = 1L;  
    private String name;  
    private float hp;  
    private int armor;  
    public Hero(String name, float hp, int armor) {  
        this.name = name;  
        this.hp = hp;  
        this.armor = armor;  
        System.out.println(this.getName() + " is born");  
    }
}    
//TestSerializable.java
package MyIO;  
import MyCharacter.Hero;  
import java.io.*;  
public class TestSerializable {  
    public static void main(String[] args) {  
        Hero garlen = new Hero("Garlen", (float) (Math.random() * 100), 100);  
        Hero[] heroes = {garlen, garlen, garlen, garlen, garlen};  
        File f = new File("D:\\garlen.txt");  
        try (  
                //创建对象输出流  
                FileOutputStream fos = new FileOutputStream(f);  
                ObjectOutputStream oos = new ObjectOutputStream(fos);  
//            创建对象输入流  
                FileInputStream fis = new FileInputStream(f);  
                ObjectInputStream ois = new ObjectInputStream(fis)  
        ) {  
            oos.writeObject(heroes);  
            Hero[] heros = (Hero[]) ois.readObject();  
            for (Hero hero : heros) {  
                System.out.println(hero.getName() + "信息为：\n" + hero.getHp() + "血量，护甲为：" + hero.getArmor());  
            }  
        } catch (IOException | ClassNotFoundException e) {  
            throw new RuntimeException(e);  
        }  
    }  
}
```
#### 系统输入输出流
- `System.out` 是常用的在控制台输出数据的  
- `System.in` 可以从控制台输入数据

```java
package MyIO;  
import java.io.IOException;  
import java.io.InputStream;  
public class TestSystemIO {  
    public static void main(String[] args) {  
        InputStream is = System.in;  
        while (true) {  
            try {  
                /*  
                  敲入a,然后敲回车可以看到                                   97 10                                   97是a的ASCII码                                  10分别对应回车换行                  */  
                int i = is.read();  
                System.out.println(i);  
            } catch (IOException e) {  
                throw new RuntimeException(e);  
            }  
        }  
    }  
}
```
##### Scanner 读取字符串
使用 **System. in. read** 虽然可以读取数据，但是很不方便，使用 `Scanner` 就可以**逐行读取**了
```java
public static void scanner() {  
    Scanner s = new Scanner(System.in);  
    while (true) {  
        String s1 = s.next();  
        if (s1.equals("exit"))  
            break;  
        System.out.println(s1);  
    }
```
### 集合框架
#### ArrayList
ArrayList 相当于 C++里的 Vector，动态数组，可以自动扩容
ArrayList 实现了 List 接口，通常会定义 List 引用指向 ArrayList 对象，便于多态。
|          |                              |
|:--------:|:----------------------------:|
|   add    |             增加             |
| contains |         判断是否存在         |
|   get    |      获取指定位置的对象      |
| indexOf  |      获取对象所处的位置      |
|  remove  |             删除             |
|   set    |             替换             |
|   size   |           获取大小           |
| toArray  |          转换为数组          |
|  addAll  | 把另一个容器所有对象都加进来 |
|  clear   |             清空             |
eg：toArray
```java
package Myvector;  
import MyCharacter.Hero;  
import java.util.ArrayList;  
import java.util.HashMap;  
public class TestArrayList {  
    public static void main(String[] args) {  
        ArrayList<Hero> heroList = new ArrayList<>() {  
            {  
//                匿名内部类ArrayList对象初始化块  
                for (int i = 0; i < 5; i++) {  
                    int finalI = i;  
                    add(new Hero(new HashMap<>() {  
                        //                        匿名内部类Hero对象初始化块  
                        {  
                            put("name", "张三" + finalI);  
                            put("hp", (float) Math.random() * 100);  
                            put("armor", 10);  
                        }  
                    }));  
                }  
            }  
        };  
        for (Object o : heroList.toArray()) {  
            System.out.println(o.toString());  
        }  
        heroList.clear();  
        System.out.println(heroList.size());  
    }  
}
```
#### 泛型 Generic
- 不指定泛型的容器，可以存放任何类型的元素
- 指定了泛型的容器，只能存放指定类型的元素以及其子类

```java
//对于不使用泛型的容器，可以往里面放英雄，也可以往里面放物品
        List heros = new ArrayList();
        heros.add(new Hero("盖伦"));
        //本来用于存放英雄的容器，现在也可以存放物品了
        heros.add(new Item("冰杖"));
        //对象转型会出现问题
        Hero h1=  (Hero) heros.get(0);
        //尤其是在容器里放的对象太多的时候，就记不清楚哪个位置放的是哪种类型的对象了
        Hero h2=  (Hero) heros.get(1);
        //引入泛型Generic
        //声明容器的时候，就指定了这种容器，只能放Hero，放其他的就会出错
        List<Hero> genericheros = new ArrayList<Hero>();
        genericheros.add(new Hero("盖伦"));
        //如果不是Hero类型，根本就放不进去
        //genericheros.add(new Item("冰杖"));
        //除此之外，还能存放Hero的子类
        genericheros.add(new APHero());
        //并且在取出数据的时候，不需要再进行转型了，因为里面肯定是放的Hero或者其子类
        Hero h = genericheros.get(0);
```
> `List<Hero> genericheros = new ArrayList<Hero>();` 可以简写为 `List<Hero> genericheros2 = new ArrayList<>();`

ArrayList 容器有迭代器，可以通过迭代器进行遍历全部元素，`iterator` 方法得到迭代器, 迭代器通过 `hasNext` 方法进行迭代并自动更新位置。
![](https://stepimagewm.how2j.cn/806.png)
```java
        List<Hero> heros = new ArrayList<Hero>();
        //放5个Hero进入容器
        for (int i = 0; i < 5; i++) {
            heros.add(new Hero("hero name " +i));
        }
        //第二种遍历，使用迭代器
        System.out.println("--------使用while的iterator-------");
        Iterator<Hero> it= heros.iterator();
        //从最开始的位置判断"下一个"位置是否有数据
        //如果有就通过next取出来，并且把指针向下移动
        //直到"下一个"位置没有数据
        while(it.hasNext()){
            Hero h = it.next();
            System.out.println(h);
        }
        //迭代器的for写法
        System.out.println("--------使用for的iterator-------");
        for (Iterator<Hero> iterator = heros.iterator(); iterator.hasNext();) {
            Hero hero = (Hero) iterator.next();
            System.out.println(hero);
        }
```
#### 其他集合
序列分先进先出 FIFO, 先进后出 FILO  
	- FIFO 在 Java 中又叫 Queue 队列  
	- FILO 在 Java 中又叫 Stack 栈
##### LinkedList
LinkedList 也实现了 List 接口，诸如 add, remove, contains 等等方法
###### Deque
除了实现了 List 接口外，LinkedList 还实现了双向链表结构 `Deque`，可以很方便的在**头尾插入删除数据**
```java
//LinkedList是一个双向链表结构的list
        LinkedList<Hero> ll =new LinkedList<Hero>();
        //所以可以很方便的在头部和尾部插入数据
        //在最后插入新的英雄
        ll.addLast(new Hero("hero1"));
        ll.addLast(new Hero("hero2"));
        ll.addLast(new Hero("hero3"));
        System.out.println(ll);
        //在最前面插入新的英雄
        ll.addFirst(new Hero("heroX"));
        System.out.println(ll);
        //查看最前面的英雄
        System.out.println(ll.getFirst());
        //查看最后面的英雄
        System.out.println(ll.getLast());
        //查看不会导致英雄被删除
        System.out.println(ll);
        //取出最前面的英雄
        System.out.println(ll.removeFirst());
        //取出最后面的英雄
        System.out.println(ll.removeLast());
        //取出会导致英雄被删除
        System.out.println(ll);
```
###### Queue
LinkedList 除了实现了 List 和 Deque 外，还实现了 **Queue 接口** (队列)。  
Queue 是先进先出队列 FIFO，常用方法：  
> 1. `offer` 在最后添加元素  
> 2. `poll` 取出第一个元素  
> 3. `peek` 查看第一个元素

```java
//和ArrayList一样，LinkedList也实现了List接口
        List ll =new LinkedList<Hero>();
        //所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口
        //Queue代表FIFO 先进先出的队列
        Queue<Hero> q= new LinkedList<Hero>();
        //加在队列的最后面
        System.out.print("初始化队列：\t");
        q.offer(new Hero("Hero1"));
        q.offer(new Hero("Hero2"));
        q.offer(new Hero("Hero3"));
        q.offer(new Hero("Hero4"));
        System.out.println(q);
        System.out.print("把第一个元素取poll()出来:\t");
        //取出第一个Hero，FIFO 先进先出
        Hero h = q.poll();
        System.out.println(h);
        System.out.print("取出第一个元素之后的队列:\t");
        System.out.println(q);
        //把第一个拿出来看一看，但是不取出来
        h=q.peek();
        System.out.print("查看peek()第一个元素:\t");
        System.out.println(h);
        System.out.print("查看并不会导致第一个元素被取出来:\t");
        System.out.println(q);
```
##### 二叉树
二叉树由各种节点组成  
二叉树特点：  
> - 每个节点都可以有**左子节点**，**右子节点**  
> - 每一个节点都有一个**值**
![](https://stepimagewm.how2j.cn/1008.png)

###### 插入
```java
package collection;
public class Node {
    // 左子节点
    public Node leftNode;
    // 右子节点
    public Node rightNode;
    // 值
    public Object value;
    // 插入 数据
    public void add(Object v) {
        // 如果当前节点没有值，就把数据放在当前节点上
        if (null == value)
            value = v;
        // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系
        else {
            // 新增的值，比当前值小或者相同
            if ((Integer) v -((Integer)value) <= 0) {
                if (null == leftNode)
                    leftNode = new Node();
                leftNode.add(v);
            }
            // 新增的值，比当前值大
            else {
                if (null == rightNode)
                    rightNode = new Node();
                rightNode.add(v);
            }
        }
    }
    public static void main(String[] args) {
        int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 };
        Node roots = new Node();
        for (int number : randoms) {
            roots.add(number);
        }
    }
}
```
###### 遍历
二叉树的遍历分左序，中序，右序  
> 1. 左序即： 中间的数遍历后放在左边  
> 2. 中序即： 中间的数遍历后放在中间  
> 3. 右序即： 中间的数遍历后放在右边

eg：中序遍历（递归）
```java
// 中序遍历所有的节点
    public List<Object> values() {
        List<Object> values = new ArrayList<>();
        // 左节点的遍历结果
        if (null != leftNode)
            values.addAll(leftNode.values());
        // 当前节点
        values.add(value);
        // 右节点的遍历结果
        if (null != rightNode)
            values.addAll(rightNode.values());
        return values;
    }
```
eg：英雄 tree
```java
package Myvector;  
import MyCharacter.Hero;  
import java.util.ArrayList;  
import java.util.HashMap;  
import java.util.List;  
public class HeroTree {  
    HeroTree left = null;  
    HeroTree right = null;  
    Hero value;  
    public static void main(String[] args) {  
        HeroTree heroTree = new HeroTree() {  
            {  
                for (int i = 0; i < 10; i++) {  
                    int finalI = i;  
                    add(new Hero(new HashMap<>() {  
                        {  
                            put("name", "张三" + finalI);  
                            put("hp", (float) Math.random() * 100);  
                            put("armor", 10);  
                        }  
                    }));  
                }  
            }  
        };  
        inorderTraversal(heroTree);  
//        System.out.println(heroTree.values());  
    }  
    public static void inorderTraversal(HeroTree tree) {  
        if (tree != null) {  
            inorderTraversal(tree.left);  
            System.out.println(tree.value.toString());  
            inorderTraversal(tree.right);  
        }  
    }  
    // 中序遍历所有的节点  
    public List<Object> values() {  
        List<Object> values = new ArrayList<>();  
        // 左节点的遍历结果  
        if (null != left)  
            values.addAll(left.values());  
        // 当前节点  
        values.add(value);  
        // 右节点的遍历结果  
        if (null != right)  
            values.addAll(right.values());  
        return values;  
    }  
    public void add(Hero hero) {  
//        添加根节点  
        if (this.value == null) {  
            this.value = hero;  
        } else {  
            if (hero.getHp() <= this.value.getHp()) {  
                if (this.left == null) {  
                    this.left = new HeroTree();  
                }  
                this.left.add(hero);  
            } else {  
                if (this.right == null) {  
                    this.right = new HeroTree();  
                }  
                this.right.add(hero);  
            }  
        }  
    }  
}
```
##### HashMap
HashMap 储存数据的方式是—— 键值对
```java
HashMap<String,String> dictionary = new HashMap<>();
        dictionary.put("adc", "物理英雄");
        dictionary.put("apc", "魔法英雄");
        dictionary.put("t", "坦克");
```
（1）**键唯一，值可重复**
对于 HashMap 而言，key 是唯一的，不可以重复的。  
所以，以相同的 key 把不同的 value 插入到 Map 中会导致旧元素被覆盖，只留下最后插入的元素。  
不过，同一个对象可以作为值插入到 map 中，只要对应的 key 不一样
```java
HashMap<String,Hero> heroMap = new HashMap<String,Hero>();
        heroMap.put("gareen", new Hero("gareen1"));
        System.out.println(heroMap);
        //key为gareen已经有value了，再以gareen作为key放入数据，会导致原英雄，被覆盖
        //不会增加新的元素到Map中
        heroMap.put("gareen", new Hero("gareen2"));
        System.out.println(heroMap);
        //清空map
        heroMap.clear();
        Hero gareen = new Hero("gareen");
        //同一个对象可以作为值插入到map中，只要对应的key不一样
        heroMap.put("hero1", gareen);
        heroMap.put("hero2", gareen);
        System.out.println(heroMap);
```
###### HashMap 性能卓越的原因
> **哈希计算数组索引，同哈希值采用链表进行延长存储。**
1. **hashcode 概念**
所有的对象，都有一个对应的 hashcode（散列值）  
比如字符串“gareen”对应的是 1001 (实际上不是，这里是方便理解，假设的值)  
比如字符串“temoo”对应的是 1004  
比如字符串“db”对应的是 1008  
比如字符串“annie”对应的也是 1008  
2. **保存数据** 
准备一个数组，其长度是 2000，并且设定特殊的 hashcode 算法，使得所有字符串对应的 hashcode，都会落在 0-1999 之间  
要存放名字是"gareen"的英雄，就把该英雄和名称组成一个键值对，存放在数组的 1001 这个位置上  
要存放名字是"temoo"的英雄，就把该英雄存放在数组的 1004 这个位置上  
要存放名字是"db"的英雄，就把该英雄存放在数组的 1008 这个位置上  
要存放名字是"annie"的英雄，然而 "annie"的 hashcode 1008 对应的位置已经有 db 英雄了，那么就在这里创建一个链表，接在 db 英雄后面存放 annie  
3. **查找数据**  
比如要查找 gareen，首先计算"gareen"的 hashcode 是 1001，根据 1001 这个下标，到数组中进行定位，（根据数组下标进行定位，是非常快速的） 发现 1001 这个位置就只有一个英雄，那么该英雄就是 gareen.  
比如要查找 annie，首先计算"annie"的 hashcode 是 1008，根据 1008 这个下标，到数组中进行定位，发现 1008 这个位置有两个英雄，那么就对两个英雄的名字进行逐一比较 (equals)，因为此时需要比较的量就已经少很多了，很快也就可以找出目标英雄，这就是使用 hashmap 进行查询，非常快原理。
##### HashSet
（1）**元素不能重复**
Set 中的元素，不能重复
（2）**没有顺序**
Set 中的元素，没有顺序。  
严格的说，是没有按照元素的插入顺序排列 
HashSet 的具体顺序，既不是按照插入顺序，也不是按照 hashcode 的顺序。
（3）**遍历**
Set 不提供 get ()来获取指定位置的元素  
所以遍历需要用到**迭代器**，或者**增强型 for 循环**
```java
//遍历Set可以采用迭代器iterator
        for (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext();) {
            Integer i = (Integer) iterator.next();
            System.out.println(i);
        }
        //或者采用增强型for循环
        for (Integer i : numbers) {
            System.out.println(i);
        }
```
（4）**HashSet 和 HashMap 的关系**
通过观察 HashSet 的源代码（[如何查看源代码](https://how2j.cn/k/helloworld/helloworld-eclipse-tips/300.html#step706)）  
可以发现 HashSet 自身并没有独立的实现，而是在里面**封装了一个 Map**.  
HashSet 是作为**Map 的 key**而存在的  
而 value 是一个命名为 PRESENT 的 static 的 Object 对象，因为是一个类属性，所以只会有一个。
##### Collection
Collection 是一个**接口**
- Collection 是 Set List Queue 和 Deque 的接口  
- Queue: 先进先出队列  
- Deque: 双向链表  
  
> 注：Collection 和 Map 之间没有关系，Collection 是放一个一个对象的，Map 是放键值对的  
> 注：Deque 继承 Queue, 间接的继承了 Collection
![](https://stepimagewm.how2j.cn/830.png)

##### Collections
Collections 是一个类，**容器的工具类**, 就如同 Arrays 是数组的工具类
|关键字|简介|示例代码|
|:---:|:---:|
|reverse|反转|
|shuffle|混淆|
|sort|排序|
|swap|交换|
|rotate|滚动|
|synchronizedList|线程安全化|
```java
Collections.reverse(numbers);
Collections.shuffle(numbers);
Collections.sort(numbers);
Collections.swap(numbers,0,5);
Collections.rotate(numbers,2);//把集合向右滚动2个单位
List<Integer> synchronizedNumbers = (List<Integer>) Collections.synchronizedList(numbers);//把非线程安全的List转换为线程安全的List
```
#### ArrayList 和 LinkedList 的区别
ArrayList: 有顺序, 可重复
HashSet: 无顺序，不可重复
#### HashMap 和 Hashtable 的区别
HashMap 和 Hashtable 都实现了 Map 接口，都是键值对保存数据的方式  
> 1. 区别 1：  
> HashMap 可以存放 **null**  
> Hashtable 不能存放 null  
> 2. 区别 2：  
> HashMap 不是[线程安全的类](https://how2j.cn/k/thread/thread-synchronized/355.html#step793)  
> Hashtable 是**线程安全的类**

#### HashSet LinkedHashSet TreeSet
HashSet： 无序  
LinkedHashSet： 按照插入顺序  
TreeSet： 从小到大排序
#### 比较器
##### Comparator
Comparator 是一个用于比较对象的类，通过重写该类的 compare 方法按照指定规则对类对象进行比较实现排序，`compare` 方法中**返回正数**表示**第一个形参大于第二个形参**，返回**负数则相反**，**返回 0 则相等**。
```java
List<Hero> heroes = new ArrayList<>();  
        Random r = new Random();  
        for (int i = 0; i < 10; i++) {  
            heroes.add(new Hero("hero" + i, r.nextFloat(), r.nextInt()));  
        }  
        System.out.println("初始化后的集合：");  
        System.out.println(heroes);  
        Collections.sort(heroes, new Comparator<Hero>() {  
            @Override  
//            正数表示h1比h2要大  
            public int compare(Hero h1, Hero h2) {  
                if (h1.getHp() > h2.getHp())  
                    return 1;  
                else if (h1.getHp() < h2.getHp()) {  
                    return -1;  
                }  
                return 0;  
            }  
        });  
        System.out.println("按照血量排序后的集合：");  
        System.out.println(heroes);
```
##### Comparable
类实现 **Comparable** 接口重写 `compareTo` 方法，在类里面提供**比较算法**  
`Collections.sort` 就有足够的信息进行排序了，也**无需额外提供比较器 Comparator**   
> 注： **如果返回-1, 就表示当前的更小，否则就是更大**
```java
//Hero.java实现Comparable接口重写compareTo方法
package MyCharacter;  
import exception.EnemyHeroIsDeadException;  
import java.io.Serializable;  
import java.util.Map;  
public class Hero implements Mortal, Serializable, Comparable<Hero> {  
    //表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号  
    private static final long serialVersionUID = 1L;  
    private String name;  
    private float hp;  
    private int armor;  
    public Hero() {  
        System.out.println("Hero 构造");  
    }  
    public Hero(String name, float hp, int armor) {  
        this.name = name;  
        this.hp = hp;  
        this.armor = armor;  
    }  
    @Override  
    public String toString() {  
        super.toString();  
        return name + "的血量是 " + hp;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public float getHp() {  
        return hp;  
    }  
    public void setHp(float hp) {  
        this.hp = hp;  
    }  
    public int getArmor() {  
        return armor;  
    }  
    public void setArmor(int armor) {  
        this.armor = armor;  
    }  
    @Override  
    public int compareTo(Hero h) {  
        if (hp < h.getHp())  
            return -1;  
        return 1;  
    }  
}
//TestComparable.java
List<Hero> heroes = new ArrayList<>();  
        Random r = new Random();  
        for (int i = 0; i < 10; i++) {  
            heroes.add(new Hero("hero" + i, r.nextFloat(), r.nextInt()));  
        }  
        System.out.println("初始化后的集合：");  
        System.out.println(heroes);
        System.out.println("按照血量排序后的集合：");  
        System.out.println(heroes);
```
#### 聚合操作
JDK 8 之后，引入了**对集合的聚合操作**，可以非常容易的**遍历，筛选，比较**集合中的元素。用好聚合的前提是必须先掌握 [Lambda表达式](https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html)
```java
String name =heros
.stream()
.sorted((h1,h2)->h1.hp>h2.hp?-1:1)
.skip(2)
.map(h->h.getName())
.findFirst()
.get();
```
```java
Random r = new Random();
        List<Hero> heros = new ArrayList<Hero>();
        for (int i = 0; i < 10; i++) {
            heros.add(new Hero("hero " + i, r.nextInt(1000), r.nextInt(100)));
        }
        System.out.println("初始化集合后的数据 (最后一个数据重复)：");
        System.out.println(heros);
        //传统方式
        Collections.sort(heros,new Comparator<Hero>() {
            @Override
            public int compare(Hero o1, Hero o2) {
                return (int) (o2.hp-o1.hp);
            }
        });
        Hero hero = heros.get(2);
        System.out.println("通过传统方式找出来的hp第三高的英雄名称是:" + hero.name);
        //聚合方式
        String name =heros
            .stream()
            .sorted((h1,h2)->h1.hp>h2.hp?-1:1)
            .skip(2)
            .map(h->h.getName())
            .findFirst()
            .get();
        System.out.println("通过聚合操作找出来的hp第三高的英雄名称是:" + name);
```
## 泛型
