---
title: 后端开发学习
tags:
  - Mysql
  - Java
categories: Backend_development
date: 2023-10-08 13:29:26
sticky: 90
excerpt: Web—study about Java、Mysql、Redis、Linux
---
# Java
## Java 基础
### 1. 变量
从小到大自动转，从大到小强制转（精度丢失，值可能不正确）
> Java 中进行二元与运算类型的提升规则 
> 1. 整数运算： 如果两个操作数有一个为 long，则结果也为 long；没有 long 时，结果为 int。即使操作数全为 short、byte，结果也是 int。 
> 2. 浮点运算： 如果两个操作数有一个为 double，则结果为 double；只有两个操作数都是 float，则结果才为 float。注意：int 与 float 运算，结果为 float。

### 2. 命名规则
- 变量命名只能使用**字母数字 $ \_**  
- 变量第一个字符只能使用字母 $ _  
- 变量第一个字符不能使用数字，不能使用关键字  
> 注：_ 是下划线，不是-减号或者—— 破折号

java 关键字：
![|300](https://stepimagewm.how2j.cn/523.png)
![|300](https://stepimagewm.how2j.cn/522.png)
### 3. final 修饰词
当形参被 final 修饰时不能对形参再次赋值，如果形参是对象可以改变内部的属性
1. final 修饰类
   - 当 final 修饰类时，该类无法被继承
2. final 修饰方法
   - 被 final 修饰的方法不能被重写
3. final 修饰基本类型变量
   - 当一个变量被 final 修饰的时候，该变量只有一次赋值的机会
4. final 修饰引用
   - 被 final 修饰的引用只能指向一次对象
5. final 修饰常量
   - 常量值不变
- 

### 4. 操作符 Scanner
使用 Scanner 类，需要在最前面加上  
`import java.util.Scanner;`
> 如果在通过 `nextInt()` 读取了整数后，再接着读取字符串，读出来的是回车换行: **"\r\n"**, 因为 nextInt 仅仅读取数字信息，而不会读取回车换行"\r\n".  
	所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该**连续执行两次 nextLine ()**，第一次是取走回车换行，第二次才是读取真正的字符串
```java
import java.util.Scanner;
public class HelloWorld {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int i = s.nextInt();
        System.out.println("读取的整数是"+ i);
        String rn = s.nextLine();
        String a = s.nextLine();
        System.out.println("读取的字符串是："+a);
    }
}
```
### 5. 数组
数组是一个**固定长度**，包含了**相同类型数据**的**容器**
`int[] a; 和 int a[]` 都声明了一个数组变量，仅仅声明并没有创建分配空间。
创建一个长度是 5 的数组，并且使用**引用 a 指向该数组**，a 是一个地址，占据 **4** 个字节
`a = new int[5];`
常用方法：
```java
String Arrays.toString(数组)                 将数组拼接成一个字符串
int Arrays.binarySearch(数组，查找的元素)            二分法查护元素
int[] Arrays.copyOf(原数组，新数组长度)              拷贝数组
int[]Arrays.copyOfRange(原数组，起始索引，结束索引)   拷贝数组（指定范围）
void Arrays.fill(数组，元素)                        使用同一元素填充数组
void Arrays.sort(数组)                              对数组进行排序，也可按照自己自定义的规则
boolean Arrays.equals(数组a，数组b)                  返回两个数组是否元素相等的结果
```
eg：
```java
import java.util.Arrays;  
import java.util.Comparator;  
import java.util.Random;  
public class MyArray {  
    public static void main(String[] args) {  
        //声明一个引用  
        Integer[] a;  
        //创建一个长度是5的数组，并且使用引用a指向该数组  
        a = new Integer[5];  
        for (int i = 0; i < 5; i++) {  
            a[i]= new Random().nextInt(5);  
        }  
        Arrays.sort(a,new Comparator<Integer>(){  
            @Override  
            public int compare(Integer o1,Integer o2) {  
                // 降序  
                return o2-o1;  
        }});  
        System.out.println(Arrays.toString(a));  
    }  
}
```
> [!NOTE]
> 分配空间，同时赋值
> 写法一： 分配空间同时赋值
> `int[] a = new int[]{100,102,444,836,3236};`
>  
> 写法二： 省略了 new int[], 效果一样
> `int[] b = {100,102,444,836,3236};`

数组排序：
```java
import java.util.Arrays;  
public class MySort {  
    int [] a;  
    MySort(int []array ){  
        this.a = array;  
    }  
    public void ChoseSort(int [] array){  
        for (int i = 0; i < array.length; i++) {  
            for (int j = i+1; j < array.length; j++) {  
                if (array[i]> array[j]) {  
                    int temp = array[i];  
                    array[i] = array[j];  
                    array[j] = temp;  
                }  
            }  
        }  
    }  
    public  void BubbleSort(int [] array){  
        for (int i = 0; i < array.length; i++) {  
            for (int j = 0; j < array.length-1-i; j++) {  
                if (array[j]> array[j+1]) {  
                    int temp = array[j];  
                    array[j] = array[j+1];  
                    array[j+1] = temp;  
                }  
            }  
        }  
    }  
    public static void main(String[] args) {  
        MySort sort = new MySort(new int[]{1, 3, 4, 6, 2, 7, 8, 5, 9, 10});  
        sort.ChoseSort(sort.a);  
        sort.BubbleSort(sort.a);  
        System.out.println(Arrays.toString(sort.a));  
    }  
}
```
增强型 for 循环遍历
```java
for (int each : values) {
    System.out.println (each);
}
```
#### 二维数组
```java
		//初始化二维数组，
       int[][] a = new int[2][3]; //有两个一维数组，每个一维数组的长度是3
       a[1][2] = 5;  //可以直接访问一维数组，因为已经分配了空间
       //只分配了二维数组
       int[][] b = new int[2][]; //有两个一维数组，每个一维数组的长度暂未分配
       b[0]  =new int[3]; //必须事先分配长度，才可以访问
       b[0][2] = 5;
       //指定内容的同时，分配空间
       int[][] c = new int[][]{
               {1,2,4},
               {4,5},
               {6,7,8,9}
       };
```
### 6. 类和对象
#### 引用
引用的概念，如果一个变量的类型是类类型，而非基本类型，那么该变量又叫做引用。
`Hero h = new Hero();`
![](https://stepimagewm.how2j.cn/618.png)
> 引用 h 指向 Hero 对象

![](https://stepimagewm.how2j.cn/617.png)
> 多个引用指向同一个对象

![](https://stepimagewm.how2j.cn/619.png)
> 一个引用只能指向一个对象

### 7. 包 (package)
- 把比较接近的类，规划在同一个包下
- 在最开始的地方声明该类所处于的包名
- 使用同一个包下的其他类，直接使用即可  
- 但是要使用其他包下的类，必须 import

### 8. 访问修饰符
成员变量有四种修饰符：
<span style="background:rgba(240, 200, 0, 0.2)">1. private 私有的  </span>
<span style="background:rgba(240, 200, 0, 0.2)">2. package/friendly/default 不写  </span>
<span style="background:rgba(240, 200, 0, 0.2)">3. protected 受保护的  </span>
<span style="background:rgba(240, 200, 0, 0.2)">4. public 公共的</span>
![](https://stepimagewm.how2j.cn/604.png)
![](https://stepimagewm.how2j.cn/610.png)
![](https://stepimagewm.how2j.cn/611.png)
![](https://stepimagewm.how2j.cn/612.png)
> [!NOTE]
> 那么什么情况该用什么修饰符呢？
> 从作用域来看，public 能够使用所有的情况。但是大家在工作的时候，又不会真正全部都使用 public, 那么到底什么情况该用什么修饰符呢？
> 
> 1. 属性通常使用 private 封装起来
> 2. 方法一般使用 public 用于被调用
> 3. 会被子类继承的方法，通常使用 protected
> 4. package 用的不多，一般新手会用 package, 因为还不知道有修饰符这个东西
> 
> 再就是作用范围最小原则
> 简单说，能用 private 就用 private，不行就放大一级，用 package, 再不行就用 protected，最后用 public。这样就能把数据尽量的封装起来，没有必要露出来的，就不用露出来了

### 9. 类属性（static 变量）
1. 当一个属性被 **static** 修饰的时候，就叫做**类属性**，又叫做**静态属性**  
2. 当一个属性被声明成类属性，那么**所有的对象，都共享一个值**

访问方式：
1. 对象. 类属性
2. 类. 类属性

对象属性初始化：
1. 声明该属性的时候初始化  
2. 构造方法中初始化  
3. 初始化块

静态属性初始化：
1. 声明该属性的时候初始化  
2. 静态初始化块

> 初始化顺序：<font color="#ff0000">静态属性声明>静态初始化块>对象属性声明>对象属性初始化块>构造方法</font>
### 10. 类方法（static 方法）
- 类方法： 又叫做**静态方法**
- 对象方法： 又叫**实例方法**，非静态方法  
  
> 访问一个对象方法，必须建立在**有一个对象的前提**的基础上  
> 访问类方法，不需要对象的存在，直接就访问
> 静态方法只能调用静态方法和静态属性，不能调用对象属性和方法

### 11. 单例模式
单例模式又叫做 Singleton 模式，指的是一个类，在一个 JVM 里，**只有一个实例存在**。
*单例模式的设计目的是确保一个类只有一个实例，并提供全局访问点以供其他对象使用。因此，在传统的单例模式中，不允许继承该类，因为继承会导致类的实例数量增多。*
#### 饿汉式单例模式
单例模式的类应该只有一个示例，通过**私有化其构造方法**，使得外部无法通过 new 得到新的实例。
这种单例模式又叫做*饿汉式单例模式*，无论如何都会创建一个实例
```java
package charactor;
public class GiantDragon {
    //私有化构造方法使得该类无法在外部通过new 进行实例化
	private GiantDragon(){
	}
	//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个
	private static GiantDragon instance = new GiantDragon();
	//public static 方法，提供给调用者获取12行定义的对象
	public static GiantDragon getInstance(){
		return instance;
	}
}
```
#### 懒汉式单例模式
**懒汉式**单例模式与**饿汉式**单例模式不同，只有在调用 getInstance 的时候，才会创建实例
```java
package charactor;
public class GiantDragon {
    //私有化构造方法使得该类无法在外部通过new 进行实例化
    private GiantDragon(){        
    }
    //准备一个类属性，用于指向一个实例化对象，但是暂时指向null
    private static GiantDragon instance;
    //public static 方法，返回实例对象
    public static GiantDragon getInstance(){
    	//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象
    	if(null==instance){
    		instance = new GiantDragon();
    	}
    	//返回 instance指向的对象
        return instance;
    }
}
```
> [!NOTE]
> **什么时候使用饿汉式，什么时候使用懒汉式？**
> 饿汉式，是**立即加载**的方式，无论是否会用到这个对象，都会加载。
> 如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。
> 
> 懒汉式，是**延迟加载**的方式，只有使用的时候才会加载。并且有线程安全的考量 (鉴于同学们学习的进度，暂时不对线程的章节做展开)。
> 使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。
> 
> 看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式

#### 单例模式的三要素
什么是单例模式？
1. 构造方法私有化  
2. 静态属性指向实例  
3. public static 的 getInstance 方法，返回第二步的静态属性

### 12. 枚举（enum）
枚举 enum 是一种特殊的类 (还是类)，使用枚举可以很方便的定义常量
eg：
```java
public enum Season {
SPRING,SUMMER,AUTUMN,WINTER
}
public class HelloWorld {
	public static void main(String[] args) {
		Season season = Season.SPRING;
		switch (season) {
		case SPRING:
			System.out.println("春天");
			break;
		case SUMMER:
			System.out.println("夏天");
			break;
		case AUTUMN:
			System.out.println("秋天");
			break;
		case WINTER:
			System.out.println("冬天");
			break;
		}
	}
}
```
借助增强型 for 循环，可以很方便的遍历一个枚举都有哪些常量：
```java
public class HelloWorld {
	public static void main(String[] args) {
		for (Season s : Season.values()) {
			System.out.println(s);
		}
	}
}
```
---
### 13. 接口与继承
#### 接口
接口就像是一种约定，对类进行约束规范，便于顶层设计规范化
eg：
```java
package MyCharacter;  
public interface Healer {  
    void heal(int healAmount);  
}
package MyCharacter;  
public class Support extends Hero implements Healer {  
    @Override  
    public void heal(int healAmount) {  
        this.setHp(this.getHp() + healAmount);  
        System.out.println("当前英雄的血量为" + this.getHp() + "点");  
    }  
}
```
#### 对象转型
##### 子类转父类（向上转型）
引用类型和对象类型不一致时，需要进行类型转换，类型转换有时候会成功，有时候会失败。
*转换是否成功判别方法：**把右边的当做左边来用，看是否能说通***
> 子类向父类转型（向上转型）一般都是可以的，父类引用指向子类对象

![](https://stepimagewm.how2j.cn/624.png)
##### 父类转子类 (向下转型)
父类转子类，有的时候行，有的时候不行，所以必须进行**强制转换**。强制转换的意思就是转换有风险，风险自担。
转换总结：
![](https://stepimagewm.how2j.cn/625.png)
> 10 行： 把 ad 当做 Hero 使用，一定可以，转换之后，h 引用指向一个 ad 对象  
> 11 行： h 引用有可能指向一个 ad 对象，也有可能指向一个 support 对象，所以把 h 引用转换成 AD 类型的时候，就有可能成功，有可能失败，因此要进行强制转换，换句话说转换后果自负，到底能不能转换成功，要看引用 h 到底指向的是哪种对象  
> 在这个例子里，**h 指向的是一个 ad 对象**，所以转换成 ADHero 类型，是可以的  
> 12 行：把一个 support 对象当做 Hero 使用，一定可以，转换之后，**h 引用指向一个 support 对象**  
> 13 行：这个时候，h 指向的是一个 **support** 对象，所以转换成 **ADHero** 类型，会失败。失败的表现形式是抛出异常 ClassCastException 类型转换异常
```java
package charactor;
import charactor1.Support;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        Hero h =new Hero();
        ADHero ad = new ADHero();
        Support s =new Support();
        h = ad;
        ad = (ADHero) h;
        h = s;
        ad = (ADHero)h;
    }
}
```
> [!NOTE]
> ![](https://stepimagewm.how2j.cn/626.png)
> **没有继承关系**的两个类，互相转换一定会失败，抛出异常

##### 实现类转换成接口 (向上转型)
类似于子类转父类，一样可行。
![](https://stepimagewm.how2j.cn/627.png)
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        AD adi = ad;
    }
}
```
##### 接口转换成实现类 (向下转型)
![]( https://stepimagewm.how2j.cn/628.png )
> 7 行： ad 引用指向 ADHero，而 adi 引用是接口类型：AD，实现类转换为接口，是向上转型，所以无需强制转换，并且一定能成功  
> 8 行: **adi** 实际上是**指向**一个 **ADHero** 的，所以能够转换成功  
> 9 行： adi 引用所指向的对象是一个 ADHero，要转换为 ADAPHero 就会失败。
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        AD adi = ad;
        ADHero adHero = (ADHero) adi;
        ADAPHero adapHero = (ADAPHero) adi;
        adapHero.magicAttack();
    }
}
```
##### instanceof 
`a instanceof className` 判断一个引用所指向的对象，是否是类的对象，或者子类的对象。
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
        ADHero ad = new ADHero();
        APHero ap = new APHero();
        Hero h1= ad;
        Hero h2= ap;
        //判断引用h1指向的对象，是否是ADHero类型
        System.out.println(h1 instanceof ADHero);
        //判断引用h2指向的对象，是否是APHero类型
        System.out.println(h2 instanceof APHero);
        //判断引用h1指向的对象，是否是Hero的子类型
        System.out.println(h1 instanceof Hero);
    }
}
```
#### 重写
子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖 override
> 调用子类的方法首先调用重写的方法，如果没有再调用父类方法。
---
#### 多态
操作符的多态  
+ 可以作为算数运算，也可以作为字符串连接  
类的多态
- 父类引用指向子类对象
---
##### 操作符多态
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp;
    public static void main(String[] args) {
    	int i = 5;
    	int j = 6;
    	int k = i+j; //如果+号两侧都是整型，那么+代表 数字相加
    	System.out.println(k);
    	int a = 5;
    	String b = "5";
    	String c = a+b; //如果+号两侧，任意一个是字符串，那么+代表字符串连接
    	System.out.println(c);
    }
}
```
##### 类多态
父类引用指向子类，调用父类引用被重写的方法，优先执行指向的子类的重写方法，即同类型调用同一方法，呈现不同的状态。
```java
package property;
public class Item {
	String name;
	int price;
	public void buy(){
		System.out.println("购买");
	}
	public void effect() {
		System.out.println("物品使用后，可以有效果 ");
	}
	public static void main(String[] args) {
		Item i1= new LifePotion();
		Item i2 = new MagicPotion();
		System.out.print("i1是Item类型，执行effect打印:");
		i1.effect();
		System.out.print("i2也是Item类型，执行effect打印:");
		i2.effect();
	}
}
```
> [!NOTE] **类的多态条件**
> 1. 父类（接口）引用指向子类对象  
> 2. 调用重写的方法

##### 使用类多态 VS 不使用类多态
不使用：
```java
package charactor;
import property.LifePotion;
import property.MagicPotion;
public class Hero {
    public String name; 
    protected float hp;
    public void useLifePotion(LifePotion lp){
    	lp.effect();
    }
    public void useMagicPotion(MagicPotion mp){
    	mp.effect();
    }
    public static void main(String[] args) {
    	Hero garen =  new Hero();
        garen.name = "盖伦";
    	LifePotion lp =new LifePotion();
    	MagicPotion mp =new MagicPotion();
    	garen.useLifePotion(lp);
    	garen.useMagicPotion(mp);
    }
}
```
使用：
```java
package charactor;
import property.Item;
import property.LifePotion;
import property.MagicPotion;
public class Hero {
    public String name; 
    protected float hp;
    public void useItem(Item i){
    	i.effect();
    }
    public static void main(String[] args) {
    	Hero garen =  new Hero();
        garen.name = "盖伦";
    	LifePotion lp =new LifePotion();
    	MagicPotion mp =new MagicPotion();
    	garen.useItem(lp);
    	garen.useItem(mp);    	
    }
}
```
> 由此可知，使用类多态可以简化设计，减少冗余的相同逻辑方法的设计实现，提高开发效率。

##### 练习
- immortal 是不朽的，不死的意思
- mortal 就是终有一死的，凡人的意思
 
> 1. 设计一个接口
> 接口叫做 Mortal, 其中有一个方法叫做 die
> 2. 实现接口
> 分别让 ADHero, APHero, ADAPHero 这三个类，实现 Mortal 接口，不同的类实现 die 方法的时候，都打印出不一样的字符串
> 3. 为 Hero 类，添加一个方法, 在这个方法中调用 m 的 die 方法。
> public void kill (Mortal m)
> 4. 在主方法中
> 首先实例化出一个 Hero 对象:盖伦
> 然后实例化出 3 个对象，分别是 ADHero, APHero, ADAPHero 的实例
> 然后让盖伦 kill 这 3 个对象

```java
//Hero
package MyCharacter;  
public class Hero {  
    private String name;  
    private float hp;  
    private int armor;  
    public static void main(String[] args) {  
        Hero garLen = new Hero();  
        garLen.setName("Garlen");  
        ADHero adHero = new ADHero();  
        adHero.setName("ADHero");  
        APHero apHero = new APHero();  
        apHero.setName("APHero");  
        ADAPHero adapHero = new ADAPHero();  
        adapHero.setName("ADAPHero");  
        garLen.kill(adHero, apHero, adapHero);  
    }  
    public void kill(Mortal... ms) {  
        for (Mortal m : ms) {  
            m.die();  
        }  
    }  
    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    public float getHp() {  
        return hp;  
    }  
    public void setHp(float hp) {  
        this.hp = hp;  
    }  
    public int getArmor() {  
        return armor;  
    }  
    public void setArmor(int armor) {  
        this.armor = armor;  
    }  
}
//Mortal
package MyCharacter;  
public interface Mortal {  
    void die();  
}
//ADHero
package MyCharacter;  
public class ADHero extends Hero implements AD, Mortal {  
    @Override  
    public void physicAttack() {  
        System.out.println("ADHero 物理攻击");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
//APHero
package MyCharacter;  
public class APHero extends Hero implements AP, Mortal {  
    @Override  
    public void magicAttack() {  
        System.out.println("AP Hero magic attack!");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
//ADAPHero
package MyCharacter;  
public class ADAPHero extends Hero implements AD, AP, Mortal {  
    @Override  
    public void physicAttack() {  
        System.out.println("进行物理攻击");  
    }  
    @Override  
    public void magicAttack() {  
        System.out.println("进行魔法攻击");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
```
---
#### 隐藏
与**重写**类似，方法的重写是**子类覆盖父类**的**对象方法**，**隐藏**，就是**子类覆盖父类**的**类方法**
```java
//父类
package MyCharacter;  
public class Hero {  
    private String name;  
    private float hp;  
    private int armor;  
    public static void battle() {  
        System.out.println("Hero battleWin");  
    } 
}
//子类隐藏父类的类方法
package MyCharacter;  
public class ADHero extends Hero implements AD, Mortal {  
    //隐藏父类的battleWin方法  
    public static void battle() {  
        System.out.println("ad hero battle win");  
    }  
    public static void main(String[] args) {  
        Hero.battle();  
        ADHero.battle();  
    }  
    @Override  
    public void physicAttack() {  
        System.out.println("ADHero 物理攻击");  
    }  
    @Override  
    public void die() {  
        System.out.println(this.getName() + "阵亡");  
    }  
}
```
> [!NOTE] 父类引用指向子类调用隐藏方法（**类方法不存在多态**）？
> 在 Java 中，对于类方法（静态方法），编译时会根据引用类型（即变量类型）来决定调用的方法。实际上，类方法并不具有多态性，也不会被子类的重写所影响。由于 h 是父类类型的引用，即使它指向一个子类对象（ADHero），编译器仍然会**根据引用类型**（Hero）来**决定调用的方法**。

#### super
实例化子类对象时，其父类的构造方法也会被调用，并且是**父类构造方法先调用**，子类构造方法会**默认调用父类的无参的构造方法**
（1）使用关键字 super **显式调用父类带参的构造方法**
```java
public ADHero(String name){
        super(name);
        System.out.println("AD Hero的构造方法");
    }
```
（2）通过 super 调用父类属性
```java
public int getMoveSpeed2(){
return super.moveSpeed;
}
```
（3）通过 super 调用父类方法
```java
// 重写useItem，并在其中调用父类的userItem方法
	public void useItem(Item i) {
		System.out.println("adhero use item");
		super.useItem(i);
	}
```
---
#### Object 超类
Object 类是所有类的父类，即基类，声明一个类的时候，默认是继承了 Object
1. Object 类提供一个 **toString 方法**，所以所有的类都有 toString 方法  
toString()的意思是返回当前对象的**字符串表达**
2. 当一个对象**没有任何引用指向它**的时候，它就满足垃圾回收的条件，当它被垃圾回收的时候，它的 **finalize()** 方法就会被调用。finalize() 不是开发人员主动调用的方法，而是由虚拟机 JVM 调用的。
3. **equals()** 用于判断两个对象的内容是否相同，假设，当两个英雄的 hp 相同的时候，我们就认为这两个英雄相同
4. `==` 这不是 Object 的方法，但是用于判断两个对象是否相同，更准确的讲，用于判断两个引用，是否指向了同一个对象
5. **hashCode 方法**返回一个对象的**哈希值**，但是在了解哈希值的意义之前，讲解这个方法没有意义。
6. Object 还提供**线程同步**相关方法：**wait()，notify()，notifyAll()**
7. getClass()会返回一个对象的类对象，属于**反射**原理。
---
#### 抽象类
在类中声明一个方法，这个方法**没有方法体**，是一个“空”方法，这样的方法就叫**抽象方法**，使用修饰符“**abstract**"，当一个类有抽象方法的时候，该类必须被声明为**抽象类**，不能被实例化。
抽象类可以没有抽象方法，也可以有具体方法
> [!NOTE] 抽象类和接口的区别
> 1. 区别1：  
> - 子类**只能继承一个抽象类**，不能继承多个  
> - 子类**可以实现多个接口**
> 2. 区别2：  
> - 抽象类可以定义 public,protected,package,private 静态和非静态属性，final 和非 final 属性  
> - 但是接口中声明的属性，只能是 public 静态 final 的，即便没有显式的声明  
> 注: **抽象类和接口都可以有实体方法**。 **接口**中的实体方法，叫做**默认方法**

#### 内部类
分类：
- 非静态内部类  
- 静态内部类  
- 匿名类  
- 本地类

##### 非静态内部类
非静态内部类可以直接在一个类里面定义，当外部类对象存在时内部类才有意义。
语法: `new 外部类().new 内部类()`
```java
package charactor;
public class Hero {
	private String name; // 姓名
	float hp; // 血量
	float armor; // 护甲
	int moveSpeed; // 移动速度
	// 非静态内部类，只有一个外部类对象存在的时候，才有意义
	// 战斗成绩只有在一个英雄对象存在的时候才有意义
	class BattleScore {
		int kill;
		int die;
		int assit;
		public void legendary() {
			if (kill >= 8)
				System.out.println(name + "超神！");
			else
				System.out.println(name + "尚未超神！");
		}
	}
	public static void main(String[] args) {
		Hero garen = new Hero();
		garen.name = "盖伦";
		// 实例化内部类
		// BattleScore对象只有在一个英雄对象存在的时候才有意义
		// 所以其实例化必须建立在一个外部类对象的基础之上
		BattleScore score = garen.new BattleScore();
		score.kill = 9;
		score.legendary();
	}
}
```
##### 静态内部类
与**非静态内部类**不同，静态内部类水晶类的实例化**不需要一个外部类的实例为基础**，可以**直接实例化**  
语法：`new 外部类.静态内部类()`;  
因为没有一个外部类的实例，所以在**静态内部类里面不可以访问外部类的实例属性和方法**，除了可以访问外部类的**私有静态成员**外，静态内部类和普通类没什么大的区别
```java
package charactor;
public class Hero {
    public String name; 
    protected float hp; 
    private static void battleWin(){
        System.out.println("battle win");
    }
    //敌方的水晶
    static class EnemyCrystal{
    	int hp=5000;
    	//如果水晶的血量为0，则宣布胜利
    	public void checkIfVictory(){
    		if(hp==0){
    			Hero.battleWin();
    			//静态内部类不能直接访问外部类的对象属性
    			System.out.println(name + " win this game");
    		}
    	}
    }
    public static void main(String[] args) {
    	//实例化静态内部类
    	Hero.EnemyCrystal crystal = new Hero.EnemyCrystal();
    	crystal.checkIfVictory();
	}
}
```
##### 匿名类
匿名类指的是在**声明一个类的同时实例化它**，使代码更加简洁精练  
通常情况下，要使用一个接口或者抽象类，都必须创建一个子类  
有的时候，为了快速使用，**直接实例化一个抽象类，并“当场”实现其抽象方法**。  
既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做**匿名类**
```java
package charactor;
public abstract class Hero {
    String name; //姓名
    float hp; //血量
    float armor; //护甲
    int moveSpeed; //移动速度
    public abstract void attack();
    public static void main(String[] args) {
        ADHero adh=new ADHero();
        //通过打印adh，可以看到adh这个对象属于ADHero类
        adh.attack();
        System.out.println(adh);
        Hero h = new Hero(){
            //当场实现attack方法
            public void attack() {
                System.out.println("新的进攻手段");
            }
        };
        h.attack();
        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名
        System.out.println(h);
    }
}
```
> **在匿名类中使用外部的局部变量，外部的局部变量必须修饰为 final，否则报错（jdk 8 中不需要强制用 final 修饰，因为编译器会自动加上）**
```java
package charactor;
public abstract class Hero {
    public abstract void attack();
    public static void main(String[] args) {
    	//在匿名类中使用外部的局部变量，外部的局部变量必须修饰为final
    	final int damage = 5;
        Hero h = new Hero(){
            public void attack() {
                System.out.printf("新的进攻手段，造成%d点伤害",damage );
            }
        };
    }
}
```
##### 本地类
本地类可以理解为有名字的匿名类  
**内部类与匿名类**不一样的是，**内部类必须声明在成员的位置**，即与属性和方法平等的位置。本地类和匿名类一样，**直接声明在代码块里面**，可以是主方法，for 循环里等等地方
```java
package charactor;
public abstract class Hero {
    String name; //姓名
    float hp; //血量
    float armor; //护甲
    int moveSpeed; //移动速度
    public abstract void attack();
    public static void main(String[] args) {
        //与匿名类的区别在于，本地类有了自定义的类名
        class SomeHero extends Hero{
        	public void attack() {
                System.out.println( name+ " 新的进攻手段");
            }
        }
        SomeHero h  =new SomeHero();
        h.name ="地卜师";
        h.attack();
    }
}
```
#### 默认方法
jdk 8 新特性，指接口也可以提供具体方法，不单单只能提供抽象方法
Mortal 这个接口，增加了一个默认方法 revive，这个方法有实现体，并且必须被声明为 **default**，实现接口功能扩展。
```java
package MyCharacter;  
public interface Mortal {  
    void die();  
    default void revive() {  
        System.out.println("我又回来啦");  
    }  
}
```
#### UML
UML-Unified Module Language 统一建模语言，可以很方便的用于描述类的属性，方法，以及类和类之间的关系。
![](https://stepimagewm.how2j.cn/2305.png)
![](https://stepimagewm.how2j.cn/2318.png)
![](https://stepimagewm.how2j.cn/2319.png)
> 带箭头的实线，表示 Spider，Cat, Fish 都继承于 Animal 这个父类.
![](https://stepimagewm.how2j.cn/2320.png)
> 表示 Fish实现了 Pet这个接口
![](https://stepimagewm.how2j.cn/2321.png) 

---
### 数字与字符串
#### 封装类
数字封装类有  
**Byte,Short,Integer,Long,Float,Double**  
这些类都是抽象类**Number**的子类
```java
//基本类型转换成封装类型
        Integer it = new Integer(i);
        //封装类型转换成基本类型
        int i2 = it.intValue();
```
1. 自动装箱：
   - 不需要调用构造方法，通过 `=` 符号自动把基本类型转换为类类型就叫装箱
   - `int i = 5;//自动转换就叫装箱Integer it2 = i;`
2. 自动拆箱
   - 不需要调用 Integer 的 intValue 方法，通过=就自动转换成 int 类型，就叫拆箱
   - `  int i = 5;Integer it = new Integer (i);//封装类型转换成基本类型int i2 = it.intValue ();//自动转换就叫拆箱 int i3 = it; `

- int 的最大值可以通过其对应的封装类 **Integer.MAX_VALUE** 获取
- int 的最小值可以通过其对应的封装类 **Integer.MIN_VALUE** 获取

#### 字符串转换
##### 数字转字符串
1. 方法1： 使用 String 类的静态方法 **valueOf**  
2. 方法2： 先把基本类型装箱为对象，然后调用对象的**toString**
```java
package NumberString;  
public class NumToStr {  
    public static void main(String[] args) {  
        int i = 10;  
//        方法1  
        String s1 = String.valueOf(i);  
//        方法2  
        Integer i1 = i;  
        String s2 = i1.toString();  
    }  
}
```
##### 字符串转数字
调用 Integer 的**静态方法 parseInt**
`int i3 = Integer.parseInt(s1);`
#### 数学 Math 包
java.lang.Math 提供了一些常用的数学运算方法，并且都是以静态方法的形式存在
**四舍五入, 随机数，开方，次方，π，自然常数：**
```java
public class MathUse {  
    public static void main(String[] args) {  
        float f1 = 3.4f;  
        float f2 = 3.5f;  
        System.out.printf("%d, %d", Math.round(f1), Math.round(f2));  
        //得到一个0-1之间的随机浮点数（取不到1）  
        System.out.println(Math.random());  
        //得到一个0-10之间的随机整数 （取不到10）  
        System.out.println((int) (Math.random() * 10));  
        //开方  
        System.out.println(Math.sqrt(9));  
        //次方（2的4次方）  
        System.out.println(Math.pow(2, 4));  
        //π  
        System.out.println(Math.PI);  
        //自然常数  
        System.out.println(Math.E);  
    }  
}
```
#### 格式化输出
如果不使用格式化输出，就需要进行字符串连接，如果变量比较多，拼接就会显得繁琐  
使用格式化输出，就可以简洁明了  
- %s 表示字符串  
- %d 表示数字  
- %n 表示换行

printf 和 format 格式化输出效果一样，printf 中调用了 format
```java
//使用格式化输出  
//%s表示字符串，%d表示数字,%n表示换行  
String name = "亚瑟";  
String sentenceFormat = "%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n";  
int kill = 1;  
String title = "超神";  
System.out.printf(sentenceFormat, name, kill, title);
System.out.format(sentenceFormat, name, kill, title);
```
- **换行符**就是**另起一行** --- '\\n' 换行（newline）  
- **回车符**就是**回到一行的开头** --- '\\r' 回车（return）

#### immutable
immutable 是指不可改变的,比如创建了一个字符串对象,String garen ="盖伦";
**不可改变**的具体含义是指：
- 不能增加长度
- 不能减少长度
- 不能插入字符
- 不能删除字符
- 不能修改字符
一旦创建好这个字符串，里面的内容永远不能改变,String 的表现就像是一个**常量**
#### 字符串常用方法
|                 方法名                 |        简介        |     |
|:--------------------------------------:|:------------------:| --- |
|                 charAt                 |      获取字符      |     |
|              toCharArray               | 获取对应的字符数组 |     |
|               subString                |    截取子字符串    |     |
|                 split                  |        分隔        |     |
|                  trim                  |    去掉首尾空格    |     |
|      toLowerCase  <br>toUpperCase      |       大小写       |     |
| indexOf  <br>lastIndexOf  <br>contains |        定位        |     |
|      replaceAll  <br>replaceFirst      |        替换        |     |
#### 比较字符串
1. 是否是同一个对象
`==` 用于用于判断两个字符串对象是否相同（不是内容是否相同）
```java
String str1 = "the light";
        String str2 = new String(str1);
        //==用于判断是否是同一个字符串对象
        System.out.println( str1  ==  str2);
```
特例：str 3 与 str1 内容完全一样，复用之前的对象并未创建新 String 对象
```java
		String str1 = "the light";
        String str3 = "the light";
        System.out.println( str1  ==  str3);
```
2. 是否内容相同
使用 **equals** 进行字符串内容的比较，必须大小写一致  
**equalsIgnoreCase**，忽略大小写判断内容是否一致
```java
		System.out.println(str1.equals(str3));//大小写不一样，返回false
        System.out.println(str1.equalsIgnoreCase(str3));//忽略大小写的比较，返回true
```
3. 是否以子字符串开始或者结束
**startsWith** //以...开始，**endsWith** //以...结束
#### StringBuffer
StringBuffer 是**可变长**的字符串
| 关键字                       | 描述                |     |
| ---------------------------- | ------------------- | --- |
| append delete insert reverse | 追加 删除 插入 反转 |     |
| length capacity              | 长度容量            |     |
```java
package NumberString;  
public class MyStringBuffer {  
    public static void main(String[] args) {  
        String str1 = "let there ";  
        StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象  
        sb.append("be light"); //在最后追加  
        System.out.println(sb);  
        sb.delete(4, 10);//删除4-10之间的字符  
        System.out.println(sb);  
        sb.insert(4, "there ");//在4这个位置插入 there  
        System.out.println(sb);  
        sb.reverse(); //反转  
        System.out.println(sb);  
    }  
}
```
> StringBuffer 性能明显优于**字符串拼接**

### 日期
时间原点概念：
> 所有的数据类型，无论是整数，布尔，浮点数还是字符串，最后都需要以数字的形式表现出来。
> 日期类型也不例外，换句话说，一个日期，比如 2020 年 10 月 1 日，在计算机里，会用一个数字来代替。
> 那么最特殊的一个数字，就是零. 零这个数字，就代表 Java 中的时间原点，其对应的日期是 1970 年 1 月 1 日 8 点 0 分 0 秒。 (为什么是 8 点，因为中国的太平洋时区是 UTC-8，刚好和格林威治时间差 8 个小时)
> 为什么对应 1970 年呢？ 因为 1969 年发布了第一个 UNIX 版本：AT&T，综合考虑，当时就把 1970 年当做了时间原点。
> 所有的日期，都是以为这个 0 点为基准，每过一毫秒，就+1。

#### Date
##### 创建日期对象
`import java.util.Date`
```java
import java.util.Date;  
public class MyDate {  
    public static void main(String[] args) {  
        Date date = new Date();  
//        输出当前系统时间  
        System.out.println(date);  
        Date date1 = new Date(10000L);  
//        输出距离1970-1-1 08:00:00过了10000毫秒的时间  
        System.out.println(date1);  
    }  
}
```
- getTime () 获得一个长整型距离1970-1-1 08:00:00所经过的毫秒数
- System.currentTimeMillis()效果与 getTime（）相同，可能有几十毫秒误差。

```java
//当前日期的毫秒数
        System.out.println("Date.getTime() \t\t\t返回值: "+now.getTime());
        //通过System.currentTimeMillis()获取当前日期的毫秒数
        System.out.println("System.currentTimeMillis() \t返回值: "+System.currentTimeMillis());
```
##### 日期格式化
> y 代表年
> M 代表月
> d 代表日
> H 代表24进制的小时
> h 代表12进制的小时
> m 代表分钟
> s 代表秒
> S 代表毫秒
###### 日期转字符串
`SimpleDateFormat` 类对象通过 `format` 方法对日期进行格式化为字符串
```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");  
Date d = new Date();  
String str = sdf.format(d);  
System.out.println("当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: " + str);  
SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd");  
Date d1 = new Date();  
String str1 = sdf1.format(d1);  
System.out.println("当前时间通过 yyyy-MM-dd 格式化后的输出: " + str1);
```
###### 字符串转日期
`SimpleDateFormat` 格式（yyyy/MM/dd HH:mm:ss）需要和**字符串格式保持一致**，如果不一样就会抛出解析异常 ParseException，通过调用 SimpleDateFormat 对象的 `parse` 方法将字符串转为日期。
```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
String str = "2016-1-5 12:12:12";  
try {  
    Date d = sdf.parse(str);  
    System.out.printf("字符串 %s 通过格式  yyyy/MM/dd HH:mm:ss %n转换为日期对象: %s", str, d.toString());  
} catch (ParseException e) {  
    // TODO Auto-generated catch block  
    e.printStackTrace();  
}
```
#### Calendar 
Calendar 类即**日历类**，常用于进行“翻日历”，比如下个月的今天是多久
采用[单例模式](https://how2j.cn/k/class-object/class-object-singleton/349.html)获取日历对象 `Calendar.getInstance()`;
日历对象的 `getTime` 方法获取当前日期，`setTime` 方法设置日历日期。
```java
//采用单例模式获取日历对象Calendar.getInstance();  
Calendar c = Calendar.getInstance();  
//通过日历对象得到日期对象  
Date d = c.getTime();  
System.out.println(d);  
Date d2 = new Date(0);  
c.setTime(d2); //把这个日历，调成日期 : 1970.1.1 08:00:00  
System.out.println(c.getTime());
```
##### 翻日历
1. `add` 方法，在原日期上增加年/月/日  
2. `set` 方法，直接设置年/月/日
```java
import java.text.SimpleDateFormat;  
import java.util.Calendar;  
import java.util.Date;  
public class TestCalendar {  
    private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
    public static void main(String[] args) {  
        Calendar c = Calendar.getInstance();  
        Date now = c.getTime();  
        // 当前日期  
        System.out.println("当前日期：\t" + format(c.getTime()));  
        // 下个月的今天  
        c.setTime(now);  
        c.add(Calendar.MONTH, 1);  
        System.out.println("下个月的今天:\t" + format(c.getTime()));  
        // 去年的今天  
        c.setTime(now);  
        c.add(Calendar.YEAR, -1);  
        System.out.println("去年的今天:\t" + format(c.getTime()));  
        // 上个月的第三天  
        c.setTime(now);  
        c.add(Calendar.MONTH, -1);  
        c.set(Calendar.DATE, 3);  
        System.out.println("上个月的第三天:\t" + format(c.getTime()));  
    }  
    private static String format(Date time) {  
        return sdf.format(time);  
    }  
}
```

> [!NOTE]
> 对日期需要**修改**的时候**用 Calendar**，直接获取当前日期用 Date

## Java 中级

### 异常处理

### I/O


### 集合框架


### 泛型





