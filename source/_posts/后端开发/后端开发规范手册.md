---
title: 后端开发规范手册
date: 2023-12-23 15:16:24
tags:
  - rules
sticky: 60
excerpt: 关于后端开发的程序和包的命名规范。
author: fcs
index_img: https://picsum.photos/800/250
lang: zh-CN
header-left: "![](D:/开发图片/logo32.png)"
---

![](https://picsum.photos/800/250)

# Spring应用程序编码和命名规范


SpringBoot项目目录结构

    SpringBoot项目目录结构是有命名规范的，编码和命名反映了对应模块的功能。

---
##     一、规范的意义和作用

- 编码规范可以最大限度的提高团队开发的合作效率
- 编码规范可以尽可能的减少一个软件的维护成本 , 并且几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护
- 编码规范可以改善软件的可读性，可以让开发人员尽快而彻底地理解新的代码
- 规范性编码还可以让开发人员养成好的编码习惯，甚至锻炼出更加严谨的思维

---
##     二、代码仓库规范

###     （一）公共组件

- 公共组件通常指Java库，提供特定问题的处理程序包
- 公共组件仓库地址：[https://git.company.com/java-library-group](https://git.company.com/java-library-group)
- 公共组件的坐标命名规范
    - 分组编号：<groupId>com.company.library</groudId> 固定取值
    - 组件名称：<artifactId>name</artifactId> name根据组件名称定义
    - 组件版本：<version>x.y.z</versio> x.y.z根据组件实际版本情况定义

###     （二）服务组件

- 服务组件通常指可以独立部署，运行，维护的服务程序包
- 服务组件仓库地址：[https://git.company.com/server-microservice-group](https://git.company.com/server-microservice-group)
- 应用组件的坐标命名规范
    - 分组编号：<groupId>com.company.server</groudId>固定取值
    - 组件名称：<artifactId>name</artifactId> name根据组件名称定义
    - 组件版本：<version>x.y.z</versio> x.y.z根据组件实际版本情况定义

---
##     三、开发环境规范

- 开发环境：JDK8+
- 开发工具：IntelliJ IDEA 2017（安装Lombok Plugin）
- 构建工具：Maven3.x
- 代码管理工具：Git /TortoiseGit

---
##     四、项目结构规范

###     （一）简述

    一个项目对应代码仓库中的一个仓库，项目结构是指一个基于Maven创建的项目目录结构。公共组件项目，通常会创建一个Maven普通项目。服务组件项目，通常会创建一个Maven聚合项目，并在聚合项目目录下创建多个继承Maven聚合项目的Maven模块，它们一起作为服务组件项目的组成部分。

###     （二）项目名

- 要求
    - 英文名称，作为仓库，项目，项目根目录，组件（公共组件，服务组件）的名称
    - 中文名称，用于代码仓库的描述
    - 项目名称和代码仓库的名称保持一致
- 定义
    - 项目名称通常由团队负责人确定
- 示例
    - 项目中文名：人脸数据仓库
    - 项目英文名：data-warehouse-face
    - 项目目录名：data-warehouse-face
    - 项目仓库地址：[https://git.company.com/server-microservice-group/data-warehouse-face.git](https://git.company.com/server-microservice-group/data-warehouse-face.git)
    - 初始版本：1.0.0
    - 示例是一个服务组件，根据上面定义的信息确定该服务组件的Maven坐标命名：

`<groupId>com.company.server</groupId> <artifactId>data-warehouse-face</artifactId> <version>1.0.0</version>`

###     （三）模块命名

- 要求示例
    - 模块名称：{项目名称}-{模块名称} 模块名称简洁体现职责
    - 模块名字作为模块组件的名称
- 人脸数据仓库的数据接入模块名称：data-warehouse-face-access

###     （四）项目目录

- 项目目录遵循Maven约定目录格式

###     （五）源码目录

- 源码目录指：{项目目录}/src/main/
- 打包定义目录：src/main/assembly
- 代码目录：src/main/java
- 资源目录：src/main/resources文档目录：src/main/docs
    - /db：数据库脚本归档
    - /data：内部依赖数据归档
- 脚本目录：src/main/bin
    - run-manage.sh 运行管理脚本（通过参数start, stop, status, help info控制程序运行）
    - sh：服务组件启动脚本
    - sh：服务组件停止脚本

---
##     五、编码规范

###     （一）包规范

- 项目基本包：com.company.{项目英文名（较长时适当简化）}.{模块名（可选）}
- config：配置类
- startup：与服务启动相关的类
- client：提供客户端实现的相关类
- common：公共类，定义常量类，组件
- entity: 数据库相关的实体类
- model:数据模型类(参数模型，数据传输模型等）
- control:控制层接口
- service: 服务层
- dao：数据库访问层

**POJO**

POJO（Plain Old Java Object）是指***普通的 Java 对象***，没有任何特殊的注解或功能。POJO 通常用于表示数据，例如用户、商品等。

**Entity**

***Entity 是指数据库中的表对应的对象***。Entity 通常具有以下特性：

* 具有对应表中的所有字段。
* 具有默认的构造方法和 getter/setter 方法。
* 具有 equals()、hashCode() 和 toString() 方法。

**Model**

其属性字段可能不与entity一一对应，Model是一个高度优化组合或者精简后的一个用于在View层展示数据的对象。（*可能为多个entity的某些属性组合，也可能为单一entity的精简，具体结合业务需求来决定*。）
根据实际开发中来看，model作为包命名，包内一般写与前端交互的response和request，根据业务需要的数据将entity中一个或多个字段数据封装成res和req。

**VO**

VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。

VO与DTO都是展示层与服务层之间传递数据的对象，那为什么区分成两个呢，参考论坛老哥——对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，***DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据***。

VO（Value Object）是指用于传输数据的对象。VO 通常具有以下特性：

* 只包含业务数据，不包含业务逻辑。
* 通常是简单的对象，没有太多的字段。

**DTO**

***DTO（数据传输对象）封装的数据面向表现层（UI），Model封装的数据面向业务逻辑层（service）***。开发中模型改了但是UI没变，则只需要改变model，而不需要改其他。
DTO（Data Transfer Object）是指用于传输数据的对象。DTO 通常具有以下特性：
* 与 VO 类似，只包含业务数据，不包含业务逻辑。
* 通常是复杂的对象，具有较多的字段。
在用户修改密码的controller中，我们可能只需要拿到用户名、用户密码和用户修改新密码，即可对数据库进行操作，则我们把用户密码和用户修改新密码封装为一个dto类型，只拿到自己需要的类型

**Domain**

Domain 是指业务领域中的对象。Domain 通常具有以下特性：

* 可以是 Entity、Model、VO 或 DTO 的组合。
* 可以包含业务逻辑。

**区别**

POJO、Entity、Model、VO、Dto、Domain 的区别如下表所示：

| 特性 | POJO | Entity | Model | VO | DTO | Domain |
|---|---|---|---|---|---|---|
| 作用 | 表示数据 | 表示数据库中的表 | 表示业务数据 | 传输数据 | 传输数据 | 业务领域中的对象 |
| 特性 | 没有特殊的注解或功能 | 具有对应表中的所有字段，具有默认的构造方法和 getter/setter 方法，具有 equals()、hashCode() 和 toString() 方法 | 具有 Entity 的所有特性，可以包含业务逻辑 | 只包含业务数据，不包含业务逻辑 | 与 VO 类似，只包含业务数据，不包含业务逻辑 | 可以是 Entity、Model、VO 或 DTO 的组合，可以包含业务逻辑 |
| 使用场景 | 用于表示数据，例如用户、商品等 | 用于表示数据库中的表，通常用于持久化数据 | 用于表示业务数据，例如用户、商品等 | 用于传输数据，例如用于前端与后端的通信 | 用于传输数据，例如用于前端与后端的通信 | 用于表示业务领域中的对象，例如订单、商品等 |



###     （二）日志记录

- 统一使用SLF4j接口

###     （三）异常处理

- 运行时异常：通过参数检查等方式避免或抛出运行时异常，日志记录
- 检查异常：检查异常需要捕获，处理，日志记录

###     （四）接口定义

- 原则
    - 接口地址定义表明用意
    - 接口地址定义清晰，简洁，无歧义
    - 同一个服务组件的接口定义具有一致性
- 格式
    - 控制类的顶层地址格式:/{顶层分类名}，例如：/library 人员库相关接口的顶层地址
    - 接口定义使用Swagger的API注解说明
    - 标注完整的请求信息，请求方法，请求地址，参数可选性，接口描述
- 请求方式
    - GET URL-Params
    - POST Form-Data
    - POST RequestBody(JSON格式)
    - POST Mulitpart
- 响应方式
    - 统一的响应模型

###     （五）辅助工具

- 字符串处理：apache common-lang3
- 时间日期处理：joda-time
- JSON处理：Gson，Fastjson
- 集合扩展工具：guava
- 文件和流处理：commons-io
- 编解码：commons-codec
- 建议：尽可能使用开源组件

###     （六）代码注释

- 类、接口、枚举顶层注释
- 接口方法注释
- 静态方法注释
- 公开方法注释
- 类的属性字段注释
- 常量注释
- 不限于以上

---
##     六、代码控制规范

###     （一）拉取原则

- 强制
    - 每日开始工作拉取
- 约定
    - 提交之前拉取

###     （二）提交原则

- 强制
    - 提交代码必须构建成功（比如：编译，打包成共）
    - 提交代码必须完整（比如：少提文件）
    - 提交代码必须忽略到本地临时文件（比如：target, logs, .idea, *.iml,dist 等）
- 约定
    - 完成一个功能提交
    - 修改一个Bug修改提交
    - 解决冲突提交
    - 每日结束工作提交

###     （三）提交注释

- 强制
    - 中文填写注释
    - 注释反映本次提交变更情况
- 约定
    - 注释描述添加前缀，前缀如下
    - [创建] 通常在项目创建时使用
    - [新增]
    - [修改]
    - [删除]
    - [修复-number] 修复Bug使用，number是Bug编号

---
##     七、构建规范

###     （一）公共组件构建规范

- 构建输出组件包
- 构建输出组件源码包
- 构建发布到公司私有仓库

###     （二）服务组件构建规范

- 服务组件包命名：{组件名称}-{版本号}-bin.zip
- 构建输出到工程根目录下的dist/{组件名称}-{yyyyMMddHH}目录


---
# 参考

1. [SpringBoot编码规范和命名规则 - Judy\_Zhu - 博客园](https://www.cnblogs.com/zero-legend/p/14057772.html)