

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="http://qnpicmap.fcsluck.top/pics/202311162214229.png">
  <link rel="icon" href="http://qnpicmap.fcsluck.top/pics/202311162214229.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="fcs">
  <meta name="keywords" content="">
  
    <meta name="description" content="一些关于springcloud alibaba微服务框架中间件的学习记录。">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringCloud Alibaba-微服务进阶">
<meta property="og:url" content="https://alleyf.github.io/2023/11/c09639791c22.html">
<meta property="og:site_name" content="alleyf">
<meta property="og:description" content="一些关于springcloud alibaba微服务框架中间件的学习记录。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picsum.photos/800/250">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/V1dFqQMR7T2GzSJ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/pQkSrLx9NZRn8Ub.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/VStPIABaXxMp2N9.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/wWbuXRGizrQCT8J.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/bM8doEZPth7DHfe.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/O3pMSvDbxPKYT5q.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/sbKTUqhLViIfrmR.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/dom3WpJsiajgCE7.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/9PLBGOXoaERnUwM.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/K6VBtqEWSLnMp21.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/HIGvXAad1EOVPt6.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/WZGdJ5BYpmbMuNT.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/GCrm8wgWXLzYhtK.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/p6iYrPa8e1btZkl.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/jCl8RGhaIiUDBgm.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/2bWdfmnVOyGzlZr.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/cF5MoVX6vNnzx9j.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/FdRTjlKszDoOPU3.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/R5Jyhl29UcvuOCb.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/szyGRrEfZ1KWmpj.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/wlO9dQ1NtKCxFTi.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/cwIhdCMmATELvlN.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/jrYo3epaLMyQnu4.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/s1ko9UcD4mMQ5fW.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/1pAckEZN5ltXKWG.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/6j2pAmdfyIGz9Cu.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/7ACoW3txIsjLzu2.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/alFpWGfNejImQEw.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/5J4FfMgtGwZhP3C.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/9xthuBpgFs4PTSq.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/kacrSVGYMpwK2jx.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/YLC2H6yGoVi5z1f.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/isTaOUQwMVWGCY9.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/dR4thB5JTk1cGjm.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/7itUIhz3NupRdr6.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/DC2I1MvVFjYmPEq.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Ek4APjgGcqbitNm.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/H1AvxOK78yspP5k.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Fuxq9Dl3rGfnTZA.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/97suBpfdeF54rc2.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/cf76RJ9VUiQBlje.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/RW4JIBKVXSbG3lZ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/2pe51dHQsJkPVY7.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/5CbEGQ7rX2StUkR.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/kQF3lN24vcBqzDi.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/PQYi69aKZUXrNlJ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Lbf14V39SCdghvO.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/gVuMlAXcY34Ka2C.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/2hrxcizHPvSq8be.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/gdh43ciamLnBRFV.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/xnmustzRkFZJWIP.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/oZdLMAJaCD3Uw9F.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Hjm4Z38s95YiFvI.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/RfVAdtOqJjWlx6E.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/QpVRTYtBX6kvj2b.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/p4KTaDd1wc5BR92.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/pzOus21AWqLfr9k.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/dMZVz3kDRxYaHg5.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/F1RxtgBZNQvWpw8.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/XRnKgCivsqFE2ax.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/8MyG3WDo1wSBb5Y.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/4fPg72OJiwhDycL.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Lrw7ZJNzyDUoYG8.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/E9vnJRTPZmzaW8V.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/QgqsxdvYF59P7ne.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/tnKXB2JUarehk5T.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/FOzJdtoieAxIvPq.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/UHbcgSWV2exNCu1.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/MHiDyU54L3QsNrc.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/PfVOQWJrTiZGqh7.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/p1Y53LPihOGZjBV.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/pk1HjSi9VyxwOJQ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/fIlhGM3jPxb7wgS.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/hskQVKnE2y5PftO.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/nC6W5T4OGcJNypA.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/WVguflyZ43NxE7j.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/oipjTJBHsMSdDvc.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/AxrzjvtPWJ2YCZI.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/CbYxA3d7w46OlMm.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/gY62LD3vw157WiU.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/7BW6LGXQNl5b1Iv.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/ExWIKFSNpPoksiT.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/CmdPgcqvX4a2u9p.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Dz3EgG9eH4UXTkJ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/jSp92ODTRhlxJsn.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/FfhalnZdS2ujm1t.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/CugOUozGA6inB3R.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/XC1VekDfainIpv6.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/QkofY5gzwSr6WGn.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/5kLcAaT6wJgYXGx.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/M2yZpJLfs1i9adC.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/8OCeNap2Vy6X7WH.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/AiEXC3wBflPxHGT.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/jDAy7osQ5YIqruP.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/TvJL2PiWFU4XoaZ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/WjEcGbtkNrZi1CL.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/MPkZb1dA2Khjcty.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/H43Fy9z76LIvJGd.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/l9D8aXBxkvnZejw.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/BWiUzFrjHAao1kJ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/LsUq3AvrfhQJPCz.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/vLTZFS4yn26uabA.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/ykH1BSPcxlvY4on.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/NIe9QFW3jf1DdnV.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/LwcdO2HuWAhFr5p.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/6VOfsp9UxYJzgKD.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/yEQa2qeiNc5npV9.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/VtBlx4U1TzcqKra.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/WXn9UPgxBVhdHmb.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/93mXN5dlC2GTLOW.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/1tPwBFn7u3ScCeY.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/8yTQGZluYVe1cg2.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/UBchb4zPjHAfCSs.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/PSbw5TFhm74Wu3n.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/nZUcuM2kJ86zgBv.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Fn3R2Jrq1YyleCh.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/Cph9zPF2kaSvKdY.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/dlmYNnARZaxJ5MH.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/7zvewSLhFmbc8G1.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/G7qQoEy8DCX9bLJ.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/qoNhgzM2PXpZU9B.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/06/9LnaoUxHzlY1GdV.png">
<meta property="og:image" content="https://cn.dubbo.apache.org/imgs/v3/concepts/architecture-2.png">
<meta property="og:image" content="http://qnpicmap.fcsluck.top/pics/202311211438260.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/9a2q4ZBuWxJs861.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/yknBVt2jGgFSTO8.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/HxtXlqi7BUYWdC2.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/eEJMsxhc5Onpld8.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/j5kIgD9ZRQiGtd6.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/GWkUJx1g8ZnTV57.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/PzehXHuDyFANIKV.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/9cGyunKrTvjfDRp.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/GDnFoizW86pC5l9.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/lIpfxGjLPrOatE5.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/DnpENxIPgOUTSbM.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/q7WcUvZp8NhMb9f.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/D8hv6Kbo3eSNzVp.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/yGSt4HbT7iX3Nze.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/NGCFKhcUf9lOADX.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/NGCFKhcUf9lOADX.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/u95NJG2YskOBpXl.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/MBIDVqzf8oce2L4.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/htEoZ49zu6mipCM.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/nO9eUjMRbCmBqPT.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/emrY3SZ98CJRAOh.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/nrWPuoGRTp7F36e.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/c6auDXoHFqZT9M2.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/t5V3yQ8kbOKRpxf.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/LCVPvykIjMox9m1.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/9jsdfADB5HRC7wP.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/cYPwJnbiZlmvqD3.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/kJE5xwgZOTGWjLq.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/baiDgVyoPQ65TMX.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/5lENjHswniC4Zg8.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/rR7eThxXbufjsEo.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/UxVemu9B2cGifWv.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/RjY4JUn7v9pmryx.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/ZjRs8u2cHbBEOaW.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/RwUFdgqXlDKk7AI.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/OkV6zN9PJRlwnQF.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/3dXbs5naViUMrDO.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/aM8SCL12hkKynUu.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/xVSpC7KHE1RyOk6.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/Q9tBuprGwfleNLZ.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/itUWySuA9kvcEgs.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/AdrS9yxnRojfWgL.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/mLokEWYcQ4PXnar.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/rgiWVJMbpKzQX46.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/u8xboyv3aTJ9ZE6.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/2qensPxuf3zLoQ1.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/56TsMf24QlhZCYL.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/d3lEHLPR4VNF92T.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/8AR4H5LbOCrXZmu.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/YgibmNxD9qtHajQ.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/Rv6YkDSTPl83Hmo.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/UNEniupt5cRHz93.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/KgWzOUu8ry2V9Ej.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/vmAfh68GpuQXdUk.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/REl1qIaMXLTK6js.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/fetLjQszH7cTZmO.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/Er7RBCjm3nNJZHT.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/pFXEmbv7LCMKxwq.jpg">
<meta property="og:image" content="http://qnpicmap.fcsluck.top/pics/202311231107309.png">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/52vs9bualApXGMR.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/n9NxMEsoCeWSaVL.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/z45gI7UaKmCipEL.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/aS37QitoUdf4FZ9.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/CWfRIwoYLjQrbpH.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/s7B38pjkd4EGFLI.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/VsD2dYIpHhbt6R9.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/EM4WKHqtyz3vLSk.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/vHKPqJFahV8y7l3.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/vHKPqJFahV8y7l3.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/NApBodythmfjzMV.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/NApBodythmfjzMV.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/VWvry9TSDBinatH.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/pJefuIUXzNHhsxP.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/pvc8udVL9EwMW56.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/1fBHoQe6gc7XizO.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/mN4EfOehP8Ta2JC.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/kUelcRgb7MrGdB6.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/lzDjiI9SLH1rVY3.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/cSPRdoY43gzVNXk.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/8TEv1KQGSNA9luY.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/lICtpeK2oAGZynD.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/UfTVhAiOnMqoPX7.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/2VdCOuPLAb9Qhfx.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/H3szAX82xhpWw6j.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/03/08/LoviBfecC1DbMOg.jpg">
<meta property="article:published_time" content="2023-11-16T07:49:01.000Z">
<meta property="article:modified_time" content="2023-12-13T11:53:09.164Z">
<meta property="article:author" content="alleyf">
<meta property="article:tag" content="springcloud">
<meta property="article:tag" content="SpringCloud-Alibaba">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picsum.photos/800/250">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>SpringCloud Alibaba-微服务进阶 - alleyf</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"alleyf.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"d57048846da607439cf11718741f2eb0","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?d57048846da607439cf11718741f2eb0";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  



  
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="alleyf" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mr.Alleyf</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gallery/">
                <i class="iconfont icon-images"></i>
                画廊
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://api.likepoems.com/img/nature') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="SpringCloud Alibaba-微服务进阶"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        fcs
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-16 15:49" pubdate>
          2023年11月16日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          77k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          639 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SpringCloud Alibaba-微服务进阶</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：12 天前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><img src="https://picsum.photos/800/250" srcset="/img/loading.gif" lazyload></p>
<p>SpringCloudAlibaba、SpringCloud和SpringBoot版本之间有着一定的依赖关系，必须使用正确的版本才能有效，具体版本依赖关系可见<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">版本说明 · alibaba&#x2F;spring-cloud-alibaba Wiki · GitHub</a></p>
<h1 id="微服务进阶"><a href="#微服务进阶" class="headerlink" title="微服务进阶"></a>微服务进阶</h1><p><img src="https://s2.loli.net/2023/03/06/V1dFqQMR7T2GzSJ.png" srcset="/img/loading.gif" lazyload alt="image-20230306230950443"><br>前面我们了解了微服务的一套解决方案，但是它是基于 Netflix 的解决方案，实际上我们发现，很多框架都已经停止维护了，来看看目前我们所认识到的 SpringCloud 各大组件的维护情况：</p>
<ul>
<li><strong>注册中心：</strong> Eureka（属于<em>Netflix</em>，2. x 版本不再开源，1. x 版本仍在更新）</li>
<li><strong>服务调用：</strong> Ribbon（属于<em>Netflix</em>，停止更新，已经彻底被移除）、SpringCloud Loadbalancer（属于<em>SpringCloud</em>官方，目前的默认方案）</li>
<li><strong>服务降级：</strong> Hystrix（属于<em>Netflix</em>，停止更新，已经彻底被移除）</li>
<li><strong>路由网关：</strong> Zuul（属于<em>Netflix</em>，停止更新，已经彻底被移除）、Gateway（属于<em>SpringCloud</em>官方，推荐方案）</li>
<li><strong>配置中心：</strong> Config（属于<em>SpringCloud</em>官方）</li>
</ul>
<p>可见，我们之前使用的整套解决方案中，超过半数的组件都已经处于不可用状态，并且部分组件都是 SpringCloud 官方出手提供框架进行解决，因此，寻找一套更好的解决方案势在必行，也就引出了我们本章的主角：<strong>SpringCloud Alibaba</strong><br>阿里巴巴作为业界的互联网大厂，给出了一套全新的解决方案，官方网站（中文）： <a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/2021/zh-cn/index.html">https://spring-cloud-alibaba-group.github.io/github-pages/2021/zh-cn/index.html</a></p>
<blockquote>
<p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p>
<p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p>
</blockquote>
<p>目前 Spring Cloud Alibaba 提供了如下功能:</p>
<ol>
<li><strong>服务限流降级</strong>：支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Dubbo 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li>
<li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li>
<li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li>
<li><strong>Rpc 服务</strong>：扩展 Spring Cloud 客户端 RestTemplate 和 OpenFeign，支持调用 Dubbo RPC 服务</li>
<li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li>
<li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解，高效并且对业务零侵入地解决分布式事务问题。</li>
<li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li>
<li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li>
<li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li>
</ol>
<p>可以看到，SpringCloudAlibaba 实际上是对我们的 SpringCloud 组件增强功能，是 SpringCloud 的增强框架，可以兼容 SpringCloud 原生组件和 SpringCloudAlibaba 的组件。<br>开始学习之前，把我们之前打包好的拆分项目解压，我们将基于它进行讲解。</p>
<hr>
<p><img src="https://s2.loli.net/2023/03/06/pQkSrLx9NZRn8Ub.png" srcset="/img/loading.gif" lazyload alt="image-20230306230942876"></p>
<h2 id="Nacos-更加全能的注册中心"><a href="#Nacos-更加全能的注册中心" class="headerlink" title="Nacos 更加全能的注册中心"></a>Nacos 更加全能的注册中心</h2><p>Nacos（<strong>Na</strong>ming <strong>Co</strong>nfiguration <strong>S</strong>ervice）是一款阿里巴巴开源的服务注册与发现、配置管理的组件，相当于是 Eureka+Config 的组合形态。</p>
<h3 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>Nacos 服务器是独立安装部署的，因此我们需要下载最新的 Nacos 服务端程序，下载地址： <a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a> ，连不上可以到视频下方云盘中下载。<br><img src="https://s2.loli.net/2023/03/06/VStPIABaXxMp2N9.png" srcset="/img/loading.gif" lazyload alt="image-20230306231045825"><br>可以看到目前最新的版本是 <code>1.4.3</code> 版本（2022 年 2 月 27 日发布的），我们直接下载 <code>zip</code> 文件即可。<br>接着我们将文件进行解压，得到以下内容：<br><img src="https://s2.loli.net/2023/03/06/wWbuXRGizrQCT8J.png" srcset="/img/loading.gif" lazyload alt="image-20230306231054919"><br>我们直接将其拖入到项目文件夹下，便于我们一会在 IDEA 内部启动，接着添加运行配置：<br><img src="https://s2.loli.net/2023/03/06/bM8doEZPth7DHfe.png" srcset="/img/loading.gif" lazyload alt="image-20230306231104823"><br>其中 <code>-m standalone</code> 表示单节点模式，Mac 和 Linux 下记得将解释器设定为 <code>/bin/bash</code>，由于 Nacos 在 Mac&#x2F;Linux 默认是后台启动模式，我们修改一下它的 bash 文件，让它变成前台启动，这样 IDEA 关闭了 Nacos 就自动关闭了，否则开发环境下很容易忘记关：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注释掉 nohup $JAVA $&#123;JAVA_OPT&#125; nacos.nacos &gt;&gt; $&#123;BASE_DIR&#125;/logs/start.out 2&gt;&amp;1 &amp;</span><br><span class="hljs-comment"># 替换成下面的</span><br><span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> nacos.nacos<br></code></pre></td></tr></table></figure>
<p>接着我们点击启动：<br><img src="https://s2.loli.net/2023/03/06/O3pMSvDbxPKYT5q.png" srcset="/img/loading.gif" lazyload alt="image-20230306231113946"><br>OK，启动成功，可以看到它的管理页面地址也是给我们贴出来了： <a target="_blank" rel="noopener" href="http://localhost:8848/nacos/index.html">http://localhost:8848/nacos/index.html</a> ，访问这个地址：<br><img src="https://s2.loli.net/2023/03/06/sbKTUqhLViIfrmR.png" srcset="/img/loading.gif" lazyload alt="image-20230306231125828"><br>默认的用户名和管理员密码都是 <code>nacos</code>，直接登陆即可，可以看到进入管理页面之后功能也是相当丰富：<br><img src="https://s2.loli.net/2023/03/06/dom3WpJsiajgCE7.png" srcset="/img/loading.gif" lazyload alt="image-20230306231150574"><br>至此，Nacos 的安装与部署完成。</p>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>现在我们要实现基于 Nacos 的服务注册与发现，那么就需要导入 SpringCloudAlibaba 相关的依赖，我们在父工程将依赖进行管理：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      	<span class="hljs-comment">&lt;!-- 这里引入最新的SpringCloud依赖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>          	<span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>     	  <span class="hljs-comment">&lt;!-- 这里引入最新的SpringCloudAlibaba依赖，2021.0.1.0版本支持SpringBoot2.6.X --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>接着我们就可以在子项目中添加<strong>服务发现依赖</strong>了，比如我们以图书服务为例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>和注册到 Eureka 一样，我们也需要在配置文件中配置 Nacos 注册中心的地址：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-comment"># 之后所有的图书服务节点就81XX端口</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8101</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://cloudstudy.mysql.cn-chengdu.rds.aliyuncs.com:3306/cloudstudy</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>  <span class="hljs-comment"># 应用名称 bookservice</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">bookservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-comment"># 配置Nacos注册中心地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure>
<p>接着启动我们的图书服务，可以在 Nacos 的服务列表中找到：<br><img src="https://s2.loli.net/2023/03/06/9PLBGOXoaERnUwM.png" srcset="/img/loading.gif" lazyload alt="image-20230306231202683"><br>按照同样的方法，我们接着将另外两个服务也注册到 Nacos 中：<br><img src="https://s2.loli.net/2023/03/06/K6VBtqEWSLnMp21.png" srcset="/img/loading.gif" lazyload alt="image-20230306231211930"><br>接着我们使用 OpenFeign，实现<strong>服务发现远程调用以及负载均衡</strong>，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里需要单独导入LoadBalancer依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>编写接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;userservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/user/&#123;uid&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;bookservice&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/book/&#123;bid&#125;&quot;)</span><br>    Book <span class="hljs-title function_">getBookById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bid&quot;)</span> <span class="hljs-type">int</span> bid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span><span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById(uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream()<br>                .map(b -&gt; bookClient.getBookById(b.getBid()))<br>                .collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span>(user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run (BorrowApplication. class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着我们进行测试：<br><img src="https://s2.loli.net/2023/03/06/HIGvXAad1EOVPt6.png" srcset="/img/loading.gif" lazyload alt="image-20230306231226300"><br>测试正常，可以自动发现服务，接着我们来多配置几个实例，去掉图书服务和用户服务的端口配置：<br><img src="https://s2.loli.net/2023/03/06/WZGdJ5BYpmbMuNT.png" srcset="/img/loading.gif" lazyload alt="image-20230306231234119"><br>然后我们在图书服务和用户服务中添加一句打印方便之后查看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/&#123;uid&#125;&quot;</span>)<br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>    System.out.println (<span class="hljs-string">&quot;调用用户服务&quot;</span>);<br>    <span class="hljs-keyword">return</span> service.getUserById (uid);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在将全部服务启动：<br><img src="https://s2.loli.net/2023/03/06/GCrm8wgWXLzYhtK.png" srcset="/img/loading.gif" lazyload alt="image-20230306231244149"><br>可以看到 Nacos 中的实例数量已经显示为 <code>2</code>：<br><img src="https://s2.loli.net/2023/03/06/p6iYrPa8e1btZkl.png" srcset="/img/loading.gif" lazyload alt="image-20230306231251732"><br>接着我们调用借阅服务，看看能否负载均衡远程调用：<br><img src="https://s2.loli.net/2023/03/06/jCl8RGhaIiUDBgm.png" srcset="/img/loading.gif" lazyload alt="image-20230306231259820"><br><img src="https://s2.loli.net/2023/03/06/2bWdfmnVOyGzlZr.png" srcset="/img/loading.gif" lazyload alt="image-20230306231306653"><br>OK，负载均衡远程调用没有问题，这样我们就实现了基于 Nacos 的服务的注册与发现，实际上大致流程与 Eureka 一致。<br>值得注意的是，Nacos 区分了<strong>临时实例和非临时实例</strong>：<br><img src="https://s2.loli.net/2023/03/06/cF5MoVX6vNnzx9j.png" srcset="/img/loading.gif" lazyload alt="image-20230306231317971"><br>那么临时和非临时有什么区别呢？</p>
<ul>
<li>临时实例：和 Eureka 一样，采用心跳机制向 Nacos 发送请求保持在线状态，一旦心跳停止，代表实例下线，不保留实例信息。</li>
<li>非临时实例：由 Nacos 主动进行联系，如果连接失败，那么不会移除实例信息，而是将健康状态设定为 false，相当于会对某个实例状态持续地进行监控。</li>
</ul>
<p>我们可以通过配置文件进行修改临时实例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 将 ephemeral 修改为 false，表示非临时实例</span><br>        <span class="hljs-attr">ephemeral:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>接着我们在 Nacos 中查看，可以发现实例已经不是临时的了：<br><img src="https://s2.loli.net/2023/03/06/FdRTjlKszDoOPU3.png" srcset="/img/loading.gif" lazyload alt="image-20230306231328378"><br>如果这时我们关闭此实例，那么会变成这样：<br><img src="https://s2.loli.net/2023/03/06/R5Jyhl29UcvuOCb.png" srcset="/img/loading.gif" lazyload alt="image-20230306231337931"><br>只是将健康状态变为 false，而不会删除实例的信息。</p>
<h3 id="集群分区"><a href="#集群分区" class="headerlink" title="集群分区"></a>集群分区</h3><p>实际上集群分区概念在之前的 Eureka 中也有出现，比如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>		<span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8888/eureka</span><br>      <span class="hljs-comment"># 这个 defaultZone 是个啥玩意，为什么要用这个名称？为什么要要用这样的形式来声明注册中心？</span><br></code></pre></td></tr></table></figure>
<p>在一个分布式应用中，相同服务的实例可能会在不同的机器、位置上启动，比如我们的用户管理服务，可能在成都有 1 台服务器部署、重庆有一台服务器部署，而这时，我们在成都的服务器上启动了借阅服务，那么如果我们的借阅服务现在要调用用户服务，就应该优先选择同一个区域的用户服务进行调用，这样会使得响应速度更快。<br><img src="https://s2.loli.net/2023/03/06/szyGRrEfZ1KWmpj.png" srcset="/img/loading.gif" lazyload alt="image-20230306231411711"><br>因此，我们可以对部署在不同机房的服务进行分区，可以看到实例的分区是默认：<br><img src="https://s2.loli.net/2023/03/06/wlO9dQ1NtKCxFTi.png" srcset="/img/loading.gif" lazyload alt="image-20230306231402008"><br>我们可以直接在配置文件中进行修改：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-comment"># 修改为重庆地区的集群</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chongqing</span><br></code></pre></td></tr></table></figure>
<p>当然由于我们这里使用的是不同的启动配置，直接在启动配置中添加环境变量 <code>spring. cloud. nacos. discovery. cluster-name</code> 也行，这里我们将用户服务和图书服务两个区域都分配一个，借阅服务就配置为成都地区：<br><img src="https://s2.loli.net/2023/03/06/cwIhdCMmATELvlN.png" srcset="/img/loading.gif" lazyload alt="image-20230306231435388"><br>修改完成之后，我们来尝试重新启动一下（Nacos 也要重启），观察 Nacos 中集群分布情况：<br><img src="https://s2.loli.net/2023/03/06/jrYo3epaLMyQnu4.png" srcset="/img/loading.gif" lazyload alt="image-20230306231443247"><br>可以看到现在有两个集群，并且都有一个实例正在运行。我们接着去调用借阅服务，但是发现并没有按照区域进行优先调用，而依然使用的是轮询模式的负载均衡调用。<br>我们必须要提供 Nacos 的负载均衡实现才能开启区域优先调用机制，只需要在配制文件中进行修改即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chengdu</span><br>    <span class="hljs-comment"># 将 loadbalancer 的 nacos 支持开启，集成 Nacos 负载均衡</span><br>    <span class="hljs-attr">loadbalancer:</span><br>      <span class="hljs-attr">nacos:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p>现在我们重启借阅服务，会发现优先调用的是同区域的用户和图书服务，现在我们可以将成都地区的服务下线：<br><img src="https://s2.loli.net/2023/03/06/s1ko9UcD4mMQ5fW.png" srcset="/img/loading.gif" lazyload alt="image-20230306231453470"><br>可以看到，在下线之后，由于本区域内没有可用服务了，借阅服务将会调用重庆区域的用户服务。<br>除了根据区域优先调用之外，同一个区域内的实例也可以单独设置权重，Nacos 会优先选择权重更大的实例进行调用，我们可以直接在管理页面中进行配置：<br><img src="https://s2.loli.net/2023/03/06/1pAckEZN5ltXKWG.png" srcset="/img/loading.gif" lazyload alt="image-20230306231500731"><br>或是在配置文件中进行配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>        <span class="hljs-attr">cluster-name:</span> <span class="hljs-string">Chengdu</span><br>        <span class="hljs-comment"># 权重大小，越大越优先调用，默认为 1</span><br>        <span class="hljs-attr">weight:</span> <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure>
<p>通过配置权重，某些性能不太好的机器就能够更少地被使用，而更多的使用那些网络良好性能更高的主机上的实例。</p>
<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>前面我们学习了 SpringCloud Config，我们可以通过配置服务来加载远程配置，这样我们就可以在远端集中管理配置文件。<br>实际上我们可以在 <code>bootstrap. yml</code> 中配置远程配置文件获取，然后再进入到配置文件加载环节，而 Nacos 也支持这样的操作，使用方式也比较类似，比如我们现在想要将借阅服务的配置文件放到 Nacos 进行管理，那么这个时候就需要在 Nacos 中创建配置文件：<br><img src="https://s2.loli.net/2023/03/06/6j2pAmdfyIGz9Cu.png" srcset="/img/loading.gif" lazyload alt="image-20230306231534251"><br>将借阅服务的配置文件全部（当然正常情况下是不会全部 CV 的，只会复制那些需要经常修改的部分，这里为了省事就直接全部 CV 了）复制过来，注意<strong>Data ID</strong>的格式跟我们之前一样，<code>应用名称-环境. yml</code>，如果只编写应用名称，那么代表此配置文件无论在什么环境下都会使用，然后每个配置文件都可以进行分组，也算是一种分类方式：<br><img src="https://s2.loli.net/2023/03/06/7ACoW3txIsjLzu2.png" srcset="/img/loading.gif" lazyload alt="image-20230306231514151"><br>完成之后点击发布即可：<br><img src="https://s2.loli.net/2023/03/06/alFpWGfNejImQEw.png" srcset="/img/loading.gif" lazyload alt="image-20230306231522828"><br>然后在项目中导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org. springframework. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. alibaba. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>接着我们在借阅服务中添加 <code>bootstrap. yml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>  	<span class="hljs-comment"># 服务名称和配置文件保持一致</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">profiles:</span><br>  	<span class="hljs-comment"># 环境也是和配置文件保持一致</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>      	<span class="hljs-comment"># 配置文件后缀名</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span><br>        <span class="hljs-comment"># 配置中心服务器地址，也就是 Nacos 地址</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br></code></pre></td></tr></table></figure>
<p>现在我们启动服务试试看：<br><img src="https://s2.loli.net/2023/03/06/5J4FfMgtGwZhP3C.png" srcset="/img/loading.gif" lazyload alt="image-20230306231605960"><br>可以看到成功读取配置文件并启动了，实际上使用上来说跟之前的 Config 是基本一致的。<br>Nacos 还支持<strong>配置文件的热更新</strong>，比如我们在配置文件中添加了一个属性，而这个时候可能需要实时修改，并在后端实时更新，那么这种该怎么实现呢？我们创建一个新的 Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;$&#123;test. txt&#125;&quot;</span>)  <span class="hljs-comment">//我们从配置文件中读取 test. txt 的字符串值，作为 test 接口的返回值</span><br>    String txt;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> txt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们修改一下配置文件，然后重启服务器：<br><img src="https://s2.loli.net/2023/03/06/9xthuBpgFs4PTSq.png" srcset="/img/loading.gif" lazyload alt="image-20230306231616512"><br>可以看到已经可以正常读取了：<br><img src="https://s2.loli.net/2023/03/06/kacrSVGYMpwK2jx.png" srcset="/img/loading.gif" lazyload alt="image-20230306231626447"><br>现在我们将配置文件的值进行修改：<br><img src="https://s2.loli.net/2023/03/06/YLC2H6yGoVi5z1f.png" srcset="/img/loading.gif" lazyload alt="image-20230306231634007"><br>再次访问接口，会发现没有发生变化：<br><img src="https://s2.loli.net/2023/03/06/isTaOUQwMVWGCY9.png" srcset="/img/loading.gif" lazyload alt="image-20230306231641913"><br>但是后台是成功检测到值更新了，但是值却没改变：<br><img src="https://s2.loli.net/2023/03/06/dR4thB5JTk1cGjm.png" srcset="/img/loading.gif" lazyload alt="image-20230306231656905"><br>那么如何才能实现配置热更新呢？我们可以像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span>   <span class="hljs-comment">//添加此注解就能实现自动刷新了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@Value</span> (<span class="hljs-string">&quot;$&#123;test. txt&#125;&quot;</span>)<br>    String txt;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> txt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重启服务器，再次重复上述实验，成功。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>我们还可以将配置文件或是服务实例划分到不同的命名空间中，其实就是区分开发、生产环境或是引用归属之类的：<br><img src="https://s2.loli.net/2023/03/06/7itUIhz3NupRdr6.png" srcset="/img/loading.gif" lazyload alt="image-20230306231706215"><br>这里我们创建一个新的命名空间：<br><img src="https://s2.loli.net/2023/03/06/DC2I1MvVFjYmPEq.png" srcset="/img/loading.gif" lazyload alt="image-20230306231713676"><br>可以看到在 dev 命名空间下，没有任何配置文件和服务：<br><img src="https://s2.loli.net/2023/03/06/Ek4APjgGcqbitNm.png" srcset="/img/loading.gif" lazyload alt="image-20230306231723164"><br>我们在不同的命名空间下，实例和配置都是相互之间隔离的，我们也可以在配置文件中指定当前的命名空间。</p>
<h3 id="实现高可用"><a href="#实现高可用" class="headerlink" title="实现高可用"></a>实现高可用</h3><p>由于 Nacos 暂不支持 Arm 架构芯片的 Mac 集群搭建，本小节用 Linxu 云主机（Nacos 比较吃内存，2 个 Nacos 服务器集群，至少 2G 内存）环境演示。<br>通过前面的学习，我们已经了解了如何使用 Nacos 以及 Nacos 的功能等，最后我们来看看，如果像之前 Eureka 一样，搭建 Nacos 集群，实现高可用。<br>官方方案： <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a><br><img src="https://s2.loli.net/2023/03/06/H1AvxOK78yspP5k.jpg" srcset="/img/loading.gif" lazyload alt="deployDnsVipMode.jpg"></p>
<blockquote>
<p><a href="http://ip1:port/openAPI">http://ip1:port/openAPI</a> 直连 ip 模式，机器挂则需要修改 ip 才可以使用。</p>
<p><a href="http://SLB:port/openAPI">http://SLB:port/openAPI</a> 挂载 SLB 模式 (内网 SLB，不可暴露到公网，以免带来安全风险)，直连 SLB 即可，下面挂 server 真实 ip，可读性不好。</p>
<p><a href="http://nacos.com:port/openAPI">http://nacos.com:port/openAPI</a> 域名 + SLB 模式 (内网 SLB，不可暴露到公网，以免带来安全风险)，可读性好，而且换 ip 方便，推荐模式</p>
</blockquote>
<p>我们来看看它的架构设计，它推荐我们在所有的 Nacos 服务端之前建立一个负载均衡，我们通过访问负载均衡服务器来间接访问到各个 Nacos 服务器。实际上就，是比如有三个 Nacos 服务器做集群，但是每个服务不可能把每个 Nacos 都去访问一次进行注册，实际上只需要在任意一台 Nacos 服务器上注册即可，Nacos 服务器之间会自动同步信息，但是如果我们随便指定一台 Nacos 服务器进行注册，如果这台 Nacos 服务器挂了，但是其他 Nacos 服务器没挂，这样就没办法完成注册了，但是实际上整个集群还是可用的状态。<br>所以这里就需要在所有 Nacos 服务器之前搭建一个 SLB（服务器负载均衡），这样就可以避免上面的问题了。但是我们知道，如果要实现外界对服务访问的负载均衡，我们就得用比如之前说到的 Gateway 来实现，而这里实际上我们可以用一个更加方便的工具：Nginx，来实现（之前我们没讲过，但是使用起来很简单，放心后面会带着大家使用）<br>关于 SLB 最上方还有一个 DNS（我们在 <code>计算机网络</code> 这门课程中学习过），这个是因为 SLB 是裸 IP，如果 SLB 服务器修改了地址，那么所有微服务注册的地址也得改，所以这里是通过加域名，通过域名来访问，让 DNS 去解析真实 IP，这样就算改变 IP，只需要修改域名解析记录即可，域名地址是不会变化的。<br>最后就是 Nacos 的数据存储模式，在单节点的情况下，Nacos 实际上是将数据存放在自带的一个嵌入式数据库中：<br><img src="https://s2.loli.net/2023/03/06/Fuxq9Dl3rGfnTZA.png" srcset="/img/loading.gif" lazyload alt="image-20230306231744022"><br>而这种模式只适用于单节点，在多节点集群模式下，肯定是不能各存各的，所以，Nacos 提供了 MySQL 统一存储支持，我们只需要让所有的 Nacos 服务器连接 MySQL 进行数据存储即可，官方也提供好了 SQL 文件。<br>现在就可以开始了，第一步，我们直接导入数据库即可，文件在 conf 目录中：<br><img src="https://s2.loli.net/2023/03/06/97suBpfdeF54rc2.png" srcset="/img/loading.gif" lazyload alt="image-20230306231753589"><br>我们来将其导入到数据库，可以看到生成了很多的表：<br><img src="https://s2.loli.net/2023/03/06/cf76RJ9VUiQBlje.png" srcset="/img/loading.gif" lazyload alt="image-20230306231802722"><br>然后我们来创建两个 Nacos 服务器，做一个迷你的集群，这里使用 <code>scp</code> 命令将 nacos 服务端上传到 Linux 服务器（注意需要提前安装好 JRE 8 或更高版本的环境）：<br><img src="https://s2.loli.net/2023/03/06/RW4JIBKVXSbG3lZ.png" srcset="/img/loading.gif" lazyload alt="image-20230306231811912"><br>解压之后，我们对其配置文件进行修改，首先是 <code>application. properties</code> 配置文件，修改以下内容，包括 MySQL 服务器的信息：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">### Default web server port:</span><br><span class="hljs-attr">server.</span> <span class="hljs-string">port=8801</span><br><span class="hljs-comment">#*************** Config Module Related Configurations ***************#</span><br><span class="hljs-comment">### If use MySQL as datasource:</span><br><span class="hljs-attr">spring.</span> <span class="hljs-string">datasource. platform=mysql</span><br><span class="hljs-comment">### Count of DB:</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">num=1</span><br><span class="hljs-comment">### Connect URL of DB:</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">url. 0=jdbc:mysql://cloudstudy. mysql. cn-chengdu. rds. aliyuncs. com: 3306/nacos? characterEncoding=utf 8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">user. 0=nacos</span><br><span class="hljs-attr">db.</span> <span class="hljs-string">password. 0=nacos</span><br></code></pre></td></tr></table></figure>
<p>然后修改集群配置，这里需要重命名一下：<br><img src="https://s2.loli.net/2023/03/06/2pe51dHQsJkPVY7.png" srcset="/img/loading.gif" lazyload alt="image-20230306231821488"><br>端口记得使用内网 IP 地址：<br><img src="https://s2.loli.net/2023/03/06/5CbEGQ7rX2StUkR.png" srcset="/img/loading.gif" lazyload alt="image-20230306231828707"><br>最后我们修改一下 Nacos 的内存分配以及前台启动，直接修改 <code>startup. sh</code> 文件（内存有限，玩不起高的）：<br><img src="https://s2.loli.net/2023/03/06/kQF3lN24vcBqzDi.png" srcset="/img/loading.gif" lazyload alt="image-20230306231836711"><br>保存之后，将 nacos 复制一份，并将端口修改为 8802，接着启动这两个 Nacos 服务器。<br><img src="https://s2.loli.net/2023/03/06/PQYi69aKZUXrNlJ.png" srcset="/img/loading.gif" lazyload alt="image-20230306231845850"><br>然后我们打开管理面板，可以看到两个节点都已经启动了：<br><img src="https://s2.loli.net/2023/03/06/Lbf14V39SCdghvO.png" srcset="/img/loading.gif" lazyload alt="image-20230306231854072"><br>这样，我们第二步就完成了，接着我们需要添加一个 SLB，这里我们用 Nginx 做反向代理：</p>
<blockquote>
<p><em>Nginx</em> (engine x) 是一个高性能的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTTP">HTTP</a> 和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a> web 服务器，同时也提供了 IMAP&#x2F;POP 3&#x2F;SMTP 服务。它相当于在内网与外网之间形成一个网关，所有的请求都可以由 Nginx 服务器转交给内网的其他服务器。</p>
</blockquote>
<p>这里我们直接安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install nginx<br></code></pre></td></tr></table></figure>
<p>可以看到直接请求 80 端口之后得到，表示安装成功：<br><img src="https://s2.loli.net/2023/03/06/gVuMlAXcY34Ka2C.png" srcset="/img/loading.gif" lazyload alt="image-20230306231903833"><br>现在我们需要让其代理我们刚刚启动的两个 Nacos 服务器，我们需要对其进行一些配置。配置文件位于 <code>/etc/nginx/nginx. conf</code>，添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs conf">#添加我们在上游刚刚创建好的两个nacos服务器<br>upstream nacos-server &#123;<br>        server 10.0.0.12:8801;<br>        server 10.0.0.12:8802;<br>&#125;<br>server &#123;<br>        listen   80;<br>        server_name  1.14.121.107;<br>        location /nacos &#123;<br>                proxy_pass http://nacos-server ;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重启 Nginx 服务器，成功连接：<br><img src="https://s2.loli.net/2023/03/06/2hrxcizHPvSq8be.png" srcset="/img/loading.gif" lazyload alt="image-20230306231912734"><br>然后我们将所有的服务全部修改为云服务器上 Nacos 的地址，启动试试看。<br><img src="https://s2.loli.net/2023/03/06/gdh43ciamLnBRFV.png" srcset="/img/loading.gif" lazyload alt="image-20230306231925001"><br>这样，我们就搭建好了 Nacos 集群。</p>
<blockquote>
<p>[!NOTE] Tips</p>
<ol>
<li>nacos 集群模式时<em>cluster.conf</em>必须配置的<strong>ip 是本地 ip 地址，不能是 127.0.0.1</strong></li>
<li>nacos 修改<em>application.properties</em>配置文件不生效，原因在于 bin 目录下的 startup 启动文件中设置的<strong>配置文件的位置不对</strong>(不能带 <code>optional:</code>)，要改为：<br>windows（startup.cmd）：<code>set &quot;NACOS_CONFIG_OPTS=--spring.config.additional-location=%CUSTOM_SEARCH_LOCATIONS%&quot;</code><br>linux（startup.sh）: <code>JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; --spring.config.additional-location=$&#123;CUSTOM_SEARCH_LOCATIONS&#125;&quot;</code></li>
</ol>
</blockquote>
<hr>
<p><img src="https://s2.loli.net/2023/03/06/xnmustzRkFZJWIP.png" srcset="/img/loading.gif" lazyload alt="image-20230306231932929"></p>
<h2 id="Sentinel-流量防卫兵"><a href="#Sentinel-流量防卫兵" class="headerlink" title="Sentinel 流量防卫兵"></a>Sentinel 流量防卫兵</h2><p><strong>注意：</strong> 这一章有点小绕，思路理清。<br>经过之前的学习，我们了解了微服务存在的雪崩问题，也就是说一个微服务出现问题，有可能导致整个链路直接不可用，这种时候我们就需要进行及时的熔断和降级，这些策略，我们之前通过使用 Hystrix 来实现。<br>SpringCloud Alibaba 也有自己的微服务容错组件，但是它相比 Hystrix 更加的强大。</p>
<blockquote>
<p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
</blockquote>
<p>Sentinel 具有以下特征:</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架&#x2F;库的整合模块，例如与 Spring Cloud、Apache Dubbo、gRPC、Quarkus 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。同时 Sentinel 提供 Java&#x2F;Go&#x2F;C++ 等多语言的原生实现。</li>
<li><strong>完善的 SPI 扩展机制</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h3 id="安装与部署-1"><a href="#安装与部署-1" class="headerlink" title="安装与部署"></a>安装与部署</h3><p>和 Nacos 一样，它是独立安装和部署的，下载地址： <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">https://github.com/alibaba/Sentinel/releases</a><br><img src="https://s2.loli.net/2023/03/06/oZdLMAJaCD3Uw9F.png" srcset="/img/loading.gif" lazyload alt="image-20230306231950297"><br>注意下载下来之后是一个 <code>jar</code> 文件（其实就是个 SpringBoot 项目），我们需要在 IDEA 中添加一些运行配置：<br><img src="https://s2.loli.net/2023/03/06/Hjm4Z38s95YiFvI.png" srcset="/img/loading.gif" lazyload alt="image-20230306232001525"><br>接着就可以直接启动啦，当然默认端口占用 8080，如果需要修改，可以添加环境变量：<br><img src="https://s2.loli.net/2023/03/06/RfVAdtOqJjWlx6E.png" srcset="/img/loading.gif" lazyload alt="image-20230306232012301"><br>启动之后，就可以访问到 Sentinel 的监控页面了，用户名和密码都是 <code>sentinel</code>，地址： <a target="_blank" rel="noopener" href="http://localhost:8858/#/dashboard">http://localhost:8858/#/dashboard</a><br><img src="https://s2.loli.net/2023/03/06/QpVRTYtBX6kvj2b.png" srcset="/img/loading.gif" lazyload alt="image-20230306232020492"><br>这样就成功开启监控页面了，接着我们需要让我们的服务连接到 Sentinel 控制台，老规矩，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. alibaba. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>然后在配置文件中添加 Sentinel 相关信息（实际上 Sentinel 是本地在进行管理，但是我们可以连接到监控页面，这样就可以图形化操作了）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">userservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>      	<span class="hljs-comment"># 添加监控页面地址即可</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br></code></pre></td></tr></table></figure>
<p>现在启动我们的服务，然后访问一次服务，这样 Sentinel 中就会存在信息了（懒加载机制，不会一上来就加载）：<br><img src="https://s2.loli.net/2023/03/06/p4KTaDd1wc5BR92.png" srcset="/img/loading.gif" lazyload alt="image-20230306232031800"><br><img src="https://s2.loli.net/2023/03/06/pzOus21AWqLfr9k.png" srcset="/img/loading.gif" lazyload alt="image-20230306232038728"><br>现在我们就可以在 Sentinel 控制台中对我们的服务运行情况进行实时监控了，可以看到监控的内容非常的多，包括时间点、QPS (每秒查询率)、响应时间等数据。<br>按照上面的方式，我们将所有的服务全部连接到 Sentinel 管理面板中。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>前面我们完成了对 Sentinel 的搭建与连接，接着我们来看看 Sentinel 的第一个功能，流量控制。<br>我们的机器不可能无限制的接受和处理客户端的请求，如果不加以限制，当发生高并发情况时，系统资源将很快被耗尽。为了避免这种情况，我们就可以添加流量控制（也可以说是限流）当一段时间内的流量到达一定的阈值的时候，新的请求将不再进行处理，这样不仅可以合理地应对高并发请求，同时也能在一定程度上保护服务器不受到外界的恶意攻击。<br>那么要实现限流，正常情况下，我们该采取什么样的策略呢？</p>
<ul>
<li>方案一：<strong>快速拒绝</strong>，既然不再接受新的请求，那么我们可以直接返回一个拒绝信息，告诉用户访问频率过高。</li>
<li>方案二：<strong>预热</strong>，依然基于方案一，但是由于某些情况下高并发请求是在某一时刻突然到来，我们可以缓慢地将阈值提高到指定阈值，形成一个缓冲保护。</li>
<li>方案三：<strong>排队等待</strong>，不接受新的请求，但是也不直接拒绝，而是进队列先等一下，如果规定时间内能够执行，那么就执行，要是超时就算了。</li>
</ul>
<p>针对于是否超过流量阈值的判断，这里我们提 4 种算法：</p>
<ol>
<li><p><strong>漏桶算法</strong></p>
<p>顾名思义，就像一个桶开了一个小孔，水流进桶中的速度肯定是远大于水流出桶的速度的，这也是最简单的一种限流思路：</p>
<p><img src="https://s2.loli.net/2023/03/06/dMZVz3kDRxYaHg5.png" srcset="/img/loading.gif" lazyload alt="image-20230306232054430"></p>
<p>我们知道，桶是有容量的，所以当桶的容量已满时，就装不下水了，这时就只有丢弃请求了。</p>
<p>利用这种思想，我们就可以写出一个简单的限流算法。</p>
</li>
<li><p><strong>令牌桶算法</strong></p>
<p>只能说有点像信号量机制。现在有一个令牌桶，这个桶是专门存放令牌的，每隔一段时间就向桶中丢入一个令牌（速度由我们指定）当新的请求到达时，将从桶中删除令牌，接着请求就可以通过并给到服务，但是如果桶中的令牌数量不足，那么不会删除令牌，而是让此数据包等待。</p>
<p><img src="https://s2.loli.net/2023/03/06/F1RxtgBZNQvWpw8.png" srcset="/img/loading.gif" lazyload alt="image-20230306232102462"></p>
<p>可以试想一下，当流量下降时，令牌桶中的令牌会逐渐积累，这样如果突然出现高并发，那么就能在短时间内拿到大量的令牌。</p>
</li>
<li><p><strong>固定时间窗口算法</strong></p>
<p>我们可以对某一个时间段内的请求进行统计和计数，比如在 <code>14:15</code> 到 <code>14:16</code> 这一分钟内，请求量不能超过 <code>100</code>，也就是一分钟之内不能超过 <code>100</code> 次请求，那么就可以像下面这样进行划分：</p>
<p><img src="https://s2.loli.net/2023/03/06/XRnKgCivsqFE2ax.png" srcset="/img/loading.gif" lazyload alt="image-20230306232111506"></p>
<p>虽然这种模式看似比较合理，但是试想一下这种情况：</p>
<ul>
<li>14:15:59的时候来了 100 个请求</li>
<li>14:16:01的时候又来了 100 个请求</li>
</ul>
<p>出现上面这种情况，符合固定时间窗口算法的规则，所以这 200 个请求都能正常接受，但是，如果你反应比较快，应该发现了，我们其实希望的是 60 秒内只有 100 个请求，但是这种情况却是在 3 秒内出现了 200 个请求，很明显已经违背了我们的初衷。</p>
<p>因此，当遇到临界点时，固定时间窗口算法存在安全隐患。</p>
</li>
<li><p><strong>滑动时间窗口算法</strong></p>
<p>相对于固定窗口算法，滑动时间窗口算法更加灵活，它会动态移动窗口，重新进行计算：</p>
<p><img src="https://s2.loli.net/2023/03/06/8MyG3WDo1wSBb5Y.png" srcset="/img/loading.gif" lazyload alt="image-20230306232118585"></p>
<p>虽然这样能够避免固定时间窗口的临界问题，但是这样显然是比固定窗口更加耗时的。</p>
</li>
</ol>
<p>好了，了解完了我们的限流策略和判定方法之后，我们在 Sentinel 中进行实际测试一下，打开管理页面的簇点链路模块：<br><img src="https://s2.loli.net/2023/03/06/4fPg72OJiwhDycL.png" srcset="/img/loading.gif" lazyload alt="image-20230306232127628"><br>这里演示对我们的借阅接口进行限流，点击 <code>流控</code>，会看到让我们添加流控规则：</p>
<ul>
<li>阈值类型：QPS 就是每秒钟的请求数量，并发线程数是按服务当前使用的线程数据进行统计的。</li>
<li>流控模式：当达到阈值时，流控的对象，这里暂时只用直接。</li>
<li>流控效果：就是我们上面所说的三种方案。</li>
</ul>
<p>这里我们选择 <code>QPS</code>、阈值设定为 <code>1</code>，流控模式选择 <code>直接</code>、流控效果选择 <code>快速失败</code>，可以看到，当我们快速地进行请求时，会直接返回失败信息：<br><img src="https://s2.loli.net/2023/03/06/Lrw7ZJNzyDUoYG8.png" srcset="/img/loading.gif" lazyload alt="image-20230306232135482"><br>这里各位最好自行尝试一下其他的流控效果，熟悉和加深印象。<br>最后我们来看看这些流控模式有什么区别：</p>
<ul>
<li>直接：只针对于当前接口。</li>
<li>关联：当其他接口超过阈值时，会导致当前接口被限流。</li>
<li>链路：更细粒度的限流，能精确到具体的方法。</li>
</ul>
<p>我们首先来看看关联，比如现在我们对自带的 <code>/error</code> 接口进行限流：<br><img src="https://s2.loli.net/2023/03/06/E9vnJRTPZmzaW8V.png" srcset="/img/loading.gif" lazyload alt="image-20230306232145053"><br>注意限流是作用于关联资源的，一旦发现关联资源超过阈值，那么就会对当前的资源进行限流，我们现在来测试一下，这里使用 PostMan 的 Runner 连续对关联资源发起请求：<br><img src="https://s2.loli.net/2023/03/06/QgqsxdvYF59P7ne.png" srcset="/img/loading.gif" lazyload alt="image-20230306232239339"><br>开启 Postman，然后我们会发现借阅服务已经凉凉：<br><img src="https://s2.loli.net/2023/03/06/tnKXB2JUarehk5T.png" srcset="/img/loading.gif" lazyload alt="image-20230306232253804"><br>当我们关闭掉 Postman 的任务后，恢复正常。<br>最后我们来讲解一下链路模式，它能够更加精准的进行流量控制，链路流控模式指的是，当从指定接口过来的资源请求达到限流条件时，开启限流，这里得先讲解一下 <code>@SentinelResource</code> 的使用。<br>我们可以对某一个方法进行限流控制，无论是谁在何处调用了它，这里需要使用到 <code>@SentinelResource</code>，一旦方法被标注，那么就会进行监控，比如我们这里创建两个请求映射，都来调用 Service 的被监控方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow/&#123;uid&#125;&quot;</span>)<br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow 2/&#123;uid&#125;&quot;</span>)<br>    UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid (uid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@SentinelResource</span> (<span class="hljs-string">&quot;getBorrow&quot;</span>)   <span class="hljs-comment">//监控此方法，无论被谁执行都在监控范围内，这里给的 value 是自定义名称，这个注解可以加在任何方法上，包括 Controller 中的请求映射方法，跟 HystrixCommand 贼像</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid (uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById (uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream ()<br>                .map (b -&gt; bookClient.getBookById (b.getBid ()))<br>                .collect (Collectors.toList ());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (user, bookList);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着添加配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">borrowservice</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br>      <span class="hljs-comment"># 关闭 Context 收敛，这样被监控方法可以进行不同链路的单独控制</span><br>      <span class="hljs-attr">web-context-unify:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p>然后我们在 Sentinel 控制台中添加流控规则，注意是针对此方法，可以看到已经自动识别到 borrow 接口下调用了这个方法：<br><img src="https://s2.loli.net/2023/03/06/FOzJdtoieAxIvPq.png" srcset="/img/loading.gif" lazyload alt="image-20230306232304858"><br>最后我们在浏览器中对这两个接口都进行测试，会发现，无论请求哪个接口，只要调用了 Service 中的 <code>getUserBorrowDetailByUid</code> 这个方法，都会被限流。注意限流的形式是后台直接抛出异常，至于怎么处理我们后面再说。<br>那么这个链路选项实际上就是决定只限流从哪个方向来的调用，比如我们只对 <code>borrow 2</code> 这个接口对 <code>getUserBorrowDetailByUid</code> 方法的调用进行限流，那么我们就可以为其指定链路：<br><img src="https://s2.loli.net/2023/03/06/UHbcgSWV2exNCu1.png" srcset="/img/loading.gif" lazyload alt="image-20230306232315010"><br>然后我们会发现，限流效果只对我们配置的链路接口有效，而其他链路是不会被限流的。<br>除了直接对接口进行限流规则控制之外，我们也可以根据当前系统的资源使用情况，决定是否进行限流：<br><img src="https://s2.loli.net/2023/03/06/MHiDyU54L3QsNrc.png" srcset="/img/loading.gif" lazyload alt="image-20230306232323438"><br>系统规则支持以下的模式：</p>
<ul>
<li><strong>Load 自适应</strong>（仅对 Linux&#x2F;Unix-like 机器生效）：系统的 load 1 作为启发指标，进行自适应系统保护。当系统 load 1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li>
<li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li>
<li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li>
<li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li>
</ul>
<p>这里就不进行演示了。</p>
<h3 id="限流和异常处理"><a href="#限流和异常处理" class="headerlink" title="限流和异常处理"></a>限流和异常处理</h3><p>现在我们已经了解了如何进行限流操作，那么限流状态下的返回结果该怎么修改呢，我们看到被限流之后返回的是 Sentinel 默认的数据，现在我们希望自定义改如何操作？<br>这里我们先创建好被限流状态下需要返回的内容，定义一个请求映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/blocked&quot;</span>)<br>JSONObject <span class="hljs-title function_">blocked</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span> ();<br>    object.put (<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">403</span>);<br>    object.put (<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>    object.put (<span class="hljs-string">&quot;massage&quot;</span>, <span class="hljs-string">&quot;您的请求频率过快，请稍后再试！&quot;</span>);<br>    <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着我们在配置文件中将此页面设定为限流页面：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">transport:</span><br>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8858</span><br>      <span class="hljs-comment"># 将刚刚编写的请求映射设定为限流页面</span><br>      <span class="hljs-attr">block-page:</span> <span class="hljs-string">/blocked</span><br></code></pre></td></tr></table></figure>
<p>这样，当被限流时，就会被重定向到指定页面：<br><img src="https://s2.loli.net/2023/03/06/PfVOQWJrTiZGqh7.png" srcset="/img/loading.gif" lazyload alt="image-20230306232335949"><br>那么，对于方法级别的限流呢？经过前面的学习我们知道，当某个方法被限流时，会直接在后台抛出异常，那么这种情况我们该怎么处理呢，比如我们之前在 Hystrix 中可以直接添加一个替代方案，这样当出现异常时会直接执行我们的替代方法并返回，Sentinel 也可以。<br>比如我们还是在 <code>getUserBorrowDetailByUid</code> 方法上进行配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@SentinelResource</span> (value = <span class="hljs-string">&quot;getBorrow&quot;</span>, blockHandler = <span class="hljs-string">&quot;blocked&quot;</span>)   <span class="hljs-comment">//指定 blockHandler，也就是被限流之后的替代解决方案，这样就不会使用默认的抛出异常的形式了</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>    List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid (uid);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById (uid);<br>    List&lt;Book&gt; bookList = borrow<br>            .stream ()<br>            .map (b -&gt; bookClient.getBookById (b.getBid ()))<br>            .collect (Collectors.toList ());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (user, bookList);<br>&#125;<br><span class="hljs-comment">//替代方案，注意参数和返回值需要保持一致，并且参数最后还需要额外添加一个 BlockException</span><br><span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">blocked</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, BlockException e)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (<span class="hljs-literal">null</span>, Collections.emptyList ());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，一旦被限流将执行替代方案，最后返回的结果就是：<br><img src="https://s2.loli.net/2023/03/06/p1Y53LPihOGZjBV.png" srcset="/img/loading.gif" lazyload alt="image-20230306232346185"><br>注意 <code>blockHandler</code> 只能处理限流情况下抛出的异常，包括下面即将要介绍的热点参数限流也是同理，如果是方法本身抛出的其他类型异常，不在管控范围内，但是可以通过其他参数进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br><span class="hljs-meta">@SentinelResource</span> (value = <span class="hljs-string">&quot;test&quot;</span>,<br>        fallback = <span class="hljs-string">&quot;except&quot;</span>,    <span class="hljs-comment">//fallback 指定出现异常时的替代方案</span><br>        exceptionsToIgnore = IOException. class)  <span class="hljs-comment">//忽略那些异常，也就是说这些异常出现时不使用替代方案</span><br>String <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;HelloWorld！&quot;</span>);<br>&#125;<br><span class="hljs-comment">//替代方法必须和原方法返回值和参数一致，最后可以添加一个 Throwable 作为参数接受异常</span><br>String <span class="hljs-title function_">except</span> <span class="hljs-params">(Throwable t)</span>&#123;<br>    <span class="hljs-keyword">return</span> t.getMessage ();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样，其他的异常也可以有替代方案了：<br><img src="https://s2.loli.net/2023/03/06/pk1HjSi9VyxwOJQ.png" srcset="/img/loading.gif" lazyload alt="image-20230306232354931"><br>特别注意这种方式会在没有配置 <code>blockHandler</code> 的情况下，将 Sentinel 机制内（也就是限流的异常）的异常也一并处理了，如果配置了 <code>blockHandler</code>，那么在出现限流时，依然只会执行 <code>blockHandler</code> 指定的替代方案（因为限流是在方法执行之前进行的）</p>
<h3 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h3><p>我们还可以对某一热点数据进行精准限流，比如在某一时刻，不同参数被携带访问的频率是不一样的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://localhost:8301/test?a=10">http://localhost:8301/test?a=10</a>  访问 100 次</li>
<li><a target="_blank" rel="noopener" href="http://localhost:8301/test?b=10">http://localhost:8301/test?b=10</a>  访问 0 次</li>
<li><a target="_blank" rel="noopener" href="http://localhost:8301/test?c=10">http://localhost:8301/test?c=10</a>  访问 3 次<br>由于携带参数 <code>a</code> 的请求比较多，我们就可以只对携带参数 <code>a</code> 的请求进行限流。<br>这里我们创建一个新的测试请求映射：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/test&quot;</span>)<br><span class="hljs-meta">@SentinelResource</span> (<span class="hljs-string">&quot;test&quot;</span>)   <span class="hljs-comment">//注意这里需要添加@SentinelResource 才可以，用户资源名称就使用这里定义的资源名称</span><br>String <span class="hljs-title function_">findUserBorrows2</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;a&quot;, required = false)</span> String a,  </span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam(value = &quot;b&quot;, required = false)</span> String b,  </span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam(value = &quot;c&quot;, required = false)</span> String c)</span> &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求成功！a = &quot;</span> + a + <span class="hljs-string">&quot;, b = &quot;</span> + b + <span class="hljs-string">&quot;, c = &quot;</span> + c;  <br>&#125;<br></code></pre></td></tr></table></figure>
启动之后，我们在 Sentinel 里面进行热点配置：<br><img src="https://s2.loli.net/2023/03/06/fIlhGM3jPxb7wgS.png" srcset="/img/loading.gif" lazyload alt="image-20230306232406587"><br>然后开始访问我们的测试接口，可以看到在携带参数 a 时，当访问频率超过设定值，就会直接被限流，这里是直接在后台抛出异常：<br><img src="https://s2.loli.net/2023/03/06/hskQVKnE2y5PftO.png" srcset="/img/loading.gif" lazyload alt="image-20230306232452209"><br><img src="https://s2.loli.net/2023/03/06/nC6W5T4OGcJNypA.png" srcset="/img/loading.gif" lazyload alt="image-20230306232500754"><br>而我们使用其他参数或是不带 <code>a</code> 参数，那么就不会出现这种问题了：<br><img src="https://s2.loli.net/2023/03/06/WVguflyZ43NxE7j.png" srcset="/img/loading.gif" lazyload alt="image-20230306232514532"><br>除了直接对某个参数精准限流外，我们还可以对参数携带的指定值单独设定阈值，比如我们现在不仅希望对参数 <code>a</code> 限流，而且还希望当参数 <code>a</code> 的值为 10 时，QPS 达到 5 再进行限流，那么就可以设定例外：<br><img src="https://s2.loli.net/2023/03/06/oipjTJBHsMSdDvc.png" srcset="/img/loading.gif" lazyload alt="image-20230306232525342"><br>这样，当请求携带参数 <code>a</code>，且参数 <code>a</code> 的值为 10 时，阈值将按照我们指定的特例进行计算。</li>
</ul>
<h3 id="服务熔断和降级"><a href="#服务熔断和降级" class="headerlink" title="服务熔断和降级"></a>服务熔断和降级</h3><p>还记得我们前所说的服务降级吗，也就是说我们需要在整个微服务调用链路出现问题的时候，及时对服务进行降级，以防止问题进一步恶化。<br><img src="https://s2.loli.net/2023/03/06/AxrzjvtPWJ2YCZI.png" srcset="/img/loading.gif" lazyload alt="image-20230306232538279"><br>那么，各位是否有思考过，如果在某一时刻，服务 B 出现故障（可能就卡在那里了），而这时服务 A 依然有大量的请求，在调用服务 B，那么，由于服务 A 没办法再短时间内完成处理，新来的请求就会导致线程数不断地增加，这样，CPU 的资源很快就会被耗尽。<br>那么要防止这种情况，就只能进行隔离了，这里我们提两种隔离方案：</p>
<ol>
<li><strong>线程池隔离</strong><br>线程池隔离实际上就是对每个服务的远程调用单独开放线程池，比如服务 A 要调用服务 B，那么只基于固定数量的线程池，这样即使在短时间内出现大量请求，由于没有线程可以分配，所以就不会导致资源耗尽了。<br><img src="https://s2.loli.net/2023/03/06/CbYxA3d7w46OlMm.png" srcset="/img/loading.gif" lazyload alt="image-20230306232549778"></li>
<li><strong>信号量隔离</strong><br>信号量隔离是使用 <code>Semaphore</code> 类实现的（如果不了解，可以观看本系列并发编程篇视频教程），思想基本上与上面是相同的，也是限定指定的线程数量能够同时进行服务调用，但是它相对于线程池隔离，开销会更小一些，使用效果同样优秀，也支持超时等。<br>Sentinel 也正是采用的这种方案实现隔离的。<br>好了，说回我们的熔断和降级，当下游服务因为某种原因变得不可用或响应过慢时，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务而是快速返回或是执行自己的替代方案，这便是服务降级。<br><img src="https://s2.loli.net/2023/03/06/gY62LD3vw157WiU.png" srcset="/img/loading.gif" lazyload alt="image-20230306232602853"><br>整个过程分为三个状态：</li>
</ol>
<ul>
<li>关闭：熔断器不工作，所有请求全部该干嘛干嘛。</li>
<li>打开：熔断器工作，所有请求一律降级处理。</li>
<li>半开：尝试进行一下下正常流程，要是还不行继续保持打开状态，否则关闭。<br>那么我们来看看 Sentinel 中如何进行熔断和降级操作，打开管理页面，我们可以自由新增熔断规则：<br><img src="https://s2.loli.net/2023/03/06/7BW6LGXQNl5b1Iv.png" srcset="/img/loading.gif" lazyload alt="image-20230306232618547"><br>其中，熔断策略有三种模式：</li>
</ul>
<ol>
<li><strong>慢调用比例：</strong> 如果出现那种半天都处理不完的调用，有可能就是服务出现故障，导致卡顿，这个选项是按照最大响应时间（RT）进行判定，如果一次请求的处理时间超过了指定的 RT，那么就被判定为 <code>慢调用</code>，在一个统计时长内，如果请求数目大于最小请求数目，并且被判定为 <code>慢调用</code> 的请求比例已经超过阈值，将触发熔断。经过熔断时长之后，将会进入到半开状态进行试探（这里和 Hystrix 一致）<br>然后修改一下接口的执行，我们模拟一下慢调用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow 2/&#123;uid&#125;&quot;</span>)<br>UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid) <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep (<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
重启，然后我们创建一个新的熔断规则：<br><img src="https://s2.loli.net/2023/03/06/ExWIKFSNpPoksiT.png" srcset="/img/loading.gif" lazyload alt="image-20230306232632385"><br>可以看到，超时直接触发了熔断，进入到阻止页面：<br><img src="https://s2.loli.net/2023/03/06/CmdPgcqvX4a2u9p.png" srcset="/img/loading.gif" lazyload alt="image-20230306232642387"></li>
<li><strong>异常比例：</strong> 这个与慢调用比例类似，不过这里判断的是出现异常的次数，与上面一样，我们也来进行一些小测试：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow 2/&#123;uid&#125;&quot;</span>)<br>UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> ();<br>&#125;<br></code></pre></td></tr></table></figure>
启动服务器，接着添加我们的熔断规则：<br><img src="https://s2.loli.net/2023/03/06/Dz3EgG9eH4UXTkJ.png" srcset="/img/loading.gif" lazyload alt="image-20230306232652092"><br>现在我们进行访问，会发现后台疯狂报错，然后就熔断了：<br><img src="https://s2.loli.net/2023/03/06/jSp92ODTRhlxJsn.png" srcset="/img/loading.gif" lazyload alt="image-20230306232702794"><br><img src="https://s2.loli.net/2023/03/06/FfhalnZdS2ujm1t.png" srcset="/img/loading.gif" lazyload alt="image-20230306232711467"></li>
<li><strong>异常数：</strong> 这个和上面的唯一区别就是，只要达到指定的异常数量，就熔断，这里我们修改一下熔断规则：<br><img src="https://s2.loli.net/2023/03/06/CugOUozGA6inB3R.png" srcset="/img/loading.gif" lazyload alt="image-20230306232720801"><br>现在我们再次不断访问此接口，可以发现，效果跟之前其实是差不多的，只是判断的策略稍微不同罢了：<br><img src="https://s2.loli.net/2023/03/06/XC1VekDfainIpv6.png" srcset="/img/loading.gif" lazyload alt="image-20230306232738961"><br>那么熔断规则如何设定我们了解了，那么，如何自定义服务降级呢？之前在使用 Hystrix 的时候，如果出现异常，可以执行我们的替代方案，Sentinel 也是可以的。<br>同样的，我们只需要在 <code>@SentinelResource</code> 中配置 <code>blockHandler</code> 参数（那这里跟前面那个方法限流的配置不是一毛一样吗？没错，因为如果添加了 <code>@SentinelResource</code> 注解，那么这里会进行方法级别细粒度的限制，和之前方法级别限流一样，会在降级之后直接抛出异常，如果不添加则返回默认的限流页面，<code>blockHandler</code> 的目的就是处理这种 Sentinel 机制上的异常，所以这里其实和之前的限流配置是一个道理，因此下面熔断配置也应该对 <code>value</code> 自定义名称的资源进行配置，才能作用到此方法上）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow2/&#123;uid&#125;&quot;</span>)<br><span class="hljs-meta">@SentinelResource</span> (value = <span class="hljs-string">&quot;findUserBorrows 2&quot;</span>, blockHandler = <span class="hljs-string">&quot;test&quot;</span>)<br>UserBorrowDetail findUserBorrows <span class="hljs-number">2</span> (<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>) <span class="hljs-type">int</span> uid) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> ();<br>&#125;<br>UserBorrowDetail <span class="hljs-title function_">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, BlockException e)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span> (), Collections.emptyList ());<br>&#125;<br></code></pre></td></tr></table></figure>
接着我们对进行熔断配置，注意是对我们添加的 <code>@SentinelResource</code> 中指定名称的 <code>findUserBorrows 2</code> 进行配置：<br><img src="https://s2.loli.net/2023/03/06/QkofY5gzwSr6WGn.png" srcset="/img/loading.gif" lazyload alt="image-20230306232759448"><br>OK，可以看到熔断之后，服务降级之后的效果：<br><img src="https://s2.loli.net/2023/03/06/5kLcAaT6wJgYXGx.png" srcset="/img/loading.gif" lazyload alt="image-20230306232809712"><br>最后我们来看一下如何让 Feign 的也支持 Sentinel，前面我们使用 Hystrix 的时候，就可以直接对 Feign 的每个接口调用单独进行服务降级，而使用 Sentinel，也是可以的，首先我们需要在配置文件中开启支持：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">sentinel:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
之后的步骤其实和之前是一模一样的，首先创建实现类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserClient</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span> ();<br>        user.setName (<span class="hljs-string">&quot;我是替代方案&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
然后直接启动就可以了，中途的时候我们吧用户服务全部下掉，可以看到正常使用替代方案：<br><img src="https://s2.loli.net/2023/03/06/M2yZpJLfs1i9adC.png" srcset="/img/loading.gif" lazyload alt="image-20230306232821953"><br>这样 Feign 的配置就 OK 了，那么传统的 RestTemplate 呢？我们可以使用 <code>@SentinelRestTemplate</code> 注解实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@SentinelRestTemplate</span> (blockHandler = <span class="hljs-string">&quot;handleException&quot;</span>, blockHandlerClass = ExceptionUtil. class,<br>    fallback = <span class="hljs-string">&quot;fallback&quot;</span>, fallbackClass = ExceptionUtil. class) <span class="hljs-comment">//这里同样可以设定 fallback 等参数</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span> <span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span> ();<br>&#125;<br></code></pre></td></tr></table></figure>
这里就不多做赘述了。</li>
</ol>
<hr>
<p><img src="https://s2.loli.net/2023/03/06/8OCeNap2Vy6X7WH.png" srcset="/img/loading.gif" lazyload alt="image-20230306232833262"></p>
<h2 id="Seata-与分布式事务"><a href="#Seata-与分布式事务" class="headerlink" title="Seata 与分布式事务"></a>Seata 与分布式事务</h2><p>重难点内容，坑也多得离谱，最好保持跟 UP 一样的版本，<strong>官方文档：</strong> <a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a><br>在前面的阶段中，我们学习过事务，还记得我们之前谈到的数据库事务的特性吗？</p>
<ul>
<li><strong>原子性：</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性：</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>那么各位试想一下，在分布式环境下，有可能出现这样一个问题，比如我们下单购物，那么整个流程可能是这样的：先调用库存服务对库存进行减扣 -&gt; 然后订单服务开始下单 -&gt; 最后用户账户服务进行扣款，虽然看似是一个很简单的一个流程，但是如果没有事务的加持，很有可能会由于中途出错，比如整个流程中订单服务出现问题，那么就会导致库存扣了，但是实际上这个订单并没有生成，用户也没有付款。<br><img src="https://s2.loli.net/2023/03/06/AiEXC3wBflPxHGT.png" srcset="/img/loading.gif" lazyload alt="image-20230306233055869"><br>上面这种情况时间就是一种多服务多数据源的分布式事务模型（比较常见），因此，为了解决这种情况，我们就得实现分布式事务，让这整个流程保证原子性。<br>SpringCloud Alibaba 为我们提供了用于处理分布式事务的组件 Seata。<br><img src="https://s2.loli.net/2023/03/06/jDAy7osQ5YIqruP.png" srcset="/img/loading.gif" lazyload alt="image-20230306233108567"><br>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。<br>实际上，就是多了一个中间人来协调所有服务的事务。</li>
</ul>
<h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a>项目环境搭建</h3><p>这里我们对我们之前的图书管理系统进行升级：</p>
<ul>
<li>每个用户最多只能同时借阅 2 本不同的书。</li>
<li>图书馆中所有的书都有 3 本。</li>
<li>用户借书流程：先调用图书服务书籍数量-1 -&gt;  添加借阅记录  -&gt;  调用用户服务用户可借阅数量-1<br>那么首先我们对数据库进行修改，这里为了简便，就直接在用户表中添加一个字段用于存储用户能够借阅的书籍数量：<br><img src="https://s2.loli.net/2023/03/06/TvJL2PiWFU4XoaZ.png" srcset="/img/loading.gif" lazyload alt="image-20230306232857302"><br>然后修改书籍信息，也是直接添加一个字段用于记录剩余数量：<br><img src="https://s2.loli.net/2023/03/06/WjEcGbtkNrZi1CL.png" srcset="/img/loading.gif" lazyload alt="image-20230306232904202"><br>接着我们去编写一下对应的服务吧，首先是用户服务：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from DB_USER where uid = #&#123;uid&#125;&quot;</span>)<br>    User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select book_count from DB_USER where uid = #&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getUserBookRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span>;<br>    <span class="hljs-meta">@Update</span> (<span class="hljs-string">&quot;update DB_USER set book_count = #&#123;count&#125; where uid = #&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBookCount</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    UserMapper mapper;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserById (uid);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getUserBookRemain (uid);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.updateBookCount (uid, count) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    UserService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserById (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/remain/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">userRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getRemain (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/borrow/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">userBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> service.getRemain (uid);<br>        <span class="hljs-keyword">return</span> service.setRemain (uid, remain - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
然后是图书服务，其实跟用户服务差不多：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookMapper</span> &#123;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select * from DB_BOOK where bid = #&#123;bid&#125;&quot;</span>)<br>    Book <span class="hljs-title function_">getBookById</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>    <span class="hljs-meta">@Select</span> (<span class="hljs-string">&quot;select count from DB_BOOK  where bid = #&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span>;<br>    <span class="hljs-meta">@Update</span> (<span class="hljs-string">&quot;update DB_BOOK set count = #&#123;count&#125;  where bid = #&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">setRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid, <span class="hljs-type">int</span> count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BookMapper mapper;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookById</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getBookById (bid);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.setRemain (bid, count) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRemain</span> <span class="hljs-params">(<span class="hljs-type">int</span> bid)</span> &#123;<br>        <span class="hljs-keyword">return</span> mapper.getRemain (bid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BookService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/&#123;bid&#125;&quot;</span>)<br>    Book <span class="hljs-title function_">findBookById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid)&#123;<br>        <span class="hljs-keyword">return</span> service.getBookById (bid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/remain/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bookRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getRemain (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/borrow/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bookBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remain</span> <span class="hljs-operator">=</span> service.getRemain (uid);<br>        <span class="hljs-keyword">return</span> service.setRemain (uid, remain - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
最后完善我们的借阅服务：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span> (value = <span class="hljs-string">&quot;userservice&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/&#123;uid&#125;&quot;</span>)<br>    User <span class="hljs-title function_">getUserById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/borrow/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">userBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/user/remain/&#123;uid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">userRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span> (<span class="hljs-string">&quot;bookservice&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookClient</span> &#123;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/&#123;bid&#125;&quot;</span>)<br>    Book <span class="hljs-title function_">getBookById</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/borrow/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">bookBorrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid);<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/book/remain/&#123;bid&#125;&quot;</span>)<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">bookRemain</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>)</span> <span class="hljs-type">int</span> bid);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowService service;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow/&#123;uid&#125;&quot;</span>)<br>    UserBorrowDetail <span class="hljs-title function_">findUserBorrows</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid)&#123;<br>        <span class="hljs-keyword">return</span> service.getUserBorrowDetailByUid (uid);<br>    &#125;<br>    <span class="hljs-meta">@RequestMapping</span> (<span class="hljs-string">&quot;/borrow/take/&#123;uid&#125;/&#123;bid&#125;&quot;</span>)<br>    JSONObject <span class="hljs-title function_">borrow</span> <span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;uid&quot;</span>)</span> <span class="hljs-type">int</span> uid,<br>                      <span class="hljs-meta">@PathVariable</span> (<span class="hljs-string">&quot;bid&quot;</span>) <span class="hljs-type">int</span> bid)&#123;<br>        service.doBorrow (uid, bid);<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span> ();<br>        object.put (<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>);<br>        object.put (<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>        object.put (<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;借阅成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    BorrowMapper mapper;<br>    <span class="hljs-meta">@Resource</span><br>    UserClient userClient;<br>    <span class="hljs-meta">@Resource</span><br>    BookClient bookClient;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserBorrowDetail <span class="hljs-title function_">getUserBorrowDetailByUid</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid)</span> &#123;<br>        List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid (uid);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userClient.getUserById (uid);<br>        List&lt;Book&gt; bookList = borrow<br>                .stream ()<br>                .map (b -&gt; bookClient.getBookById (b.getBid ()))<br>                .collect (Collectors.toList ());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBorrowDetail</span> (user, bookList);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doBorrow</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span> &#123;<br>      	<span class="hljs-comment">//1. 判断图书和用户是否都支持借阅</span><br>        <span class="hljs-keyword">if</span> (bookClient.bookRemain (bid) &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;图书数量不足&quot;</span>);<br>        <span class="hljs-keyword">if</span> (userClient.userRemain (uid) &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;用户借阅量不足&quot;</span>);<br>      	<span class="hljs-comment">//2. 首先将图书的数量-1</span><br>        <span class="hljs-keyword">if</span> (! bookClient.bookBorrow (bid))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅图书时出现错误！&quot;</span>);<br>      	<span class="hljs-comment">//3. 添加借阅信息</span><br>        <span class="hljs-keyword">if</span> (mapper.getBorrow (uid, bid) != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;此书籍已经被此用户借阅了！&quot;</span>);<br>        <span class="hljs-keyword">if</span> (mapper.addBorrow (uid, bid) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在录入借阅信息时出现错误！&quot;</span>);<br>      	<span class="hljs-comment">//4. 用户可借阅-1</span><br>        <span class="hljs-keyword">if</span> (! userClient.userBorrow (uid))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅时出现错误！&quot;</span>);<br>      	<span class="hljs-comment">//完成</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
这样，只要我们的图书借阅过程中任何一步出现问题，都会抛出异常。<br>我们来测试一下：<br><img src="https://s2.loli.net/2023/03/06/MPkZb1dA2Khjcty.png" srcset="/img/loading.gif" lazyload alt="image-20230306233138135"><br>再次尝试借阅，后台会直接报错：<br><img src="https://s2.loli.net/2023/03/06/H43Fy9z76LIvJGd.png" srcset="/img/loading.gif" lazyload alt="image-20230306233147990"><br>抛出异常，但是我们发现一个问题，借阅信息添加失败了，但是图书的数量依然被-1，也就是说正常情况下，我们是希望中途出现异常之后，之前的操作全部回滚的：<br><img src="https://s2.loli.net/2023/03/06/l9D8aXBxkvnZejw.png" srcset="/img/loading.gif" lazyload alt="image-20230306233201664"><br>而这里由于是在另一个服务中进行的数据库操作，所以传统的 <code>@Transactional</code> 注解无效，这时就得借助 Seata 提供分布式事务了。</li>
</ul>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>要开始实现分布式事务，我们得先从理论上开始下手，我们来了解一下常用的分布式事务解决方案。</p>
<ol>
<li><strong>XA 分布式事务协议 - 2 PC（两阶段提交实现）</strong><br>这里的 PC 实际上指的是 Prepare 和 Commit，也就是说它分为两个阶段，一个是准备一个是提交，整个过程的参与者一共有两个角色，一个是事务的执行者，一个是事务的协调者，实际上整个分布式事务的运作都需要依靠协调者来维持：<br><img src="https://s2.loli.net/2023/03/06/BWiUzFrjHAao1kJ.png" srcset="/img/loading.gif" lazyload alt="image-20230306233211675"><br>在准备和提交阶段，会进行：<ul>
<li><strong>准备阶段：</strong><br>一个分布式事务是由协调者来开启的，首先协调者会向所有的事务执行者发送事务内容，等待所有的事务执行者答复。<br>各个事务执行者开始执行事务操作，但是不进行提交，并将 undo 和 redo 信息记录到事务日志中。<br>如果事务执行者执行事务成功，那么就告诉协调者成功 Yes，否则告诉协调者失败 No，不能提交事务。</li>
<li><strong>提交阶段：</strong><br>当所有的执行者都反馈完成之后，进入第二阶段。<br>协调者会检查各个执行者的反馈内容，如果所有的执行者都返回成功，那么就告诉所有的执行者可以提交事务了，最后再释放锁资源。<br>如果有至少一个执行者返回失败或是超时，那么就让所有的执行者都回滚，分布式事务执行失败。<br>虽然这种方式看起来比较简单，但是存在以下几个问题：</li>
<li>事务协调者是非常核心的角色，一旦出现问题，将导致整个分布式事务不能正常运行。</li>
<li>如果提交阶段发生网络问题，导致某些事务执行者没有收到协调者发来的提交命令，将导致某些执行者提交某些执行者没提交，这样肯定是不行的。</li>
</ul>
</li>
<li><strong>XA 分布式事务协议 - 3 PC（三阶段提交实现）</strong><br>三阶段提交是在二阶段提交基础上的改进版本，主要是加入了超时机制，同时在协调者和执行者中都引入了超时机制。<br>三个阶段分别进行：<ul>
<li><strong>CanCommit 阶段：</strong><br>协调者向执行者发送 CanCommit 请求，询问是否可以执行事务提交操作，然后开始等待执行者的响应。<br>执行者接收到请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态，否则返回 No</li>
<li><strong>PreCommit 阶段：</strong><br>协调者根据执行者的反应情况来决定是否可以进入第二阶段事务的 PreCommit 操作。<br>如果所有的执行者都返回 Yes，则协调者向所有执行者发送 PreCommit 请求，并进入 Prepared 阶段，执行者接收到请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中，如果成功执行，则返回成功响应。<br>如果所有的执行者至少有一个返回 No，则协调者向所有执行者发送 abort 请求，所有的执行者在收到请求或是超过一段时间没有收到任何请求时，会直接中断事务。</li>
<li><strong>DoCommit 阶段：</strong><br>该阶段进行真正的事务提交。<br>协调者接收到所有执行者发送的成功响应，那么他将从 PreCommit 状态进入到 DoCommit 状态，并向所有执行者发送 doCommit 请求，执行者接收到 doCommit 请求之后，开始执行事务提交，并在完成事务提交之后释放所有事务资源，并最后向协调者发送确认响应，协调者接收到所有执行者的确认响应之后，完成事务（如果因为网络问题导致执行者没有收到 doCommit 请求，执行者会在超时之后直接提交事务，虽然执行者只是猜测协调者返回的是 doCommit 请求，但是因为前面的两个流程都正常执行，所以能够在一定程度上认为本次事务是成功的，因此会直接提交）<br>协调者没有接收至少一个执行者发送的成功响应（也可能是响应超时），那么就会执行中断事务，协调者会向所有执行者发送 abort 请求，执行者接收到 abort 请求之后，利用其在 PreCommit 阶段记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源，执行者完成事务回滚之后，向协调者发送确认消息，协调者接收到参与者反馈的确认消息之后，执行事务的中断。<br>相比两阶段提交，三阶段提交的优势是显而易见的，当然也有缺点：</li>
<li>3 PC 在 2 PC 的第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
<li>一旦参与者无法及时收到来自协调者的信息之后，会默认执行 Commit，这样就不会因为协调者单方面的故障导致全局出现问题。</li>
<li>但是我们知道，实际上超时之后的 Commit 决策本质上就是一个赌注罢了，如果此时协调者发送的是 abort 请求但是超时未接收，那么就会直接导致数据一致性问题。</li>
</ul>
</li>
<li><strong>TCC（补偿事务）</strong><br>补偿事务 TCC 就是 Try、Confirm、Cancel，它对业务有侵入性，一共分为三个阶段，我们依次来解读一下。<ul>
<li><strong>Try 阶段：</strong><br>比如我们需要在借书时，将书籍的库存 <code>-1</code>，并且用户的借阅量也 <code>-1</code>，但是这个操作，除了直接对库存和借阅量进行修改之外，还需要将减去的值，单独存放到冻结表中，但是此时不会创建借阅信息，也就是说只是预先把关键的东西给处理了，预留业务资源出来。</li>
<li><strong>Confirm 阶段：</strong><br>如果 Try 执行成功无误，那么就进入到 Confirm 阶段，接着之前，我们就该创建借阅信息了，只能使用 Try 阶段预留的业务资源，如果创建成功，那么就对 Try 阶段冻结的值，进行解冻，整个流程就完成了。当然，如果失败了，那么进入到 Cancel 阶段。</li>
<li><strong>Cancel 阶段：</strong><br>不用猜了，那肯定是把冻结的东西还给人家，因为整个借阅操作压根就没成功。就像你付了款买了东西但是网络问题，导致交易失败，钱不可能不还给你吧。<br>跟 XA 协议相比，TCC 就没有协调者这一角色的参与了，而是自主通过上一阶段的执行情况来确保正常，充分利用了集群的优势，性能也是有很大的提升。但是缺点也很明显，它与业务具有一定的关联性，需要开发者去编写更多的补偿代码，同时并不一定所有的业务流程都适用于这种形式。</li>
</ul>
</li>
</ol>
<h3 id="Seata-机制简介"><a href="#Seata-机制简介" class="headerlink" title="Seata 机制简介"></a>Seata 机制简介</h3><p>前面我们了解了一些分布式事务的解决方案，那么我们来看一下 Seata 是如何进行分布式事务的处理的。<br><img src="https://s2.loli.net/2023/03/06/LsUq3AvrfhQJPCz.png" srcset="/img/loading.gif" lazyload alt="image-20230306233227905"><br>官网给出的是这样的一个架构图，那么图中的 RM、TM、TC 代表着什么意思呢？</p>
<ul>
<li>RM（Resource Manager）：用于直接执行本地事务的提交和回滚。</li>
<li>TM（Transaction Manager）：TM 是分布式事务的核心管理者。比如现在我们需要在借阅服务中开启全局事务，来让其自身、图书服务、用户服务都参与进来，也就是说一般全局事务发起者就是 TM。</li>
<li>TC（Transaction Controller）这个就是我们的 Seata 服务器，用于全局控制，比如在 XA 模式下就是一个协调者的角色，而一个分布式事务的启动就是由 TM 向 TC 发起请求，TC 再来与其他的 RM 进行协调操作。</li>
</ul>
<blockquote>
<p>TM 请求 TC 开启一个全局事务，TC 会生成一个 XID 作为该全局事务的编号，XID 会在微服务的调用链路中传播，保证将多个微服务的子事务关联在一起；RM 请求 TC 将本地事务注册为全局事务的分支事务，通过全局事务的 XID 进行关联；TM 请求 TC 告诉 XID 对应的全局事务是进行提交还是回滚；TC 驱动 RM 将 XID 对应的自己的本地事务进行提交还是回滚；<br>Seata 支持 4 种事务模式，官网文档：<a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></p>
</blockquote>
<ul>
<li>AT：本质上就是 2 PC 的升级版，在 AT 模式下，用户只需关心自己的 “业务 SQL”<ol>
<li>一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。</li>
<li>二阶段如果确认提交的话，因为“业务 SQL”在一阶段已经提交至数据库，所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可，当然如果需要回滚，那么就用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。</li>
</ol>
</li>
<li>TCC：和我们上面讲解的思路是一样的。</li>
<li>XA：同上，但是要求数据库本身支持这种模式才可以。</li>
<li>Saga：用于处理长事务，每个执行者需要实现事务的正向操作和补偿操作：<br><img src="https://s2.loli.net/2023/03/06/vLTZFS4yn26uabA.png" srcset="/img/loading.gif" lazyload alt="image-20230306233328901"><br>那么，以 AT 模式为例，我们的程序如何才能做到不对业务进行侵入的情况下实现分布式事务呢？实际上，Seata 客户端，是通过对数据源进行代理实现的，使用的是 DataSourceProxy 类，所以在程序这边，我们只需要将对应的代理类注册为 Bean 即可（0.9 版本之后支持自动进行代理，不用我们手动操作）<br>接下来，我们就以 AT 模式为例进行讲解。</li>
</ul>
<h3 id="使用-file-模式部署"><a href="#使用-file-模式部署" class="headerlink" title="使用 file 模式部署"></a>使用 file 模式部署</h3><p>Seata 也是以服务端形式进行部署的，然后每个服务都是客户端，服务端下载地址： <a target="_blank" rel="noopener" href="https://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip">https://github.com/seata/seata/releases/download/v1.4.2/seata-server-1.4.2.zip</a><br>把源码也下载一下： <a target="_blank" rel="noopener" href="https://github.com/seata/seata/archive/refs/heads/develop.zip">https://github.com/seata/seata/archive/refs/heads/develop.zip</a><br>下载完成之后，放入到 IDEA 项目目录中，添加启动配置，这里端口使用 8868：<br><img src="https://s2.loli.net/2023/03/06/ykH1BSPcxlvY4on.png" srcset="/img/loading.gif" lazyload alt="image-20230306233336803"><br>Seata 服务端支持本地部署或是基于注册发现中心部署（比如 Nacos、Eureka 等），这里我们首先演示一下最简单的本地部署，不需要对 Seata 的配置文件做任何修改。<br>Seata 存在着事务分组机制：</p>
<ul>
<li>事务分组：seata 的资源逻辑，可以按微服务的需要，在应用程序（客户端）对自行定义事务分组，每组取一个名字。</li>
<li>集群：seata-server 服务端一个或多个节点组成的集群 cluster。应用程序（客户端）使用时需要指定事务逻辑分组与 Seata 服务端集群（默认为 default）的映射关系。<br>为啥要设计成通过事务分组再直接映射到集群？干嘛不直接指定集群呢？获取事务分组到映射集群的配置。这样设计后，事务分组可以作为资源的逻辑隔离单位，出现某集群故障时可以快速 failover，只切换对应分组，可以把故障缩减到服务级别，但前提也是你有足够 server 集群。<br>接着我们需要将我们的<strong>各个服务作为 Seate 的客户端</strong>，只需要导入依赖即可：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com. alibaba. cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
然后添加配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">vgroup-mapping:</span><br>    	<span class="hljs-comment"># 这里需要对事务组做映射，默认的分组名为应用名称-seata-service-group，将其映射到 default 集群</span><br>    	<span class="hljs-comment"># 这个很关键，一定要配置对，不然会找不到服务</span><br>      <span class="hljs-attr">bookservice-seata-service-group:</span> <span class="hljs-string">default</span><br>    <span class="hljs-attr">grouplist:</span><br>      <span class="hljs-attr">default:</span> <span class="hljs-string">localhost:8868</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>使用 jdk8才能正常启动，使用 jdk17则报错 <code>Error creating bean with name &#39;globalTransactionScanner&#39; defined in class path resource [io/seata/spring/boot/autoconfigure/SeataAutoConfiguration.class]</code> ，直接启动后只是单纯地连接上，并没有开启任何的分布式事务。<br>接着要<strong>配置开启分布式事务</strong>，首先在<strong>启动类添加注解</strong>，此注解会添加一个后置处理器将数据源封装为支持分布式事务的<em>代理数据源</em>（虽然官方表示配置文件中已经默认开启了自动代理，但是实测 1.4.2 版本下只能打注解的方式才能生效）：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAutoDataSourceProxy</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run (BookApplication. class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
接着我们需要在开启分布式事务的方法上添加 <code>@GlobalTransactional</code> 注解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GlobalTransactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doBorrow</span> <span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">int</span> bid)</span> &#123;<br>  	<span class="hljs-comment">//这里打印一下 XID 看看，其他的服务业添加这样一个打印，如果一会都打印的是同一个 XID，表示使用的就是同一个事务</span><br>    System.out.println (RootContext.getXID ());<br>    <span class="hljs-keyword">if</span> (bookClient.bookRemain (bid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;图书数量不足&quot;</span>);<br>    <span class="hljs-keyword">if</span> (userClient.userRemain (uid) &lt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;用户借阅量不足&quot;</span>);<br>    <span class="hljs-keyword">if</span> (! bookClient.bookBorrow (bid))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅图书时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mapper.getBorrow (uid, bid) != <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;此书籍已经被此用户借阅了！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (mapper.addBorrow (uid, bid) &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在录入借阅信息时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">if</span> (! userClient.userBorrow (uid))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span> (<span class="hljs-string">&quot;在借阅时出现错误！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
由于 Seata 会分析修改数据的 sql，同时生成对应的反向回滚 SQL，这个回滚记录会存放在 undo_log 表中。所以<strong>要求每一个 Client 都有一个对应的 undo_log 表</strong>（也就是说每个服务连接的数据库都需要创建这样一个表，这里由于我们三个服务都用的同一个数据库，所以说就只用在这个数据库中创建 undo_log 表即可），表 SQL 定义如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `undo_log`<br>(<br>  `id`            <span class="hljs-type">BIGINT</span> (<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `branch_id`     <span class="hljs-type">BIGINT</span> (<span class="hljs-number">20</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `xid`           <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `context`       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `rollback_info` LONGBLOB     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_status`    <span class="hljs-type">INT</span> (<span class="hljs-number">11</span>)      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_created`   DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `log_modified`  DATETIME     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `ext`           <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br></code></pre></td></tr></table></figure>
创建完成之后，我们现在就可以启动三个服务了，我们来测试一下当出现异常的时候是不是会正常回滚：<br><img src="https://s2.loli.net/2023/03/06/NIe9QFW3jf1DdnV.png" srcset="/img/loading.gif" lazyload alt="image-20230306233351571"><br><img src="https://s2.loli.net/2023/03/06/LwcdO2HuWAhFr5p.png" srcset="/img/loading.gif" lazyload alt="image-20230306233359914"><br>首先第一次肯定是正常完成借阅操作的，接着我们再次进行请求，肯定会出现异常：<br><img src="https://s2.loli.net/2023/03/06/6VOfsp9UxYJzgKD.png" srcset="/img/loading.gif" lazyload alt="image-20230306233408870"><br><img src="https://s2.loli.net/2023/03/06/yEQa2qeiNc5npV9.png" srcset="/img/loading.gif" lazyload alt="image-20230306233417576"><br>如果能在栈追踪信息中看到 seata 相关的包，那么说明分布式事务已经开始工作了，通过日志我们可以看到，出现了回滚操作：<br><img src="https://s2.loli.net/2023/03/06/VtBlx4U1TzcqKra.png" srcset="/img/loading.gif" lazyload alt="image-20230306233428386"><br>并且数据库中确实是回滚了扣除操作：<br><img src="https://s2.loli.net/2023/03/06/WXn9UPgxBVhdHmb.png" srcset="/img/loading.gif" lazyload alt="image-20230306233436382"><br>这样，我们就通过 Seata 简单地实现了分布式事务，主要通过<em>使用 <strong>XID</strong> 来识别同一事务</em>。</li>
</ul>
<h3 id="使用-nacos-模式部署"><a href="#使用-nacos-模式部署" class="headerlink" title="使用 nacos 模式部署"></a>使用 nacos 模式部署</h3><p>前面我们实现了本地 Seata 服务的 file 模式部署，现在我们来看看如何让其配合 Nacos 进行部署，利用 Nacos 的配置管理和服务发现机制，Seata 能够更好地工作。<br>我们先单独为 Seata 配置一个命名空间：<br><img src="https://s2.loli.net/2023/03/06/93mXN5dlC2GTLOW.png" srcset="/img/loading.gif" lazyload alt="image-20230306233444767"><br>我们打开 <code>conf</code> 目录中的 <code>registry. conf</code> 配置文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">registry</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">	# 注册配置</span><br><span class="hljs-comment">	# 可以看到这里可以选择类型，默认情况下是普通的 file 类型，也就是本地文件的形式进行注册配置</span><br><span class="hljs-comment">	# 支持的类型如下，对应的类型在下面都有对应的配置</span><br><span class="hljs-comment">  # file 、nacos 、eureka、redis、zk、consul、etcd 3、sofa</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><span class="hljs-comment">	# 采用 nacos 方式会将 seata 服务端也注册到 nacos 中，这样客户端就可以利用服务发现自动找到 seata 服务</span><br><span class="hljs-comment">	# 就不需要我们手动指定 IP 和端口了，不过看似方便，坑倒是不少，后面再说</span><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  	# 应用名称，这里默认就行</span><br>    <span class="hljs-attr">application</span> = <span class="hljs-string">&quot;seata-server&quot;</span><br><span class="hljs-comment">    # Nacos 服务器地址</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;localhost:8848&quot;</span><br><span class="hljs-comment">    # 这里使用的是 SEATA_GROUP 组，一会注册到 Nacos 中就是这个组</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br><span class="hljs-comment">    # 这里就使用我们上面单独为 seata 配置的命名空间，注意填的是 ID</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;89 fc 2145-4676-48 b 8-9 edd-29 e 867879 bcb&quot;</span><br><span class="hljs-comment">    # 集群名称，这里还是使用 default</span><br>    <span class="hljs-attr">cluster</span> = <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-comment">    # Nacos 的用户名和密码</span><br>    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-comment">  	#...</span><br></code></pre></td></tr></table></figure>
<p>注册信息配置完成之后，接着我们需要将配置文件也放到 Nacos 中，让 Nacos 管理配置，这样我们就可以对配置进行热更新了，一旦环境需要变化，只需要直接在 Nacos 中修改即可。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">config</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">	# 这里我们也使用 nacos</span><br><span class="hljs-comment">  # file、nacos 、apollo、zk、consul、etcd 3</span><br>  <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>  <span class="hljs-attr">nacos</span> <span class="hljs-string">&#123;</span><br><span class="hljs-comment">  	# 跟上面一样的配法</span><br>    <span class="hljs-attr">serverAddr</span> = <span class="hljs-string">&quot;127.0.0.1:8848&quot;</span><br>    <span class="hljs-attr">namespace</span> = <span class="hljs-string">&quot;89 fc 2145-4676-48 b 8-9 edd-29 e 867879 bcb&quot;</span><br>    <span class="hljs-attr">group</span> = <span class="hljs-string">&quot;SEATA_GROUP&quot;</span><br>    <span class="hljs-attr">username</span> = <span class="hljs-string">&quot;nacos&quot;</span><br>    <span class="hljs-attr">password</span> = <span class="hljs-string">&quot;nacos&quot;</span><br><span class="hljs-comment">    # 这个不用改，默认就行</span><br>    <span class="hljs-attr">dataId</span> = <span class="hljs-string">&quot;seataServer. properties&quot;</span><br>  <span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure>
<p>接着，我们需要将配置导入到 Nacos 中，我们打开一开始下载的源码 <code>script/config-center/nacos</code> 目录，这是官方提供的上传脚本，我们直接运行即可（windows 下没对应的 bat 就很蛋疼，可以使用 git 命令行来运行一下），这里我们使用这个可交互的版本：<br><img src="https://s2.loli.net/2023/03/06/1tPwBFn7u3ScCeY.png" srcset="/img/loading.gif" lazyload alt="image-20230306233500474"><br>按照提示输入就可以了，不输入就使用的默认值，不知道为啥最新版本有四个因为参数过长还导入失败了，就离谱，不过不影响。<br>导入成功之后，可以在对应的命名空间下看到对应的配置（为啥非要一个一个配置项单独搞，就不能写一起吗）：<br><img src="https://s2.loli.net/2023/03/06/8yTQGZluYVe1cg2.png" srcset="/img/loading.gif" lazyload alt="image-20230306233510973"><br>注意，还没完，我们还需要将对应的事务组映射配置也添加上，DataId 格式为 <code>service.vgroupMapping.事务组名称</code>，比如我们就使用默认的名称，值全部依然使用 default 即可：<br><img src="https://s2.loli.net/2023/03/06/UBchb4zPjHAfCSs.png" srcset="/img/loading.gif" lazyload alt="image-20230306233521002"><br>现在我们就完成了服务端的 Nacos 配置，接着我们需要对客户端也进行 Nacos 配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">seata:</span><br>	<span class="hljs-comment"># 注册</span><br>  <span class="hljs-attr">registry:</span><br>  	<span class="hljs-comment"># 使用 Nacos</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>    	<span class="hljs-comment"># 使用 Seata 的命名空间，这样才能正确找到 Seata 服务，由于组使用的是 SEATA_GROUP，配置默认值就是，就不用配了</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-number">89</span> <span class="hljs-string">fc</span> <span class="hljs-number">2145</span><span class="hljs-number">-4676</span><span class="hljs-number">-48</span> <span class="hljs-string">b</span> <span class="hljs-number">8</span><span class="hljs-number">-9</span> <span class="hljs-string">edd-29</span> <span class="hljs-string">e</span> <span class="hljs-number">867879</span> <span class="hljs-string">bcb</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br>  <span class="hljs-comment"># 配置</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">namespace:</span> <span class="hljs-number">89</span> <span class="hljs-string">fc</span> <span class="hljs-number">2145</span><span class="hljs-number">-4676</span><span class="hljs-number">-48</span> <span class="hljs-string">b</span> <span class="hljs-number">8</span><span class="hljs-number">-9</span> <span class="hljs-string">edd-29</span> <span class="hljs-string">e</span> <span class="hljs-number">867879</span> <span class="hljs-string">bcb</span><br>      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span><br></code></pre></td></tr></table></figure>
<p>现在我们就可以启动这三个服务了，可以在 Nacos 中看到 Seata 以及三个服务都正常注册了：<br><img src="https://s2.loli.net/2023/03/06/PSbw5TFhm74Wu3n.png" srcset="/img/loading.gif" lazyload alt="image-20230306233529255"><br><img src="https://s2.loli.net/2023/03/06/nZUcuM2kJ86zgBv.png" srcset="/img/loading.gif" lazyload alt="image-20230306233538630"><br>接着我们就可以访问一下服务试试看了：<br><img src="https://s2.loli.net/2023/03/06/Fn3R2Jrq1YyleCh.png" srcset="/img/loading.gif" lazyload alt="image-20230306233545257"><br>可以看到效果和上面是一样的，不过现在我们的注册和配置都继承在 Nacos 中进行了。<br>我们还可以配置一下事务会话信息的存储方式，默认是 file 类型，那么就会在运行目录下创建 <code>file_store</code> 目录，我们可以将其搬到数据库中存储，只需要修改一下配置即可：<br><img src="https://s2.loli.net/2023/03/06/Cph9zPF2kaSvKdY.png" srcset="/img/loading.gif" lazyload alt="image-20230306233553931"><br>将 <code>store. session. mode</code> 和 <code>store. mode</code> 的值修改为 <code>db</code><br>接着我们对数据库信息进行一下配置：</p>
<ul>
<li>数据库驱动</li>
<li>数据库 URL</li>
<li>数据库用户名密码<br>其他的默认即可：<br><img src="https://s2.loli.net/2023/03/06/dlmYNnARZaxJ5MH.png" srcset="/img/loading.gif" lazyload alt="image-20230306233612224"><br>接着我们需要将对应的数据库进行创建，创建 seata 数据库，然后直接 CV 以下语句：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span><br><span class="hljs-comment">-- the table to store GlobalSession data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `global_table`<br>(<br>    `xid`                       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `transaction_id`            <span class="hljs-type">BIGINT</span>,<br>    `status`                    TINYINT      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `application_id`            <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>    `transaction_service_group` <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>),<br>    `transaction_name`          <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>),<br>    `timeout`                   <span class="hljs-type">INT</span>,<br>    `begin_time`                <span class="hljs-type">BIGINT</span>,<br>    `application_data`          <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">2000</span>),<br>    `gmt_create`                DATETIME,<br>    `gmt_modified`              DATETIME,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`xid`),<br>    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),<br>    KEY `idx_transaction_id` (`transaction_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-comment">-- the table to store BranchSession data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `branch_table`<br>(<br>    `branch_id`         <span class="hljs-type">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `xid`               <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `transaction_id`    <span class="hljs-type">BIGINT</span>,<br>    `resource_group_id` <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>    `resource_id`       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">256</span>),<br>    `branch_type`       <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">8</span>),<br>    `status`            TINYINT,<br>    `client_id`         <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">64</span>),<br>    `application_data`  <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">2000</span>),<br>    `gmt_create`        DATETIME (<span class="hljs-number">6</span>),<br>    `gmt_modified`      DATETIME (<span class="hljs-number">6</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`branch_id`),<br>    KEY `idx_xid` (`xid`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-comment">-- the table to store lock data</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `lock_table`<br>(<br>    `row_key`        <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `xid`            <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">128</span>),<br>    `transaction_id` <span class="hljs-type">BIGINT</span>,<br>    `branch_id`      <span class="hljs-type">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `resource_id`    <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">256</span>),<br>    `table_name`     <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">32</span>),<br>    `pk`             <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">36</span>),<br>    `status`         TINYINT      <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;0: locked ,1: rollbacking&#x27;</span>,<br>    `gmt_create`     DATETIME,<br>    `gmt_modified`   DATETIME,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (`row_key`),<br>    KEY `idx_status` (`status`),<br>    KEY `idx_branch_id` (`branch_id`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `distributed_lock`<br>(<br>    `lock_key`       <span class="hljs-type">CHAR</span> (<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `lock_value`     <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `expire`         <span class="hljs-type">BIGINT</span>,<br>    <span class="hljs-keyword">primary</span> key (`lock_key`)<br>) ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf <span class="hljs-number">8</span> mb <span class="hljs-number">4</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;HandleAllSession&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2023/03/06/7zvewSLhFmbc8G1.png" srcset="/img/loading.gif" lazyload alt="image-20230306233627086"><br>完成之后，重启 Seata 服务端即可：<br><img src="https://s2.loli.net/2023/03/06/G7qQoEy8DCX9bLJ.png" srcset="/img/loading.gif" lazyload alt="image-20230306233752098"><br>看到了数据源初始化成功，现在已经在使用数据库进行会话存储了。<br>如果 Seata 服务端出现报错，可能是我们自定义事务组的名称太长了：<br><img src="https://s2.loli.net/2023/03/06/qoNhgzM2PXpZU9B.png" srcset="/img/loading.gif" lazyload alt="image-20230306233933641"><br>将 <code>globle_table</code> 表的字段 <code>transaction_server_group</code> 长度适当增加一下即可：<br><img src="https://s2.loli.net/2023/03/06/9LnaoUxHzlY1GdV.png" srcset="/img/loading.gif" lazyload alt="image-20230306233940850"></li>
</ul>
<hr>
<h2 id="Dubbo-服务治理与通信"><a href="#Dubbo-服务治理与通信" class="headerlink" title="Dubbo 服务治理与通信"></a>Dubbo 服务治理与通信</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Apache Dubbo 是一款 <strong>RPC 服务开发框架</strong>，用于解决微服务架构下的<strong>服务治理与通信</strong>问题，官方提供了 Java、Golang 等多语言 SDK 实现。使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力，利用 Dubbo 提供的丰富服务治理特性，可以实现诸如<em>服务发现、负载均衡、流量调度等服务治理</em>诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑。<br>在云原生时代，Dubbo 相继衍生出了 Dubbo3、Proxyless Mesh 等架构与解决方案，在易用性、超大规模微服务实践、云原生基础设施适配、安全性等几大方向上进行了全面升级。<br>Dubbo 功能：<br>    1. <strong>微服务编程范式和工具</strong><br>    Dubbo 支持基于 IDL 或语言特定方式的服务定义，提供多种形式的服务调用形式（如同步、异步、流式等）<br>    2. <strong>高性能的 RPC 通信</strong><br>    Dubbo 帮助解决微服务组件之间的通信问题，提供了基于 HTTP、HTTP&#x2F;2、TCP 等的多种高性能通信协议实现，并支持序列化协议扩展，在实现上解决网络连接管理、数据传输等基础问题。<br>    3. <strong>微服务监控与治理</strong><br>    Dubbo 官方提供的服务发现、动态配置、负载均衡、流量路由等基础组件可以很好的帮助解决微服务基础实践的问题。除此之外，您还可以用 Admin 控制台监控微服务状态，通过周边生态完成限流降级、数据一致性、链路追踪等能力。<br>    4. <strong>部署在多种环境</strong><br>    Dubbo 服务可以直接部署在容器、Kubernetes、Service Mesh 等多种架构下。<br><img src="https://cn.dubbo.apache.org/imgs/v3/concepts/architecture-2.png" srcset="/img/loading.gif" lazyload><br>以上是 Dubbo 的工作原理图，从抽象架构上分为两层：<strong>服务治理抽象控制面</strong> 和 <strong>Dubbo 数据面</strong> 。</p>
<ul>
<li><strong>服务治理控制面</strong>：服务治理控制面不是特指如注册中心类的单个具体组件，而是对 Dubbo 治理体系的抽象表达。控制面包含协调服务发现的注册中心、流量管控策略、Dubbo Admin 控制台等，如果采用了 Service Mesh 架构则还包含 Istio 等服务网格控制面。</li>
<li><strong>Dubbo 数据面</strong>：数据面代表集群部署的所有 Dubbo 进程，进程之间通过 RPC 协议实现数据交换，Dubbo 定义了微服务应用开发与调用规范并负责完成数据传输的编解码工作。<ul>
<li>服务消费者 (Dubbo Consumer)，发起业务调用或 RPC 通信的 Dubbo 进程</li>
<li>服务提供者 (Dubbo Provider)，接收业务调用或 RPC 通信的 Dubbo 进程</li>
</ul>
</li>
</ul>
<h3 id="2-dubbo-使用-nacos"><a href="#2-dubbo-使用-nacos" class="headerlink" title="2.dubbo 使用 nacos"></a>2.dubbo 使用 nacos</h3><blockquote>
<p>[!INFO] Tips<br><strong>dubbo</strong> 远程调用传递实体类时必须为实体类添加 <code>implements Serializable</code> 接口，以实现嵌套实体传递，否则会报错。</p>
</blockquote>
<h4 id="公共调用-api-接口"><a href="#公共调用-api-接口" class="headerlink" title="公共调用 api 接口"></a>公共调用 api 接口</h4><ol>
<li>创建公共模块，将模块作为本地依赖导入需要用到的模块中</li>
</ol>
<p><img src="http://qnpicmap.fcsluck.top/pics/202311211438260.png" srcset="/img/loading.gif" lazyload alt="image.png|450"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        引入本地公共模块依赖--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>定义远程调用 api 接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.api;  <br><span class="hljs-keyword">import</span> com.test.entity.Book;  <br><span class="hljs-keyword">import</span> com.test.entity.User;  <br><span class="hljs-keyword">import</span> com.test.utils.Result;  <br><span class="hljs-comment">// Dubbo 服务提供者接口  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DubboApiService</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 调用 Dubbo 服务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  </span><br><span class="hljs-comment">     */</span>  <br>    Result&lt;String&gt; <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="供给者-provider"><a href="#供给者-provider" class="headerlink" title="供给者-provider"></a>供给者-provider</h4><p>1.引入相关的 pom 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Dubbo Spring Cloud Starter --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>2.dubbo 相关配置（低版本的springboot、springcloud无法将yml配置文件中的<code>$&#123;xxx.xxx&#125;</code>自动转换为对应的值）</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">dubbo:</span> <span class="hljs-comment">#dubbo配置  </span><br>  <span class="hljs-attr">application:</span>  <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">$&#123;spring.application.name&#125;</span>  <span class="hljs-comment">#dubbo服务名称供消费者订阅</span><br>    <span class="hljs-attr">qos-enable:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#dubbo运维服务是否开启  </span><br>  <span class="hljs-attr">scan:</span>  <br>    <span class="hljs-attr">base-packages:</span> <span class="hljs-string">com.test.service</span>  <span class="hljs-comment"># 指定要扫描远程调用接口实现类的包路径  </span><br>  <span class="hljs-attr">protocol:</span>  <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span>  <span class="hljs-comment"># 协议名称  </span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span>  <span class="hljs-comment"># 协议端口:（ -1 表示自增端口，从 20880 开始）  </span><br>  <span class="hljs-attr">registry:</span>  <br>    <span class="hljs-attr">address:</span> <span class="hljs-string">spring-cloud://$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span>  <span class="hljs-comment"># 注册中心的地址一定要加“spring-cloud://”才能注册上  </span><br>  <span class="hljs-attr">consumer:</span>  <br>    <span class="hljs-attr">check:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 消费者是否检查版本  </span><br><span class="hljs-attr">server:</span>  <br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8401</span>  <span class="hljs-comment">#应用服务端口</span><br><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">main:</span>  <br>    <span class="hljs-attr">allow-circular-references:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#Spring Boot 2.0 需要设定,允许循环引用  </span><br>    <span class="hljs-attr">allow-bean-definition-overriding:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#Spring Boot 2.1 需要设定,允许覆盖bean  </span><br>  <span class="hljs-attr">application:</span>  <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo-service-provider</span>  <span class="hljs-comment">#应用服务名称</span><br>  <span class="hljs-attr">cloud:</span>  <br>    <span class="hljs-attr">nacos:</span>  <br>      <span class="hljs-attr">discovery:</span>  <br>        <span class="hljs-comment"># 配置Nacos注册中心地址  </span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">xxx:8848</span>  <br><span class="hljs-comment">#        namespace: 0737357d-c94a-4fff-9661-4257622a83fb #区分nacos命名空间</span><br></code></pre></td></tr></table></figure>
<p>3.启动类加上 <code>@EnableDubbo</code> 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableShardingJdbc</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DubboServiceApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DubboServiceApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>4.实现 api 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DubboServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DubboApiService</span> &#123;  <br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;  <br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;Hello &quot;</span> + name + <span class="hljs-string">&quot;, response from dubbo&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="消费者-consumer"><a href="#消费者-consumer" class="headerlink" title="消费者-consumer"></a>消费者-consumer</h4><p>1.引入相关的 pom 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Dubbo Spring Cloud Starter --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>2.dubbo 相关配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">consumer:</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">5000</span><br>    <span class="hljs-attr">check:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#关闭订阅服务是否启动的检查【检查时，没有服务提供者会报错】</span><br>  <span class="hljs-attr">protocol:</span>    <span class="hljs-comment">#Dubbo 服务暴露的协议配置，其中子属性 name 为协议名称，port 为协议端口（ -1 表示自增端口，从 20880 开始）</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span>  <span class="hljs-comment">#dubbo协议缺省端口为20880，rmi协议缺省端口为1099，http和hessian协议缺省端口为80；如果没有配置port，则自动采用默认端口，如果配置为-1，则会分配一个没有被占用的端口。Dubbo 2.4.0+，分配的端口在协议缺省端口的基础上增长，确保端口段可控</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-comment">#其中前缀spring-cloud说明：挂载到 Spring Cloud注册中心</span><br>	<span class="hljs-attr">address:</span> <span class="hljs-string">spring-cloud://$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span><br>    <span class="hljs-comment"># address: spring-cloud://localhost  #dubbo服务注册端口，注册中心服务器地址，如果地址没有端口缺省为9090，同一集群内的多个地址用逗号分隔，如：ip:port,ip:port</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">subscribed-services:</span> <span class="hljs-string">dubbo-service-provider</span> <span class="hljs-comment">#指定调用的服务名称</span><br></code></pre></td></tr></table></figure>
<p>3.调用 api 接口，实现 dubbo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span>  <br><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/api/borrow&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowController</span> &#123;  <br>    <span class="hljs-meta">@Resource</span>  <br>    BorrowService borrowService;  <br>    <span class="hljs-meta">@DubboReference(check = false)</span>  <br>    DubboApiService dubboApiService;  <br>    <span class="hljs-meta">@GetMapping(&quot;/testDubbo/&#123;msg&#125;&quot;)</span>  <br>    Result&lt;String&gt; <span class="hljs-title function_">helloMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;msg&quot;)</span> String msg)</span> &#123;  <br>        <span class="hljs-keyword">return</span> dubboApiService.sayHello(msg);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-服务调用对比"><a href="#3-服务调用对比" class="headerlink" title="3.服务调用对比"></a>3.服务调用对比</h3><ol>
<li>REST 和 RPC<br>在单体应用中，各模块间的调用是通过编程语言级别的方法函数来实现，但分布式系统运行在多台机器上，一般来说，每个服务实例都是一个进程，服务间必须使用进程间通信机制来交互，而常见的通信协议主要有 RPC 和 REST 协议。<br>（1）REST：REST 是基于 HTTP 实现，使用 HTTP 协议处理数据通信，更加标准化与通用，因为无论哪种语言都支持 HTTP 协议。常见的 http API 都可以称为 Rest 接口。REST 是一种架构风格，指一组架构约束条件和原则，满足 REST 原则的应用程序或设计就是 RESTful，RESTful 把一切内容都视为资源。REST 强调组件交互的扩展性、接口的通用性、组件的独立部署、以及减少交互延迟的中间件，它强化安全，也能封装遗留系统。<br><strong>REST（Representational State Transfer）</strong>：<ul>
<li><strong>设计哲学：</strong> REST 是一种基于资源的架构风格，强调在分布式系统中的资源的标识和状态。它的设计目标是简化分布式系统的通信和状态管理。</li>
<li><strong>通信方式：</strong> REST 使用 HTTP 协议作为通信协议，通常使用标准的 HTTP 方法（GET、POST、PUT、DELETE 等）来操作资源。</li>
<li><strong>数据传输：</strong> REST 使用通常是基于文本的数据格式，如 JSON 或 XML，用于表示资源和状态。这些数据格式易于理解和处理。</li>
<li><strong>状态：</strong> REST 通信是无状态的，每个请求都包含了足够的信息来理解和处理请求，服务端不需要保留客户端的状态信息。</li>
<li><strong>缓存：</strong> REST 支持缓存，可以使用 HTTP 标准的缓存机制来提高性能。<br>（2）RPC：是一种进程间通信方式，允许像调用本地服务一样调用远程服务，通信协议大多采用二进制方式。<br><strong>RPC（Remote Procedure Call）</strong>：</li>
<li><strong>设计哲学：</strong> RPC 是一种远程调用的机制，其设计目标是使分布式系统中的方法调用就像本地方法调用一样。</li>
<li><strong>通信方式：</strong> RPC 使用自定义的协议来进行通信，它通常需要专门的 RPC 框架来处理请求和响应。常见的 RPC 框架包括 Dubbo、gRPC、Thrift 等。</li>
<li><strong>数据传输：</strong> RPC 框架通常使用二进制协议，这些协议通常比文本协议更高效。</li>
<li><strong>状态：</strong> RPC 通信可以是有状态的，服务端可以保留客户端的状态信息，这在某些场景中可能有用。</li>
<li><strong>缓存：</strong> RPC 框架通常不直接支持缓存，但可以在应用层面进行缓存的处理。<br><strong>区别：</strong></li>
</ul>
<ol>
<li><strong>设计哲学：</strong> REST 是一种基于资源和状态的架构风格，强调简化和通用性，而 RPC 专注于远程方法调用和接口定义。</li>
<li><strong>通信方式：</strong> REST 使用标准的 HTTP 协议，而 RPC 使用自定义的通信协议。</li>
<li><strong>数据传输：</strong> REST 通常使用文本格式（如 JSON 或 XML）传输数据，而 RPC 通常使用更高效的二进制协议。</li>
<li><strong>状态：</strong> REST 是无状态的，每个请求都包含足够信息，而 RPC 可以是有状态的，服务端可以保留客户端的状态信息。</li>
<li><strong>缓存：</strong> REST 直接支持 HTTP 标准的缓存机制，而 RPC 通常需要应用层面的缓存处理。</li>
</ol>
</li>
<li>dubbo 和 feign 的区别与联系:</li>
</ol>
<p> </p>
<ul>
<li>相同点: <u>Dubbo 与 Feign 都依赖注册中心、负载均衡</u>。</li>
<li>不同点:</li>
</ul>
<ol>
<li>协议<br> <strong>Dubbo</strong>：<ul>
<li>支持多传输协议(<code>Dubbo、Rmi、http、redis</code> 等等)，可以根据业务场景选择最佳的方式。非常灵活。  </li>
<li>默认的 Dubbo 协议：利用 Netty，TCP 传输，单一、异步、长连接，适合数据量小、高并发和服务提供者远远少于消费者的场景。<br> <em>Feign</em>：</li>
<li>基于 Http 传输协议，短连接，不适合高并发的访问。</li>
</ul>
</li>
<li>负载均衡<br> <strong>Dubbo</strong>：<ul>
<li>支持 4 种算法（<code>随机、轮询、活跃度、Hash 一致性</code>），而且算法里面引入权重的概念。  </li>
<li>配置的形式不仅<strong>支持代码配置，还支持 Dubbo 控制台灵活动态配置</strong>。  </li>
<li>负载均衡的算法可以精准到某个服务接口的某个方法。<br> <em>Feign</em>：</li>
<li>只支持 N 种策略：<code>轮询、随机、ResponseTime 加权</code>。  </li>
<li>负载均衡算法是 Client 级别的。</li>
</ul>
</li>
<li>容错策略<br> <strong>Dubbo</strong>：<ul>
<li>支持多种容错策略：<code>failover、failfast、brodecast、forking</code> 等，也引入了 retry 次数、timeout 等配置参数。<br> <em>Feign</em>：</li>
<li>利用<em>熔断机制来实现容错</em>的，处理的方式不一样。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">比较项</th>
<th align="center">Feign（RESTful）</th>
<th align="center">Dubbo</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通讯协议</td>
<td align="center">HTTP</td>
<td align="center">默认 Dubbo 协议</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">略低</td>
<td align="center">较高</td>
</tr>
<tr>
<td align="center">灵活度</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
</tbody></table>
<h3 id="4-Open-Feign-迁移-Dubbo"><a href="#4-Open-Feign-迁移-Dubbo" class="headerlink" title="4.Open Feign 迁移 Dubbo"></a>4.Open <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Feign&spm=1001.2101.3001.7020">Feign</a> 迁移 Dubbo</h3><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Dubbo&spm=1001.2101.3001.7020">Dubbo</a> Spring Cloud 提供了方案，即 <code>@DubboTransported</code> 注解，支持在类，方法，属性上使用。能够帮助服务消费端的 <code>Spring Cloud Open Feign</code> 接口以及 <code>@LoadBalanced</code> RestTemplate Bean 底层走 Dubbo 调用（可切换 Dubbo 支持的协议），而服务提供方则只需在原有 @RestController 类上追加  <code>@DubboServce</code> 注解（需要抽取接口）即可，换言之，在不调整 Feign 接口以及 RestTemplate URL 的前提下，实现无缝迁移。  </p>
<blockquote>
<p>前提是为每个服务提供者配置好 <code>application.yml中的dubbo</code>，尤其是 <code>port</code> 端口配置要不同（配置为 <strong>-1</strong> 自动选择不冲突的端口）。</p>
</blockquote>
<ol>
<li>修改服务提供者<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@DubboService</span>  <br><span class="hljs-meta">@RefreshScope</span> <span class="hljs-comment">//添加此注解就能实现自动刷新了  </span><br><span class="hljs-meta">@RequestMapping(&quot;/api/user&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;  <br>    <span class="hljs-meta">@Resource</span>  <br>    UserService userService;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 根据用户ID获取用户信息     *     * <span class="hljs-doctag">@param</span> uid 用户ID  </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 用户信息  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-meta">@GetMapping(&quot;/&#123;uid&#125;&quot;)</span>  <br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> Integer uid)</span> &#123;  <br>        <span class="hljs-keyword">return</span> userService.getUserById(uid);  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>消费端引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        服务调用--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li>feign 的实现，启动类上添加 <code>@EnableFeignClients</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowApplication</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        SpringApplication.run(BorrowApplication.class, args);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>feign 接口添加 <code>@DubboTransported</code> 注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboTransported(protocol = &quot;dubbo&quot;)</span>  <br><span class="hljs-meta">@FeignClient(value = &quot;user-service&quot;, fallback = UserClientImpl.class, path = &quot;/api/user/&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserClient</span> &#123;  <br>    <span class="hljs-meta">@RequestMapping(&quot;/uid&#125;&quot;)</span>  <br>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;  <br>    <span class="hljs-meta">@RequestMapping(&quot;/remain/&#123;uid&#125;&quot;)</span>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">userRemain</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;  <br>    <span class="hljs-meta">@RequestMapping(&quot;/borrow/&#123;uid&#125;&quot;)</span>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">userBorrow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;uid&quot;)</span> <span class="hljs-type">int</span> uid)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="5">
<li>调用对象添加 <code>@DubboTransported</code> 注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>  <br><span class="hljs-meta">@Slf4j</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BorrowServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BorrowService</span> &#123;  <br>    <span class="hljs-meta">@Resource</span>  <br>    BorrowMapper borrowMapper;  <br>    <span class="hljs-meta">@Resource</span>  <br>    <span class="hljs-meta">@DubboTransported</span>    <br>    UserClient userClient;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="RabbitMQ-消息队列"><a href="#RabbitMQ-消息队列" class="headerlink" title="RabbitMQ 消息队列"></a>RabbitMQ 消息队列</h2><p><img src="https://s2.loli.net/2023/03/08/9a2q4ZBuWxJs861.jpg" srcset="/img/loading.gif" lazyload alt="image-20220415163559986"><br>什么是消息队列呢？<br>我们之前如果需要进行远程调用，那么一般可以通过发送 HTTP 请求来完成，而现在，我们可以使用第二种方式，就是消息队列，它能够将发送方发送的信息放入队列中，当新的消息入队时，会通知接收方进行处理，一般消息发送方称为生产者，接收方称为消费者。<br><img src="https://s2.loli.net/2023/03/08/yknBVt2jGgFSTO8.jpg" srcset="/img/loading.gif" lazyload alt="image-20220415165805716"><br>这样我们所有的请求，都可以直接丢到消息队列中，再由消费者取出，不再是直接连接消费者的形式了，而是加了一个中间商，这也是一种很好的解耦方案，并且在高并发的情况下，由于消费者能力有限，消息队列也能起到一个削峰填谷的作用，堆积一部分的请求，再由消费者来慢慢处理，而不会像直接调用那样请求蜂拥而至。<br>那么，消息队列具体实现有哪些呢：</p>
<ul>
<li>RabbitMQ  -  性能很强，吞吐量很高，支持多种协议，集群化，消息的可靠执行特性等优势，很适合企业的开发。</li>
<li>Kafka - 提供了超高的吞吐量，ms 级别的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。</li>
<li>RocketMQ  -  阿里巴巴推出的消息队列，经历过双十一的考验，单机吞吐量高，消息的高可靠性，扩展性强，支持事务等，但是功能不够完整，语言支持性较差。</li>
</ul>
<p>我们这里，主要讲解的是 RabbitMQ 消息队列。<br><strong>官方网站：</strong> <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">https://www.rabbitmq.com</a></p>
<blockquote>
<p>RabbitMQ 拥有数万计的用户，是最受欢迎的开源消息队列之一，从 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=1qcTu2QUtrU">T-Mobile</a> 到 <a target="_blank" rel="noopener" href="https://medium.com/@runtastic/messagebus-handling-dead-letters-in-rabbitmq-using-a-dead-letter-exchange-f070699b952b">Runtastic</a>，RabbitMQ 在全球范围内用于小型初创企业和大型企业。</p>
<p>RabbitMQ 轻量级，易于在本地和云端部署，它支持多种消息协议。RabbitMQ 可以部署在分布式和联合配置中，以满足大规模、高可用性要求。</p>
<p>RabbitMQ 在许多操作系统和云环境中运行，并为<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/devtools.html">大多数流行语言</a>提供了<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/devtools.html">广泛的开发者工具</a>。</p>
</blockquote>
<p>我们首先还是来看看如何进行安装。</p>
<h3 id="安装消息队列"><a href="#安装消息队列" class="headerlink" title="安装消息队列"></a>安装消息队列</h3><p><strong>下载地址：</strong> <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a><br>由于除了消息队列本身之外还需要 Erlang 环境（RabbitMQ 就是这个语言开发的）所以我们就在我们的 Ubuntu 服务器上进行安装。<br>首先是 Erlang，比较大，1GB 左右：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install erlang<br></code></pre></td></tr></table></figure>
<p>接着安装 RabbitMQ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install rabbitmq-server<br></code></pre></td></tr></table></figure>
<p>安装完成后，可以输入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl status<br></code></pre></td></tr></table></figure>
<p>来查看当前的 RabbitMQ 运行状态，包括运行环境、内存占用、日志文件等信息：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Runtime</span><br><span class="hljs-attribute">OS</span> PID: <span class="hljs-number">13718</span><br><span class="hljs-attribute">OS</span>: Linux<br><span class="hljs-attribute">Uptime</span> (seconds): <span class="hljs-number">65</span><br><span class="hljs-attribute">Is</span> under maintenance?: false<br><span class="hljs-attribute">RabbitMQ</span> version: <span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">9</span><br><span class="hljs-attribute">Node</span> name: rabbit@ubuntu-server-<span class="hljs-number">2</span><br><span class="hljs-attribute">Erlang</span> configuration: Erlang/OTP <span class="hljs-number">23</span><span class="hljs-meta"> [erts-11.1.8] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:64]</span><br><span class="hljs-attribute">Erlang</span> processes: <span class="hljs-number">280</span> used, <span class="hljs-number">1048576</span> limit<br><span class="hljs-attribute">Scheduler</span> run queue: <span class="hljs-number">1</span><br><span class="hljs-attribute">Cluster</span> heartbeat timeout (net_ticktime): <span class="hljs-number">60</span><br></code></pre></td></tr></table></figure>
<p>这样我们的 RabbitMQ 服务器就安装完成了，要省事还得是 Ubuntu 啊。<br>可以看到默认有两个端口名被使用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Listeners</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">25672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">clustering,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">inter-node</span> <span class="hljs-string">and</span> <span class="hljs-string">CLI</span> <span class="hljs-string">tool</span> <span class="hljs-string">communication</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">amqp,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">0</span><span class="hljs-number">-9</span><span class="hljs-number">-1</span> <span class="hljs-string">and</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure>
<p>我们一会主要使用的就是 amqp 协议的那个端口 <code>5672</code> 来进行连接，25672 是集群化端口，之后我们也会用到。<br>接着我们还可以将 RabbitMQ 的管理面板开启，这样话就可以在浏览器上进行实时访问和监控了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management<br></code></pre></td></tr></table></figure>
<p>再次查看状态，可以看到多了一个管理面板，使用的是 HTTP 协议：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">Listeners</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">25672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">clustering,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">inter-node</span> <span class="hljs-string">and</span> <span class="hljs-string">CLI</span> <span class="hljs-string">tool</span> <span class="hljs-string">communication</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">amqp,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">0</span><span class="hljs-number">-9</span><span class="hljs-number">-1</span> <span class="hljs-string">and</span> <span class="hljs-string">AMQP</span> <span class="hljs-number">1.0</span><br><span class="hljs-attr">Interface:</span> [<span class="hljs-string">::</span>]<span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">15672</span><span class="hljs-string">,</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">http,</span> <span class="hljs-attr">purpose:</span> <span class="hljs-string">HTTP</span> <span class="hljs-string">API</span><br></code></pre></td></tr></table></figure>
<p>我们打开浏览器直接访问一下：<br><img src="https://s2.loli.net/2023/03/08/HxtXlqi7BUYWdC2.jpg" srcset="/img/loading.gif" lazyload alt="image-20220415203431587"><br>可以看到需要我们进行登录才可以进入，我们这里还需要创建一个用户才可以，这里就都用 admin：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl add_user 用户名 密码<br></code></pre></td></tr></table></figure>
<p>将管理员权限给予我们刚刚创建好的用户：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl set_user_tags admin administrator<br></code></pre></td></tr></table></figure>
<p>创建完成之后，我们登录一下页面：<br><img src="https://s2.loli.net/2023/03/08/eEJMsxhc5Onpld8.jpg" srcset="/img/loading.gif" lazyload alt="image-20220415203728664"><br>进入了之后会显示当前的消息队列情况，包括版本号、Erlang 版本等，这里需要介绍一下 RabbitMQ 的设计架构，这样我们就知道各个模块管理的是什么内容了：<br><img src="https://s2.loli.net/2023/03/08/j5kIgD9ZRQiGtd6.jpg" srcset="/img/loading.gif" lazyload alt="image-20220416103043845"></p>
<ul>
<li><strong>生产者（Publisher）和消费者（Consumer）：</strong> 不用多说了吧。</li>
<li><strong>Channel：</strong> 我们的客户端连接都会使用一个 Channel，再通过 Channel 去访问到 RabbitMQ 服务器，注意通信协议不是 http，而是 amqp 协议。</li>
<li><strong>Exchange：</strong> 类似于交换机一样的存在，会根据我们的请求，转发给相应的消息队列，每个队列都可以绑定到 Exchange 上，这样 Exchange 就可以将数据转发给队列了，可以存在很多个，不同的 Exchange 类型可以用于实现不同消息的模式。</li>
<li><strong>Queue：</strong> 消息队列本体，生产者所有的消息都存放在消息队列中，等待消费者取出。</li>
<li><strong>Virtual Host：</strong> 有点类似于环境隔离，不同环境都可以单独配置一个 Virtual Host，每个 Virtual Host 可以包含很多个 Exchange 和 Queue，每个 Virtual Host 相互之间不影响。</li>
</ul>
<h3 id="使用消息队列"><a href="#使用消息队列" class="headerlink" title="使用消息队列"></a>使用消息队列</h3><p>我们就从最简的的模型开始讲起：<br><img src="https://s2.loli.net/2023/03/08/GWkUJx1g8ZnTV57.jpg" srcset="/img/loading.gif" lazyload alt="image-20220417103647609"><br>（一个生产者 -&gt; 消息队列 -&gt; 一个消费者）<br>生产者只需要将数据丢进消息队列，而消费者只需要将数据从消息队列中取出，这样就实现了生产者和消费者的消息交互。我们现在来演示一下，首先进入到我们的管理页面，这里我们创建一个新的实验环境，只需要新建一个 Virtual Host 即可：<br><img src="https://s2.loli.net/2023/03/08/PzehXHuDyFANIKV.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419143014974"><br>添加新的虚拟主机之后，我们可以看到，当前 admin 用户的主机访问权限中新增了我们刚刚添加的环境：<br><img src="https://s2.loli.net/2023/03/08/9cGyunKrTvjfDRp.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419143115507"><br>现在我们来看看交换机：<br><img src="https://s2.loli.net/2023/03/08/GDnFoizW86pC5l9.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419143338487"><br>交换机列表中自动为我们新增了刚刚创建好的虚拟主机相关的预设交换机，一共7个，这里我们首先介绍一下前面两个 <code>direct</code> 类型的交换机，一个是 <code>（AMQP default）</code> 还有一个是 <code>amq.direct</code>，它们都是直连模式的交换机，我们来看看第一个：<br><img src="https://s2.loli.net/2023/03/08/lIpfxGjLPrOatE5.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419143612318"><br>第一个交换机是所有虚拟主机都会自带的一个默认交换机，并且此交换机不可删除，此交换机默认绑定到所有的消息队列，如果是通过默认交换机发送消息，那么会根据消息的 <code>routingKey</code>（之后我们发消息都会指定）决定发送给哪个同名的消息队列，同时也不能显示地将消息队列绑定或解绑到此交换机。<br>我们可以看到，详细信息中，当前交换机特性是持久化的，也就是说就算机器重启，那么此交换机也会保留，如果不是持久化，那么一旦重启就会消失。实际上我们在列表中看到 <code>D</code> 的字样，就表示此交换机是持久化的，包含一会我们要讲解的消息队列列表也是这样，所有自动生成的交换机都是持久化的。<br>我们接着来看第二个交换机，这个交换机是一个普通的直连交换机：<br><img src="https://s2.loli.net/2023/03/08/DnpENxIPgOUTSbM.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419144200533"><br>这个交换机和我们刚刚介绍的默认交换机类型一致，并且也是持久化的，但是我们可以看到它是具有绑定关系的，如果没有指定的消息队列绑定到此交换机上，那么这个交换机无法正常将信息存放到指定的消息队列中，也是根据 <code>routingKey</code> 寻找消息队列（但是可以自定义）<br>我们可以在下面直接操作，让某个队列绑定，这里我们先不进行操作。<br>介绍完了两个最基本的交换机之后（其他类型的交换机我们会在后面进行介绍），我们接着来看消息队列：<br><img src="https://s2.loli.net/2023/03/08/q7WcUvZp8NhMb9f.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419144508881"><br>可以看到消息队列列表中没有任何的消息队列，我们可以来尝试添加一个新的消息队列：<br><img src="https://s2.loli.net/2023/03/08/D8hv6Kbo3eSNzVp.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419144553817"><br>第一行，我们选择我们刚刚创建好的虚拟主机，在这个虚拟主机下创建此消息队列，接着我们将其类型定义为 <code>Classic</code> 类型，也就是经典类型（其他类型我们会在后面逐步介绍）名称随便起一个，然后持久化我们选择 <code>Transient</code> 暂时的（当然也可以持久化，看你自己）自动删除我们选择 <code>No</code>（需要至少有一个消费者连接到这个队列，之后，一旦所有与这个队列连接的消费者都断开时，就会自动删除此队列）最下面的参数我们暂时不进行任何设置（之后会用到）<br>现在，我们就创建好了一个经典的消息队列：<br><img src="https://s2.loli.net/2023/03/08/yGSt4HbT7iX3Nze.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145109450"><br>点击此队列的名称，我们可以查看详细信息：<br><img src="https://s2.loli.net/2023/03/08/NGCFKhcUf9lOADX.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145238458"><br>详细相信中包括队列的当前负载状态、属性、消息队列占用的内存，消息数量等，一会我们发送消息时可以进一步进行观察。<br>现在我们需要将此消息队列绑定到上面的第二个直连交换机，这样我们就可以通过此交换机向此消息队列发送消息了：<br><img src="https://s2.loli.net/2023/03/08/NGCFKhcUf9lOADX.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145520844"><br>这里填写之前第二个交换机的名称还有我们自定义的 <code>routingKey</code>（最好还是和消息队列名称一致，这里是为了一会演示两个交换机区别用）我们直接点击绑定即可：<br><img src="https://s2.loli.net/2023/03/08/u95NJG2YskOBpXl.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145635179"><br>绑定之后我们可以看到当前队列已经绑定对应的交换机了，现在我们可以前往交换机对此消息队列发送一个消息：<br><img src="https://s2.loli.net/2023/03/08/MBIDVqzf8oce2L4.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145725499"><br>回到交换机之后，可以卡到这边也是同步了当前的绑定信息，在下方，我们直接向此消息队列发送信息：<br><img src="https://s2.loli.net/2023/03/08/htEoZ49zu6mipCM.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145808450"><br>点击发送之后，我们回到刚刚的交换机详细页面，可以看到已经有一条新的消息在队列中了：<br><img src="https://s2.loli.net/2023/03/08/nO9eUjMRbCmBqPT.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145903723"><br>我们可以直接在消息队列这边获取消息队列中的消息，找到下方的 Get message 选项：<br><img src="https://s2.loli.net/2023/03/08/emrY3SZ98CJRAOh.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419145936160"><br>可以看到有三个选择，首先第一个 Ack Mode，这个是应答模式选择，一共有 4 个选项：<br><img src="https://s2.loli.net/2023/03/08/nrWPuoGRTp7F36e.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419150053926"></p>
<ul>
<li>Nack message requeue true：拒绝消息，也就是说不会将消息从消息队列取出，并且重新排队，一次可以拒绝多个消息。</li>
<li>Ack message requeue false：确认应答，确认后消息会从消息队列中移除，一次可以确认多个消息。</li>
<li>Reject message requeue true&#x2F;false：也是拒绝此消息，但是可以指定是否重新排队。</li>
</ul>
<p>这里我们使用默认的就可以了，这样只会查看消息是啥，但是不会取出，消息依然存在于消息队列中，第二个参数是编码格式，使用默认的就可以了，最后就是要生效的操作数量，选择 1 就行：<br><img src="https://s2.loli.net/2023/03/08/c6auDXoHFqZT9M2.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419150712314"><br>可以看到我们刚刚的消息已经成功读取到。<br>现在我们再去第一个默认交换机中尝试发送消息试试看：<br><img src="https://s2.loli.net/2023/03/08/t5V3yQ8kbOKRpxf.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419150913859"><br>如果我们使用之前自定义的<code>routingKey</code>，会显示没有路由，这是因为默认的交换机只会找对应名称的消息队列，我们现在向<code>yyds</code>发送一下试试看：<br><img src="https://s2.loli.net/2023/03/08/LCVPvykIjMox9m1.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419151016735"><br>可以看到消息成功发布了，我们来接收一下看看：<br><img src="https://s2.loli.net/2023/03/08/9jsdfADB5HRC7wP.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419151058659"><br>可以看到成功发送到此消息队列中了。<br>当然除了在交换机发送消息给消息队列之外，我们也可以直接在消息队列这里发：<br><img src="https://s2.loli.net/2023/03/08/cYPwJnbiZlmvqD3.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419151155264"><br>效果是一样的，注意这里我们可以选择是否将消息持久化，如果是持久化消息，那么就算服务器重启，此消息也会保存在消息队列中。<br>最后如果我们不需要再使用此消息队列了，我们可以手动对其进行删除或是清空：<br><img src="https://s2.loli.net/2023/03/08/kJE5xwgZOTGWjLq.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419151548923"><br>点击 Delete Queue 删除我们刚刚创建好的<code>yyds</code>队列，到这里，我们对应消息队列的一些简单使用，就讲解完毕了。</p>
<h3 id="使用-Java-操作消息队列"><a href="#使用-Java-操作消息队列" class="headerlink" title="使用 Java 操作消息队列"></a>使用 Java 操作消息队列</h3><p>现在我们来看看如何通过 Java 连接到 RabbitMQ 服务器并使用消息队列进行消息发送（这里一起讲解，包括 Java 基础版本和 SpringBoot 版本），首先我们使用最基本的 Java 客户端连接方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.14.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>依赖导入之后，我们来实现一下生产者和消费者，首先是生产者，生产者负责将信息发送到消息队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//使用 ConnectionFactory 来创建连接</span><br>    <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>    <span class="hljs-comment">//设定连接信息，基操</span><br>    factory.setHost(<span class="hljs-string">&quot;192.168.0.12&quot;</span>);<br>    factory.setPort(<span class="hljs-number">5672</span>);  <span class="hljs-comment">//注意这里写 5672，是 amqp 协议端口</span><br>    factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setVirtualHost(<span class="hljs-string">&quot;/test&quot;</span>);<br> 		<span class="hljs-comment">//创建连接</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection())&#123;<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里我们可以直接在程序中定义并创建消息队列（实际上是和我们在管理页面创建一样的效果）客户端需要通过连接创建一个新的通道（Channel），同一个连接下可以有很多个通道，这样就不用创建很多个连接也能支持分开发送了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel())&#123;   <span class="hljs-comment">//通过 Connection 创建新的 Channel</span><br>  	<span class="hljs-comment">//声明队列，如果此队列不存在，会自动创建</span><br>    channel.queueDeclare(<span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>  	<span class="hljs-comment">//将队列绑定到交换机</span><br>    channel.queueBind(<span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>);<br>  	<span class="hljs-comment">//发布新的消息，注意消息需要转换为 byte[]</span><br>    channel.basicPublish(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>.getBytes());<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>queueDeclare</code>方法的参数如下：</p>
<ul>
<li><strong>queue</strong>：队列的名称（默认创建后 routingKey 和队列名称一致）</li>
<li><strong>durable</strong>：是否持久化。</li>
<li><strong>exclusive</strong>：是否排他，如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。排他队列是基于 Connection 可见，同一个 Connection 的不同 Channel 是可以同时访问同一个连接创建的排他队列，并且，如果一个 Connection 已经声明了一个排他队列，其他的 Connection 是不允许建立同名的排他队列的，即使该队列是持久化的，一旦 Connection 关闭或者客户端退出，该排他队列都会自动被删除。</li>
<li><strong>autoDelete</strong>：是否自动删除。</li>
<li><strong>arguments</strong>：设置队列的其他一些参数，这里我们暂时不需要什么其他参数。</li>
</ul>
<p>其中<code>queueBind</code>方法参数如下：</p>
<ul>
<li><strong>queue</strong>：需要绑定的队列名称。</li>
<li><strong>exchange</strong>：需要绑定的交换机名称。</li>
<li><strong>routingKey</strong>：不用多说了吧。</li>
</ul>
<p>其中<code>basicPublish</code>方法的参数如下：</p>
<ul>
<li><strong>exchange</strong>: 对应的 Exchange 名称，我们这里就使用第二个直连交换机。</li>
<li><strong>routingKey</strong>：这里我们填写绑定时指定的 routingKey，其实和之前在管理页面操作一样。</li>
<li><strong>props</strong>：其他的配置。</li>
<li><strong>body</strong>：消息本体。</li>
</ul>
<p>执行完成后，可以在管理页面中看到我们刚刚创建好的消息队列了：<br><img src="https://s2.loli.net/2023/03/08/baiDgVyoPQ65TMX.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419153630431"><br>并且此消息队列已经成功与<code>amq.direct</code>交换机进行绑定：<br><img src="https://s2.loli.net/2023/03/08/5lENjHswniC4Zg8.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419154618613"><br>那么现在我们的消息队列中已经存在数据了，怎么将其读取出来呢？我们来看看如何创建一个消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>    <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>    factory.setHost(<span class="hljs-string">&quot;10.37.129.4&quot;</span>);<br>    factory.setPort(<span class="hljs-number">5672</span>);<br>    factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);<br>    factory.setVirtualHost(<span class="hljs-string">&quot;/test&quot;</span>);<br>    <span class="hljs-comment">//这里不使用 try-with-resource，因为消费者是一直等待新的消息到来，然后按照</span><br>    <span class="hljs-comment">//我们设定的逻辑进行处理，所以这里不能在定义完成之后就关闭连接</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>    <span class="hljs-comment">//创建一个基本的消费者</span><br>    channel.basicConsume(<span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-literal">false</span>, (s, delivery) -&gt; &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody()));<br>        <span class="hljs-comment">//basicAck 是确认应答，第一个参数是当前的消息标签，后面的参数是</span><br>        <span class="hljs-comment">//是否批量处理消息队列中所有的消息，如果为 false 表示只处理当前消息</span><br>        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//basicNack 是拒绝应答，最后一个参数表示是否将当前消息放回队列，如果</span><br>        <span class="hljs-comment">//为 false，那么消息就会被丢弃</span><br>        <span class="hljs-comment">//channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);</span><br>        <span class="hljs-comment">//跟上面一样，最后一个参数为 false，只不过这里省了</span><br>        <span class="hljs-comment">//channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</span><br>    &#125;, s -&gt; &#123;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中<code>basicConsume</code>方法参数如下：</p>
<ul>
<li><strong>queue</strong>  -  消息队列名称，直接指定。</li>
<li><strong>autoAck</strong> - 自动应答，消费者从消息队列取出数据后，需要跟服务器进行确认应答，当服务器收到确认后，会自动将消息删除，如果开启自动应答，那么消息发出后会直接删除。</li>
<li><strong>deliver</strong>  -  消息接收后的函数回调，我们可以在回调中对消息进行处理，处理完成后，需要给服务器确认应答。</li>
<li><strong>cancel</strong>  -  当消费者取消订阅时进行的函数回调，这里暂时用不到。<br>现在我们启动一下消费者，可以看到立即读取到我们刚刚插入到队列中的数据：<br><img src="https://s2.loli.net/2023/03/08/rR7eThxXbufjsEo.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419155938158"><br>我们现在继续在消息队列中插入新的数据，这里直接在网页上进行操作就行了，同样的我们也可以在消费者端接受并进行处理。<br>现在我们把刚刚创建好的消息队列删除。<br>官方文档： <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-amqp/docs/current/reference/html/">https://docs.spring.io/spring-amqp/docs/current/reference/html/</a><br>前面我们已经完成了 RabbitMQ 的安装和简单使用，并且通过 Java 连接到服务器。现在我们来尝试在 SpringBoot 中整合消息队列客户端，首先是依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
接着我们需要配置 RabbitMQ 的地址等信息：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">addresses:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/test</span><br></code></pre></td></tr></table></figure>
这样我们就完成了最基本信息配置，现在我们来看一下，如何像之前一样去声明一个消息队列，我们只需要一个配置类就行了：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;directExchange&quot;)</span>  <span class="hljs-comment">//定义交换机 Bean，可以很多个</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(<span class="hljs-string">&quot;amq.direct&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span>     <span class="hljs-comment">//定义消息队列</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>          				.nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)   <span class="hljs-comment">//非持久化类型</span><br>          				.build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>      	<span class="hljs-comment">//将我们刚刚定义的交换机和队列进行绑定</span><br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)   <span class="hljs-comment">//绑定队列</span><br>                .to(exchange)  <span class="hljs-comment">//到交换机</span><br>                .with(<span class="hljs-string">&quot;my-yyds&quot;</span>)   <span class="hljs-comment">//使用自定义的 routingKey</span><br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
接着我们来创建一个生产者，这里我们直接编写在测试用例中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringCloudMqApplicationTests</span> &#123;<br>  	<span class="hljs-comment">//RabbitTemplate 为我们封装了大量的 RabbitMQ 操作，已经由 Starter 提供，因此直接注入使用即可</span><br>    <span class="hljs-meta">@Resource</span><br>    RabbitTemplate template;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>      	<span class="hljs-comment">//使用 convertAndSend 方法一步到位，参数基本和之前是一样的</span><br>      	<span class="hljs-comment">//最后一个消息本体可以是 Object 类型，真是大大的方便</span><br>        template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
现在我们来运行一下这个测试用例：<br><img src="https://s2.loli.net/2023/03/08/UxVemu9B2cGifWv.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419221426545"><br>可以看到后台自动声明了我们刚刚定义好的消息队列和交换机以及对应的绑定关系，并且我们的数据也是成功插入到消息队列中：<br><img src="https://s2.loli.net/2023/03/08/RjY4JUn7v9pmryx.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419221532673"><br>现在我们再来看看如何创建一个消费者，因为消费者实际上就是一直等待消息然后进行处理的角色，这里我们只需要创建一个监听器就行了，它会一直等待消息到来然后再进行处理：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <span class="hljs-comment">//注册为 Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span>   <span class="hljs-comment">//定义此方法为队列 yyds 的监听器，一旦监听到新的消息，就会接受并处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Message message)</span>&#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
接着我们启动服务器：<br><img src="https://s2.loli.net/2023/03/08/ZjRs8u2cHbBEOaW.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419230223151"><br>可以看到控制台成功输出了我们之前放入队列的消息，并且管理页面中也显示此消费者已经连接了：<br><img src="https://s2.loli.net/2023/03/08/RwUFdgqXlDKk7AI.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419230315376"><br>接着我们再通过管理页面添加新的消息看看，也是可以正常进行接受的。<br>当然，如果我们需要确保消息能够被消费者接受并处理，然后得到消费者的反馈，也是可以的：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>  	<span class="hljs-comment">//会等待消费者消费然后返回响应结果</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> template.convertSendAndReceive(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;收到消费者响应：&quot;</span>+res);<br>&#125; <br></code></pre></td></tr></table></figure>
消费者这边只需要返回一个对应的结果即可：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;收到!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
测试没有问题：<br><img src="https://s2.loli.net/2023/03/08/OkV6zN9PJRlwnQF.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421142425891"><br>那么如果我们需要直接接收一个 JSON 格式的消息，并且希望直接获取到实体类呢？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>  	...<br>    <span class="hljs-meta">@Bean(&quot;jacksonConverter&quot;)</span>   <span class="hljs-comment">//直接创建一个用于 JSON 转换的 Bean</span><br>    <span class="hljs-keyword">public</span> Jackson2JsonMessageConverter <span class="hljs-title function_">converter</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
接着我们只需要指定转换器就可以了：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>  	<span class="hljs-comment">//指定 messageConverter 为我们刚刚创建的 Bean 名称</span><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;, messageConverter = &quot;jacksonConverter&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(User user)</span>&#123;  <span class="hljs-comment">//直接接收 User 类型</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
现在我们直接在管理页面发送：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;LB&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
!<img src="https://s2.loli.net/2023/03/08/3dXbs5naViUMrDO.jpg" srcset="/img/loading.gif" lazyload alt="image-20220416225912100">]( <a target="_blank" rel="noopener" href="https://tva1.sinaimg.cn/large/e6c9d24ely1h1byhcakabj221m0lwac0.jpg">https://tva1.sinaimg.cn/large/e6c9d24ely1h1byhcakabj221m0lwac0.jpg</a> )<br>可以看到成功完成了转换，并输出了用户信息：<br><img src="https://s2.loli.net/2023/03/08/aM8SCL12hkKynUu.jpg" srcset="/img/loading.gif" lazyload alt="image-20220416225829807"><br>同样的，我们也可以直接发送 User，因为我们刚刚已经配置了 <code>Jackson2JsonMessageConverter</code> 为 Bean，所以直接使用就可以了：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>    template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;yyds&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
可以看到后台的数据类型为：<br><img src="https://s2.loli.net/2023/03/08/xVSpC7KHE1RyOk6.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419232715025"><br><img src="https://s2.loli.net/2023/03/08/Q9tBuprGwfleNLZ.jpg" srcset="/img/loading.gif" lazyload alt="image-20220416231709750"><br>这样，我们就通过 SpringBoot 实现了 RabbitMQ 的简单使用。</li>
</ul>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>消息队列中的数据，如果迟迟没有消费者来处理，那么就会一直占用消息队列的空间。比如我们模拟一下抢车票的场景，用户下单高铁票之后，会进行抢座，然后再进行付款，但是如果用户下单之后并没有及时的付款，这张票不可能一直让这个用户占用着，因为你不买别人还要买呢，所以会在一段时间后超时，让这张票可以继续被其他人购买。<br>这时，我们就可以使用死信队列，将那些用户超时未付款的或是用户主动取消的订单，进行进一步的处理，以下类型的消息都会被判定为死信：</p>
<ul>
<li>消息被拒绝(basic.reject &#x2F; basic.nack)，并且 requeue &#x3D; false</li>
<li>消息 TTL 过期</li>
<li>队列达到最大长度<br><img src="https://s2.loli.net/2023/03/08/itUWySuA9kvcEgs.jpg" srcset="/img/loading.gif" lazyload alt="image-20220419112336088"><br>那么如何构建这样的一种使用模式呢？实际上本质就是一个死信交换机+绑定的死信队列，当正常队列中的消息被判定为死信时，会被发送到对应的死信交换机，然后再通过交换机发送到死信队列中，死信队列也有对应的消费者去处理消息。<br>这里我们直接在配置类中创建一个新的死信交换机和死信队列，并进行绑定：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;directDlExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">dlExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//创建一个新的死信交换机</span><br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yydsDlQueue&quot;)</span>   <span class="hljs-comment">//创建一个新的死信队列</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">dlQueue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .nonDurable(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>                .build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;dlBinding&quot;)</span>   <span class="hljs-comment">//死信交换机和死信队列进绑定</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">dlBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directDlExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsDlQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>                .noargs();<br>    &#125;<br>		...<br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)<br>                .deadLetterExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>)   <span class="hljs-comment">//指定死信交换机</span><br>                .deadLetterRoutingKey(<span class="hljs-string">&quot;dl-yyds&quot;</span>)   <span class="hljs-comment">//指定死信 RoutingKey</span><br>                .build();<br>    &#125;<br>  	...<br>&#125;<br></code></pre></td></tr></table></figure>
接着我们将监听器修改为死信队列监听：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;dl-yyds&quot;, messageConverter = &quot;jacksonConverter&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(User user)</span>&#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
配置完成后，我们来尝试启动一下吧，注意启动之前记得把之前的队列给删了，这里要重新定义。<br><img src="https://s2.loli.net/2023/03/08/AdrS9yxnRojfWgL.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420103846981"><br>队列列表中已经出现了我们刚刚定义好的死信队列，并且 yyds 队列也支持死信队列发送功能了，现在我们尝试向此队列发送一个消息，但是我们将其拒绝：<br><img src="https://s2.loli.net/2023/03/08/mLokEWYcQ4PXnar.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420105359931"><br>可以看到拒绝后，如果不让消息重新排队，那么就会变成死信，直接被丢进死信队列中，可以看到在拒绝后：<br><img src="https://s2.loli.net/2023/03/08/rgiWVJMbpKzQX46.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420105455291"><br>现在我们来看看第二种情况，RabbitMQ 支持将超过一定时间没被消费的消息自动删除，这需要消息队列设定 TTL 值，如果消息的存活时间超过了 Time To Live 值，就会被自动删除，自动删除后的消息如果有死信队列，那么就会进入到死信队列中。<br>现在我们将 yyds 消息队列设定 TTL 值（毫秒为单位）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>            .nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)<br>            .deadLetterExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>)<br>            .deadLetterRoutingKey(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>            .ttl(<span class="hljs-number">5000</span>)   <span class="hljs-comment">//如果 5 秒没处理，就自动删除</span><br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure>
现在我们重启测试一下，注意修改了之后记得删除之前的 yyds 队列：<br><img src="https://s2.loli.net/2023/03/08/u8xboyv3aTJ9ZE6.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420110317997"><br>可以看到现在 yyds 队列已经具有 TTL 特性了，我们现在来插入一个新的消息：<br><img src="https://s2.loli.net/2023/03/08/2qensPxuf3zLoQ1.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420110504022"><br>可以看到消息 5 秒钟之后就不见了，而是被丢进了死信队列中。<br>最后我们来看一下当消息队列长度达到最大的情况，现在我们将消息队列的长度进行限制：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>            .nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>)<br>            .deadLetterExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>)<br>            .deadLetterRoutingKey(<span class="hljs-string">&quot;dl-yyds&quot;</span>)<br>            .maxLength(<span class="hljs-number">3</span>)   <span class="hljs-comment">//将最大长度设定为 3</span><br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure>
现在我们重启一下，然后尝试连续插入 4 个消息：<br><img src="https://s2.loli.net/2023/03/08/56TsMf24QlhZCYL.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420135316458"><br>可以看到 yyds 消息队列新增了 Limit 特性，也就是限定长度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) <br>        template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2023/03/08/d3lEHLPR4VNF92T.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420135419673"><br>可以看到因为长度限制为 3，所以有一个消息直接被丢进了死信队列中，为了能够更直观地观察消息队列的机制，我们为 User 类新增一个时间字段：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    String name;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toString();<br>&#125;<br></code></pre></td></tr></table></figure>
接着每隔一秒钟插入一个：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">publisher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        template.convertAndSend(<span class="hljs-string">&quot;amq.direct&quot;</span>, <span class="hljs-string">&quot;my-yyds&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
再次进行上述实验，可以发现如果到达队列长度限制，那么每次插入都会把位于队首的消息丢进死信队列，来腾出空间给新来的消息。</li>
</ul>
<h3 id="工作队列模式"><a href="#工作队列模式" class="headerlink" title="工作队列模式"></a>工作队列模式</h3><p><strong>注意：</strong> XX 模式只是一种设计思路，并不是指的具体的某种实现，可以理解为实现 XX 模式需要怎么去写。<br>前面我们了解了最简的一个消费者一个生产者的模式，接着我们来了解一下一个生产者多个消费者的情况：<br><img src="https://s2.loli.net/2023/03/08/8AR4H5LbOCrXZmu.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420151258324"><br>实际上这种模式就非常适合多个工人等待新的任务到来的场景，我们的任务有很多个，一个一个丢进消息队列，而此时工人有很多个，那么我们就可以将这些任务分配个各个工人，让他们各自负责一些任务，并且做的快的工人还可以做完成一些（能者多劳）。<br>非常简单，我们只需要创建两个监听器即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;   <span class="hljs-comment">//这里直接接收 String 类型的数据</span><br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver2</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;二号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到我们发送消息时，会自动进行轮询分发：<br><img src="https://s2.loli.net/2023/03/08/YgibmNxD9qtHajQ.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420154602883"><br>那么如果我们一开始就在消息队列中放入一部分消息在开启消费者呢？<br><img src="https://s2.loli.net/2023/03/08/Rv6YkDSTPl83Hmo.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420154654901"><br>可以看到，如果是一开始就存在消息，会被一个消费者一次性全部消耗，这是因为我们没有对消费者的 Prefetch count（预获取数量，一次性获取消息的最大数量）进行限制，也就是说我们现在希望的是消费者一次只能拿一个消息，而不是将所有的消息全部都获取。<br><img src="https://s2.loli.net/2023/03/08/UNEniupt5cRHz93.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420160253144"><br>因此我们需要对这个数量进行一些配置，这里我们需要在配置类中定义一个自定义的 <code>ListenerContainerFactory</code>，可以在这里设定消费者 Channel 的 <code>PrefetchCount</code> 的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> CachingConnectionFactory connectionFactory;<br><span class="hljs-meta">@Bean(name = &quot;listenerContainer&quot;)</span><br><span class="hljs-keyword">public</span> SimpleRabbitListenerContainerFactory <span class="hljs-title function_">listenerContainer</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SimpleRabbitListenerContainerFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRabbitListenerContainerFactory</span>();<br>    factory.setConnectionFactory(connectionFactory);<br>    factory.setPrefetchCount(<span class="hljs-number">1</span>);   <span class="hljs-comment">//将 PrefetchCount 设定为 1 表示一次只能取一个</span><br>    <span class="hljs-keyword">return</span> factory;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着我们在监听器这边指定即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;,  containerFactory = &quot;listenerContainer&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;, containerFactory = &quot;listenerContainer&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver2</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;二号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在我们再次启动服务器，可以看到 PrefetchCount 被限定为 1了：<br><img src="https://s2.loli.net/2023/03/08/KgWzOUu8ry2V9Ej.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420164702864"><br>再次重复上述的实现，可以看到消息不会被一号消费者给全部抢走了：<br><img src="https://s2.loli.net/2023/03/08/vmAfh68GpuQXdUk.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420164827502"><br>当然除了去定义两个相同的监听器之外，我们也可以直接在注解中定义，比如我们现在需要 10 个同样的消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds&quot;,  containerFactory = &quot;listenerContainer&quot;, concurrency = &quot;10&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到在管理页面中出现了 10 个消费者：<br><img src="https://s2.loli.net/2023/03/08/REl1qIaMXLTK6js.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420170349298"><br>至此，有关工作队列模式就讲到这里。</p>
<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>前面我们已经了解了 RabbitMQ 客户端的一些基本操作，包括普通的消息模式，接着我们来了解一下其他的模式，首先是发布订阅模式，它支持多种方式：<br><img src="https://s2.loli.net/2023/03/08/fetLjQszH7cTZmO.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420172252440"><br>比如我们在阿里云买了云服务器，但是最近快到期了，那么就会给你的手机、邮箱发送消息，告诉你需要去续费了，但是手机短信和邮件发送并不一定是同一个业务提供的，但是现在我们又希望能够都去执行，所以就可以用到发布订阅模式，简而言之就是，发布一次，消费多个。<br>实现这种模式其实也非常简单，但是如果使用我们之前的直连交换机，肯定是不行的，我们这里需要用到另一种类型的交换机，叫做<code>fanout</code>（扇出）类型，这时一种广播类型，<em>消息会被广播到所有与此交换机绑定的消息队列</em>中。<br>这里我们使用默认的交换机：<br><img src="https://s2.loli.net/2023/03/08/Er7RBCjm3nNJZHT.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420225300171"><br>这个交换机是一个<code>fanout</code>类型的交换机，我们就是要它就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;fanoutExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>      	<span class="hljs-comment">//注意这里是 fanoutExchange</span><br>        <span class="hljs-keyword">return</span> ExchangeBuilder.fanoutExchange(<span class="hljs-string">&quot;amq.fanout&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yydsQueue1&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds1&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;fanoutExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue1&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds1&quot;</span>)<br>                .noargs();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yydsQueue2&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds2&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;binding2&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;fanoutExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue2&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds2&quot;</span>)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里我们将两个队列都绑定到此交换机上，我们先启动看看效果：<br><img src="https://s2.loli.net/2023/03/08/pFXEmbv7LCMKxwq.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420230954785"><br>绑定没有什么问题，接着我们搞两个监听器，监听一下这两个队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds1&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;一号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;yyds2&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiver2</span><span class="hljs-params">(String data)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;二号消息队列监听器 &quot;</span>+data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在我们通过交换机发送消息，看看是不是两个监听器都会接收到消息：<br><img src="http://qnpicmap.fcsluck.top/pics/202311231107309.png" srcset="/img/loading.gif" lazyload alt="image.png"><br>可以看到确实是两个消息队列都能够接受到此消息，这样我们就实现了发布订阅模式。</p>
<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>路由模式实际上我们一开始就已经实现了，我们可以在绑定时指定想要的<code>routingKey</code>只有生产者发送时指定了对应的<code>routingKey</code>才能到达对应的队列。<br><img src="https://s2.loli.net/2023/03/08/52vs9bualApXGMR.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420232826848"><br>当然除了我们之前的一次绑定之外，同一个消息队列可以多次绑定到交换机，并且使用不同的<code>routingKey</code>，这样只要满足其中一个都可以被发送到此消息队列中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;directExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(<span class="hljs-string">&quot;amq.direct&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span>   <span class="hljs-comment">//使用 yyds1 绑定</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds1&quot;</span>)<br>                .noargs();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;binding2&quot;)</span>   <span class="hljs-comment">//使用 yyds2 绑定</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;directExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;yyds2&quot;</span>)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>启动后我们可以看到管理面板中出现了两个绑定关系：<br><img src="https://s2.loli.net/2023/03/08/n9NxMEsoCeWSaVL.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420233606749"><br>这里可以测试一下，随便使用哪个<code>routingKey</code>都可以。</p>
<h3 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h3><p>实际上这种模式就是一种模糊匹配的模式，我们可以将<code>routingKey</code>以模糊匹配的方式去进行转发。<br><img src="https://s2.loli.net/2023/03/08/z45gI7UaKmCipEL.jpg" srcset="/img/loading.gif" lazyload alt="image-20220420233721239"><br>我们可以使用<code>*</code>或<code>#</code>来表示：</p>
<ul>
<li><code>*</code> ：表示任意的一个单词</li>
<li><code>#</code> ：表示 0 个或多个单词<br>这里我们来测试一下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;topicExchange&quot;)</span>  <span class="hljs-comment">//这里使用预置的 Topic 类型交换机</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.topicExchange(<span class="hljs-string">&quot;amq.topic&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;topicExchange&quot;)</span> Exchange exchange,</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)<br>                .with(<span class="hljs-string">&quot;*.test.*&quot;</span>)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
启动项目，可以看到只要是满足通配符条件的都可以成功转发到对应的消息队列：<br><img src="https://s2.loli.net/2023/03/08/aS37QitoUdf4FZ9.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421103753962"><br>接着我们可以再试试看<code>#</code>通配符。<br>除了我们这里使用的默认主题交换机之外，还有一个叫做<code>amq.rabbitmq.trace</code>的交换机：<br><img src="https://s2.loli.net/2023/03/08/CWfRIwoYLjQrbpH.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421104035463"><br>可以看到它也是<code>topic</code>类型的，那么这个交换机是做什么的呢？实际上这是用于帮助我们记录和追踪生产者和消费者使用消息队列的交换机，它是一个内部的交换机，那么如果使用呢？首先创建一个消息队列用于接收记录：<br><img src="https://s2.loli.net/2023/03/08/s7B38pjkd4EGFLI.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421104619325"><br>接着我们需要在控制台将虚拟主机<code>/test</code>的追踪功能开启：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl trace_on -p /test<br></code></pre></td></tr></table></figure>
开启后，我们将此队列绑定到上面的交换机上：<br><img src="https://s2.loli.net/2023/03/08/VsD2dYIpHhbt6R9.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421104843224"><br><img src="https://s2.loli.net/2023/03/08/EM4WKHqtyz3vLSk.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421105141144"><br>由于发送到此交换机上的<code>routingKey</code>为 routing key 为 publish.交换机名称和 deliver.队列名称，分别对应生产者投递到交换机的消息，和消费者从队列上获取的消息，因此这里使用<code>#</code>通配符进行绑定。<br>现在我们来测试一下，比如还是往 yyds 队列发送消息：<br><img src="https://s2.loli.net/2023/03/08/vHKPqJFahV8y7l3.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421105242770"><br>可以看到在发送消息，并且消费者已经处理之后，<code>trace</code>队列中新增了两条消息，那么我们来看看都是些什么消息：<br><img src="https://s2.loli.net/2023/03/08/vHKPqJFahV8y7l3.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421105528532"><br>通过追踪，我们可以很明确地得知消息发送的交换机、routingKey、用户等信息，包括信息本身，同样的，消费者在取出数据时也有记录：<br><img src="https://s2.loli.net/2023/03/08/NApBodythmfjzMV.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421105638715"><br>我们可以明确消费者的地址、端口、具体操作的队列以及取出的消息信息等。<br>到这里，我们就已经了解了 3 种类型的交换机。</li>
</ul>
<h3 id="第四种交换机类型"><a href="#第四种交换机类型" class="headerlink" title="第四种交换机类型"></a>第四种交换机类型</h3><p>通过前面的学习，我们已经介绍了三种交换机类型，现在我们来介绍一下第四种交换机类型<code>header</code>，它是根据头部信息来决定的，在我们发送的消息中是可以携带一些头部信息的（类似于 HTTP），我们可以根据这些头部信息来决定路由到哪一个消息队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;headerExchange&quot;)</span>  <span class="hljs-comment">//注意这里返回的是 HeadersExchange</span><br>    <span class="hljs-keyword">public</span> HeadersExchange <span class="hljs-title function_">exchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder<br>                .headersExchange(<span class="hljs-string">&quot;amq.headers&quot;</span>)  <span class="hljs-comment">//RabbitMQ 为我们预置了两个，这里用第一个就行</span><br>                .build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;yydsQueue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queue</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(<span class="hljs-string">&quot;yyds&quot;</span>).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;binding&quot;)</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding2</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;headerExchange&quot;)</span> HeadersExchange exchange,  //这里和上面一样的类型</span><br><span class="hljs-params">                           <span class="hljs-meta">@Qualifier(&quot;yydsQueue&quot;)</span> Queue queue)</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder<br>                .bind(queue)<br>                .to(exchange)   <span class="hljs-comment">//使用 HeadersExchange 的 to 方法，可以进行进一步配置</span><br>          			<span class="hljs-comment">//.whereAny(&quot;a&quot;, &quot;b&quot;).exist();   这个是只要存在任意一个指定的头部 Key 就行</span><br>                <span class="hljs-comment">//.whereAll(&quot;a&quot;, &quot;b&quot;).exist();   这个是必须存在所有指定的的头部 Key</span><br>                .where(<span class="hljs-string">&quot;test&quot;</span>).matches(<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">//比如我们现在需要消息的头部信息中包含 test，并且值为 hello 才能转发给我们的消息队列</span><br>      					<span class="hljs-comment">//.whereAny(Collections.singletonMap(&quot;test&quot;, &quot;hello&quot;)).match();  传入 Map 也行，批量指定键值对</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在我们来启动一下试试看：<br><img src="https://s2.loli.net/2023/03/08/NApBodythmfjzMV.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421110926077"><br>结果发现，消息可以成功发送到消息队列，这就是使用头部信息进行路由。<br>这样，我们就介绍完了所有四种类型的交换机。</p>
<h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p>前面我们对于 RabbitMQ 的相关内容已经基本讲解完毕了，最后我们来尝试搭建一个集群，让 RabbitMQ 之间进行数据复制（镜像模式）稍微有点麻烦。<br>可能会用到的一些命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo rabbitmqctl stop_app<br>sudo rabbitmqctl join_cluster rabbit@ubuntu-server<br>sudo rabbitmqctl start_app<br></code></pre></td></tr></table></figure>
<p>实现复制即可。</p>
<hr>
<h2 id="SpringCloud-消息组件"><a href="#SpringCloud-消息组件" class="headerlink" title="SpringCloud 消息组件"></a>SpringCloud 消息组件</h2><p>前面我们已经学习了如何使用 RabbitMQ 消息队列，接着我们来简单介绍一下 SpringCloud 为我们提供的一些消息组件。</p>
<h3 id="SpringCloud-Stream"><a href="#SpringCloud-Stream" class="headerlink" title="SpringCloud Stream"></a>SpringCloud Stream</h3><p><strong>官方文档：</strong> <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-stream/docs/3.2.2/reference/html/">https://docs.spring.io/spring-cloud-stream/docs/3.2.2/reference/html/</a><br>前面我们介绍了 RabbitMQ，了解了消息队列相关的一些操作，但是可能我们会遇到不同的系统在用不同的消息队列，比如系统 A 用的 Kafka、系统 B 用的 RabbitMQ，但是我们现在又没有学习过 Kafka，那么怎么办呢？有没有一种方式像 JDBC 一样，我们只需要关心 SQL 和业务本身，而不用关心数据库的具体实现呢？<br><em>SpringCloud Stream</em> 能够做到，它能够<em>屏蔽底层实现，我们使用统一的消息队列操作方式</em>就能操作多种不同类型的消息队列。<br><img src="https://s2.loli.net/2023/03/08/VWvry9TSDBinatH.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421225215709"><br>它屏蔽了 RabbitMQ 底层操作，让我们使用统一的 Input 和 Output 形式，以 Binder 为中间件，这样就算我们切换了不同的消息队列，也无需修改代码，而具体某种消息队列的底层实现是交给 Stream 在做的。<br>这里我们创建一个新的项目来测试一下：<br><img src="https://s2.loli.net/2023/03/08/pJefuIUXzNHhsxP.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421215534386"><br>依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2021.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  RabbitMQ的Stream实现  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>首先我们来编写一下生产者，首先是配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">binders:</span>   <span class="hljs-comment">#此处配置要绑定的rabbitmq的服务信息</span><br>        <span class="hljs-attr">local-server:</span> <span class="hljs-comment">#绑定名称 ，随便起一个就行</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment">#消息组件类型 ，这里使用的是 RabbitMQ，就填写 rabbit</span><br>          <span class="hljs-attr">environment:</span>  <span class="hljs-comment">#服务器相关信息 ，按照下面的方式填写就行，爆红别管</span><br>            <span class="hljs-attr">spring:</span><br>              <span class="hljs-attr">rabbitmq:</span><br>                <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span><br>                <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>                <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>                <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>                <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/test</span><br>	  <span class="hljs-attr">bindings:</span><br>        <span class="hljs-attr">test-out-0:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">test.exchange</span><br></code></pre></td></tr></table></figure>
<p>接着我们来编写一个 Controller，一会访问一次这个接口，就向消息队列发送一个数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PublishController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    StreamBridge bridge;  <span class="hljs-comment">//通过 bridge 来发送消息</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/publish&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">publish</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//第一个参数其实就是 RabbitMQ 的交换机名称（数据会发送给这个交换机，到达哪个消息队列，不由我们决定）</span><br>      	<span class="hljs-comment">//这个交换机的命名稍微有一些规则:</span><br>      	<span class="hljs-comment">//输入:    &lt;名称&gt; + -in- + &lt;index&gt;</span><br>      	<span class="hljs-comment">//输出:    &lt;名称&gt; + -out- + &lt;index&gt;</span><br>      	<span class="hljs-comment">//这里我们使用输出的方式，来将数据发送到消息队列，注意这里的名称会和之后的消费者 Bean 名称进行对应</span><br>        bridge.send(<span class="hljs-string">&quot;test-out-0&quot;</span>, <span class="hljs-string">&quot;HelloWorld!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;消息发送成功！&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在我们来将生产者启动一下，访问一下接口：<br><img src="https://s2.loli.net/2023/03/08/pvc8udVL9EwMW56.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421220955906"><br>可以看到消息成功发送，我们来看看 RabbitMQ 这边的情况：<br><img src="https://s2.loli.net/2023/03/08/1fBHoQe6gc7XizO.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421221027145"><br>新增了一个<code>test-in-0</code>交换机，并且此交换机是 topic 类型的：<br><img src="https://s2.loli.net/2023/03/08/mN4EfOehP8Ta2JC.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421221107547"><br>但是目前没有任何队列绑定到此交换机上，因此我们刚刚发送的消息实际上是没有给到任何队列的。<br>接着我们来编写一下消费者，消费者的编写方式比较特别，只需要定义一个 Consumer 就可以了，其他配置保持一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerComponent</span> &#123;<br>    <span class="hljs-meta">@Bean(&quot;test&quot;)</span>   <span class="hljs-comment">//注意这里需要填写我们前面交换机名称中&quot;名称&quot;，这样生产者发送的数据才会正确到达</span><br>    <span class="hljs-keyword">public</span> Consumer&lt;String&gt; <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> System.out::println;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>配置中需要修改一下目标交换机：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8002</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>    	<span class="hljs-string">...</span><br>      <span class="hljs-attr">bindings:</span><br>      	<span class="hljs-comment">#因为消费者是输入 ，默认名称为方法名-in-index，这里我们将其指定为我们刚刚定义的交换机</span><br>        <span class="hljs-attr">test-in-0:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">test.exchange</span><br></code></pre></td></tr></table></figure>
<p>接着我们直接启动就可以了，可以看到启动之后，自动为我们创建了一个新的队列：<br><img src="https://s2.loli.net/2023/03/08/kUelcRgb7MrGdB6.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421221733723"><br>而这个队列实际上就是我们消费者等待数据到达的队列：<br><img src="https://s2.loli.net/2023/03/08/lzDjiI9SLH1rVY3.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421221807577"><br>可以看到当前队列直接绑定到了我们刚刚创建的交换机上，并且<code>routingKey</code>是直接写的<code>#</code>，也就是说一会消息会直接过来。<br>现在我们再来访问一些消息发送接口：<br><img src="https://s2.loli.net/2023/03/08/cSPRdoY43gzVNXk.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421221938730"><br><img src="https://s2.loli.net/2023/03/08/8TEv1KQGSNA9luY.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421221952663"><br>可以看到消费者成功地进行消费了：<br><img src="https://s2.loli.net/2023/03/08/lICtpeK2oAGZynD.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421222011924"><br>这样，我们就通过使用 SpringCloud Stream 来屏蔽掉底层 RabbitMQ 来直接进行消息的操作了。</p>
<h3 id="SpringCloud-Bus"><a href="#SpringCloud-Bus" class="headerlink" title="SpringCloud Bus"></a>SpringCloud Bus</h3><p><strong>官方文档：</strong> <a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-bus/reference/html/">https://cloud.spring.io/spring-cloud-bus/reference/html/</a><br>实际上它就相当于是一个消息总线，可用于向各个服务广播某些状态的更改（比如云端配置更改，可以结合 Config 组件实现动态更新配置，当然我们前面学习的 Nacos 其实已经包含这个功能了）或其他管理指令。<br>这里我们也是简单使用一下吧，Bus 需要基于一个具体的消息队列实现，比如 RabbitMQ 或是 Kafka，这里我们依然使用 RabbitMQ。<br>我们将最开始的微服务拆分项目继续使用，比如现在我们希望借阅服务的某个接口调用时，能够给用户服务和图书服务发送一个通知，首先是依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>接着我们只需要在配置文件中将 RabbitMQ 的相关信息配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">addresses:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/test</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span>    <span class="hljs-comment">#暴露端点 ，一会用于提醒刷新</span><br></code></pre></td></tr></table></figure>
<p>然后启动我们的三个服务器，可以看到在管理面板中：<br><img src="https://s2.loli.net/2023/03/08/UfTVhAiOnMqoPX7.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421232118952"><br>新增了 springCloudBug 这样一个交换机，并且：<br><img src="https://s2.loli.net/2023/03/08/2VdCOuPLAb9Qhfx.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421232146646"><br>自动生成了各自的消息队列，这样就可以监听并接收到消息了。<br>现在我们访问一个端口：<br><img src="https://s2.loli.net/2023/03/08/H3szAX82xhpWw6j.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421233200950"><br>此端口是用于通知别人进行刷新，可以看到调用之后，消息队列中成功出现了一次消费：<br><img src="https://s2.loli.net/2023/03/08/LoviBfecC1DbMOg.jpg" srcset="/img/loading.gif" lazyload alt="image-20220421233302328"><br>现在我们结合之前使用的 Config 配置中心，来看看是不是可以做到通知之后所有的配置动态刷新了。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://itbaima.net/<br>title: &quot;柏码 - 让每一行代码都闪耀智慧的光芒！&quot;<br>host: itbaima.net<br>favicon: /favicon.ico<br></code></pre></td></tr></table></figure>
<ol>
<li><a target="_blank" rel="noopener" href="https://itbaima.net/">柏码 - 让每一行代码都闪耀智慧的光芒！</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://cn.dubbo.apache.org/<br>title: &quot;Apache Dubbo 中文&quot;<br>description: &quot;Apache Dubbo 官网&quot;<br>host: cn.dubbo.apache.org<br>image: https://cn.dubbo.apache.org/zh-cn/featured-background.jpg<br></code></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/">Apache Dubbo</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.cnblogs.com/1234cjq/p/15740904.html#:~:text=dubbo%3A%20scan%3A%20base%20-%20packages%3A%20com.cloud.rapid.user.service.api.dubbo%20protocol%3A%20%23Dubbo ,%E8%A1%A8%E7%A4%BA%E8%87%AA%E5%A2%9E%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%BB%8E%2020880%20%E5%BC%80%E5%A7%8B%EF%BC%89%20name%3A%20dubbo%20port%3A%20-1%20%23dubbo%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%9C%81%E7%AB%AF%E5%8F%A3%E4%B8%BA20880%EF%BC%8Crmi%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%9C%81%E7%AB%AF%E5%8F%A3%E4%B8%BA1099%EF%BC%8Chttp%E5%92%8Chessian%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%9C%81%E7%AB%AF%E5%8F%A3%E4%B8%BA80%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AEport%EF%BC%8C%E5%88%99%E8%87%AA%E5%8A%A8%E9%87%87%E7%94%A8%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%85%8D%E7%BD%AE%E4%B8%BA-1%EF%BC%8C%E5%88%99%E4%BC%9A%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E3%80%82<br>title: &quot;springcloud-alibaba 整合 dubbo - 一缕清风丶 - 博客园&quot;<br>description: &quot;记一次 springcloud-alibaba 框架下整合 spring-cloud-starter-dubbo 现状: 现在微服务之间的相互调用使用 feign 接口都需要注解@FeignClient，例:@FeignClient(contextId = &amp;quot;sysRoleMenuService&amp;&quot;<br>host: www.cnblogs.com<br></code></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/1234cjq/p/15740904.html#:~:text=dubbo%3A%20scan%3A%20base%20-%20packages%3A%20com.cloud.rapid.user.service.api.dubbo%20protocol%3A%20%23Dubbo,%E8%A1%A8%E7%A4%BA%E8%87%AA%E5%A2%9E%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%BB%8E%2020880%20%E5%BC%80%E5%A7%8B%EF%BC%89%20name%3A%20dubbo%20port%3A%20-1%20%23dubbo%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%9C%81%E7%AB%AF%E5%8F%A3%E4%B8%BA20880%EF%BC%8Crmi%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%9C%81%E7%AB%AF%E5%8F%A3%E4%B8%BA1099%EF%BC%8Chttp%E5%92%8Chessian%E5%8D%8F%E8%AE%AE%E7%BC%BA%E7%9C%81%E7%AB%AF%E5%8F%A3%E4%B8%BA80%EF%BC%9B%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AEport%EF%BC%8C%E5%88%99%E8%87%AA%E5%8A%A8%E9%87%87%E7%94%A8%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%85%8D%E7%BD%AE%E4%B8%BA-1%EF%BC%8C%E5%88%99%E4%BC%9A%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%8D%A0%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E3%80%82">springcloud-alibaba整合dubbo - 一缕清风丶 - 博客园</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" class="category-chain-item">后端开发</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/springcloud/">#springcloud</a>
      
        <a href="/tags/SpringCloud-Alibaba/">#SpringCloud-Alibaba</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>SpringCloud Alibaba-微服务进阶</div>
      <div>https://alleyf.github.io/2023/11/c09639791c22.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>fcs</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月16日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年12月13日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/59c10a08fce4.html" title="各种环境配置">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">各种环境配置</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/d5e126511000.html" title="SpringCloud-微服务基础">
                        <span class="hidden-mobile">SpringCloud-微服务基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.7.2/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"636f2864e051a199b91c","clientSecret":"5185fd11115bbcd8d2f636bc80de6bed98ed14c1","repo":"Gitalk","owner":"Alleyf","admin":["Alleyf"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":false,"proxy":"https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token"},
          {
            id: '5e04db4469db63a6daf19bcbb5bae204'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/Alleyf" target="_blank" rel="nofollow noopener"><span>Alleyf</span></a> <i class="iconfont icon-love"></i> <a href="https://fcsy.fit" target="_blank" rel="nofollow noopener"><span>Homepage</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      陕ICP备2022010038号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2022010038"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="http://qnpicmap.fcsluck.top/pics/202311161820757.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>陕公网安备2022010038号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
