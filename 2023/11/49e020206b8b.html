

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="http://qnpicmap.fcsluck.top/pics/202311162214229.png">
  <link rel="icon" href="http://qnpicmap.fcsluck.top/pics/202311162214229.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="fcs">
  <meta name="keywords" content="">
  
    <meta name="description" content="一些关于 java8 以后版本的新特性的常用操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java常用新特性-Lambda-Optional-Stream">
<meta property="og:url" content="https://alleyf.github.io/2023/11/49e020206b8b.html">
<meta property="og:site_name" content="alleyf">
<meta property="og:description" content="一些关于 java8 以后版本的新特性的常用操作。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picsum.photos/800/250">
<meta property="article:published_time" content="2023-11-30T03:29:33.000Z">
<meta property="article:modified_time" content="2023-12-01T06:51:52.508Z">
<meta property="article:author" content="alleyf">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Lambda">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://picsum.photos/800/250">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java常用新特性-Lambda-Optional-Stream - alleyf</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"alleyf.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"d57048846da607439cf11718741f2eb0","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?d57048846da607439cf11718741f2eb0";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  



  
<!-- hexo injector head_end start --><script> let HEXO_MMEDIA_DATA = { js: [], css: [], aplayerData: [], metingData: [], artPlayerData: [], dplayerData: []}; </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="alleyf" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mr.Alleyf</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gallery/">
                <i class="iconfont icon-images"></i>
                画廊
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss"></i>
                RSS
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/Alleyf">
                <i class="iconfont icon-github-fill"></i>
                Github
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://api.likepoems.com/img/nature') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java常用新特性-Lambda-Optional-Stream"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        fcs
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-30 11:29" pubdate>
          2023年11月30日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          247 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java常用新特性-Lambda-Optional-Stream</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：1 年前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><img src="https://picsum.photos/800/250" srcset="/img/loading.gif" lazyload></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Java 8 是 Oracle 公司于 2014 年 3 月 18 日发布的，距离今天已经过了近十年的时间了，Java 并没有就此止步，而是继续不断发展壮大，几乎每隔 6 个月，就会冒出一个新版本，最新的版本已经快要迭代到 Java 22 了，与 Java 8 相差了足足十来个版本，但是由于 Java 8 的稳定和生态完善，依然有很多公司在坚持使用 Java 8，不过随着 SpringBoot 3.0 的到来，现在强制要求使用 Java 17 版本（同样也是 LTS 长期维护版本），下一个 Java 版本的时代，或许已经临近了。</p>
<p><img src="https://s2.loli.net/2023/03/06/ydzZwiofBFELMRx.png" srcset="/img/loading.gif" lazyload alt="image-20230306174835142"></p>
<p>随着这些主流框架全面拥抱 Java 17，为了不被时代所淘汰，我们的学习之路，也要继续前行了。就像很多年前 Java 6 还是主流的时代，终究还是被 Java 8 所取代一样。</p>
<p><img src="https://s2.loli.net/2023/03/06/nK23fZLOpyI4iaU.png" srcset="/img/loading.gif" lazyload alt="image-20230306174844769"></p>
<h1 id="Java-8-关键特性回顾"><a href="#Java-8-关键特性回顾" class="headerlink" title="Java 8 关键特性回顾"></a>Java 8 关键特性回顾</h1><p>在开始之前，我们先来回顾一下 Java 8 中学习的 Lambda 表达式和 Optional 类，有关 Stream API 请各位小伙伴回顾一下 Java SE 篇视频教程，这里不再进行介绍。</p>
<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>在 Java 8 之前，我们在某些情况下可能需要用到匿名内部类，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//现在我们想新建一个线程来搞事情</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;   <span class="hljs-comment">//创建一个实现Runnable的匿名内部类</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//具体的实现逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        &#125;<br>    &#125;);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在创建 Thread 时，我们需要传入一个 Runnable 接口的实现类，来指定具体的在新的线程中要执行的任务，相关的逻辑需要我们在 <code>run()</code> 方法中实现，这时为了方便，我们就直接使用匿名内部类的方式传入一个实现，但是这样的写法实在是太过臃肿了。</p>
<p>在 Java 8之后，我们可以对类似于这种匿名内部类的写法，进行缩减，实际上我们进行观察会发现，真正有用的那一部分代码，实际上就是我们对 <code>run()</code> 方法的具体实现，而其他的部分实际上在任何地方编写都是一模一样的，那么我们能否针对于这种情况进行优化呢？我们现在只需要一个简短的 lambda 表达式即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//现在我们想新建一个线程来做事情</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);  <span class="hljs-comment">//只需留下我们需要具体实现的方法体</span><br>    &#125;);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以发现，原本需要完整编写包括类、方法在内的所有内容，全部不再需要，而是直接使用类似于 <code>() ‐&gt; &#123; 代码语句 &#125;</code> 的形式进行替换即可。是不是感觉瞬间代码清爽了 N 倍？</p>
<p>当然这只是一种写法而已，如果各位不好理解，可以将其视为之前匿名内部类写法的一种缩短。</p>
<blockquote>
<p>但是注意，它的底层其实并不只是简简单单的语法糖替换，而是通过 <code>invokedynamic</code> 指令实现的，不难发现，匿名内部类会在编译时创建一个单独的 class 文件，但是 lambda 却不会，间接说明编译之后 lambda 并不是以匿名内部类的形式存在的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//现在我们想新建一个线程来做事情</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();   <span class="hljs-comment">//这里我们拋个异常看看</span><br>&#125;);<br>thread.start();<br></code></pre></td></tr></table></figure>


<p><img src="https://s2.loli.net/2023/03/06/mdifva9M3tozOrq.png" srcset="/img/loading.gif" lazyload alt="image-20230306174907441"></p>
<blockquote>
<p>可以看到，实际上是 Main 类中的 <code>lambda$main$0()</code> 方法抛出的异常，但是我们的 Main 类中压根没有这个方法，很明显是自动生成的。所以，与其说 Lambda 是匿名内部类的语法糖，不如说是我们为所需要的接口提供了一个方法作为它的实现。比如 Runnable 接口需要一个方法体对它的 <code>run()</code> 方法进行实现，而这里我们就通过 lambda 的形式给了它一个方法体，这样就万事具备了，而之后创建实现类就只需要交给 JVM 去处理就好了。</p>
</blockquote>
<p>我们来看一下 Lambda 表达式的具体规范：</p>
<ul>
<li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li>
<li>和匿名内部类不同，<strong>Lambda 仅支持接口，不支持抽象类</strong></li>
<li><strong>接口内部必须有且仅有一个抽象方法</strong>（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li>
</ul>
<p>比如我们之前使用的 Runable 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>   <span class="hljs-comment">//添加了此注解的接口，都支持lambda表达式，符合函数式接口定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//有且仅有一个抽象方法，此方法返回值为void，且没有参数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，Runable 的的匿名内部类实现，就可以简写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;    &#125;;<br></code></pre></td></tr></table></figure>

<p>我们也可以写一个玩玩：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Test</span> &#123;   <span class="hljs-comment">//接口类型</span><br>    String <span class="hljs-title function_">test</span><span class="hljs-params">(Integer i)</span>;    <span class="hljs-comment">//只有这一个抽象方法，且接受一个int类型参数，返回一个String类型结果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>它的 Lambda 表达式的实现就可以写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> (Integer i) -&gt; &#123; <span class="hljs-keyword">return</span> i+<span class="hljs-string">&quot;&quot;</span>; &#125;;  <span class="hljs-comment">//这里我们就简单将i转换为字符串形式</span><br></code></pre></td></tr></table></figure>

<p>不过还可以进行优化，首先方法参数类型是可以省略的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> (i) -&gt; &#123; <span class="hljs-keyword">return</span> i+<span class="hljs-string">&quot;&quot;</span>; &#125;;<br></code></pre></td></tr></table></figure>

<p>由于只有一个参数，可以不用添加小括号（多个参数时需要）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> i -&gt; &#123; <span class="hljs-keyword">return</span> i+<span class="hljs-string">&quot;&quot;</span>; &#125;;<br></code></pre></td></tr></table></figure>

<p>由于仅有返回语句这一行，所以可以直接写最终返回的结果，并且无需花括号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> i -&gt; i+<span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>这样，相比我们之前直接去编写一个匿名内部类，是不是简介了很多很多。当然，除了我们手动编写接口中抽象方法的方法体之外，如果已经有实现好的方法，是可以直接拿过来用的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">test</span><span class="hljs-params">(Integer i)</span>;   <span class="hljs-comment">//接口中的定义</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">impl</span><span class="hljs-params">(Integer i)</span>&#123;   <span class="hljs-comment">//现在有一个静态方法，刚好匹配接口中抽象方法的返回值和参数列表</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是已经存在的实现&quot;</span>+i;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以，我们可以直接将此方法，作为 lambda 表达式的方法体实现（其实这就是一种方法引用，引用了一个方法过来，这也是为什么前面说 <code>是我们为所需要的接口提供了一个方法作为它的实现</code>，是不是越来越体会到这句话的精髓了）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> Main::impl;    <span class="hljs-comment">//使用 类名::方法名称 的形式来直接引用一个已有的方法作为实现</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">impl</span><span class="hljs-params">(Integer i)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是已经存在的实现&quot;</span>+i;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>比如我们现在需要对一个数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>&#125;;   <span class="hljs-comment">//来个数组</span><br>    Arrays.sort(array, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;   <span class="hljs-comment">//Arrays.sort()可以由我们自己指定排序规则，只需要实现Comparator方法即可</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>            <span class="hljs-keyword">return</span> o1 - o2;<br>        &#125;<br>    &#125;);<br>    System.out.println(Arrays.toString(array));   <span class="hljs-comment">//按从小到大的顺序排列</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是我们发现，Integer 类中有一个叫做 <code>compare</code> 的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">return</span> (x &lt; y) ? -<span class="hljs-number">1</span> : ((x == y) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法是一个静态方法，但是它却和 <code>Comparator</code> 需要实现的方法返回值和参数定义一模一样，所以，懂的都懂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>&#125;;<br>    Arrays.sort(array, Integer::compare);   <span class="hljs-comment">//直接指定一手，效果和上面是一模一样</span><br>    System.out.println(Arrays.toString(array));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么要是不是静态方法而是普通的成员方法呢？我们注意到 Comparator 要求我们实现的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>     <span class="hljs-keyword">return</span> o1 - o2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 o1和 o2都是 Integer 类型的，我们发现 Integer 类中有一个 <code>compareTo</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Integer anotherInteger)</span> &#123;<br>    <span class="hljs-keyword">return</span> compare(<span class="hljs-built_in">this</span>.value, anotherInteger.value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>只不过这个方法并不是静态的，而是对象所有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>&#125;;<br>Arrays.sort(array, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1.compareTo(o2);   <span class="hljs-comment">//这样进行比较也行，和上面效果依然是一样的</span><br>    &#125;<br>&#125;);<br>System.out.println(Arrays.toString(array));<br></code></pre></td></tr></table></figure>

<p>但是此时我们会发现，IDEA 提示我们可以缩写，这是为什么呢？实际上，当我们<em>使用非静态方法时，会使用抽象方参数列表的第一个作为目标对象，后续参数作为目标对象成员方法的参数</em>，也就是说，此时，<code>o1</code> 作为目标对象，<code>o2</code> 作为参数，正好匹配了 <code>compareTo</code> 方法，所以，直接缩写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>&#125;;<br>    Arrays.sort(array, Integer::compareTo);  <span class="hljs-comment">//注意这里调用的不是静态方法</span><br>    System.out.println(Arrays.toString(array));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>成员方法也可以让对象本身不成为参与的那一方，仅仅引用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">mainObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    Integer[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>&#125;;<br>    Arrays.sort(array, mainObject::reserve);  <span class="hljs-comment">//使用Main类的成员方法，但是mainObject对象并未参与进来，只是借用了一下刚好匹配的方法</span><br>    System.out.println(Arrays.toString(array));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reserve</span><span class="hljs-params">(Integer a, Integer b)</span>&#123;  <span class="hljs-comment">//现在Main类中有一个刚好匹配的方法</span><br>    <span class="hljs-keyword">return</span> b.compareTo(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，类的构造方法同样可以作为方法引用传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Test</span> &#123;<br>    String <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>;   <span class="hljs-comment">//现在我们需要一个参数为String返回值为String的实现</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现，String 类中刚好有一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(String original)</span> &#123;   <span class="hljs-comment">//由于String类的构造方法返回的肯定是一个String类型的对象，且此构造方法需要一个String类型的对象，所以，正好匹配了接口中的</span><br>    <span class="hljs-built_in">this</span>.value = original.value;<br>    <span class="hljs-built_in">this</span>.coder = original.coder;<br>    <span class="hljs-built_in">this</span>.hash = original.hash;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>于是乎：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> String::<span class="hljs-keyword">new</span>;   <span class="hljs-comment">//没错，构造方法直接使用new关键字就行</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然除了上面提到的这些情况可以使用方法引用之外，还有很多地方都可以。Java 8 也为我们提供了一些内置的函数式接口供我们使用：<strong>Consumer、Function、Supplier</strong> 等。</p>
<h3 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h3><p>Java 8 中新引入了 <strong>Optional</strong> 特性，来让我们<em>更优雅的处理空指针异常</em>。我们先来看看下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String str)</span>&#123;   <span class="hljs-comment">//现在我们要实现一个方法，将传入的字符串转换为小写并打印</span><br>    System.out.println(str.toLowerCase());  <span class="hljs-comment">//那太简单了吧，直接转换打印一气呵成</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这样实现的话，我们少考虑了一个问题，万一给进来的 <code>str</code> 是 <code>null</code> 呢？如果是 <code>null</code> 的话，在调用 <code>toLowerCase</code> 方法时岂不是直接空指针异常了？所以我们还得判空一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-keyword">if</span>(str != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(str.toLowerCase());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是这样写着就不能一气呵成了，我现在又有强迫症，我就想一行解决，这时，Optional 来了，我们可以将任何的变量包装进 Optional 类中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String str)</span>&#123;<br>    Optional<br>            .ofNullable(str)   <span class="hljs-comment">//将str包装进Optional</span><br>            .ifPresent(s -&gt; &#123;   <span class="hljs-comment">//ifPresent表示只有对象不为null才会执行里面的逻辑，实现一个Consumer（接受一个参数，返回值为void）</span><br>                System.out.println(s);   <br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于这里只有一句打印，所以我们来优化一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String str)</span>&#123;<br>    Optional<br>            .ofNullable(str)   <span class="hljs-comment">//将str包装进Optional</span><br>            .ifPresent(System.out::println);  <br>  	<span class="hljs-comment">//println也是接受一个String参数，返回void，所以这里使用我们前面提到的方法引用的写法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，我们就又可以一气呵成了，是不是感觉比之前的写法更优雅。</p>
<p>除了在不为空时执行的操作外，还可以直接从 Optional 中获取被包装的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Optional.ofNullable(str).get());<br></code></pre></td></tr></table></figure>

<p>不过此时当被包装的对象为 null 时会直接抛出异常，当然，我们还可以指定如果 get 的对象为 null 的替代方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Optional.ofNullable(str).orElse(<span class="hljs-string">&quot;VVV&quot;</span>));   <span class="hljs-comment">//orElse表示如果为空就返回里面的内容</span><br></code></pre></td></tr></table></figure>

<h1 id="Java-9-新特性"><a href="#Java-9-新特性" class="headerlink" title="Java 9 新特性"></a>Java 9 新特性</h1><p>这一部分，我们将介绍 Java 9 为我们带来的新特性，Java 9 的主要特性有，全新的模块机制、接口的 private 方法等。</p>
<h3 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h3><p>在我们之前的开发中，不知道各位有没有发现一个问题，就是当我们导入一个 <code>jar</code> 包作为依赖时（包括 JDK 官方库），实际上很多功能我们并不会用到，但是由于它们是属于同一个依赖捆绑在一起，这样就会导致我们可能只用到一部分内容，但是需要引用一个完整的类库，实际上我们可以把用不到的类库排除掉，大大降低依赖库的规模。</p>
<p>于是，Java 9 引入了模块机制来对这种情况进行优化，在之前的我们的项目是这样的：</p>
<p><img src="https://s2.loli.net/2023/03/06/veG1HYjonRZxgFf.png" srcset="/img/loading.gif" lazyload alt="image-20230306174940813"></p>
<p>而在引入模块机制之后：</p>
<p><img src="https://s2.loli.net/2023/03/06/IYURLgpc1FZGlV7.png" srcset="/img/loading.gif" lazyload alt="image-20230306174956804"></p>
<p>可以看到，模块可以由一个或者多个在一起的 Java 包组成，通过将这些包分出不同的模块，我们就可以按照模块的方式进行管理了。这里我们创建一个新的项目，并在 <code>src</code> 目录下，新建 <code>module-info.java</code> 文件表示此项目采用模块管理机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> NewHelloWorld &#123;  <span class="hljs-comment">//模块名称随便起一个就可以，但是注意必须是唯一的，以及模块内的包名也得是唯一的，即使模块不同</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着我们来创建一个主类：</p>
<p><img src="https://s2.loli.net/2023/03/06/mboyzvKkQcSfwde.png" srcset="/img/loading.gif" lazyload alt="image-20230306175006986"></p>
<p>程序可以正常运行，貌似和之前没啥区别，不过我们发现，JDK 为我们提供的某些框架不见了：</p>
<p><img src="https://s2.loli.net/2023/03/06/MtImErZ1iAo9ROy.png" srcset="/img/loading.gif" lazyload alt="image-20230306175016858"></p>
<p>Java 为我们提供的 <code>logging</code> 相关日志库呢？我们发现现在居然不见了？实际上它就是被作为一个模块单独存在，这里我们需进行模块导入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> NewHelloWorld &#123;  <span class="hljs-comment">//模块名称随便起一个就可以</span><br>    <span class="hljs-keyword">requires</span> java.logging;   <span class="hljs-comment">//除了JDK的一些常用包之外，只有我们明确需要的模块才会导入依赖库</span><br>  	<span class="hljs-comment">//当然如果要导入JavaSE的所有依赖，想之前一样的话，直接 requires java.se;  即可</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们导入 java.logging 相关模块后，就可以正常使用 Logger 了：</p>
<p><img src="https://s2.loli.net/2023/03/06/76FXVyfaUnc12z8.png" srcset="/img/loading.gif" lazyload alt="image-20230306175043681"></p>
<p><img src="http://qnpicmap.fcsluck.top/pics/202311301353848.png" srcset="/img/loading.gif" lazyload alt="|450"></p>
<p>是不是瞬间感觉编写代码时清爽了许多，全新的模块化机制提供了另一个级别的 Java 代码可见性、可访问性的控制，不过，你以为仅仅是做了包的分离吗？我们可以来尝试通过反射获取 JDK 提供的类中的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Java17版本的String类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,<br>               Constable, ConstantDesc &#123;<br>    <span class="hljs-meta">@Stable</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value;  <span class="hljs-comment">//自JDK9后，为了提高性能，String底层数据存放的是byte[]而不是char[]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>    Class&lt;String&gt; stringClass = String.class;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> stringClass.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);   <span class="hljs-comment">//这里我们通过反射来获取String类中的value字段</span><br>    field.setAccessible(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//由于是private访问权限，所以我们修改一下</span><br>    System.out.println(field.get(<span class="hljs-string">&quot;ABCD&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是我们发现，在程序运行之后，修改操作被阻止了：</p>
<p><img src="https://s2.loli.net/2023/03/06/AjqJtyLoSD7p5BK.png" srcset="/img/loading.gif" lazyload alt="image-20230306175056384"></p>
<p>反射 API 的 Java 9 封装和安全性得到了改进，如果模块没有明确授权给其他模块使用反射的权限，那么其他模块是不允许使用反射进行修改的，看来 Unsafe 类是玩不成了。</p>
<p>我们现在就来细嗦一下这个模块机制，首先模块具有四种类型：</p>
<ul>
<li><strong>系统模块：</strong> 来自 JDK 和 JRE 的模块（官方提供的模块，比如我们上面用的），我们也可以直接使用 <code>java --list-modules</code> 命令来列出所有的模块，不同的模块会导出不同的包供我们使用。</li>
<li><strong>应用程序模块：</strong> 我们自己写的 Java 模块项目。</li>
<li><strong>自动模块：</strong> 可能有些库并不是 Java 9 以上的模块项目，这种时候就需要做兼容了，默认情况下是直接导出所有的包，可以访问所有其他模块提供的类，不然之前版本的库就用不了了。</li>
<li><strong>未命名模块：</strong> 我们自己创建的一个 Java 项目，如果没有创建 <code>module-info.java</code>，那么<em>会按照未命名模块进行处理，未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的 Java 8 代码才能正常地在 Java 9 以及之后的版本下运行</em>。不过，由于没有使用 Java 9 的模块新特性，<em>未命名模块只能默认暴露给其他未命名的模块和自动模块，应用程序模块无法访问这些类</em>（实际上就是传统 Java 8 以下的编程模式，因为没有模块只需要导包就行）</li>
</ul>
<p>这里我们就来创建两个项目，看看如何使用模块机制，首先我们在项目 A 中，添加一个 User 类，一会项目 B 需要用到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot; (&quot;</span>+age+<span class="hljs-string">&quot;岁)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着我们编写一下项目 A 的模块设置：</p>
<p><img src="https://s2.loli.net/2023/03/06/FRCYrpHJe14SUVa.png" srcset="/img/loading.gif" lazyload alt="image-20230306175110049"></p>
<p>这里我们将 <code>com.test</code> 包下所有内容都暴露出去，<strong>默认情况下所有的包都是私有的，就算其他项目将此项目作为依赖也无法使用</strong>。</p>
<p>接着我们现在想要在项目 B 中使用项目 A 的 User 类，我们需要进行导入：</p>
<p><img src="https://s2.loli.net/2023/03/06/6C3N5AsSHZv8emK.png" srcset="/img/loading.gif" lazyload alt="image-20230306175950291"></p>
<blockquote>
<p>[!WARNING]<br>requires 导入模块时添加 <strong>static</strong> 关键字表示只在编译时需要，运行时可以不需要。</p>
</blockquote>
<p>现在我们就可以在 Main 类中使用模块 <code>module.a</code> 中暴露出来的包内容了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.test.User;   <span class="hljs-comment">//如果模块module.a不暴露，那么将无法导入</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;lbw&quot;</span>, <span class="hljs-number">18</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然除了普通的 <code>exports</code> 进行包的全局暴露之外，我们也可以直接<strong>指定将包暴露给指定的模块</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> <span class="hljs-keyword">module</span>.a &#123;<br>    <span class="hljs-keyword">exports</span> com.test to <span class="hljs-keyword">module</span>.b;   <span class="hljs-comment">//这里我们将com.test包暴露给指定的模块module.b，非指定的模块即使导入也无法使用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>不过现在还有一个问题，如果模块 <code>module.a</code> 依赖于其他模块，那么会不会传递给依赖于模块 <code>module.a</code> 的模块呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> <span class="hljs-keyword">module</span>.a &#123;<br>    <span class="hljs-keyword">exports</span> com.test to <span class="hljs-keyword">module</span>.b;   <span class="hljs-comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span><br>    <span class="hljs-keyword">requires</span> java.logging;   <span class="hljs-comment">//这里添加一个模块的依赖</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/06/EviljcLBzpOa3QI.png" srcset="/img/loading.gif" lazyload alt="image-20230306180001653"></p>
<p>可以看到，在模块 <code>module.b</code> 中，并没有进行依赖传递，说明哪个模块导入的依赖只能哪个模块用，但是现在我们希望依赖可以传递，就是哪个模块用了什么依赖，依赖此模块的模块也会自动进行依赖，我们可以通过一个关键字 <strong>transitive</strong> 进行<em>模块级依赖传递</em>解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> <span class="hljs-keyword">module</span>.a &#123;<br>    <span class="hljs-keyword">exports</span> com.test to <span class="hljs-keyword">module</span>.b;   <span class="hljs-comment">//使用exports将com.test包下所有内容暴露出去，这样其他模块才能导入</span><br>    <span class="hljs-keyword">requires</span> transitive java.logging;   <span class="hljs-comment">//使用 transitive 来向其他模块传递此依赖</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在就可以使用了：</p>
<p><img src="https://s2.loli.net/2023/03/06/VbDXB86Jszn5Arv.png" srcset="/img/loading.gif" lazyload alt="image-20230306180011462"></p>
<p>还有我们前面演示的反射，我们发现如果我们依赖了一个模块，是没办法直接进行反射操作的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-number">18</span>);<br>    Class&lt;User&gt; userClass = User.class;<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> userClass.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>    field.setAccessible(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//尝试修改访问权限</span><br>    System.out.println(field.get(user));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/06/Y1hIQKRbrB9fzOs.png" srcset="/img/loading.gif" lazyload alt="image-20230306180056716"></p>
<p>我们可以通过添加 <strong>open</strong> 或者 <strong>opens</strong> 关键字为其他模块开放某些运行使用反射的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">open <span class="hljs-keyword">module</span> <span class="hljs-keyword">module</span>.a &#123;   <span class="hljs-comment">//直接添加 open 关键字开放整个模块的反射权限</span><br>    <span class="hljs-keyword">exports</span> com.test to <span class="hljs-keyword">module</span>.b;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> <span class="hljs-keyword">module</span>.a &#123;<br>    <span class="hljs-keyword">exports</span> com.test to <span class="hljs-keyword">module</span>.b;<br>    opens com.test to <span class="hljs-keyword">module</span>.b;   <span class="hljs-comment">//通过使用 opens 关键字来为其他模块开放反射权限</span><br>  	<span class="hljs-comment">//也可以指定目标开放反射 opens com.test to module.b;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们<em>还可以指定模块需要使用的抽象类或是接口实现</em>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Test</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">open <span class="hljs-keyword">module</span> <span class="hljs-keyword">module</span>.a &#123;<br>    <span class="hljs-keyword">exports</span> com.test to <span class="hljs-keyword">module</span>.b;<br>    uses com.test.Test;  <span class="hljs-comment">//使用 uses 指定，Test 是一个接口（比如需要的服务等），模块需要使用到</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以在模块 B 中去实现一下，然后声明我们提供了实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.main;<br><br><span class="hljs-keyword">import</span> com.test.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Test</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> <span class="hljs-keyword">module</span>.b &#123;<br>    <span class="hljs-keyword">requires</span> <span class="hljs-keyword">module</span>.a;   <span class="hljs-comment">//导入项目 A 的模块，此模块暴露了 com.test 包</span><br>    provides com.test.Test with com.main.TestImpl;  <span class="hljs-comment">//声明此模块提供了 Test 的实现类</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>了解了以上的相关知识后，我们就可以简单地进行模块的使用了。比如现在我们创建了一个新的 Maven 项目：</p>
<p><img src="https://s2.loli.net/2023/03/06/95RQrFIBaMghy2X.png" srcset="/img/loading.gif" lazyload alt="image-20230306180028905"></p>
<p>然后我们导入了 lombok 框架的依赖，如果我们不创建 <code>module-info.java</code> 文件，那么就是一个未命名模块，未命名模块默认可以使用其他所有模块提供的类，实际上就是我们之前的开发模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> lombok.extern.java.Log;<br><br><span class="hljs-meta">@Log</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Hello World!&quot;</span>);   <span class="hljs-comment">//使用 lombok 提供的注解，可以正常运行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们希望按照全新的模块化开发模式来进行开发，将我们的项目从未命名模块改进为应用程序模块，所以我们先创建好 <code>module-info.java</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> com.test &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，直接报错了：</p>
<p><img src="https://s2.loli.net/2023/03/06/1b7xQKIrpMdUwem.png" srcset="/img/loading.gif" lazyload alt="image-20230306180116166"></p>
<p>明明导入了 lombok 依赖，却无法使用，这是因为我们还需要去依赖对应的模块才行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> com.test &#123;<br>    <span class="hljs-keyword">requires</span> lombok;   <span class="hljs-comment">//lombok 模块</span><br>    <span class="hljs-keyword">requires</span> java.logging;    <span class="hljs-comment">//JUL 日志模块，也需要使用到</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/03/06/1rdbseu5kDBgAU9.png" srcset="/img/loading.gif" lazyload alt="image-20230306180127459"></p>
<p>这样我们就可以正常使用了，之后为了教程演示方便，咱们还是不用模块。</p>
<h3 id="JShell-交互式编程"><a href="#JShell-交互式编程" class="headerlink" title="JShell 交互式编程"></a>JShell 交互式编程</h3><p>Java 9 为我们通过了一种交互式编程工具 JShell，你还别说，真有 Python 那味。</p>
<p><img src="https://s2.loli.net/2023/03/06/HhrVDqeOwPZ6lvS.png" srcset="/img/loading.gif" lazyload alt="image-20230306180136996"></p>
<p>环境配置完成后，我们只需要输入 <code>jshell</code> 命令即可开启交互式编程了，它支持我们一条一条命令进行操作。</p>
<p>比如我们来做一个简单的计算：</p>
<p><img src="https://s2.loli.net/2023/03/06/BYnUL5WmTgavrS6.png" srcset="/img/loading.gif" lazyload alt="image-20230306180146794"></p>
<p>我们一次输入一行（可以不加分号），先定义一个 a&#x3D;10 和 b&#x3D;10，然后定义 c 并得到 a+b 的结果，可以看到还是非常方便的，但是注意语法还是和 Java 是一样的。</p>
<p><img src="https://s2.loli.net/2023/03/06/NM7ruqzwX34poG2.png" srcset="/img/loading.gif" lazyload alt="image-20230306180158288"></p>
<p>我们也可以快速创建一个方法供后续的调用。当我们按下 Tab 键还可以进行自动补全：</p>
<p><img src="https://s2.loli.net/2023/03/06/1Yy7DHoPdOjV8L5.png" srcset="/img/loading.gif" lazyload alt="image-20230306180220301"></p>
<p>除了直接运行我们写进去的代码之外，它还支持使用命令，输入 <code>help</code> 来查看命令列表：</p>
<p><img src="https://s2.loli.net/2023/03/06/k9aUe5QXbJfmZDr.png" srcset="/img/loading.gif" lazyload alt="image-20230306180228542"></p>
<p>比如我们可以使用 <code>/vars</code> 命令来展示当前定义的变量列表：</p>
<p><img src="https://s2.loli.net/2023/03/06/z7uTFCqdxgfHYb5.png" srcset="/img/loading.gif" lazyload alt="image-20230306180242109"></p>
<p>当我们不想使用 jshell 时，直接输入 <code>/exit</code> 退出即可：</p>
<p><img src="http://qnpicmap.fcsluck.top/pics/202311301506552.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="接口中的-private-方法"><a href="#接口中的-private-方法" class="headerlink" title="接口中的 private 方法"></a>接口中的 private 方法</h3><p>在 Java 8 中，接口中 的方法支持添加 <code>default</code> 关键字来添加默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 test 方法默认实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而在 Java 9 中，接口再次得到强化，现在<strong>接口中可以存在私有方法</strong>了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是 test 方法默认实现&quot;</span>);<br>        <span class="hljs-built_in">this</span>.inner();   <span class="hljs-comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inner</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//声明一个私有方法</span><br>        System.out.println(<span class="hljs-string">&quot;我是接口中的私有方法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>私有方法必须要提供方法体，因为权限为私有的，也只有这里能进行方法的具体实现了，并且此方法只能被接口中的其他私有方法或是默认实现调用。</p>
</blockquote>
<h3 id="集合类新增工厂方法"><a href="#集合类新增工厂方法" class="headerlink" title="集合类新增工厂方法"></a>集合类新增工厂方法</h3><p>在之前，如果我们想要快速创建一个 Map 只能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();   <span class="hljs-comment">//要快速使用 Map，需要先创建一个 Map 对象，然后再添加数据</span><br>    map.put(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-number">19</span>);<br>    map.put(<span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-number">23</span>);<br><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而在 Java 9 之后，我们可以直接通过 <code>of</code> 方法来快速创建了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String, Integer&gt; map = Map.of(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">//直接一句搞定</span><br><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>非常方便 of 方法还被重载了很多次，分别适用于快速创建包含 0~10 对键值对的 Map：</p>
<p><img src="https://s2.loli.net/2023/03/06/J4wLnr79lO1pYaj.png" srcset="/img/loading.gif" lazyload alt="image-20230306180306844"></p>
<p>但是注意，<strong>通过这种方式创建的 Map 和通过 Arrays 创建的 List 比较类似，也是无法进行修改的。</strong></p>
<p>当然，除了 Map 之外，其他的集合类都有相应的 <code>of</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = Set.of(<span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>);  <span class="hljs-comment">//注意 Set 中元素顺序并不一定你的添加顺序</span><br>    List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>);   <span class="hljs-comment">//好耶，再也不用 Arrays 了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h3><p>还记得我们之前在 JavaSE 中学习的 Stream 流吗？当然这里不是指进行 IO 操作的流，而是 JDK1.8 新增的 Stream API，通过它大大方便了我们的编程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Stream<br>            .of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>)   <span class="hljs-comment">//这里我们可以直接将一些元素封装到 Stream 中</span><br>            .filter(s -&gt; s.equals(<span class="hljs-string">&quot;B&quot;</span>))   <span class="hljs-comment">//通过过滤器过滤</span><br>            .distinct()   <span class="hljs-comment">//去重</span><br>            .forEach(System.out::println);   <span class="hljs-comment">//最后打印</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>自从有了 Stream，我们对于集合的一些操作就大大地简化了，对集合中元素的批量处理，只需要在 Stream 中一气呵成（具体的详细操作请回顾 JavaSE 篇）</p>
<p>如此方便的框架，在 Java 9 得到了进一步的增强：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Stream<br>            .of(<span class="hljs-literal">null</span>)   <span class="hljs-comment">//如果传入 null 会报错</span><br>            .forEach(System.out::println);<br><br>    Stream<br>            .ofNullable(<span class="hljs-literal">null</span>) <span class="hljs-comment">//使用新增的 ofNullable 方法，这样就不会了，不过这样的话流里面就没东西了</span><br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有，我们可以通过<strong>迭代快速生成一组数据</strong>（实际上 Java 8 就有了，这里<em>新增的是允许结束迭代的</em>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Stream<br>            .iterate(<span class="hljs-number">0</span>, i -&gt; i + <span class="hljs-number">1</span>)   <span class="hljs-comment">//Java8 只能像这样生成无限的流，第一个参数是种子，就是后面的 UnaryOperator 的参数 i 一开始的值，最后会返回一个值作为 i 的新值，每一轮都会执行 UnaryOperator 并生成一个新值到流中，这个是源源不断的，如果不加 limit()进行限制的话，将无限生成下去。</span><br>      			.limit(<span class="hljs-number">20</span>)   <span class="hljs-comment">//这里限制生成 20 个</span><br>            .forEach(System.out::println); <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Stream<br>            <span class="hljs-comment">//不知道怎么写？参考一下：for (int i = 0;i &lt; 20;i++)</span><br>            .iterate(<span class="hljs-number">0</span>, i -&gt; i &lt; <span class="hljs-number">20</span>, i -&gt; i + <span class="hljs-number">1</span>)  <span class="hljs-comment">//快速生成一组 0~19 的 int 数据，中间可以添加一个断言，表示什么时候结束生成</span><br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Stream 还新增了<em>对数据的截断操作</em>，比如我们希望在读取到某个元素时截断，不再继续操作后面的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Stream<br>            .iterate(<span class="hljs-number">0</span>, i -&gt; i + <span class="hljs-number">1</span>)<br>            .limit(<span class="hljs-number">20</span>)<br>            .takeWhile(i -&gt; i &lt; <span class="hljs-number">10</span>)   <span class="hljs-comment">//当 i 小于 10 时正常通过，一旦大于等于 10 直接截断</span><br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Stream<br>            .iterate(<span class="hljs-number">0</span>, i -&gt; i + <span class="hljs-number">1</span>)<br>            .limit(<span class="hljs-number">20</span>)<br>            .dropWhile(i -&gt; i &lt; <span class="hljs-number">10</span>)   <span class="hljs-comment">//和上面相反，上来就是截断状态，只有当满足条件时再开始通过</span><br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="其他小型变动"><a href="#其他小型变动" class="headerlink" title="其他小型变动"></a>其他小型变动</h3><p>Try-with-resource 语法现在不需要再完整的声明一个变量了，我们可以直接将现有的变量丢进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Files.newInputStream(Paths.get(<span class="hljs-string">&quot;pom.xml&quot;</span>));<br>    <span class="hljs-keyword">try</span> (inputStream) &#123;   <span class="hljs-comment">//单独丢进 try 中，效果是一样的</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>            System.out.print((<span class="hljs-type">char</span>) inputStream.read());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Java 8 中引入了 Optional 类，它很好的解决了判空问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    test(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span>&#123;<br>    <span class="hljs-comment">//比如现在我们想执行 System.out.println(str.toLowerCase())</span><br>    <span class="hljs-comment">//但是由于我们不清楚给进来的 str 到底是不是 null，如果是 null 的话会引起空指针异常</span><br>    <span class="hljs-comment">//但是去单独进行一次 null 判断写起来又不太简洁，这时我们可以考虑使用 Optional 进行包装</span><br>    Optional<br>            .ofNullable(s)<br>            .ifPresent(str -&gt; System.out.println(str.toLowerCase()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种写法就有点像 Kotlin 或是 JS 中的语法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(<span class="hljs-literal">null</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(str : <span class="hljs-type">String</span>?)</span></span>&#123;   <span class="hljs-comment">//传入的 String 对象可能为 null，这里类型写为 String?</span><br>    println(str?.lowercase())   <span class="hljs-comment">// ?.表示只有不为空才进行调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 Java 9 新增了一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    Optional.ofNullable(str).ifPresentOrElse(s -&gt; &#123;  <span class="hljs-comment">//通过使用 ifPresentOrElse，我们同时处理两种情况</span><br>        System.out.println(<span class="hljs-string">&quot;被包装的元素为：&quot;</span>+s);     <span class="hljs-comment">//第一种情况和 ifPresent 是一样的</span><br>    &#125;, () -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;被包装的元素为 null&quot;</span>);   <span class="hljs-comment">//第二种情况是如果为 null 的情况</span><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以使用 <code>or()</code> 方法快速替换为另一个 Optional 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    Optional.ofNullable(str)<br>      .or(() -&gt; Optional.of(<span class="hljs-string">&quot;AAA&quot;</span>))   <span class="hljs-comment">//如果当前被包装的类不是 null，依然返回自己，但是如果是 null，那就返回 Supplier 提供的另一个 Optional 包装</span><br>      .ifPresent(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然还支持直接转换为 Stream，这里就不多说了。</p>
<p>在 Java 8 及之前，<em>匿名内部类是没办法使用钻石运算符进行自动类型推断</em>的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;   <span class="hljs-comment">//这里我们写一个泛型类</span><br>    <span class="hljs-keyword">public</span> T t;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-built_in">this</span>.t = t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    Test&lt;String&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;(<span class="hljs-string">&quot;AAA&quot;</span>) &#123;   <span class="hljs-comment">//在低版本这样写是会直接报错的，因为匿名内部类不支持自动类型推断，但是很明显我们这里给的参数是 String 类型的，所以明明有机会进行类型推断，却还是要我们自己填类型，就很蠢</span><br>      <span class="hljs-comment">//在 Java 9 之后，这样的写法终于可以编译通过了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然除了以上的特性之外还有 Java 9 的多版本 JAR 包支持、CompletableFuture API 的改进等，因为不太常用，这里就不做介绍了。</p>
<h1 id="Java-10-新特性"><a href="#Java-10-新特性" class="headerlink" title="Java 10 新特性"></a>Java 10 新特性</h1><p>Java 10 主要带来的是一些内部更新，相比 Java 9 带来的直观改变不是很多，其中比较突出的就是局部变量类型推断了。</p>
<h3 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h3><p>在 Java 中，我们可以使用自动类型推断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// String a = &quot;Hello World!&quot;;   之前我们定义变量必须指定类型</span><br>    <span class="hljs-type">var</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;   <span class="hljs-comment">//现在我们使用 var 关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是注意，<code>var</code> 关键字必须位于有初始值设定的变量上，否则鬼知道你要用什么类型。</p>
<p><img src="https://s2.loli.net/2023/03/06/xgoX2Cy9lST4Gkc.png" srcset="/img/loading.gif" lazyload alt="image-20230306180322150"></p>
<p>我们来看看是不是类型也能正常获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    System.out.println(a.getClass());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里虽然是有了 var 关键字进行自动类型推断，但是最终还是会变成 String 类型，得到的 Class 也是 String 类型。但是 Java 终究不像 JS 那样进行动态推断，这种类型推断仅仅发生在编译期间，到最后编译完成后还是会变成具体类型的：</p>
<p><img src="https://s2.loli.net/2023/03/06/og94MUsWPdyulmX.png" srcset="/img/loading.gif" lazyload alt="image-20230306180329364"></p>
<p>并且 <code>var</code> 关键字仅适用于局部变量，我们是没办法在其他地方使用的，比如类的成员变量：</p>
<p><img src="https://s2.loli.net/2023/03/06/g4aIlhC6GQfu2NF.png" srcset="/img/loading.gif" lazyload alt="image-20230306180337900"></p>
<h1 id="Java-11-新特性"><a href="#Java-11-新特性" class="headerlink" title="Java 11 新特性"></a>Java 11 新特性</h1><p>Java 11 是继 Java 8 之后的又一个 TLS 长期维护版本，在 Java 17 出现之前，一直都是此版本作为广泛使用的版本，其中比较关键的是用于 Lambda 的形参局部变量语法。</p>
<h3 id="用于-Lambda-的形参局部变量语法"><a href="#用于-Lambda-的形参局部变量语法" class="headerlink" title="用于 Lambda 的形参局部变量语法"></a>用于 Lambda 的形参局部变量语法</h3><p>在 Java 10 我们认识了 <code>var</code> 关键字，它能够直接让局部变量自动进行类型推断，不过它不支持在 lambda 中使用：</p>
<p><img src="https://s2.loli.net/2023/03/06/uaNSkgeOUQTxoLl.png" srcset="/img/loading.gif" lazyload alt="image-20230306180413626"></p>
<p>但是实际上这里是完全可以进行类型推断的，所以在 Java 11，终于是支持了，这样编写就不会报错了：</p>
<p><img src="https://s2.loli.net/2023/03/06/Nft9Csk6ac8AgY2.png" srcset="/img/loading.gif" lazyload alt="image-20230306180421523"></p>
<h3 id="针对于-String-类的方法增强"><a href="#针对于-String-类的方法增强" class="headerlink" title="针对于 String 类的方法增强"></a>针对于 String 类的方法增强</h3><p>在 Java 11 为 String 新增一些更加方便的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AB\nC\nD&quot;</span>;<br>    System.out.println(str.isBlank());    <span class="hljs-comment">//isBlank 方法用于判断是否字符串为空或者是仅包含空格</span><br>    str<br>            .lines()   <span class="hljs-comment">//根据字符串中的\n 换行符进行切割，分为多个字符串，并转换为 Stream 进行操作</span><br>            .forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们还可以通过 <code>repeat()</code> 方法来让字符串重复拼接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABCD&quot;</span>;   <span class="hljs-comment">//比如现在我们有一个 ABCD，但是现在我们想要一个 ABCDABCD 这样的基于原本字符串的重复字符串</span><br>    System.out.println(str.repeat(<span class="hljs-number">2</span>));  <span class="hljs-comment">//一个 repeat 就搞定了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以快速地进行<strong>空格去除</strong>操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; A B C D &quot;</span>;<br>    System.out.println(str.strip());   <span class="hljs-comment">//去除首尾空格</span><br>    System.out.println(str.stripLeading());  <span class="hljs-comment">//去除首部空格</span><br>    System.out.println(str.stripTrailing());   <span class="hljs-comment">//去除尾部空格</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>根据换行符 <code>\n</code> 进行切割字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;A\nB\nCD&quot;</span>;   <span class="hljs-comment">//根据换行符\n进行切割字符串</span><br>str.lines()  <br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<h3 id="全新的-HttpClient-使用"><a href="#全新的-HttpClient-使用" class="headerlink" title="全新的 HttpClient 使用"></a>全新的 HttpClient 使用</h3><p>在 Java 9 的时候其实就已经引入了全新的 Http Client API，用于取代之前比较老旧的 HttpURLConnection 类，新的 API 支持最新的 HTTP2 和 WebSocket 协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException, InterruptedException &#123;<br>    <span class="hljs-type">HttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClient.newHttpClient();   <span class="hljs-comment">//直接创建一个新的 HttpClient</span><br>  	<span class="hljs-comment">//现在我们只需要构造一个 Http 请求实体，就可以让客户端帮助我们发送出去了（实际上就跟浏览器访问类似）</span><br>    <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> HttpRequest.newBuilder().uri(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot; https://www.baidu.com&quot;</span> )).build();<br>  	<span class="hljs-comment">//现在我们就可以把请求发送出去了，注意 send 方法后面还需要一个响应体处理器（内置了很多）这里我们选择 ofString 直接吧响应实体转换为 String 字符串</span><br>    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());<br>  	<span class="hljs-comment">//来看看响应实体是什么吧</span><br>    System.out.println(response.body());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>利用全新的客户端，我们甚至可以轻松地做一个爬虫，比如现在我们想去批量下载某个网站的壁纸：</p>
<p>网站地址： <a target="_blank" rel="noopener" href="https://pic.netbian.top/">https://pic.netbian.top/</a></p>
<p>我们随便点击一张壁纸，发现网站的 URL 格式为：</p>
<p><img src="https://s2.loli.net/2023/03/06/BxUmcfP2d7F3Luy.png" srcset="/img/loading.gif" lazyload alt="image-20230306180458933"></p>
<p>并且不同的壁纸似乎都是这样： <a target="_blank" rel="noopener" href="https://pic.netbian.top/tupian/%E6%95%B0%E5%AD%97.html">https://pic.netbian.top/tupian/数字.html</a> ，好了差不多可以开始整活了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException, InterruptedException &#123;  <br>    <span class="hljs-type">HttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClient.newHttpClient();  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt; end; i++) &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">10000</span>, <span class="hljs-number">99999</span>);  <span class="hljs-comment">//随机获得图片序列号</span><br>        <span class="hljs-type">var</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://pic.netbian.top/tupian/&quot;</span> + id + <span class="hljs-string">&quot;.html&quot;</span>;  <br>        <span class="hljs-type">var</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;img-&quot;</span> + id + <span class="hljs-string">&quot;.jpg&quot;</span>;  <br>        List&lt;String&gt; imgs = crawler(client, url);  <br>        Optional.ofNullable(imgs).ifPresent(s -&gt; downloadImage(s, client, fileName));  <br>        <span class="hljs-comment">// 设置下载进度条  </span><br>        System.out.print(<span class="hljs-string">&quot;已下载序号为：&quot;</span> + id + <span class="hljs-string">&quot; 的图片\r&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，最后控制台成功获取到这些图片的网站页面了：</p>
<p><img src="https://s2.loli.net/2023/03/06/gI1ker9wuKfWZ64.png" srcset="/img/loading.gif" lazyload alt="image-20230306180509828"></p>
<p>接着我们需要来观察一下网站的 HTML 具体怎么写的，把图片的地址提取出来：</p>
<p><img src="https://s2.loli.net/2023/03/06/koQX2LCjhVU1EZt.png" srcset="/img/loading.gif" lazyload alt="image-20230306180647473"></p>
<p>好了，知道图片在哪里就好办了，直接通过正则表达式截取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">crawler</span><span class="hljs-params">(HttpClient client, String url)</span> <span class="hljs-keyword">throws</span> URISyntaxException, IOException, InterruptedException &#123;  <br>        <span class="hljs-keyword">if</span> (url.contains(<span class="hljs-string">&quot;?&quot;</span>)) &#123;  <br>            url = url.substring(<span class="hljs-number">0</span>, url.indexOf(<span class="hljs-string">&quot;?&quot;</span>));  <br>        &#125;  <br>        <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> HttpRequest.newBuilder().uri(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(url)).header(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;</span>).build();  <span class="hljs-comment">//这里我们按照规律，批量获取  </span><br>        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());  <br><span class="hljs-comment">//        System.out.println(response.body());  </span><br>        <span class="hljs-keyword">if</span> (response.statusCode() == <span class="hljs-number">403</span>) &#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> response.body();  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;btwaf=\\d+&quot;</span>;  <br>  <br>            <span class="hljs-type">Pattern</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Pattern.compile(pattern);  <br>            <span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> r.matcher(text);  <br>  <br>            <span class="hljs-keyword">if</span> (m.find()) &#123;  <br>                <span class="hljs-type">var</span> <span class="hljs-variable">newUrl</span> <span class="hljs-operator">=</span> url + <span class="hljs-string">&quot;?&quot;</span>.concat(m.group());  <br>                System.out.println(newUrl);  <br>                crawler(client, newUrl);  <br>            &#125;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> response.body();  <br>            <span class="hljs-type">String</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;img src=\&quot;https([^\&quot;]+)\&quot;&quot;</span>;  <br>  <br>            <span class="hljs-type">Pattern</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Pattern.compile(pattern);  <br>            <span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> r.matcher(text);  <br>  <br>            <span class="hljs-keyword">if</span> (m.find()) &#123;  <br>                <span class="hljs-type">var</span> <span class="hljs-variable">imgurl</span> <span class="hljs-operator">=</span> m.group();  <br><span class="hljs-comment">//                System.out.println(imgurl); </span><br>                <span class="hljs-keyword">if</span> (imgurl.contains(<span class="hljs-string">&quot;https&quot;</span>)) &#123;  <br>                    <span class="hljs-type">var</span> <span class="hljs-variable">imgUrl</span> <span class="hljs-operator">=</span> imgurl.substring(imgurl.indexOf(<span class="hljs-string">&quot;https&quot;</span>), imgurl.length() - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.jpg&quot;</span>;  <br>                    <span class="hljs-keyword">return</span> List.of(imgUrl);  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>好了，现在图片地址也可以批量拿到了，直接获取这些图片然后保存到本地吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadImage</span><span class="hljs-params">(List&lt;String&gt; imgs, HttpClient client, String fileName)</span> &#123;  <br>        imgs.forEach(img -&gt; &#123;  <br>            Optional.ofNullable(img).ifPresent(s -&gt; &#123;  <br>                <span class="hljs-keyword">try</span> &#123;  <br><span class="hljs-comment">//                    System.out.println(s);  </span><br>                    <span class="hljs-comment">//创建请求，把图片取到  </span><br>                    <span class="hljs-type">HttpRequest</span> <span class="hljs-variable">imageRequest</span> <span class="hljs-operator">=</span> HttpRequest.newBuilder().uri(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(s)).build();  <br>                    <span class="hljs-comment">//这里以输入流的方式获取，不过貌似可以直接下载文件，各位小伙伴可以单独试试看  </span><br>                    HttpResponse&lt;InputStream&gt; imageResponse = client.send(imageRequest, HttpResponse.BodyHandlers.ofInputStream());  <br>                    <span class="hljs-comment">//拿到输入流和文件输出流  </span><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">imageInput</span> <span class="hljs-operator">=</span> imageResponse.body();  <br>                    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;E:\\IDEAProjects\\javaNewProps\\module-b\\src\\main\\resources\\images\\&quot;</span> + fileName); <span class="hljs-comment">//一会要保存的格式  </span><br>                    <span class="hljs-keyword">try</span> (stream; imageInput) &#123;  <span class="hljs-comment">//直接把要 close 的变量放进来就行，简洁一些了  </span><br>                        <span class="hljs-type">int</span> size;   <span class="hljs-comment">//下面具体保存过程的不用我多说了吧  </span><br>                        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br>                        <span class="hljs-keyword">while</span> ((size = imageInput.read(data)) &gt; <span class="hljs-number">0</span>) &#123;  <br>                            stream.write(data, <span class="hljs-number">0</span>, size);  <br>                        &#125;  <br>                    &#125;  <br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>                &#125;  <br>            &#125;);  <br>        &#125;);  <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>我们现在来看看效果吧，美女的图片已经成功保存到本地了：</p>
<p><img src="http://qnpicmap.fcsluck.top/pics/202311302206160.png" srcset="/img/loading.gif" lazyload></p>
<p>当然，比较简单的爬虫到此为止了。</p>
<h1 id="Java-12-16-新特性"><a href="#Java-12-16-新特性" class="headerlink" title="Java 12-16 新特性"></a>Java 12-16 新特性</h1><p>由于 Java 版本的更新迭代速度自 Java 9 开始为半年更新一次（Java 8 到 Java 9 隔了整整三年），所以各个版本之间的更新内容比较少，剩余的 6 个版本，我们就多个版本放在一起进行讲解了。</p>
<p><img src="https://s2.loli.net/2023/03/06/uWatQdpZYiJKhVr.png" srcset="/img/loading.gif" lazyload alt="image-20230306180737638"></p>
<p>Java12-16 这五个版本并非长期支持版本，所以很多特性都是一种处于实验性功能，12&#x2F;13 版本引入了一些实验性功能，并根据反馈进行调整，最后在后续版本中正式开放使用，其实就是体验服的那种感觉。</p>
<h3 id="增强型-switch-语法"><a href="#增强型-switch-语法" class="headerlink" title="增强型 switch 语法"></a>增强型 switch 语法</h3><p>在 Java 12 引入全新的 switch 语法，让我们使用 switch 语句更加的灵活，比如我们想要编写一个根据成绩得到等级的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入分数（范围 0 - 100）返回对应的等级：</span><br><span class="hljs-comment"> *      100-90：优秀</span><br><span class="hljs-comment"> *      70-80：良好</span><br><span class="hljs-comment"> *      60-70：及格</span><br><span class="hljs-comment"> *      0-60：寄</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> score 分数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 等级</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">grade</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在我们使用 switch 来实现这个功能，之前的写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">grade</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span>&#123;<br>    score /= <span class="hljs-number">10</span>;  <span class="hljs-comment">//既然分数段都是整数，那就直接整除 10</span><br>  	<span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">switch</span> (score) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>            res =  <span class="hljs-string">&quot;优秀&quot;</span>;   <span class="hljs-comment">//不同的分数段就可以返回不同的等级了</span><br>        		<span class="hljs-keyword">break</span>;   <span class="hljs-comment">//别忘了 break，不然会贯穿到后面</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            res = <span class="hljs-string">&quot;良好&quot;</span>;<br>        		<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            res = <span class="hljs-string">&quot;及格&quot;</span>;<br>        		<span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            res = <span class="hljs-string">&quot;不及格&quot;</span>;<br>        		<span class="hljs-keyword">break</span>;<br>    &#125;<br>  	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是现在我们可以使用<strong>增强型 Switch 语法</strong>了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">grade</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span>&#123;<br>    score /= <span class="hljs-number">10</span>;  <span class="hljs-comment">//既然分数段都是整数，那就直接整除 10</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (score) &#123;   <span class="hljs-comment">//增强版 switch 语法</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span> -&gt; <span class="hljs-string">&quot;优秀&quot;</span>;   <span class="hljs-comment">//语法那是相当的简洁，而且也不需要我们自己考虑 break 或是 return 来结束 switch 了（有时候就容易忘记，这样的话就算忘记也没事了）</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>, <span class="hljs-number">7</span> -&gt; <span class="hljs-string">&quot;良好&quot;</span>; <br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span> -&gt; <span class="hljs-string">&quot;及格&quot;</span>;<br>        <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&quot;不及格&quot;</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不过最后编译出来的样子，貌似还是和之前是一样的：</p>
<p><img src="https://s2.loli.net/2023/03/06/ZcAmGyCQrD4uSMR.png" srcset="/img/loading.gif" lazyload alt="image-20230306180750556"></p>
<p>这种全新的 switch 语法称为 <code>switch 表达式</code>，它的意义不仅仅体现在语法的精简上，我们来看看它的详细规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (obj) &#123;   <span class="hljs-comment">//这里和之前的 switch 语句是一样的，但是注意这样的 switch 是有返回值的，所以可以被变量接收</span><br>    <span class="hljs-keyword">case</span> [匹配值, ...] -&gt; <span class="hljs-string">&quot;优秀&quot;</span>;   <span class="hljs-comment">//case 后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此 case 语句的结果</span><br>    <span class="hljs-keyword">case</span> ...   <span class="hljs-comment">//根据不同的分支，可以存在多个 case</span><br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&quot;不及格&quot;</span>;   <span class="hljs-comment">//注意，表达式要求必须涵盖所有的可能，所以是需要添加 default 的</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (obj) &#123;   <span class="hljs-comment">//增强版 switch 语法</span><br>    <span class="hljs-keyword">case</span> [匹配值, ...] -&gt; <span class="hljs-string">&quot;优秀&quot;</span>;<br>    <span class="hljs-keyword">default</span> -&gt; &#123;   <span class="hljs-comment">//我们可以使用花括号来将整套逻辑括起来</span><br>        <span class="hljs-comment">//... 我是其他要做的事情</span><br>        <span class="hljs-keyword">yield</span>  <span class="hljs-string">&quot;不及格&quot;</span>;  <span class="hljs-comment">//注意处理完成后需要返回最终结果，但是这样并不是使用 return，而是 yield 关键字</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>当然，也可以像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (args.length) &#123;   <span class="hljs-comment">//增强版 switch 语法</span><br>    <span class="hljs-keyword">case</span> [匹配值, ...]:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;AAA&quot;</span>;   <span class="hljs-comment">//传统的:写法，通过 yield 指定返回结果，同样不需要 break</span><br>    <span class="hljs-keyword">default</span>:<br>    		System.out.println(<span class="hljs-string">&quot;默认情况&quot;</span>);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;BBB&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。唯一遗憾的是依然不支持区间匹配。</p>
<blockquote>
<p>switch 表达式在 <code>Java 14</code> 才正式开放使用，所以我们项目的代码级别需要调整到 14 以上。</p>
</blockquote>
<h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>如果你学习过 Python，一定知道三引号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#当我们需要使用复杂字符串时 ，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串</span><br>multi_line =  <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                nice to meet you!</span><br><span class="hljs-string">                  nice to meet you!</span><br><span class="hljs-string">                      nice to meet you!</span><br><span class="hljs-string">                &quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span> multi_line<br></code></pre></td></tr></table></figure>

<p>没错，Java13 也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了：</p>
<p><img src="https://s2.loli.net/2023/03/06/CqVmXrshfFExgRO.png" srcset="/img/loading.gif" lazyload alt="image-20230306180802418"></p>
<p>可以看到，Java 中也可以使用这样的<strong>三引号来表示字符串</strong>了，并且我们可以随意在里面使用特殊字符，包括双引号等，但是最后编译出来的结果实际上还是会变成一个之前这样使用了转义字符的字符串：</p>
<p><img src="https://s2.loli.net/2023/03/06/s2ImkOEN5cJZPvU.png" srcset="/img/loading.gif" lazyload alt="image-20230306180813359"></p>
<p>仔细想想，这样我们写 SQL 或是 HTML 岂不是就舒服多了？</p>
<blockquote>
<p>文本块表达式在 Java 15 才正式开放使用，所以我们项目的代码级别需要调整到 15 以上。</p>
</blockquote>
<h3 id="新的-instanceof-语法"><a href="#新的-instanceof-语法" class="headerlink" title="新的 instanceof 语法"></a>新的 instanceof 语法</h3><p>在 Java 14，instanceof 迎来了一波小更新, 比如我们之前要重写一个类的 equals 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Student) &#123;   <span class="hljs-comment">//首先判断是否为 Student 类型</span><br>            <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) obj;  <span class="hljs-comment">//如果是，那么就类型转换</span><br>            <span class="hljs-keyword">return</span> student.name.equals(<span class="hljs-built_in">this</span>.name);  <span class="hljs-comment">//最后比对属性是否一样</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本 instanceof 加强之后，我们就不需要了，我们可以直接将 student 替换为<strong>模式变量</strong>：</p>
<p><img src="https://s2.loli.net/2023/03/06/YRyg2qEi5kcDuX9.png" srcset="/img/loading.gif" lazyload alt="image-20230306180828080"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>  <br><span class="hljs-meta">@AllArgsConstructor</span>  <br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Student student) &#123;   <span class="hljs-comment">//在比较完成的屁股后面，直接写变量名字，而这个变量就是类型转换之后的</span><br>            <span class="hljs-keyword">return</span> student.name.equals(<span class="hljs-built_in">this</span>.name);  <span class="hljs-comment">//下面直接用，是不是贼方便</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在使用 <code>instanceof</code> <em>判断类型成立后，会自动强制转换类型为指定类型，简化了我们手动转换的步骤</em>。</p>
<blockquote>
<p>新的 instanceof 语法在 Java 16 才正式开放使用，所以我们项目的代码级别需要调整到 16 以上。</p>
</blockquote>
<h3 id="空指针异常的改进"><a href="#空指针异常的改进" class="headerlink" title="空指针异常的改进"></a>空指针异常的改进</h3><p>相信各位小伙伴在调试代码时，经常遇到空指针异常，比如下面的这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String a, String b)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> a.length() + b.length();   <span class="hljs-comment">//可能给进来的 a 或是 b 为 null</span><br>    System.out.println(length);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么为空时，就会直接：</p>
<p><img src="https://s2.loli.net/2023/03/06/lOSDTM4WcqzR5Ud.png" srcset="/img/loading.gif" lazyload alt="image-20230306180839217"></p>
<p>但是由于我们这里 a 和 b 都调用了 <code>length()</code> 方法，虽然空指针异常告诉我们问题出现在这一行，但是到底是 a 为 null 还是 b 为 null 呢？我们是没办法直接得到的（遇到过这种问题的扣个 1 吧，只能调试，就很头疼）</p>
<p>但是当我们在 Java 14 或更高版本运行时：</p>
<p><img src="https://s2.loli.net/2023/03/06/eunGbL8qOE9MZwi.png" srcset="/img/loading.gif" lazyload alt="image-20230306180847472"></p>
<p>这里会明确指出是哪一个变量调用出现了空指针，更人性化。</p>
<h3 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h3><p>继类、接口、枚举、注解之后的又一新类型来了，它的名字叫”记录”，在 Java 14 中首次出场，这一出场，Lombok 的噩梦来了。</p>
<p>在实际开发中，很多的类仅仅只是充当一个实体类罢了，保存的是一些不可变数据，比如我们从数据库中查询的账户信息，最后会被映射为一个实体类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;   <span class="hljs-comment">//使用 Lombok，一个注解就搞定了</span><br>    String username;<br>    String password;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Lombok 可以说是简化代码的神器了，他能在编译时自动生成 getter 和 setter、构造方法、toString()方法等实现，在编写这些实体类时，简直不要太好用，而这一波，官方也是看不下去了，于是自己也搞了一个记录类型。</p>
<p>记录类型本质上也是一个普通的类，不过是 final 类型且继承自 java.lang.Record 抽象类的，它会在编译时，会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法，好家伙，这是要逼死 Lombok 啊。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Account</span><span class="hljs-params">(String username, String password)</span> &#123;  <span class="hljs-comment">//直接把字段写在括号中</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用起来也是非常方便，自动生成了构造方法和成员字段的公共 get 方法：</p>
<p><img src="https://s2.loli.net/2023/03/06/iopGnBQf6v3VS7Y.png" srcset="/img/loading.gif" lazyload alt="image-20230306180856852"></p>
<p>并且 toString 也是被重写了的：</p>
<p><img src="https://s2.loli.net/2023/03/06/cvOXQklZybzHPfs.png" srcset="/img/loading.gif" lazyload alt="image-20230306180905242"></p>
<p><code>equals()</code> 方法仅做成员字段之间的值比较，也是帮助我们实现好了的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Account</span> <span class="hljs-variable">account0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br><span class="hljs-type">Account</span> <span class="hljs-variable">account1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-string">&quot;Admin&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);   <span class="hljs-comment">//两个属性都是一模一样的</span><br>System.out.println(account0.equals(account1));  <span class="hljs-comment">//得到 true</span><br></code></pre></td></tr></table></figure>

<p>是不是感觉这种类型就是专门为这种实体类而生的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Account</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <span class="hljs-comment">//支持实现接口，但是不支持继承，因为继承的坑位已经默认被占了</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>记录类型在 Java 16 才正式开放使用，所以我们项目的代码级别需要调整到 16 以上。</p>
</blockquote>
<h1 id="Java-17-新特性"><a href="#Java-17-新特性" class="headerlink" title="Java 17 新特性"></a>Java 17 新特性</h1><p>Java 17 作为新的 LTS 长期维护版本，我们来看看都更新了什么（不包含预览特性，包括 switch 第二次增强，哈哈，果然还是强度不够，都连续加强两个版本了）</p>
<h3 id="密封类型"><a href="#密封类型" class="headerlink" title="密封类型"></a>密封类型</h3><p>密封类型可以说是 Java 17 正式推出的又一重磅类型，它在 Java 15 首次提出并测试了两个版本。</p>
<p>在 Java 中，我们可以通过继承（extends 关键字）来实现类的能力复用、扩展与增强。但有的时候，可能并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p>
<p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加 <code>final</code> 关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;   <span class="hljs-comment">//添加 final 关键字后，不允许对此类继承</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样有一个缺点，如果添加了 <code>final</code> 关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承 A，但是不允许别人写的类继承 A，这时该咋写？在 Java 17 之前想要实现就很麻烦。</p>
<p>但是现在我们可以使用密封类型来实现这个功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">permits</span> B&#123;   <span class="hljs-comment">//在 class 关键字前添加 sealed 关键字，表示此类为密封类型，permits 后面跟上允许继承的类型，多个子类使用逗号隔开</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>密封类型有以下要求：</p>
<ul>
<li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li>
<li>必须有子类继承，且不能是匿名内部类或是 lambda 的形式。</li>
<li><code>sealed</code> 写在原来 <code>final</code> 的位置，但是不能和 <code>final</code>、<code>non-sealed</code> 关键字同时出现，只能选择其一。</li>
<li>继承的子类必须显式标记为 <code>final</code>、<code>sealed</code> 或是 <code>non-sealed</code> 类型。</li>
</ul>
<p>标准的声明格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> [<span class="hljs-keyword">abstract</span>] [class/interface] 类名 [extends 父类] [implements 接口, ...] <span class="hljs-keyword">permits</span> [子类, ...]&#123;<br>		<span class="hljs-comment">//里面的该怎么写就怎么写</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意子类格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> [<span class="hljs-keyword">final</span>/<span class="hljs-keyword">sealed</span>/<span class="hljs-keyword">non-sealed</span>] class 子类 extends 父类 &#123;   <span class="hljs-comment">//必须继承自父类</span><br>			<span class="hljs-comment">//final 类型：任何类不能再继承当前类，到此为止，已经封死了。</span><br>  		<span class="hljs-comment">//sealed 类型：同父类，需要指定由哪些类继承。</span><br>  		<span class="hljs-comment">//non-sealed 类型：重新开放为普通类，任何类都可以继承。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>比如现在我们写了这些类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <span class="hljs-keyword">permits</span> B&#123;   <span class="hljs-comment">//指定 B 继承 A</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;   <span class="hljs-comment">//在子类 final，彻底封死</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看到其他的类无论是继承 A 还是继承 B 都无法通过编译：</p>
<p><img src="https://s2.loli.net/2023/03/06/Zbv6coLkh5ujP4N.png" srcset="/img/loading.gif" lazyload alt="image-20230306180916878"></p>
<p><img src="https://s2.loli.net/2023/03/06/NubaU8iHE4YAL6M.png" srcset="/img/loading.gif" lazyload alt="image-20230306180924756"></p>
<p>但是如果此时我们主动将 B 设定为 <code>non-sealed</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">non-sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样就可以正常继承了，因为 B 指定了 <code>non-sealed</code> 主动放弃了密封特性，这样就显得非常灵活了。</p>
<p>当然我们也可以通过反射来获取类是否为密封类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Class&lt;A&gt; a = A.class;<br>    System.out.println(a.isSealed());   <span class="hljs-comment">//是否为密封</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h1><ol>
<li>java 出入牛犊- [[Java Notes]]</li>
<li>java 小试牛刀- [[Java_Exercise]]</li>
<li>java 窥探炼器-[[Java常用新特性-Lambda-Optional-Stream]]</li>
<li>Springboot 速成秘籍-[[SpringBoot启示录]]</li>
<li>Spring出入牛犊-[[Spring核心学习]]</li>
<li>SpringSecurity 行走利器-[[SpringSecurity]]</li>
<li>SpringBoot 结丹-[[SpringBoot]]</li>
<li>SpringBoot 整活-[[SpringBoot+Vue项目实战]]</li>
<li>SpringCloud 元婴-[[SpringCloud-微服务基础]]</li>
<li>SpringCloud 淬炼-[[SpringCloud Alibaba-微服务进阶]]</li>
<li>SpringCloud 盘它-[[SpringCloud-微服务应用]]</li>
<li>SpringCLoud 空明-[[Spring Cloud Alibaba 微服务原理与实战-阅读心得]]</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cardlink">url: https://www.bilibili.com/video/BV1tU4y1y7Fg/?vd_source=9c896fa9c3f9023797e8efe7be0c113e<br>title: &quot;JavaSE 9-17 新特性 已完结（IDEA 2022.1 最新版）4K 蓝光画质 Java9/10/11/12/13/14/15/16/17 讲解_哔哩哔哩_bilibili&quot;<br>description: &quot;JavaSE 9-17 新特性 已完结（IDEA 2022.1 最新版）4K 蓝光画质 Java9/10/11/12/13/14/15/16/17 讲解共计 19 条视频，包括：Java9-17 新特性介绍、Java8 回顾：Lambda 表达式、Java8 回顾：Optional 类等，UP 主更多精彩视频，请关注 UP 账号。&quot;<br>host: www.bilibili.com<br>image: https://i2.hdslb.com/bfs/archive/dc0cc9464c6fc274c1f23f682a01dab5a358217b.jpg@100w_100h_1c.png<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tU4y1y7Fg/?vd_source=9c896fa9c3f9023797e8efe7be0c113e">JavaSE 9-17 新特性 已完结（IDEA 2022.1最新版）4K蓝光画质 Java9&#x2F;10&#x2F;11&#x2F;12&#x2F;13&#x2F;14&#x2F;15&#x2F;16&#x2F;17讲解_哔哩哔哩_bilibili</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" class="category-chain-item">后端开发</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/Lambda/">#Lambda</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java常用新特性-Lambda-Optional-Stream</div>
      <div>https://alleyf.github.io/2023/11/49e020206b8b.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>fcs</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月30日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2023年12月1日</div>
        </div>
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/3e87c166eb21.html" title="正则表达式-Regex">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">正则表达式-Regex</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/e3cf5e8cdf6a.html" title="全栈+运维-技术架构成熟解决方案">
                        <span class="hidden-mobile">全栈+运维-技术架构成熟解决方案</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.7.2/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"636f2864e051a199b91c","clientSecret":"5185fd11115bbcd8d2f636bc80de6bed98ed14c1","repo":"Gitalk","owner":"Alleyf","admin":["Alleyf"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":false,"proxy":"https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token"},
          {
            id: 'c058a56d235dde3f4e3302f7ff6ccad9'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/Alleyf" target="_blank" rel="nofollow noopener"><span>Alleyf</span></a> <i class="iconfont icon-love"></i> <a href="https://fcsy.fit" target="_blank" rel="nofollow noopener"><span>Homepage</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      陕ICP备2022010038号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2022010038"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="http://qnpicmap.fcsluck.top/pics/202311161820757.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>陕公网安备2022010038号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.1/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/assets/mmedia/mmedia-loader.js"></script><!-- hexo injector body_end end --></body>
</html>
